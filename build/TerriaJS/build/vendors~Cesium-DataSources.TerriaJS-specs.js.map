{"version":3,"sources":["webpack:///./node_modules/terriajs-cesium/Source/Core/HermitePolynomialApproximation.js","webpack:///./node_modules/terriajs-cesium/Source/Core/LagrangePolynomialApproximation.js","webpack:///./node_modules/terriajs-cesium/Source/Core/Spherical.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CheckerboardMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositeMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CzmlDataSource.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GridMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/KmlCamera.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/KmlDataSource.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/KmlLookAt.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/KmlTour.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/KmlTourFlyTo.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/KmlTourWait.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineArrowMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineDashMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineOutlineMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PositionPropertyArray.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PropertyArray.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/Rotation.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StripeMaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StripeOrientation.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/VelocityOrientationProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/VelocityVectorProperty.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/Autolinker.js"],"names":[],"mappings":";;;;;;;;;AAAA,iGAAO;AACP,QAAQ,uGAAgB;AACxB,QAAQ,6FAAW;AACnB,QAAQ,2GAAkB;AAC1B,QAAQ,uFAAQ;AAChB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,eAAe;AACtC;AACA,2BAA2B,yCAAyC;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA,uBAAuB,yCAAyC;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB,mBAAmB,eAAe;AAClC,mBAAmB,eAAe;AAClC;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB,iFAAiF,uBAAuB;AACxG,eAAe,OAAO;AACtB;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;;AAEA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA,2BAA2B,wBAAwB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,UAAU;AACtC,uBAAuB,yBAAyB;AAChD;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB,iFAAiF,uBAAuB;AACxG,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,eAAe;AACtC,uBAAuB,yBAAyB;AAChD;AACA;AACA;;AAEA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;;AAEA,2BAA2B,wBAAwB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC5RF,iGAAO;AACP,QAAQ,6FAAW;AACnB,KAAK,mCAAE;AACP;AACA;;AAEA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;AACxB,iFAAiF,uBAAuB;AACxG,eAAe,OAAO;AACtB;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACtEF,iGAAO;AACP,QAAQ,yFAAS;AACjB,QAAQ,uGAAgB;AACxB,QAAQ,6FAAW;AACnB,KAAK,mCAAE;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACvLF,iGAAO;AACP,QAAQ,yGAAoB;AAC5B,QAAQ,+FAAe;AACvB,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,+FAAe;AACvB,QAAQ,sIAA4B;AACpC,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB,4BAA4B,eAAe;AAC5E;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS,kEAAkE,YAAY;AACtG,eAAe,SAAS,kEAAkE,YAAY;AACtG,eAAe,SAAS,8CAA8C,iBAAiB;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,2DAA2D,YAAY;AACvE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,4DAA4D,YAAY;AACxE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACtJF,iGAAO;AACP,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,iHAAwB;AAChC,QAAQ,+FAAe;AACvB,QAAQ,wHAAqB;AAC7B,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,wBAAwB,kBAAkB,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC3HF,iGAAO;AACP,QAAQ,mGAAiB;AACzB,QAAQ,uHAA2B;AACnC,QAAQ,yGAAoB;AAC5B,QAAQ,yGAAoB;AAC5B,QAAQ,6GAAsB;AAC9B,QAAQ,yGAAoB;AAC5B,QAAQ,uGAAmB;AAC3B,QAAQ,+FAAe;AACvB,QAAQ,yGAAoB;AAC5B,QAAQ,yGAAoB;AAC5B,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,iHAAwB;AAChC,QAAQ,qIAAkC;AAC1C,QAAQ,uGAAmB;AAC3B,QAAQ,+FAAe;AACvB,QAAQ,uHAA2B;AACnC,QAAQ,yHAA4B;AACpC,QAAQ,iJAAwC;AAChD,QAAQ,mGAAiB;AACzB,QAAQ,mGAAiB;AACzB,QAAQ,yGAAoB;AAC5B,QAAQ,mJAAyC;AACjD,QAAQ,2HAA6B;AACrC,QAAQ,6FAAc;AACtB,QAAQ,+GAAuB;AAC/B,QAAQ,qHAA0B;AAClC,QAAQ,yGAAoB;AAC5B,QAAQ,uGAAmB;AAC3B,QAAQ,iHAAwB;AAChC,QAAQ,qGAAkB;AAC1B,QAAQ,6GAAsB;AAC9B,QAAQ,uGAAmB;AAC3B,QAAQ,6GAAsB;AAC9B,QAAQ,iIAAgC;AACxC,QAAQ,2HAA6B;AACrC,QAAQ,mHAAyB;AACjC,QAAQ,qHAA0B;AAClC,QAAQ,uHAA2B;AACnC,QAAQ,2GAAqB;AAC7B,QAAQ,2GAAqB;AAC7B,QAAQ,mHAAyB;AACjC,QAAQ,uGAAmB;AAC3B,QAAQ,yGAAoB;AAC5B,QAAQ,wHAAqB;AAC7B,QAAQ,4GAAe;AACvB,QAAQ,sHAAoB;AAC5B,QAAQ,8IAAgC;AACxC,QAAQ,gIAAyB;AACjC,QAAQ,wIAA6B;AACrC,QAAQ,wIAA6B;AACrC,QAAQ,wHAAqB;AAC7B,QAAQ,sIAA4B;AACpC,QAAQ,sHAAoB;AAC5B,QAAQ,sHAAoB;AAC5B,QAAQ,sHAAoB;AAC5B,QAAQ,0GAAc;AACtB,QAAQ,oHAAmB;AAC3B,QAAQ,oHAAmB;AAC3B,QAAQ,wHAAqB;AAC7B,QAAQ,gHAAiB;AACzB,QAAQ,sHAAoB;AAC5B,QAAQ,8HAAwB;AAChC,QAAQ,gIAAyB;AACjC,QAAQ,gHAAiB;AACzB,QAAQ,gHAAiB;AACzB,QAAQ,0IAA8B;AACtC,QAAQ,8GAAgB;AACxB,QAAQ,gHAAiB;AACzB,QAAQ,oHAAmB;AAC3B,QAAQ,gJAAiC;AACzC,QAAQ,8IAAgC;AACxC,QAAQ,8IAAgC;AACxC,QAAQ,sHAAoB;AAC5B,QAAQ,oJAAmC;AAC3C,QAAQ,gIAAyB;AACjC,QAAQ,sGAAY;AACpB,QAAQ,gHAAiB;AACzB,QAAQ,4GAAe;AACvB,QAAQ,wHAAqB;AAC7B,QAAQ,wHAAqB;AAC7B,QAAQ,sGAAY;AACpB,QAAQ,oIAA2B;AACnC,QAAQ,oHAAmB;AAC3B,QAAQ,kIAA0B;AAClC,QAAQ,wHAAqB;AAC7B,QAAQ,kKAA0C;AAClD,QAAQ,kJAAkC;AAC1C,QAAQ,4IAA+B;AACvC,QAAQ,kIAA0B;AAClC,QAAQ,8GAAgB;AACxB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,SAAS;AAC3E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU,iBAAiB,kBAAkB,gFAAgF;AAC7H;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,aAAa;AAChD;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACn5EF,iGAAO;AACP,QAAQ,yGAAoB;AAC5B,QAAQ,+FAAe;AACvB,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,+FAAe;AACvB,QAAQ,sIAA4B;AACpC,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB,oBAAoB,eAAe;AACpE;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS,6DAA6D,YAAY;AACjG,eAAe,SAAS;AACxB,eAAe,SAAS,6CAA6C,iBAAiB;AACtF,eAAe,SAAS,qDAAqD,iBAAiB;AAC9F,eAAe,SAAS,kDAAkD,iBAAiB;AAC3F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,0DAA0D,YAAY;AACtE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,6BAA6B,iBAAiB;AAC9C;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACvLF,iGAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AChBF,iGAAO;AACP,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,uHAA2B;AACnC,QAAQ,yGAAoB;AAC5B,QAAQ,yGAAoB;AAC5B,QAAQ,6GAAsB;AAC9B,QAAQ,yGAAoB;AAC5B,QAAQ,uGAAmB;AAC3B,QAAQ,+FAAe;AACvB,QAAQ,yGAAoB;AAC5B,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,iHAAwB;AAChC,QAAQ,uGAAmB;AAC3B,QAAQ,+FAAe;AACvB,QAAQ,2HAA6B;AACrC,QAAQ,yHAA4B;AACpC,QAAQ,uHAA2B;AACnC,QAAQ,qHAA0B;AAClC,QAAQ,mGAAiB;AACzB,QAAQ,yGAAoB;AAC5B,QAAQ,6FAAc;AACtB,QAAQ,+GAAuB;AAC/B,QAAQ,+GAAuB;AAC/B,QAAQ,iHAAwB;AAChC,QAAQ,yGAAoB;AAC5B,QAAQ,qHAA0B;AAClC,QAAQ,+GAAuB;AAC/B,QAAQ,uGAAmB;AAC3B,QAAQ,qGAAkB;AAC1B,QAAQ,6GAAsB;AAC9B,QAAQ,6GAAsB;AAC9B,QAAQ,iIAAgC;AACxC,QAAQ,qHAA0B;AAClC,QAAQ,uHAA2B;AACnC,QAAQ,2GAAqB;AAC7B,QAAQ,yGAAoB;AAC5B,QAAQ,qHAA0B;AAClC,QAAQ,uGAAmB;AAC3B,QAAQ,yGAAoB;AAC5B,QAAQ,uGAAmB;AAC3B,QAAQ,wHAAqB;AAC7B,QAAQ,wIAA6B;AACrC,QAAQ,0GAAc;AACtB,QAAQ,oHAAmB;AAC3B,QAAQ,kGAAU;AAClB,QAAQ,gHAAiB;AACzB,QAAQ,sHAAoB;AAC5B,QAAQ,wGAAa;AACrB,QAAQ,wGAAa;AACrB,QAAQ,oGAAW;AACnB,QAAQ,8GAAgB;AACxB,QAAQ,4GAAe;AACvB,QAAQ,gHAAiB;AACzB,QAAQ,8GAAgB;AACxB,QAAQ,oHAAmB;AAC3B,QAAQ,sHAAoB;AAC5B,QAAQ,gIAAyB;AACjC,QAAQ,wHAAqB;AAC7B,QAAQ,wHAAqB;AAC7B,QAAQ,oIAA2B;AACnC,QAAQ,kIAA0B;AAClC,QAAQ,kJAAkC;AAC1C,QAAQ,8GAAgB;AACxB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,qCAAqC;AACrC,uEAAuE;AACvE,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,yBAAyB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,UAAU,iBAAiB;AAC3B;AACA;AACA;AACA,QAAQ,sEAAsE;AAC9E;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB,0BAA0B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB;AACA,aAAa;AACb,aAAa;AACb;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,aAAa;AAChD;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA,iBAAiB,wBAAwB;AACzC;AACA;;;AAGA,0CAA0C;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAsF,oBAAoB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC1iGF,iGAAO,EAAE,mCAAE;AACX;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACfF,iGAAO;AACP,QAAQ,mGAAiB;AACzB,QAAQ,+FAAe;AACvB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO,oDAAoD;AAC1E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,qBAAqB;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AClKF,iGAAO;AACP,QAAQ,iHAAwB;AAChC,QAAQ,mGAAiB;AACzB,QAAQ,mGAAiB;AACzB,QAAQ,iHAAwB;AAChC,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,OAAO;AACtB,eAAe,OAAO,sEAAsE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,mBAAmB,KAAK;AACpD;AACA;AACA,eAAe,OAAO,qDAAqD;AAC3E,iBAAiB,OAAO,EAAE,mBAAmB,KAAK,iCAAiC;AACnF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ,qBAAqB,wBAAwB;AACpE;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACjHF,iGAAO;AACP,QAAQ,mGAAiB;AACzB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ,qBAAqB,uBAAuB;AACnE;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACpDF,iGAAO;AACP,QAAQ,+FAAe;AACvB,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,+FAAe;AACvB,QAAQ,sIAA4B;AACpC,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB,6BAA6B,eAAe;AAC7E;AACA,eAAe,SAAS,0BAA0B,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6BAA6B,YAAY,EAAE,eAAe;AAC1D;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC5GF,iGAAO;AACP,QAAQ,+FAAe;AACvB,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,+FAAe;AACvB,QAAQ,sIAA4B;AACpC,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB,6BAA6B,eAAe;AAC7E;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS,wDAAwD,YAAY;AAC5F,eAAe,SAAS,iEAAiE,YAAY;AACrG,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qDAAqD,YAAY;AACjE;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,qDAAqD,YAAY;AACjE;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC5JF,iGAAO;AACP,QAAQ,+FAAe;AACvB,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,+FAAe;AACvB,QAAQ,sIAA4B;AACpC,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB,gCAAgC,eAAe;AAChF;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS,wDAAwD,YAAY;AAC5F,eAAe,SAAS,+DAA+D,YAAY;AACnG,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qDAAqD,YAAY;AACjE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,qDAAqD,YAAY;AACjE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AChJF,iGAAO;AACP,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,iHAAwB;AAChC,QAAQ,+FAAe;AACvB,QAAQ,2GAAqB;AAC7B,QAAQ,iHAAwB;AAChC,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,eAAe;AAC9B,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACnLF,iGAAO;AACP,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,iHAAwB;AAChC,QAAQ,+FAAe;AACvB,QAAQ,2GAAqB;AAC7B,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACpJF,iGAAO;AACP,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,iHAAwB;AAChC,QAAQ,6FAAc;AACtB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe;AACpC;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,SAAS;AAC9B;AACA;;;AAGA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,qBAAqB,SAAS;AAC9B;AACA;;;AAGA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B;AACA;;;AAGA;AACA;;AAEA;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,qEAAqE,kDAAkD;AACvH;AACA,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,qBAAqB,SAAS;AAC9B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC9HF,iGAAO;AACP,QAAQ,+FAAe;AACvB,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,+FAAe;AACvB,QAAQ,sIAA4B;AACpC,QAAQ,sGAAY;AACpB,QAAQ,wHAAqB;AAC7B,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uBAAuB,sBAAsB,eAAe;AACtE;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS,+EAA+E,wBAAwB;AAC/H,eAAe,SAAS,kEAAkE,YAAY;AACtG,eAAe,SAAS,kEAAkE,YAAY;AACtG,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,qDAAqD,wBAAwB;AAC7E;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,2DAA2D,YAAY;AACvE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,4DAA4D,YAAY;AACxE;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,eAAe;AAChC;AACA,eAAe,WAAW;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACxLF,iGAAO;AACP,QAAQ,6GAAsB;AAC9B,KAAK,mCAAE;AACP;AACA;;AAEA;AACA,8CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC1BF,iGAAO;AACP,QAAQ,yGAAoB;AAC5B,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,uGAAmB;AAC3B,QAAQ,+FAAe;AACvB,QAAQ,mGAAiB;AACzB,QAAQ,yGAAoB;AAC5B,QAAQ,yGAAoB;AAC5B,QAAQ,sGAAY;AACpB,QAAQ,kIAA0B;AAClC,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe,uBAAuB,iBAAiB;AACjE,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC5JF,iGAAO;AACP,QAAQ,yGAAoB;AAC5B,QAAQ,6GAAsB;AAC9B,QAAQ,mGAAiB;AACzB,QAAQ,qHAA0B;AAClC,QAAQ,iHAAwB;AAChC,QAAQ,+FAAe;AACvB,QAAQ,yGAAoB;AAC5B,QAAQ,sGAAY;AACpB,KAAK,mCAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe,uBAAuB,iBAAiB;AACjE,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC9MF;AACA,MAAM,IAA0C;AAChD;AACA,IAAI,iCAAO,EAAE,mCAAE;AACf;AACA,KAAK;AAAA,oGAAC;AACN,GAAG,MAAM,EAON;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ,iCAAiC;AACzC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAmD;AAC3F,wBAAwB;AACxB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB,yBAAyB,iCAAiC;AAC1D,UAAU,uBAAuB;AACjC,+DAA+D,6BAA6B;AAC5F;;;AAGA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA;AACA,KAAK,YAAY,sCAAsC,sBAAsB;AAC7E;AACA;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAgD,uCAAuC,MAAM;AACrG;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA,YAAY,OAAO;AACnB,4BAA4B,YAAY,GAAG,aAAa,GAAG,aAAa;AACxE,OAAO,eAAe,OAAO,eAAe;AAC5C,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,MAAM,OAAO;AACb,mEAAmE;AACnE;AACA;AACA,gCAAgC;;AAEhC,IAAI;AACJ,gCAAgC,8CAA8C;;AAE9E,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,YAAY,uBAAuB;AACnC,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;;AAEA;AACA,0BAA0B;;AAE1B,GAAG;AACH,iCAAiC;;AAEjC,GAAG;AACH;;AAEA,GAAG,OAAO;AACV;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA,EAAE;;;AAGF;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA,yCAAyC,mBAAmB;AAC5D;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,EAAE;;;AAGF;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,kCAAkC,iBAAiB,kBAAkB,iCAAiC;AACtG;AACA;AACA;AACA;AACA,oEAAoE,iBAAiB,yBAAyB;AAC9G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gDAAgD,uCAAuC,MAAM;AAC9I;AACA;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA,WAAW,OAAO;AAClB,gBAAgB,YAAY,GAAG,aAAa,GAAG,aAAa,GAAG,eAAe;AAC9E,UAAU,eAAe;AACzB,WAAW,OAAO;AAClB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,8BAA8B,kBAAkB,EAAE;;;AAGlD;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,0BAA0B,sDAAsD;AAChF;;AAEA,mDAAmD;AACnD,uCAAuC;AACvC;;AAEA,gCAAgC;AAChC;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,EAAE;AACd,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA,GAAG;AACH,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA,EAAE;;;;AAIF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAuE;AAC7F;AACA,QAAQ;AACR;AACA,4BAA4B;AAC5B;AACA;AACA,wBAAwB;AACxB,6BAA6B;AAC7B,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,6BAA6B;AAC7B,uCAAuC;AACvC;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,mEAAmE,iBAAiB,yBAAyB;AAC7G;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gDAAgD;AAC9E;AACA,gBAAgB;AAChB;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA,iEAAiE,kBAAkB,SAAS;AAC5F;AACA;;AAEA;AACA,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA,cAAc,iBAAiB;AAC/B;AACA;;;AAGA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;;AAEA,oDAAoD;AACpD,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA,wCAAwC;AACxC,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,gDAAgD;;AAEhD;AACA,EAAE;;;AAGF;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA,+EAA+E,iBAAiB;AAChG,+BAA+B,qCAAqC,YAAY,iCAAiC;AACjH,oDAAoD,qCAAqC;AACzF;AACA;AACA;AACA,mEAAmE,iBAAiB,yBAAyB;AAC7G;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,EAAE;;;AAGF;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA,YAAY,uBAAuB;AACnC;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;;AAGF;AACA,wEAAwE,KAAK;AAC7E;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,YAAY,0CAA0C;AACtD;AACA,aAAa,OAAO;AACpB,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD,EAAE;;;AAGF;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA,qBAAqB,gBAAgB;AACrC,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+CAA+C;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA,gCAAgC,gBAAgB;AAChD,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG;;AAElG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,qCAAqC,OAAO,KAAK,MAAM,KAAK,MAAM,OAAO,MAAM,MAAM;;;AAGrF;AACA,yDAAyD;AACzD;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,aAAa,iCAAiC;AAC9C,qBAAqB,+CAA+C;AACpE,OAAO,mDAAmD;AAC1D;AACA;AACA;AACA,qGAAqG;;AAErG;AACA,iDAAiD,UAAU;AAC3D,gDAAgD,kBAAkB;AAClE,mDAAmD,SAAS;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA,iCAAiC,oDAAoD;AACrF;AACA;AACA,YAAY,OAAO;AACnB,iCAAiC,cAAc;AAC/C,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA,iCAAiC,oDAAoD;AACrF;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO,yCAAyC,OAAO;AACnE;AACA,YAAY,QAAQ;AACpB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA,gCAAgC,kDAAkD;AAClF;AACA;AACA,YAAY,OAAO;AACnB,eAAe,KAAK;AACpB,aAAa;AACb;AACA;AACA,gDAAgD,aAAa;AAC7D,EAAE;;;AAGF;AACA,gCAAgC,8CAA8C;AAC9E;AACA;AACA,YAAY,OAAO;AACnB,aAAa;AACb;AACA;AACA,8CAA8C,aAAa;AAC3D;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oDAAoD;AAC9D,SAAS,8CAA8C;AACvD,SAAS,kDAAkD;AAC3D,iFAAiF,KAAK,UAAU;AAChG;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA,yBAAyB,oDAAoD;AAC7E;AACA,wBAAwB,8CAA8C;AACtE,wBAAwB,kDAAkD;AAC1E;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;AACA,mBAAmB,YAAY;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uCAAuC;AAC3C;AACA,iCAAiC,qCAAqC;AACtE;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gEAAgE,uCAAuC;AACvG;AACA,iCAAiC,qCAAqC;AACtE;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA,4DAA4D,OAAO;AACnE;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA,mEAAmE,OAAO;AAC1E,uBAAuB,QAAQ;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,oEAAoE,uCAAuC;AAC3G,aAAa,KAAK,gBAAgB,uCAAuC,eAAe;AACxF;AACA;AACA,mBAAmB,kEAAkE;AACrF;AACA,iCAAiC,qCAAqC;AACtE;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,uDAAuD,uCAAuC;AAC9F;AACA,iCAAiC,qCAAqC;AACtE;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uCAAuC;AACrE;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA,UAAU,eAAe;AACzB;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;;AAGA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;;AAEzC,oCAAoC,KAAK;;AAEzC,2BAA2B;AAC3B,6BAA6B,IAAI,cAAc,EAAE,aAAa,EAAE,SAAS,EAAE;AAC3E;AACA;AACA;AACA;;AAEA,4GAA4G;AAC5G;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA,SAAS,oBAAoB,OAAO,gCAAgC;AACpE;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,6DAA6D;AAC7D;AACA,YAAY,OAAO;AACnB;AACA,aAAa;AACb;AACA;AACA,gBAAgB;;AAEhB;AACA,8GAA8G;;AAE9G;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;;AAGF;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,OAAO,oBAAoB;AAC3B,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,mBAAmB;AACnB;;AAEA;AACA,wCAAwC,kDAAkD;;AAE1F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,0CAA0C,sDAAsD;;AAEhG,GAAG;AACH;AACA;AACA,yCAAyC,6CAA6C;;AAEtF,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,0CAA0C,qEAAqE;;AAE/G,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO,0CAA0C,oBAAoB;AACjF,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,sDAAsD;AAC1D;AACA;AACA;AACA;AACA;AACA,IAAI,sDAAsD;AAC1D;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,4BAA4B,sDAAsD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;;AAGA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qCAAqC;AACzC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,YAAY,iBAAiB,sCAAsC,qCAAqC;AACxG;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA,kDAAkD;AAClD;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;;;AAGA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA,+EAA+E,WAAW;AAC1F,QAAQ,qBAAqB;AAC7B;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,8FAA8F,WAAW;AACzG,KAAK,WAAW;AAChB;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,4BAA4B,UAAU,cAAc,6EAA6E;AACjI,EAAE;;;AAGF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;;AAEtD;AACA,EAAE;;;AAGF;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;;AAEA,CAAC","file":"vendors~Cesium-DataSources.TerriaJS-specs.js","sourcesContent":["define([\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Math'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        CesiumMath) {\n    'use strict';\n\n    var factorial = CesiumMath.factorial;\n\n    function calculateCoefficientTerm(x, zIndices, xTable, derivOrder, termOrder, reservedIndices) {\n        var result = 0;\n        var reserved;\n        var i;\n        var j;\n\n        if (derivOrder > 0) {\n            for (i = 0; i < termOrder; i++) {\n                reserved = false;\n                for (j = 0; j < reservedIndices.length && !reserved; j++) {\n                    if (i === reservedIndices[j]) {\n                        reserved = true;\n                    }\n                }\n\n                if (!reserved) {\n                    reservedIndices.push(i);\n                    result += calculateCoefficientTerm(x, zIndices, xTable, derivOrder - 1, termOrder, reservedIndices);\n                    reservedIndices.splice(reservedIndices.length - 1, 1);\n                }\n            }\n\n            return result;\n        }\n\n        result = 1;\n        for (i = 0; i < termOrder; i++) {\n            reserved = false;\n            for (j = 0; j < reservedIndices.length && !reserved; j++) {\n                if (i === reservedIndices[j]) {\n                    reserved = true;\n                }\n            }\n\n            if (!reserved) {\n                result *= x - xTable[zIndices[i]];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * An {@link InterpolationAlgorithm} for performing Hermite interpolation.\n     *\n     * @exports HermitePolynomialApproximation\n     */\n    var HermitePolynomialApproximation = {\n        type : 'Hermite'\n    };\n\n    /**\n     * Given the desired degree, returns the number of data points required for interpolation.\n     *\n     * @param {Number} degree The desired degree of interpolation.\n     * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).\n     * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n     * @exception {DeveloperError} degree must be 0 or greater.\n     * @exception {DeveloperError} inputOrder must be 0 or greater.\n     */\n    HermitePolynomialApproximation.getRequiredDataPoints = function(degree, inputOrder) {\n        inputOrder = defaultValue(inputOrder, 0);\n\n        \n\n        return Math.max(Math.floor((degree + 1) / (inputOrder + 1)), 2);\n    };\n\n    /**\n     * Interpolates values using Hermite Polynomial Approximation.\n     *\n     * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n     * in this array must be in increasing order and the same value must not occur twice in the array.\n     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n     * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n     * each independent variable value in xTable.\n     * @param {Number[]} [result] An existing array into which to store the result.\n     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n     */\n    HermitePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {\n        if (!defined(result)) {\n            result = new Array(yStride);\n        }\n\n        var i;\n        var j;\n        var d;\n        var s;\n        var len;\n        var index;\n        var length = xTable.length;\n        var coefficients = new Array(yStride);\n\n        for (i = 0; i < yStride; i++) {\n            result[i] = 0;\n\n            var l = new Array(length);\n            coefficients[i] = l;\n            for (j = 0; j < length; j++) {\n                l[j] = [];\n            }\n        }\n\n        var zIndicesLength = length, zIndices = new Array(zIndicesLength);\n\n        for (i = 0; i < zIndicesLength; i++) {\n            zIndices[i] = i;\n        }\n\n        var highestNonZeroCoef = length - 1;\n        for (s = 0; s < yStride; s++) {\n            for (j = 0; j < zIndicesLength; j++) {\n                index = zIndices[j] * yStride + s;\n                coefficients[s][0].push(yTable[index]);\n            }\n\n            for (i = 1; i < zIndicesLength; i++) {\n                var nonZeroCoefficients = false;\n                for (j = 0; j < zIndicesLength - i; j++) {\n                    var zj = xTable[zIndices[j]];\n                    var zn = xTable[zIndices[j + i]];\n\n                    var numerator;\n                    if (zn - zj <= 0) {\n                        index = zIndices[j] * yStride + yStride * i + s;\n                        numerator = yTable[index];\n                        coefficients[s][i].push(numerator / factorial(i));\n                    } else {\n                        numerator = (coefficients[s][i - 1][j + 1] - coefficients[s][i - 1][j]);\n                        coefficients[s][i].push(numerator / (zn - zj));\n                    }\n                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0);\n                }\n\n                if (!nonZeroCoefficients) {\n                    highestNonZeroCoef = i - 1;\n                }\n            }\n        }\n\n        for (d = 0, len = 0; d <= len; d++) {\n            for (i = d; i <= highestNonZeroCoef; i++) {\n                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, []);\n                for (s = 0; s < yStride; s++) {\n                    var coeff = coefficients[s][i][0];\n                    result[s + d * yStride] += coeff * tempTerm;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    var arrayScratch = [];\n\n    /**\n     * Interpolates values using Hermite Polynomial Approximation.\n     *\n     * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n     * in this array must be in increasing order and the same value must not occur twice in the array.\n     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n     * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n     * each independent variable value in xTable.\n     * @param {Number} inputOrder The number of derivatives supplied for input.\n     * @param {Number} outputOrder The number of derivatives desired for output.\n     * @param {Number[]} [result] An existing array into which to store the result.\n     *\n     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n     */\n    HermitePolynomialApproximation.interpolate = function(x, xTable, yTable, yStride, inputOrder, outputOrder, result) {\n        var resultLength = yStride * (outputOrder + 1);\n        if (!defined(result)) {\n            result = new Array(resultLength);\n        }\n        for (var r = 0; r < resultLength; r++) {\n            result[r] = 0;\n        }\n\n        var length = xTable.length;\n        // The zIndices array holds copies of the addresses of the xTable values\n        // in the range we're looking at. Even though this just holds information already\n        // available in xTable this is a much more convenient format.\n        var zIndices = new Array(length * (inputOrder + 1));\n        var i;\n        for (i = 0; i < length; i++) {\n            for (var j = 0; j < (inputOrder + 1); j++) {\n                zIndices[i * (inputOrder + 1) + j] = i;\n            }\n        }\n\n        var zIndiceslength = zIndices.length;\n        var coefficients = arrayScratch;\n        var highestNonZeroCoef = fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder);\n        var reservedIndices = [];\n\n        var tmp = zIndiceslength * (zIndiceslength + 1) / 2;\n        var loopStop = Math.min(highestNonZeroCoef, outputOrder);\n        for (var d = 0; d <= loopStop; d++) {\n            for (i = d; i <= highestNonZeroCoef; i++) {\n                reservedIndices.length = 0;\n                var tempTerm = calculateCoefficientTerm(x, zIndices, xTable, d, i, reservedIndices);\n                var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);\n\n                for (var s = 0; s < yStride; s++) {\n                    var dimOne = Math.floor(s * tmp);\n                    var coef = coefficients[dimOne + dimTwo];\n                    result[s + d * yStride] += coef * tempTerm;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    function fillCoefficientList(coefficients, zIndices, xTable, yTable, yStride, inputOrder) {\n        var j;\n        var index;\n        var highestNonZero = -1;\n        var zIndiceslength = zIndices.length;\n        var tmp = zIndiceslength * (zIndiceslength + 1) / 2;\n\n        for (var s = 0; s < yStride; s++) {\n            var dimOne = Math.floor(s * tmp);\n\n            for (j = 0; j < zIndiceslength; j++) {\n                index = zIndices[j] * yStride * (inputOrder + 1) + s;\n                coefficients[dimOne + j] = yTable[index];\n            }\n\n            for (var i = 1; i < zIndiceslength; i++) {\n                var coefIndex = 0;\n                var dimTwo = Math.floor(i * (1 - i) / 2) + (zIndiceslength * i);\n                var nonZeroCoefficients = false;\n\n                for (j = 0; j < zIndiceslength - i; j++) {\n                    var zj = xTable[zIndices[j]];\n                    var zn = xTable[zIndices[j + i]];\n\n                    var numerator;\n                    var coefficient;\n                    if (zn - zj <= 0) {\n                        index = zIndices[j] * yStride * (inputOrder + 1) + yStride * i + s;\n                        numerator = yTable[index];\n                        coefficient = (numerator / CesiumMath.factorial(i));\n                        coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n                        coefIndex++;\n                    } else {\n                        var dimTwoMinusOne = Math.floor((i - 1) * (2 - i) / 2) + (zIndiceslength * (i - 1));\n                        numerator = coefficients[dimOne + dimTwoMinusOne + j + 1] - coefficients[dimOne + dimTwoMinusOne + j];\n                        coefficient = (numerator / (zn - zj));\n                        coefficients[dimOne + dimTwo + coefIndex] = coefficient;\n                        coefIndex++;\n                    }\n                    nonZeroCoefficients = nonZeroCoefficients || (numerator !== 0.0);\n                }\n\n                if (nonZeroCoefficients) {\n                    highestNonZero = Math.max(highestNonZero, i);\n                }\n            }\n        }\n\n        return highestNonZero;\n    }\n\n    return HermitePolynomialApproximation;\n});\n","define([\n        './defined'\n    ], function(\n        defined) {\n    'use strict';\n\n    /**\n     * An {@link InterpolationAlgorithm} for performing Lagrange interpolation.\n     *\n     * @exports LagrangePolynomialApproximation\n     */\n    var LagrangePolynomialApproximation = {\n        type : 'Lagrange'\n    };\n\n    /**\n     * Given the desired degree, returns the number of data points required for interpolation.\n     *\n     * @param {Number} degree The desired degree of interpolation.\n     * @returns {Number} The number of required data points needed for the desired degree of interpolation.\n     */\n    LagrangePolynomialApproximation.getRequiredDataPoints = function(degree) {\n        return Math.max(degree + 1.0, 2);\n    };\n\n    /**\n     * Interpolates values using Lagrange Polynomial Approximation.\n     *\n     * @param {Number} x The independent variable for which the dependent variables will be interpolated.\n     * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values\n     * in this array must be in increasing order and the same value must not occur twice in the array.\n     * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three\n     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.\n     * @param {Number} yStride The number of dependent variable values in yTable corresponding to\n     * each independent variable value in xTable.\n     * @param {Number[]} [result] An existing array into which to store the result.\n     * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.\n     */\n    LagrangePolynomialApproximation.interpolateOrderZero = function(x, xTable, yTable, yStride, result) {\n        if (!defined(result)) {\n            result = new Array(yStride);\n        }\n\n        var i;\n        var j;\n        var length = xTable.length;\n\n        for (i = 0; i < yStride; i++) {\n            result[i] = 0;\n        }\n\n        for (i = 0; i < length; i++) {\n            var coefficient = 1;\n\n            for (j = 0; j < length; j++) {\n                if (j !== i) {\n                    var diffX = xTable[i] - xTable[j];\n                    coefficient *= (x - xTable[j]) / diffX;\n                }\n            }\n\n            for (j = 0; j < yStride; j++) {\n                result[j] += coefficient * yTable[i * yStride + j];\n            }\n        }\n\n        return result;\n    };\n\n    return LagrangePolynomialApproximation;\n});\n","define([\n        './Check',\n        './defaultValue',\n        './defined'\n    ], function(\n        Check,\n        defaultValue,\n        defined) {\n    'use strict';\n\n    /**\n     * A set of curvilinear 3-dimensional coordinates.\n     *\n     * @alias Spherical\n     * @constructor\n     *\n     * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\n     * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.\n     * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.\n     */\n    function Spherical(clock, cone, magnitude) {\n        /**\n         * The clock component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.clock = defaultValue(clock, 0.0);\n        /**\n         * The cone component.\n         * @type {Number}\n         * @default 0.0\n         */\n        this.cone = defaultValue(cone, 0.0);\n        /**\n         * The magnitude component.\n         * @type {Number}\n         * @default 1.0\n         */\n        this.magnitude = defaultValue(magnitude, 1.0);\n    }\n\n    /**\n     * Converts the provided Cartesian3 into Spherical coordinates.\n     *\n     * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.\n     * @param {Spherical} [result] The object in which the result will be stored, if undefined a new instance will be created.\n     * @returns {Spherical} The modified result parameter, or a new instance if one was not provided.\n     */\n    Spherical.fromCartesian3 = function(cartesian3, result) {\n        \n\n        var x = cartesian3.x;\n        var y = cartesian3.y;\n        var z = cartesian3.z;\n        var radialSquared = x * x + y * y;\n\n        if (!defined(result)) {\n            result = new Spherical();\n        }\n\n        result.clock = Math.atan2(y, x);\n        result.cone = Math.atan2(Math.sqrt(radialSquared), z);\n        result.magnitude = Math.sqrt(radialSquared + z * z);\n        return result;\n    };\n\n    /**\n     * Creates a duplicate of a Spherical.\n     *\n     * @param {Spherical} spherical The spherical to clone.\n     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.\n     * @returns {Spherical} The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)\n     */\n    Spherical.clone = function(spherical, result) {\n        if (!defined(spherical)) {\n            return undefined;\n        }\n\n        if (!defined(result)) {\n            return new Spherical(spherical.clock, spherical.cone, spherical.magnitude);\n        }\n\n        result.clock = spherical.clock;\n        result.cone = spherical.cone;\n        result.magnitude = spherical.magnitude;\n        return result;\n    };\n\n    /**\n     * Computes the normalized version of the provided spherical.\n     *\n     * @param {Spherical} spherical The spherical to be normalized.\n     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.\n     * @returns {Spherical} The modified result parameter or a new instance if result was undefined.\n     */\n    Spherical.normalize = function(spherical, result) {\n      \n\n        if (!defined(result)) {\n            return new Spherical(spherical.clock, spherical.cone, 1.0);\n        }\n\n        result.clock = spherical.clock;\n        result.cone = spherical.cone;\n        result.magnitude = 1.0;\n        return result;\n    };\n\n    /**\n     * Returns true if the first spherical is equal to the second spherical, false otherwise.\n     *\n     * @param {Spherical} left The first Spherical to be compared.\n     * @param {Spherical} right The second Spherical to be compared.\n     * @returns {Boolean} true if the first spherical is equal to the second spherical, false otherwise.\n     */\n    Spherical.equals = function(left, right) {\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (left.clock === right.clock) &&\n                (left.cone === right.cone) &&\n                (left.magnitude === right.magnitude));\n    };\n\n    /**\n     * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.\n     *\n     * @param {Spherical} left The first Spherical to be compared.\n     * @param {Spherical} right The second Spherical to be compared.\n     * @param {Number} [epsilon=0.0] The epsilon to compare against.\n     * @returns {Boolean} true if the first spherical is within the provided epsilon of the second spherical, false otherwise.\n     */\n    Spherical.equalsEpsilon = function(left, right, epsilon) {\n        epsilon = defaultValue(epsilon, 0.0);\n        return (left === right) ||\n               ((defined(left)) &&\n                (defined(right)) &&\n                (Math.abs(left.clock - right.clock) <= epsilon) &&\n                (Math.abs(left.cone - right.cone) <= epsilon) &&\n                (Math.abs(left.magnitude - right.magnitude) <= epsilon));\n    };\n\n    /**\n     * Returns true if this spherical is equal to the provided spherical, false otherwise.\n     *\n     * @param {Spherical} other The Spherical to be compared.\n     * @returns {Boolean} true if this spherical is equal to the provided spherical, false otherwise.\n     */\n    Spherical.prototype.equals = function(other) {\n        return Spherical.equals(this, other);\n    };\n\n    /**\n     * Creates a duplicate of this Spherical.\n     *\n     * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.\n     * @returns {Spherical} The modified result parameter or a new instance if result was undefined.\n     */\n    Spherical.prototype.clone = function(result) {\n        return Spherical.clone(this, result);\n    };\n\n    /**\n    * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.\n    *\n    * @param {Spherical} other The Spherical to be compared.\n    * @param {Number} epsilon The epsilon to compare against.\n    * @returns {Boolean} true if this spherical is within the provided epsilon of the provided spherical, false otherwise.\n    */\n    Spherical.prototype.equalsEpsilon = function(other, epsilon) {\n        return Spherical.equalsEpsilon(this, other, epsilon);\n    };\n\n    /**\n    * Returns a string representing this instance in the format (clock, cone, magnitude).\n    *\n    * @returns {String} A string representing this instance.\n    */\n    Spherical.prototype.toString = function() {\n        return '(' + this.clock + ', ' + this.cone + ', ' + this.magnitude + ')';\n    };\n\n    return Spherical;\n});\n","define([\n        '../Core/Cartesian2',\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Event',\n        './createPropertyDescriptor',\n        './Property'\n    ], function(\n        Cartesian2,\n        Color,\n        defaultValue,\n        defined,\n        defineProperties,\n        Event,\n        createPropertyDescriptor,\n        Property) {\n    'use strict';\n\n    var defaultEvenColor = Color.WHITE;\n    var defaultOddColor = Color.BLACK;\n    var defaultRepeat = new Cartesian2(2.0, 2.0);\n\n    /**\n     * A {@link MaterialProperty} that maps to checkerboard {@link Material} uniforms.\n     * @alias CheckerboardMaterialProperty\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Property} [options.evenColor=Color.WHITE] A Property specifying the first {@link Color}.\n     * @param {Property} [options.oddColor=Color.BLACK] A Property specifying the second {@link Color}.\n     * @param {Property} [options.repeat=new Cartesian2(2.0, 2.0)] A {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.\n     */\n    function CheckerboardMaterialProperty(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._definitionChanged = new Event();\n        this._evenColor = undefined;\n        this._evenColorSubscription = undefined;\n        this._oddColor = undefined;\n        this._oddColorSubscription = undefined;\n        this._repeat = undefined;\n        this._repeatSubscription = undefined;\n\n        this.evenColor = options.evenColor;\n        this.oddColor = options.oddColor;\n        this.repeat = options.repeat;\n    }\n\n    defineProperties(CheckerboardMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CheckerboardMaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._evenColor) && //\n                       Property.isConstant(this._oddColor) && //\n                       Property.isConstant(this._repeat);\n            }\n        },\n\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof CheckerboardMaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n\n        /**\n         * Gets or sets the Property specifying the first {@link Color}.\n         * @memberof CheckerboardMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.WHITE\n         */\n        evenColor : createPropertyDescriptor('evenColor'),\n\n        /**\n         * Gets or sets the Property specifying the second {@link Color}.\n         * @memberof CheckerboardMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.BLACK\n         */\n        oddColor : createPropertyDescriptor('oddColor'),\n\n        /**\n         * Gets or sets the {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.\n         * @memberof CheckerboardMaterialProperty.prototype\n         * @type {Property}\n         * @default new Cartesian2(2.0, 2.0)\n         */\n        repeat : createPropertyDescriptor('repeat')\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    CheckerboardMaterialProperty.prototype.getType = function(time) {\n        return 'Checkerboard';\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CheckerboardMaterialProperty.prototype.getValue = function(time, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n        result.lightColor = Property.getValueOrClonedDefault(this._evenColor, time, defaultEvenColor, result.lightColor);\n        result.darkColor = Property.getValueOrClonedDefault(this._oddColor, time, defaultOddColor, result.darkColor);\n        result.repeat = Property.getValueOrDefault(this._repeat, time, defaultRepeat);\n        return result;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CheckerboardMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CheckerboardMaterialProperty && //\n                       Property.equals(this._evenColor, other._evenColor) && //\n                       Property.equals(this._oddColor, other._oddColor) && //\n                       Property.equals(this._repeat, other._repeat));\n    };\n\n    return CheckerboardMaterialProperty;\n});\n","define([\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        './CompositeProperty',\n        './Property'\n    ], function(\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        CompositeProperty,\n        Property) {\n    'use strict';\n\n    /**\n     * A {@link CompositeProperty} which is also a {@link MaterialProperty}.\n     *\n     * @alias CompositeMaterialProperty\n     * @constructor\n     */\n    function CompositeMaterialProperty() {\n        this._definitionChanged = new Event();\n        this._composite = new CompositeProperty();\n        this._composite.definitionChanged.addEventListener(CompositeMaterialProperty.prototype._raiseDefinitionChanged, this);\n    }\n\n    defineProperties(CompositeMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositeMaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._composite.isConstant;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositeMaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositeMaterialProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._composite._intervals;\n            }\n        }\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    CompositeMaterialProperty.prototype.getType = function(time) {\n        \n\n        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getType(time);\n        }\n        return undefined;\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositeMaterialProperty.prototype.getValue = function(time, result) {\n        \n\n        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValue(time, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositeMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositeMaterialProperty && //\n                this._composite.equals(other._composite, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositeMaterialProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    return CompositeMaterialProperty;\n});\n","define([\n        '../Core/ArcType',\n        '../Core/BoundingRectangle',\n        '../Core/Cartesian2',\n        '../Core/Cartesian3',\n        '../Core/Cartographic',\n        '../Core/ClockRange',\n        '../Core/ClockStep',\n        '../Core/Color',\n        '../Core/CornerType',\n        '../Core/createGuid',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayCondition',\n        '../Core/Ellipsoid',\n        '../Core/Event',\n        '../Core/ExtrapolationType',\n        '../Core/getFilenameFromUri',\n        '../Core/HermitePolynomialApproximation',\n        '../Core/isArray',\n        '../Core/Iso8601',\n        '../Core/JulianDate',\n        '../Core/LagrangePolynomialApproximation',\n        '../Core/LinearApproximation',\n        '../Core/Math',\n        '../Core/NearFarScalar',\n        '../Core/PolygonHierarchy',\n        '../Core/Quaternion',\n        '../Core/Rectangle',\n        '../Core/ReferenceFrame',\n        '../Core/Resource',\n        '../Core/RuntimeError',\n        '../Core/Spherical',\n        '../Core/TimeInterval',\n        '../Core/TimeIntervalCollection',\n        '../Scene/ClassificationType',\n        '../Scene/ColorBlendMode',\n        '../Scene/HeightReference',\n        '../Scene/HorizontalOrigin',\n        '../Scene/LabelStyle',\n        '../Scene/ShadowMode',\n        '../Scene/VerticalOrigin',\n        '../ThirdParty/Uri',\n        '../ThirdParty/when',\n        './BillboardGraphics',\n        './BoxGraphics',\n        './CallbackProperty',\n        './CheckerboardMaterialProperty',\n        './ColorMaterialProperty',\n        './CompositeMaterialProperty',\n        './CompositePositionProperty',\n        './CompositeProperty',\n        './ConstantPositionProperty',\n        './ConstantProperty',\n        './CorridorGraphics',\n        './CylinderGraphics',\n        './DataSource',\n        './DataSourceClock',\n        './EllipseGraphics',\n        './EllipsoidGraphics',\n        './EntityCluster',\n        './EntityCollection',\n        './GridMaterialProperty',\n        './ImageMaterialProperty',\n        './LabelGraphics',\n        './ModelGraphics',\n        './NodeTransformationProperty',\n        './PathGraphics',\n        './PointGraphics',\n        './PolygonGraphics',\n        './PolylineArrowMaterialProperty',\n        './PolylineDashMaterialProperty',\n        './PolylineGlowMaterialProperty',\n        './PolylineGraphics',\n        './PolylineOutlineMaterialProperty',\n        './PositionPropertyArray',\n        './Property',\n        './PropertyArray',\n        './PropertyBag',\n        './RectangleGraphics',\n        './ReferenceProperty',\n        './Rotation',\n        './SampledPositionProperty',\n        './SampledProperty',\n        './StripeMaterialProperty',\n        './StripeOrientation',\n        './TimeIntervalCollectionPositionProperty',\n        './TimeIntervalCollectionProperty',\n        './VelocityOrientationProperty',\n        './VelocityVectorProperty',\n        './WallGraphics'\n    ], function(\n        ArcType,\n        BoundingRectangle,\n        Cartesian2,\n        Cartesian3,\n        Cartographic,\n        ClockRange,\n        ClockStep,\n        Color,\n        CornerType,\n        createGuid,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        DistanceDisplayCondition,\n        Ellipsoid,\n        Event,\n        ExtrapolationType,\n        getFilenameFromUri,\n        HermitePolynomialApproximation,\n        isArray,\n        Iso8601,\n        JulianDate,\n        LagrangePolynomialApproximation,\n        LinearApproximation,\n        CesiumMath,\n        NearFarScalar,\n        PolygonHierarchy,\n        Quaternion,\n        Rectangle,\n        ReferenceFrame,\n        Resource,\n        RuntimeError,\n        Spherical,\n        TimeInterval,\n        TimeIntervalCollection,\n        ClassificationType,\n        ColorBlendMode,\n        HeightReference,\n        HorizontalOrigin,\n        LabelStyle,\n        ShadowMode,\n        VerticalOrigin,\n        Uri,\n        when,\n        BillboardGraphics,\n        BoxGraphics,\n        CallbackProperty,\n        CheckerboardMaterialProperty,\n        ColorMaterialProperty,\n        CompositeMaterialProperty,\n        CompositePositionProperty,\n        CompositeProperty,\n        ConstantPositionProperty,\n        ConstantProperty,\n        CorridorGraphics,\n        CylinderGraphics,\n        DataSource,\n        DataSourceClock,\n        EllipseGraphics,\n        EllipsoidGraphics,\n        EntityCluster,\n        EntityCollection,\n        GridMaterialProperty,\n        ImageMaterialProperty,\n        LabelGraphics,\n        ModelGraphics,\n        NodeTransformationProperty,\n        PathGraphics,\n        PointGraphics,\n        PolygonGraphics,\n        PolylineArrowMaterialProperty,\n        PolylineDashMaterialProperty,\n        PolylineGlowMaterialProperty,\n        PolylineGraphics,\n        PolylineOutlineMaterialProperty,\n        PositionPropertyArray,\n        Property,\n        PropertyArray,\n        PropertyBag,\n        RectangleGraphics,\n        ReferenceProperty,\n        Rotation,\n        SampledPositionProperty,\n        SampledProperty,\n        StripeMaterialProperty,\n        StripeOrientation,\n        TimeIntervalCollectionPositionProperty,\n        TimeIntervalCollectionProperty,\n        VelocityOrientationProperty,\n        VelocityVectorProperty,\n        WallGraphics) {\n    'use strict';\n\n    // A marker type to distinguish CZML properties where we need to end up with a unit vector.\n    // The data is still loaded into Cartesian3 objects but they are normalized.\n    function UnitCartesian3() {}\n    UnitCartesian3.packedLength = Cartesian3.packedLength;\n    UnitCartesian3.unpack = Cartesian3.unpack;\n    UnitCartesian3.pack = Cartesian3.pack;\n\n    // As a side note, for the purposes of CZML, Quaternion always indicates a unit quaternion.\n\n    var currentId;\n\n    function createReferenceProperty(entityCollection, referenceString) {\n        if (referenceString[0] === '#') {\n            referenceString = currentId + referenceString;\n        }\n        return ReferenceProperty.fromString(entityCollection, referenceString);\n    }\n\n    function createSpecializedProperty(type, entityCollection, packetData) {\n        if (defined(packetData.reference)) {\n            return createReferenceProperty(entityCollection, packetData.reference);\n        }\n\n        if (defined(packetData.velocityReference)) {\n            var referenceProperty = createReferenceProperty(entityCollection, packetData.velocityReference);\n            switch (type) {\n                case Cartesian3:\n                case UnitCartesian3:\n                    return new VelocityVectorProperty(referenceProperty, type === UnitCartesian3);\n                case Quaternion:\n                    return new VelocityOrientationProperty(referenceProperty);\n            }\n        }\n\n        throw new RuntimeError(JSON.stringify(packetData) + ' is not valid CZML.');\n    }\n\n    function createAdapterProperty(property, adapterFunction) {\n        return new CallbackProperty(function(time, result) {\n            return adapterFunction(property.getValue(time, result));\n        }, property.isConstant);\n    }\n\n    var scratchCartesian = new Cartesian3();\n    var scratchSpherical = new Spherical();\n    var scratchCartographic = new Cartographic();\n    var scratchTimeInterval = new TimeInterval();\n    var scratchQuaternion = new Quaternion();\n\n    function unwrapColorInterval(czmlInterval) {\n        var rgbaf = czmlInterval.rgbaf;\n        if (defined(rgbaf)) {\n            return rgbaf;\n        }\n\n        var rgba = czmlInterval.rgba;\n        if (!defined(rgba)) {\n            return undefined;\n        }\n\n        var length = rgba.length;\n        if (length === Color.packedLength) {\n            return [Color.byteToFloat(rgba[0]), Color.byteToFloat(rgba[1]), Color.byteToFloat(rgba[2]), Color.byteToFloat(rgba[3])];\n        }\n\n        rgbaf = new Array(length);\n        for (var i = 0; i < length; i += 5) {\n            rgbaf[i] = rgba[i];\n            rgbaf[i + 1] = Color.byteToFloat(rgba[i + 1]);\n            rgbaf[i + 2] = Color.byteToFloat(rgba[i + 2]);\n            rgbaf[i + 3] = Color.byteToFloat(rgba[i + 3]);\n            rgbaf[i + 4] = Color.byteToFloat(rgba[i + 4]);\n        }\n        return rgbaf;\n    }\n\n    function unwrapUriInterval(czmlInterval, sourceUri) {\n        var uri = defaultValue(czmlInterval.uri, czmlInterval);\n        if (defined(sourceUri)) {\n            return sourceUri.getDerivedResource({\n                url: uri\n            });\n        }\n\n        return Resource.createIfNeeded(uri);\n    }\n\n    function unwrapRectangleInterval(czmlInterval) {\n        var wsen = czmlInterval.wsen;\n        if (defined(wsen)) {\n            return wsen;\n        }\n\n        var wsenDegrees = czmlInterval.wsenDegrees;\n        if (!defined(wsenDegrees)) {\n            return undefined;\n        }\n\n        var length = wsenDegrees.length;\n        if (length === Rectangle.packedLength) {\n            return [CesiumMath.toRadians(wsenDegrees[0]), CesiumMath.toRadians(wsenDegrees[1]), CesiumMath.toRadians(wsenDegrees[2]), CesiumMath.toRadians(wsenDegrees[3])];\n        }\n\n        wsen = new Array(length);\n        for (var i = 0; i < length; i += 5) {\n            wsen[i] = wsenDegrees[i];\n            wsen[i + 1] = CesiumMath.toRadians(wsenDegrees[i + 1]);\n            wsen[i + 2] = CesiumMath.toRadians(wsenDegrees[i + 2]);\n            wsen[i + 3] = CesiumMath.toRadians(wsenDegrees[i + 3]);\n            wsen[i + 4] = CesiumMath.toRadians(wsenDegrees[i + 4]);\n        }\n        return wsen;\n    }\n\n    function convertUnitSphericalToCartesian(unitSpherical) {\n        var length = unitSpherical.length;\n        scratchSpherical.magnitude = 1.0;\n        if (length === 2) {\n            scratchSpherical.clock = unitSpherical[0];\n            scratchSpherical.cone = unitSpherical[1];\n            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n        }\n\n        var result = new Array(length / 3 * 4);\n        for (var i = 0, j = 0; i < length; i += 3, j += 4) {\n            result[j] = unitSpherical[i];\n\n            scratchSpherical.clock = unitSpherical[i + 1];\n            scratchSpherical.cone = unitSpherical[i + 2];\n            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n\n            result[j + 1] = scratchCartesian.x;\n            result[j + 2] = scratchCartesian.y;\n            result[j + 3] = scratchCartesian.z;\n        }\n        return result;\n    }\n\n    function convertSphericalToCartesian(spherical) {\n        var length = spherical.length;\n        if (length === 3) {\n            scratchSpherical.clock = spherical[0];\n            scratchSpherical.cone = spherical[1];\n            scratchSpherical.magnitude = spherical[2];\n            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n        }\n\n        var result = new Array(length);\n        for (var i = 0; i < length; i += 4) {\n            result[i] = spherical[i];\n\n            scratchSpherical.clock = spherical[i + 1];\n            scratchSpherical.cone = spherical[i + 2];\n            scratchSpherical.magnitude = spherical[i + 3];\n            Cartesian3.fromSpherical(scratchSpherical, scratchCartesian);\n\n            result[i + 1] = scratchCartesian.x;\n            result[i + 2] = scratchCartesian.y;\n            result[i + 3] = scratchCartesian.z;\n        }\n        return result;\n    }\n\n    function convertCartographicRadiansToCartesian(cartographicRadians) {\n        var length = cartographicRadians.length;\n        if (length === 3) {\n            scratchCartographic.longitude = cartographicRadians[0];\n            scratchCartographic.latitude = cartographicRadians[1];\n            scratchCartographic.height = cartographicRadians[2];\n            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);\n            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n        }\n\n        var result = new Array(length);\n        for (var i = 0; i < length; i += 4) {\n            result[i] = cartographicRadians[i];\n\n            scratchCartographic.longitude = cartographicRadians[i + 1];\n            scratchCartographic.latitude = cartographicRadians[i + 2];\n            scratchCartographic.height = cartographicRadians[i + 3];\n            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);\n\n            result[i + 1] = scratchCartesian.x;\n            result[i + 2] = scratchCartesian.y;\n            result[i + 3] = scratchCartesian.z;\n        }\n        return result;\n    }\n\n    function convertCartographicDegreesToCartesian(cartographicDegrees) {\n        var length = cartographicDegrees.length;\n        if (length === 3) {\n            scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[0]);\n            scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[1]);\n            scratchCartographic.height = cartographicDegrees[2];\n            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);\n            return [scratchCartesian.x, scratchCartesian.y, scratchCartesian.z];\n        }\n\n        var result = new Array(length);\n        for (var i = 0; i < length; i += 4) {\n            result[i] = cartographicDegrees[i];\n\n            scratchCartographic.longitude = CesiumMath.toRadians(cartographicDegrees[i + 1]);\n            scratchCartographic.latitude = CesiumMath.toRadians(cartographicDegrees[i + 2]);\n            scratchCartographic.height = cartographicDegrees[i + 3];\n            Ellipsoid.WGS84.cartographicToCartesian(scratchCartographic, scratchCartesian);\n\n            result[i + 1] = scratchCartesian.x;\n            result[i + 2] = scratchCartesian.y;\n            result[i + 3] = scratchCartesian.z;\n        }\n        return result;\n    }\n\n    function unwrapCartesianInterval(czmlInterval) {\n        var cartesian = czmlInterval.cartesian;\n        if (defined(cartesian)) {\n            return cartesian;\n        }\n\n        var cartesianVelocity = czmlInterval.cartesianVelocity;\n        if (defined(cartesianVelocity)) {\n            return cartesianVelocity;\n        }\n\n        var unitCartesian = czmlInterval.unitCartesian;\n        if (defined(unitCartesian)) {\n            return unitCartesian;\n        }\n\n        var unitSpherical = czmlInterval.unitSpherical;\n        if (defined(unitSpherical)) {\n            return convertUnitSphericalToCartesian(unitSpherical);\n        }\n\n        var spherical = czmlInterval.spherical;\n        if (defined(spherical)) {\n            return convertSphericalToCartesian(spherical);\n        }\n\n        var cartographicRadians = czmlInterval.cartographicRadians;\n        if (defined(cartographicRadians)) {\n            return convertCartographicRadiansToCartesian(cartographicRadians);\n        }\n\n        var cartographicDegrees = czmlInterval.cartographicDegrees;\n        if (defined(cartographicDegrees)) {\n            return convertCartographicDegreesToCartesian(cartographicDegrees);\n        }\n\n        throw new RuntimeError(JSON.stringify(czmlInterval) + ' is not a valid CZML interval.');\n    }\n\n    function normalizePackedCartesianArray(array, startingIndex) {\n        Cartesian3.unpack(array, startingIndex, scratchCartesian);\n        Cartesian3.normalize(scratchCartesian, scratchCartesian);\n        Cartesian3.pack(scratchCartesian, array, startingIndex);\n    }\n\n    function unwrapUnitCartesianInterval(czmlInterval) {\n        var cartesian = unwrapCartesianInterval(czmlInterval);\n        if (cartesian.length === 3) {\n            normalizePackedCartesianArray(cartesian, 0);\n            return cartesian;\n        }\n\n        for (var i = 1; i < cartesian.length; i += 4) {\n            normalizePackedCartesianArray(cartesian, i);\n        }\n\n        return cartesian;\n    }\n\n    function normalizePackedQuaternionArray(array, startingIndex) {\n        Quaternion.unpack(array, startingIndex, scratchQuaternion);\n        Quaternion.normalize(scratchQuaternion, scratchQuaternion);\n        Quaternion.pack(scratchQuaternion, array, startingIndex);\n    }\n\n    function unwrapQuaternionInterval(czmlInterval) {\n        var unitQuaternion = czmlInterval.unitQuaternion;\n        if (defined(unitQuaternion)) {\n            if (unitQuaternion.length === 4) {\n                normalizePackedQuaternionArray(unitQuaternion, 0);\n                return unitQuaternion;\n            }\n\n            for (var i = 1; i < unitQuaternion.length; i += 5) {\n                normalizePackedQuaternionArray(unitQuaternion, i);\n            }\n        }\n        return unitQuaternion;\n    }\n\n    function getPropertyType(czmlInterval) {\n        // The associations in this function need to be kept in sync with the\n        // associations in unwrapInterval.\n\n        // Intentionally omitted due to conficts in CZML property names:\n        // * Image (conflicts with Uri)\n        // * Rotation (conflicts with Number)\n        //\n        // cartesianVelocity is also omitted due to incomplete support for\n        // derivative information in CZML properties.\n        // (Currently cartesianVelocity is hacked directly into the position processing code)\n        if (typeof czmlInterval === 'boolean') {\n            return Boolean;\n        } else if (typeof czmlInterval === 'number') {\n            return Number;\n        } else if (typeof czmlInterval === 'string') {\n            return String;\n        } else if (czmlInterval.hasOwnProperty('array')) {\n            return Array;\n        } else if (czmlInterval.hasOwnProperty('boolean')) {\n            return Boolean;\n        } else if (czmlInterval.hasOwnProperty('boundingRectangle')) {\n            return BoundingRectangle;\n        } else if (czmlInterval.hasOwnProperty('cartesian2')) {\n            return Cartesian2;\n        } else if (czmlInterval.hasOwnProperty('cartesian') ||\n                   czmlInterval.hasOwnProperty('spherical') ||\n                   czmlInterval.hasOwnProperty('cartographicRadians') ||\n                   czmlInterval.hasOwnProperty('cartographicDegrees')) {\n            return Cartesian3;\n        } else if (czmlInterval.hasOwnProperty('unitCartesian') ||\n                   czmlInterval.hasOwnProperty('unitSpherical')) {\n            return UnitCartesian3;\n        } else if (czmlInterval.hasOwnProperty('rgba') ||\n                   czmlInterval.hasOwnProperty('rgbaf')) {\n            return Color;\n        } else if (czmlInterval.hasOwnProperty('arcType')) {\n            return ArcType;\n        } else if (czmlInterval.hasOwnProperty('classificationType')) {\n            return ClassificationType;\n        } else if (czmlInterval.hasOwnProperty('colorBlendMode')) {\n            return ColorBlendMode;\n        } else if (czmlInterval.hasOwnProperty('cornerType')) {\n            return CornerType;\n        } else if (czmlInterval.hasOwnProperty('heightReference')) {\n            return HeightReference;\n        } else if (czmlInterval.hasOwnProperty('horizontalOrigin')) {\n            return HorizontalOrigin;\n        } else if (czmlInterval.hasOwnProperty('date')) {\n            return JulianDate;\n        } else if (czmlInterval.hasOwnProperty('labelStyle')) {\n            return LabelStyle;\n        } else if (czmlInterval.hasOwnProperty('number')) {\n            return Number;\n        } else if (czmlInterval.hasOwnProperty('nearFarScalar')) {\n            return NearFarScalar;\n        } else if (czmlInterval.hasOwnProperty('distanceDisplayCondition')) {\n            return DistanceDisplayCondition;\n        } else if (czmlInterval.hasOwnProperty('object') ||\n                   czmlInterval.hasOwnProperty('value')) {\n            return Object;\n        } else if (czmlInterval.hasOwnProperty('unitQuaternion')) {\n            return Quaternion;\n        } else if (czmlInterval.hasOwnProperty('shadowMode')) {\n            return ShadowMode;\n        } else if (czmlInterval.hasOwnProperty('string')) {\n            return String;\n        } else if (czmlInterval.hasOwnProperty('stripeOrientation')) {\n            return StripeOrientation;\n        } else if (czmlInterval.hasOwnProperty('wsen') ||\n                   czmlInterval.hasOwnProperty('wsenDegrees')) {\n            return Rectangle;\n        } else if (czmlInterval.hasOwnProperty('uri')) {\n            return Uri;\n        } else if (czmlInterval.hasOwnProperty('verticalOrigin')) {\n            return VerticalOrigin;\n        }\n        // fallback case\n        return Object;\n    }\n\n    function unwrapInterval(type, czmlInterval, sourceUri) {\n        // The associations in this function need to be kept in sync with the\n        // associations in getPropertyType\n        switch (type) {\n            case ArcType:\n                return ArcType[defaultValue(czmlInterval.arcType, czmlInterval)];\n            case Array:\n                return czmlInterval.array;\n            case Boolean:\n                return defaultValue(czmlInterval['boolean'], czmlInterval);\n            case BoundingRectangle:\n                return czmlInterval.boundingRectangle;\n            case Cartesian2:\n                return czmlInterval.cartesian2;\n            case Cartesian3:\n                return unwrapCartesianInterval(czmlInterval);\n            case UnitCartesian3:\n                return unwrapUnitCartesianInterval(czmlInterval);\n            case Color:\n                return unwrapColorInterval(czmlInterval);\n            case ClassificationType:\n                return ClassificationType[defaultValue(czmlInterval.classificationType, czmlInterval)];\n            case ColorBlendMode:\n                return ColorBlendMode[defaultValue(czmlInterval.colorBlendMode, czmlInterval)];\n            case CornerType:\n                return CornerType[defaultValue(czmlInterval.cornerType, czmlInterval)];\n            case HeightReference:\n                return HeightReference[defaultValue(czmlInterval.heightReference, czmlInterval)];\n            case HorizontalOrigin:\n                return HorizontalOrigin[defaultValue(czmlInterval.horizontalOrigin, czmlInterval)];\n            case Image:\n                return unwrapUriInterval(czmlInterval, sourceUri);\n            case JulianDate:\n                return JulianDate.fromIso8601(defaultValue(czmlInterval.date, czmlInterval));\n            case LabelStyle:\n                return LabelStyle[defaultValue(czmlInterval.labelStyle, czmlInterval)];\n            case Number:\n                return defaultValue(czmlInterval.number, czmlInterval);\n            case NearFarScalar:\n                return czmlInterval.nearFarScalar;\n            case DistanceDisplayCondition:\n                return czmlInterval.distanceDisplayCondition;\n            case Object:\n                return defaultValue(defaultValue(czmlInterval.object, czmlInterval.value), czmlInterval);\n            case Quaternion:\n                return unwrapQuaternionInterval(czmlInterval);\n            case Rectangle:\n                return unwrapRectangleInterval(czmlInterval);\n            case Rotation:\n                return defaultValue(czmlInterval.number, czmlInterval);\n            case ShadowMode:\n                return ShadowMode[defaultValue(defaultValue(czmlInterval.shadowMode, czmlInterval.shadows), czmlInterval)];\n            case String:\n                return defaultValue(czmlInterval.string, czmlInterval);\n            case StripeOrientation:\n                return StripeOrientation[defaultValue(czmlInterval.stripeOrientation, czmlInterval)];\n            case Uri:\n                return unwrapUriInterval(czmlInterval, sourceUri);\n            case VerticalOrigin:\n                return VerticalOrigin[defaultValue(czmlInterval.verticalOrigin, czmlInterval)];\n            default:\n                throw new RuntimeError(type);\n        }\n    }\n\n    var interpolators = {\n        HERMITE : HermitePolynomialApproximation,\n        LAGRANGE : LagrangePolynomialApproximation,\n        LINEAR : LinearApproximation\n    };\n\n    function updateInterpolationSettings(packetData, property) {\n        var interpolationAlgorithm = packetData.interpolationAlgorithm;\n        var interpolationDegree = packetData.interpolationDegree;\n        if (defined(interpolationAlgorithm) || defined(interpolationDegree)) {\n            property.setInterpolationOptions({\n                interpolationAlgorithm : interpolators[interpolationAlgorithm],\n                interpolationDegree : interpolationDegree\n            });\n        }\n\n        var forwardExtrapolationType = packetData.forwardExtrapolationType;\n        if (defined(forwardExtrapolationType)) {\n            property.forwardExtrapolationType = ExtrapolationType[forwardExtrapolationType];\n        }\n\n        var forwardExtrapolationDuration = packetData.forwardExtrapolationDuration;\n        if (defined(forwardExtrapolationDuration)) {\n            property.forwardExtrapolationDuration = forwardExtrapolationDuration;\n        }\n\n        var backwardExtrapolationType = packetData.backwardExtrapolationType;\n        if (defined(backwardExtrapolationType)) {\n            property.backwardExtrapolationType = ExtrapolationType[backwardExtrapolationType];\n        }\n\n        var backwardExtrapolationDuration = packetData.backwardExtrapolationDuration;\n        if (defined(backwardExtrapolationDuration)) {\n            property.backwardExtrapolationDuration = backwardExtrapolationDuration;\n        }\n    }\n\n    var iso8601Scratch = {\n        iso8601 : undefined\n    };\n\n    function intervalFromString(intervalString) {\n        if (!defined(intervalString)) {\n            return undefined;\n        }\n        iso8601Scratch.iso8601 = intervalString;\n        return TimeInterval.fromIso8601(iso8601Scratch);\n    }\n\n    function wrapPropertyInInfiniteInterval(property) {\n        var interval = Iso8601.MAXIMUM_INTERVAL.clone();\n        interval.data = property;\n        return interval;\n    }\n\n    function convertPropertyToComposite(property) {\n        // Create the composite and add the old property, wrapped in an infinite interval.\n        var composite = new CompositeProperty();\n        composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n        return composite;\n    }\n\n    function convertPositionPropertyToComposite(property) {\n        // Create the composite and add the old property, wrapped in an infinite interval.\n        var composite = new CompositePositionProperty(property.referenceFrame);\n        composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n        return composite;\n    }\n\n    function processProperty(type, object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {\n        var combinedInterval = intervalFromString(packetData.interval);\n        if (defined(constrainedInterval)) {\n            if (defined(combinedInterval)) {\n                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n            } else {\n                combinedInterval = constrainedInterval;\n            }\n        }\n\n        var packedLength;\n        var unwrappedInterval;\n        var unwrappedIntervalLength;\n\n        // CZML properties can be defined in many ways.  Most ways represent a structure for\n        // encoding a single value (number, string, cartesian, etc.)  Regardless of the value type,\n        // if it encodes a single value it will get loaded into a ConstantProperty eventually.\n        // Alternatively, there are ways of defining a property that require specialized\n        // client-side representation. Currently, these are ReferenceProperty,\n        // and client-side velocity computation properties such as VelocityVectorProperty.\n        var isValue = !defined(packetData.reference) && !defined(packetData.velocityReference);\n        var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n\n        if (packetData.delete === true) {\n            // If deleting this property for all time, we can simply set to undefined and return.\n            if (!hasInterval) {\n                object[propertyName] = undefined;\n                return;\n            }\n\n            // Deleting depends on the type of property we have.\n            return removePropertyData(object[propertyName], combinedInterval);\n        }\n\n        var isSampled = false;\n\n        if (isValue) {\n            unwrappedInterval = unwrapInterval(type, packetData, sourceUri);\n            if (!defined(unwrappedInterval)) {\n                // not a known value type, bail\n                return;\n            }\n            packedLength = defaultValue(type.packedLength, 1);\n            unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);\n            isSampled = !defined(packetData.array) && (typeof unwrappedInterval !== 'string') && (unwrappedIntervalLength > packedLength) && (type !== Object);\n        }\n\n        // Rotation is a special case because it represents a native type (Number)\n        // and therefore does not need to be unpacked when loaded as a constant value.\n        var needsUnpacking = typeof type.unpack === 'function' && type !== Rotation;\n\n        // Any time a constant value is assigned, it completely blows away anything else.\n        if (!isSampled && !hasInterval) {\n            if (isValue) {\n                object[propertyName] = new ConstantProperty(needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval);\n            } else {\n                object[propertyName] = createSpecializedProperty(type, entityCollection, packetData);\n            }\n            return;\n        }\n\n        var property = object[propertyName];\n\n        var epoch;\n        var packetEpoch = packetData.epoch;\n        if (defined(packetEpoch)) {\n            epoch = JulianDate.fromIso8601(packetEpoch);\n        }\n\n        // Without an interval, any sampled value is infinite, meaning it completely\n        // replaces any non-sampled property that may exist.\n        if (isSampled && !hasInterval) {\n            if (!(property instanceof SampledProperty)) {\n                object[propertyName] = property = new SampledProperty(type);\n            }\n            property.addSamplesPackedArray(unwrappedInterval, epoch);\n            updateInterpolationSettings(packetData, property);\n            return;\n        }\n\n        var interval;\n\n        // A constant value with an interval is normally part of a TimeIntervalCollection,\n        // However, if the current property is not a time-interval collection, we need\n        // to turn it into a Composite, preserving the old data with the new interval.\n        if (!isSampled && hasInterval) {\n            // Create a new interval for the constant value.\n            combinedInterval = combinedInterval.clone();\n            if (isValue) {\n                combinedInterval.data = needsUnpacking ? type.unpack(unwrappedInterval, 0) : unwrappedInterval;\n            } else {\n                combinedInterval.data = createSpecializedProperty(type, entityCollection, packetData);\n            }\n\n            // If no property exists, simply use a new interval collection\n            if (!defined(property)) {\n                object[propertyName] = property = isValue ? new TimeIntervalCollectionProperty() : new CompositeProperty();\n            }\n\n            if (isValue && property instanceof TimeIntervalCollectionProperty) {\n                // If we created a collection, or it already was one, use it.\n                property.intervals.addInterval(combinedInterval);\n            } else if (property instanceof CompositeProperty) {\n                // If the collection was already a CompositeProperty, use it.\n                if (isValue) {\n                    combinedInterval.data = new ConstantProperty(combinedInterval.data);\n                }\n                property.intervals.addInterval(combinedInterval);\n            } else {\n                // Otherwise, create a CompositeProperty but preserve the existing data.\n                object[propertyName] = property = convertPropertyToComposite(property);\n\n                // Change the new data to a ConstantProperty and add it.\n                if (isValue) {\n                    combinedInterval.data = new ConstantProperty(combinedInterval.data);\n                }\n                property.intervals.addInterval(combinedInterval);\n            }\n\n            return;\n        }\n\n        // isSampled && hasInterval\n        if (!defined(property)) {\n            object[propertyName] = property = new CompositeProperty();\n        }\n\n        // Create a CompositeProperty but preserve the existing data.\n        if (!(property instanceof CompositeProperty)) {\n            object[propertyName] = property = convertPropertyToComposite(property);\n        }\n\n        // Check if the interval already exists in the composite.\n        var intervals = property.intervals;\n        interval = intervals.findInterval(combinedInterval);\n        if (!defined(interval) || !(interval.data instanceof SampledProperty)) {\n            // If not, create a SampledProperty for it.\n            interval = combinedInterval.clone();\n            interval.data = new SampledProperty(type);\n            intervals.addInterval(interval);\n        }\n        interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n        updateInterpolationSettings(packetData, interval.data);\n    }\n\n    function removePropertyData(property, interval) {\n        if (property instanceof SampledProperty) {\n            property.removeSamples(interval);\n            return;\n        } else if (property instanceof TimeIntervalCollectionProperty) {\n            property.intervals.removeInterval(interval);\n            return;\n        } else if (property instanceof CompositeProperty) {\n            var intervals = property.intervals;\n            for (var i = 0; i < intervals.length; ++i) {\n                var intersection = TimeInterval.intersect(intervals.get(i), interval, scratchTimeInterval);\n                if (!intersection.isEmpty) {\n                    // remove data from the contained properties\n                    removePropertyData(intersection.data, interval);\n                }\n            }\n            // remove the intervals from the composite\n            intervals.removeInterval(interval);\n            return;\n        }\n    }\n\n    function processPacketData(type, object, propertyName, packetData, interval, sourceUri, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        if (isArray(packetData)) {\n            for (var i = 0, len = packetData.length; i < len; ++i) {\n                processProperty(type, object, propertyName, packetData[i], interval, sourceUri, entityCollection);\n            }\n        } else {\n            processProperty(type, object, propertyName, packetData, interval, sourceUri, entityCollection);\n        }\n    }\n\n    function processPositionProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {\n        var combinedInterval = intervalFromString(packetData.interval);\n        if (defined(constrainedInterval)) {\n            if (defined(combinedInterval)) {\n                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n            } else {\n                combinedInterval = constrainedInterval;\n            }\n        }\n\n        var numberOfDerivatives = defined(packetData.cartesianVelocity) ? 1 : 0;\n        var packedLength = Cartesian3.packedLength * (numberOfDerivatives + 1);\n        var unwrappedInterval;\n        var unwrappedIntervalLength;\n        var isValue = !defined(packetData.reference);\n        var hasInterval = defined(combinedInterval) && !combinedInterval.equals(Iso8601.MAXIMUM_INTERVAL);\n\n        if (packetData.delete === true) {\n            // If deleting this property for all time, we can simply set to undefined and return.\n            if (!hasInterval) {\n                object[propertyName] = undefined;\n                return;\n            }\n\n            // Deleting depends on the type of property we have.\n            return removePositionPropertyData(object[propertyName], combinedInterval);\n        }\n\n        var referenceFrame;\n        var isSampled = false;\n\n        if (isValue) {\n            if (defined(packetData.referenceFrame)) {\n                referenceFrame = ReferenceFrame[packetData.referenceFrame];\n            }\n            referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n            unwrappedInterval = unwrapCartesianInterval(packetData);\n            unwrappedIntervalLength = defaultValue(unwrappedInterval.length, 1);\n            isSampled = unwrappedIntervalLength > packedLength;\n        }\n\n        // Any time a constant value is assigned, it completely blows away anything else.\n        if (!isSampled && !hasInterval) {\n            if (isValue) {\n                object[propertyName] = new ConstantPositionProperty(Cartesian3.unpack(unwrappedInterval), referenceFrame);\n            } else {\n                object[propertyName] = createReferenceProperty(entityCollection, packetData.reference);\n            }\n            return;\n        }\n\n        var property = object[propertyName];\n\n        var epoch;\n        var packetEpoch = packetData.epoch;\n        if (defined(packetEpoch)) {\n            epoch = JulianDate.fromIso8601(packetEpoch);\n        }\n\n        // Without an interval, any sampled value is infinite, meaning it completely\n        // replaces any non-sampled property that may exist.\n        if (isSampled && !hasInterval) {\n            if (!(property instanceof SampledPositionProperty) || (defined(referenceFrame) && property.referenceFrame !== referenceFrame)) {\n                object[propertyName] = property = new SampledPositionProperty(referenceFrame, numberOfDerivatives);\n            }\n            property.addSamplesPackedArray(unwrappedInterval, epoch);\n            updateInterpolationSettings(packetData, property);\n            return;\n        }\n\n        var interval;\n\n        // A constant value with an interval is normally part of a TimeIntervalCollection,\n        // However, if the current property is not a time-interval collection, we need\n        // to turn it into a Composite, preserving the old data with the new interval.\n        if (!isSampled && hasInterval) {\n            // Create a new interval for the constant value.\n            combinedInterval = combinedInterval.clone();\n            if (isValue) {\n                combinedInterval.data = Cartesian3.unpack(unwrappedInterval);\n            } else {\n                combinedInterval.data = createReferenceProperty(entityCollection, packetData.reference);\n            }\n\n            // If no property exists, simply use a new interval collection\n            if (!defined(property)) {\n                if (isValue) {\n                    property = new TimeIntervalCollectionPositionProperty(referenceFrame);\n                } else {\n                    property = new CompositePositionProperty(referenceFrame);\n                }\n                object[propertyName] = property;\n            }\n\n            if (isValue && property instanceof TimeIntervalCollectionPositionProperty && (defined(referenceFrame) && property.referenceFrame === referenceFrame)) {\n                // If we create a collection, or it already existed, use it.\n                property.intervals.addInterval(combinedInterval);\n            } else if (property instanceof CompositePositionProperty) {\n                // If the collection was already a CompositePositionProperty, use it.\n                if (isValue) {\n                    combinedInterval.data = new ConstantPositionProperty(combinedInterval.data, referenceFrame);\n                }\n                property.intervals.addInterval(combinedInterval);\n            } else {\n                // Otherwise, create a CompositePositionProperty but preserve the existing data.\n                object[propertyName] = property = convertPositionPropertyToComposite(property);\n\n                // Change the new data to a ConstantPositionProperty and add it.\n                if (isValue) {\n                    combinedInterval.data = new ConstantPositionProperty(combinedInterval.data, referenceFrame);\n                }\n                property.intervals.addInterval(combinedInterval);\n            }\n\n            return;\n        }\n\n        // isSampled && hasInterval\n        if (!defined(property)) {\n            object[propertyName] = property = new CompositePositionProperty(referenceFrame);\n        } else if (!(property instanceof CompositePositionProperty)) {\n            // Create a CompositeProperty but preserve the existing data.\n            object[propertyName] = property = convertPositionPropertyToComposite(property);\n        }\n\n        // Check if the interval already exists in the composite.\n        var intervals = property.intervals;\n        interval = intervals.findInterval(combinedInterval);\n        if (!defined(interval) || !(interval.data instanceof SampledPositionProperty) || (defined(referenceFrame) && interval.data.referenceFrame !== referenceFrame)) {\n            // If not, create a SampledPositionProperty for it.\n            interval = combinedInterval.clone();\n            interval.data = new SampledPositionProperty(referenceFrame, numberOfDerivatives);\n            intervals.addInterval(interval);\n        }\n        interval.data.addSamplesPackedArray(unwrappedInterval, epoch);\n        updateInterpolationSettings(packetData, interval.data);\n    }\n\n    function removePositionPropertyData(property, interval) {\n        if (property instanceof SampledPositionProperty) {\n            property.removeSamples(interval);\n            return;\n        } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n            property.intervals.removeInterval(interval);\n            return;\n        } else if (property instanceof CompositePositionProperty) {\n            var intervals = property.intervals;\n            for (var i = 0; i < intervals.length; ++i) {\n                var intersection = TimeInterval.intersect(intervals.get(i), interval, scratchTimeInterval);\n                if (!intersection.isEmpty) {\n                    // remove data from the contained properties\n                    removePositionPropertyData(intersection.data, interval);\n                }\n            }\n            // remove the intervals from the composite\n            intervals.removeInterval(interval);\n            return;\n        }\n    }\n\n    function processPositionPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        if (isArray(packetData)) {\n            for (var i = 0, len = packetData.length; i < len; ++i) {\n                processPositionProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);\n            }\n        } else {\n            processPositionProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);\n        }\n    }\n\n    function processMaterialProperty(object, propertyName, packetData, constrainedInterval, sourceUri, entityCollection) {\n        var combinedInterval = intervalFromString(packetData.interval);\n        if (defined(constrainedInterval)) {\n            if (defined(combinedInterval)) {\n                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n            } else {\n                combinedInterval = constrainedInterval;\n            }\n        }\n\n        var property = object[propertyName];\n        var existingMaterial;\n        var existingInterval;\n\n        if (defined(combinedInterval)) {\n            if (!(property instanceof CompositeMaterialProperty)) {\n                property = new CompositeMaterialProperty();\n                object[propertyName] = property;\n            }\n            //See if we already have data at that interval.\n            var thisIntervals = property.intervals;\n            existingInterval = thisIntervals.findInterval({\n                start : combinedInterval.start,\n                stop : combinedInterval.stop\n            });\n            if (defined(existingInterval)) {\n                //We have an interval, but we need to make sure the\n                //new data is the same type of material as the old data.\n                existingMaterial = existingInterval.data;\n            } else {\n                //If not, create it.\n                existingInterval = combinedInterval.clone();\n                thisIntervals.addInterval(existingInterval);\n            }\n        } else {\n            existingMaterial = property;\n        }\n\n        var materialData;\n        if (defined(packetData.solidColor)) {\n            if (!(existingMaterial instanceof ColorMaterialProperty)) {\n                existingMaterial = new ColorMaterialProperty();\n            }\n            materialData = packetData.solidColor;\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);\n        } else if (defined(packetData.grid)) {\n            if (!(existingMaterial instanceof GridMaterialProperty)) {\n                existingMaterial = new GridMaterialProperty();\n            }\n            materialData = packetData.grid;\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'cellAlpha', materialData.cellAlpha, undefined, sourceUri, entityCollection);\n            processPacketData(Cartesian2, existingMaterial, 'lineCount', materialData.lineCount, undefined, sourceUri, entityCollection);\n            processPacketData(Cartesian2, existingMaterial, 'lineThickness', materialData.lineThickness, undefined, sourceUri, entityCollection);\n            processPacketData(Cartesian2, existingMaterial, 'lineOffset', materialData.lineOffset, undefined, sourceUri, entityCollection);\n        } else if (defined(packetData.image)) {\n            if (!(existingMaterial instanceof ImageMaterialProperty)) {\n                existingMaterial = new ImageMaterialProperty();\n            }\n            materialData = packetData.image;\n            processPacketData(Image, existingMaterial, 'image', materialData.image, undefined, sourceUri, entityCollection);\n            processPacketData(Cartesian2, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);\n            processPacketData(Boolean, existingMaterial, 'transparent', materialData.transparent, undefined, sourceUri, entityCollection);\n        } else if (defined(packetData.stripe)) {\n            if (!(existingMaterial instanceof StripeMaterialProperty)) {\n                existingMaterial = new StripeMaterialProperty();\n            }\n            materialData = packetData.stripe;\n            processPacketData(StripeOrientation, existingMaterial, 'orientation', materialData.orientation, undefined, sourceUri, entityCollection);\n            processPacketData(Color, existingMaterial, 'evenColor', materialData.evenColor, undefined, sourceUri, entityCollection);\n            processPacketData(Color, existingMaterial, 'oddColor', materialData.oddColor, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'offset', materialData.offset, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);\n        } else if (defined(packetData.polylineOutline)) {\n            if (!(existingMaterial instanceof PolylineOutlineMaterialProperty)) {\n                existingMaterial = new PolylineOutlineMaterialProperty();\n            }\n            materialData = packetData.polylineOutline;\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);\n            processPacketData(Color, existingMaterial, 'outlineColor', materialData.outlineColor, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'outlineWidth', materialData.outlineWidth, undefined, sourceUri, entityCollection);\n        } else if (defined(packetData.polylineGlow)) {\n            if (!(existingMaterial instanceof PolylineGlowMaterialProperty)) {\n                existingMaterial = new PolylineGlowMaterialProperty();\n            }\n            materialData = packetData.polylineGlow;\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'glowPower', materialData.glowPower, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'taperPower', materialData.taperPower, undefined, sourceUri, entityCollection);\n        } else if (defined(packetData.polylineArrow)) {\n            if (!(existingMaterial instanceof PolylineArrowMaterialProperty)) {\n                existingMaterial = new PolylineArrowMaterialProperty();\n            }\n            materialData = packetData.polylineArrow;\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);\n        } else if (defined(packetData.polylineDash)) {\n            if (!(existingMaterial instanceof PolylineDashMaterialProperty)) {\n                existingMaterial = new PolylineDashMaterialProperty();\n            }\n            materialData = packetData.polylineDash;\n            processPacketData(Color, existingMaterial, 'color', materialData.color, undefined, undefined, entityCollection);\n            processPacketData(Color, existingMaterial, 'gapColor', materialData.gapColor, undefined, undefined, entityCollection);\n            processPacketData(Number, existingMaterial, 'dashLength', materialData.dashLength, undefined, sourceUri, entityCollection);\n            processPacketData(Number, existingMaterial, 'dashPattern', materialData.dashPattern, undefined, sourceUri, entityCollection);\n        } else if (defined(packetData.checkerboard)) {\n            if (!(existingMaterial instanceof CheckerboardMaterialProperty)) {\n                existingMaterial = new CheckerboardMaterialProperty();\n            }\n            materialData = packetData.checkerboard;\n            processPacketData(Color, existingMaterial, 'evenColor', materialData.evenColor, undefined, sourceUri, entityCollection);\n            processPacketData(Color, existingMaterial, 'oddColor', materialData.oddColor, undefined, sourceUri, entityCollection);\n            processPacketData(Cartesian2, existingMaterial, 'repeat', materialData.repeat, undefined, sourceUri, entityCollection);\n        }\n\n        if (defined(existingInterval)) {\n            existingInterval.data = existingMaterial;\n        } else {\n            object[propertyName] = existingMaterial;\n        }\n    }\n\n    function processMaterialPacketData(object, propertyName, packetData, interval, sourceUri, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        if (isArray(packetData)) {\n            for (var i = 0, len = packetData.length; i < len; ++i) {\n                processMaterialProperty(object, propertyName, packetData[i], interval, sourceUri, entityCollection);\n            }\n        } else {\n            processMaterialProperty(object, propertyName, packetData, interval, sourceUri, entityCollection);\n        }\n    }\n\n    function processName(entity, packet, entityCollection, sourceUri) {\n        var nameData = packet.name;\n        if (defined(nameData)) {\n            entity.name = packet.name;\n        }\n    }\n\n    function processDescription(entity, packet, entityCollection, sourceUri) {\n        var descriptionData = packet.description;\n        if (defined(descriptionData)) {\n            processPacketData(String, entity, 'description', descriptionData, undefined, sourceUri, entityCollection);\n        }\n    }\n\n    function processPosition(entity, packet, entityCollection, sourceUri) {\n        var positionData = packet.position;\n        if (defined(positionData)) {\n            processPositionPacketData(entity, 'position', positionData, undefined, sourceUri, entityCollection);\n        }\n    }\n\n    function processViewFrom(entity, packet, entityCollection, sourceUri) {\n        var viewFromData = packet.viewFrom;\n        if (defined(viewFromData)) {\n            processPacketData(Cartesian3, entity, 'viewFrom', viewFromData, undefined, sourceUri, entityCollection);\n        }\n    }\n\n    function processOrientation(entity, packet, entityCollection, sourceUri) {\n        var orientationData = packet.orientation;\n        if (defined(orientationData)) {\n            processPacketData(Quaternion, entity, 'orientation', orientationData, undefined, sourceUri, entityCollection);\n        }\n    }\n\n    function processProperties(entity, packet, entityCollection, sourceUri) {\n        var propertiesData = packet.properties;\n        if (defined(propertiesData)) {\n            if (!defined(entity.properties)) {\n                entity.properties = new PropertyBag();\n            }\n\n            // We cannot simply call processPacketData(entity, 'properties', propertyData, undefined, sourceUri, entityCollection)\n            // because each property of \"properties\" may vary separately.\n            // The properties will be accessible as entity.properties.myprop.getValue(time).\n\n            for (var key in propertiesData) {\n                if (propertiesData.hasOwnProperty(key)) {\n                    if (!entity.properties.hasProperty(key)) {\n                        entity.properties.addProperty(key);\n                    }\n\n                    var propertyData = propertiesData[key];\n                    if (isArray(propertyData)) {\n                        for (var i = 0, len = propertyData.length; i < len; ++i) {\n                            processProperty(getPropertyType(propertyData[i]), entity.properties, key, propertyData[i], undefined, sourceUri, entityCollection);\n                        }\n                    } else {\n                        processProperty(getPropertyType(propertyData), entity.properties, key, propertyData, undefined, sourceUri, entityCollection);\n                    }\n                }\n            }\n        }\n    }\n\n    function processReferencesArrayPacketData(object, propertyName, references, interval, entityCollection, PropertyArrayType, CompositePropertyArrayType) {\n        var properties = references.map(function(reference) {\n            return createReferenceProperty(entityCollection, reference);\n        });\n\n        if (defined(interval)) {\n            interval = intervalFromString(interval);\n            var property = object[propertyName];\n            if (!(property instanceof CompositePropertyArrayType)) {\n                // If the property was not already a CompositeProperty,\n                // create a CompositeProperty but preserve the existing data.\n\n                // Create the composite and add the old property, wrapped in an infinite interval.\n                var composite = new CompositePropertyArrayType();\n                composite.intervals.addInterval(wrapPropertyInInfiniteInterval(property));\n\n                object[propertyName] = property = composite;\n            }\n\n            interval.data = new PropertyArrayType(properties);\n            property.intervals.addInterval(interval);\n        } else {\n            object[propertyName] = new PropertyArrayType(properties);\n        }\n    }\n\n    function processArrayPacketData(object, propertyName, packetData, entityCollection) {\n        var references = packetData.references;\n        if (defined(references)) {\n            processReferencesArrayPacketData(object, propertyName, references, packetData.interval, entityCollection, PropertyArray, CompositeProperty);\n        } else {\n            processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n        }\n    }\n\n    function processArray(object, propertyName, packetData, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        if (isArray(packetData)) {\n            for (var i = 0, length = packetData.length; i < length; ++i) {\n                processArrayPacketData(object, propertyName, packetData[i], entityCollection);\n            }\n        } else {\n            processArrayPacketData(object, propertyName, packetData, entityCollection);\n        }\n    }\n\n    function processPositionArrayPacketData(object, propertyName, packetData, entityCollection) {\n        var references = packetData.references;\n        if (defined(references)) {\n            processReferencesArrayPacketData(object, propertyName, references, packetData.interval, entityCollection, PositionPropertyArray, CompositePositionProperty);\n        } else {\n            if (defined(packetData.cartesian)) {\n                packetData.array = Cartesian3.unpackArray(packetData.cartesian);\n            } else if (defined(packetData.cartographicRadians)) {\n                packetData.array = Cartesian3.fromRadiansArrayHeights(packetData.cartographicRadians);\n            } else if (defined(packetData.cartographicDegrees)) {\n                packetData.array = Cartesian3.fromDegreesArrayHeights(packetData.cartographicDegrees);\n            }\n\n            if (defined(packetData.array)) {\n                processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n            }\n        }\n    }\n\n    function processPositionArray(object, propertyName, packetData, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        if (isArray(packetData)) {\n            for (var i = 0, length = packetData.length; i < length; ++i) {\n                processPositionArrayPacketData(object, propertyName, packetData[i], entityCollection);\n            }\n        } else {\n            processPositionArrayPacketData(object, propertyName, packetData, entityCollection);\n        }\n    }\n\n    function unpackCartesianArray(array) {\n        return Cartesian3.unpackArray(array);\n    }\n\n    function unpackCartographicRadiansArray(array) {\n        return Cartesian3.fromRadiansArrayHeights(array);\n    }\n\n    function unpackCartographicDegreesArray(array) {\n        return Cartesian3.fromDegreesArrayHeights(array);\n    }\n\n    function processPositionArrayOfArraysPacketData(object, propertyName, packetData, entityCollection) {\n        var references = packetData.references;\n        if (defined(references)) {\n            var properties = references.map(function(referenceArray) {\n                var tempObj = {};\n                processReferencesArrayPacketData(tempObj, 'positions', referenceArray, packetData.interval, entityCollection, PositionPropertyArray, CompositePositionProperty);\n                return tempObj.positions;\n            });\n            object[propertyName] = new PositionPropertyArray(properties);\n        } else {\n            if (defined(packetData.cartesian)) {\n                packetData.array = packetData.cartesian.map(unpackCartesianArray);\n            } else if (defined(packetData.cartographicRadians)) {\n                packetData.array = packetData.cartographicRadians.map(unpackCartographicRadiansArray);\n            } else if (defined(packetData.cartographicDegrees)) {\n                packetData.array = packetData.cartographicDegrees.map(unpackCartographicDegreesArray);\n            }\n\n            if (defined(packetData.array)) {\n                processPacketData(Array, object, propertyName, packetData, undefined, undefined, entityCollection);\n            }\n        }\n    }\n\n    function processPositionArrayOfArrays(object, propertyName, packetData, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        if (isArray(packetData)) {\n            for (var i = 0, length = packetData.length; i < length; ++i) {\n                processPositionArrayOfArraysPacketData(object, propertyName, packetData[i], entityCollection);\n            }\n        } else {\n            processPositionArrayOfArraysPacketData(object, propertyName, packetData, entityCollection);\n        }\n    }\n\n    function processAvailability(entity, packet, entityCollection, sourceUri) {\n        var packetData = packet.availability;\n        if (!defined(packetData)) {\n            return;\n        }\n\n        var intervals;\n        if (isArray(packetData)) {\n            for (var i = 0, len = packetData.length; i < len; ++i) {\n                if (!defined(intervals)) {\n                    intervals = new TimeIntervalCollection();\n                }\n                intervals.addInterval(intervalFromString(packetData[i]));\n            }\n        } else {\n            intervals = new TimeIntervalCollection();\n            intervals.addInterval(intervalFromString(packetData));\n        }\n        entity.availability = intervals;\n    }\n\n    function processAlignedAxis(billboard, packetData, interval, sourceUri, entityCollection) {\n        if (!defined(packetData)) {\n            return;\n        }\n\n        processPacketData(UnitCartesian3, billboard, 'alignedAxis', packetData, interval, sourceUri, entityCollection);\n    }\n\n    function processBillboard(entity, packet, entityCollection, sourceUri) {\n        var billboardData = packet.billboard;\n        if (!defined(billboardData)) {\n            return;\n        }\n\n        var interval = intervalFromString(billboardData.interval);\n        var billboard = entity.billboard;\n        if (!defined(billboard)) {\n            entity.billboard = billboard = new BillboardGraphics();\n        }\n\n        processPacketData(Boolean, billboard, 'show', billboardData.show, interval, sourceUri, entityCollection);\n        processPacketData(Image, billboard, 'image', billboardData.image, interval, sourceUri, entityCollection);\n        processPacketData(Number, billboard, 'scale', billboardData.scale, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian2, billboard, 'pixelOffset', billboardData.pixelOffset, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian3, billboard, 'eyeOffset', billboardData.eyeOffset, interval, sourceUri, entityCollection);\n        processPacketData(HorizontalOrigin, billboard, 'horizontalOrigin', billboardData.horizontalOrigin, interval, sourceUri, entityCollection);\n        processPacketData(VerticalOrigin, billboard, 'verticalOrigin', billboardData.verticalOrigin, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, billboard, 'heightReference', billboardData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Color, billboard, 'color', billboardData.color, interval, sourceUri, entityCollection);\n        processPacketData(Rotation, billboard, 'rotation', billboardData.rotation, interval, sourceUri, entityCollection);\n        processAlignedAxis(billboard, billboardData.alignedAxis, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, billboard, 'sizeInMeters', billboardData.sizeInMeters, interval, sourceUri, entityCollection);\n        processPacketData(Number, billboard, 'width', billboardData.width, interval, sourceUri, entityCollection);\n        processPacketData(Number, billboard, 'height', billboardData.height, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, billboard, 'scaleByDistance', billboardData.scaleByDistance, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, billboard, 'translucencyByDistance', billboardData.translucencyByDistance, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, billboard, 'pixelOffsetScaleByDistance', billboardData.pixelOffsetScaleByDistance, interval, sourceUri, entityCollection);\n        processPacketData(BoundingRectangle, billboard, 'imageSubRegion', billboardData.imageSubRegion, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, billboard, 'distanceDisplayCondition', billboardData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(Number, billboard, 'disableDepthTestDistance', billboardData.disableDepthTestDistance, interval, sourceUri, entityCollection);\n    }\n\n    function processBox(entity, packet, entityCollection, sourceUri) {\n        var boxData = packet.box;\n        if (!defined(boxData)) {\n            return;\n        }\n\n        var interval = intervalFromString(boxData.interval);\n        var box = entity.box;\n        if (!defined(box)) {\n            entity.box = box = new BoxGraphics();\n        }\n\n        processPacketData(Boolean, box, 'show', boxData.show, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian3, box, 'dimensions', boxData.dimensions, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, box, 'heightReference', boxData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, box, 'fill', boxData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(box, 'material', boxData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, box, 'outline', boxData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, box, 'outlineColor', boxData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, box, 'outlineWidth', boxData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, box, 'shadows', boxData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, box, 'distanceDisplayCondition', boxData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n    }\n\n    function processCorridor(entity, packet, entityCollection, sourceUri) {\n        var corridorData = packet.corridor;\n        if (!defined(corridorData)) {\n            return;\n        }\n\n        var interval = intervalFromString(corridorData.interval);\n        var corridor = entity.corridor;\n        if (!defined(corridor)) {\n            entity.corridor = corridor = new CorridorGraphics();\n        }\n\n        processPacketData(Boolean, corridor, 'show', corridorData.show, interval, sourceUri, entityCollection);\n        processPositionArray(corridor, 'positions', corridorData.positions, entityCollection);\n        processPacketData(Number, corridor, 'width', corridorData.width, interval, sourceUri, entityCollection);\n        processPacketData(Number, corridor, 'height', corridorData.height, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, corridor, 'heightReference', corridorData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Number, corridor, 'extrudedHeight', corridorData.extrudedHeight, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, corridor, 'extrudedHeightReference', corridorData.extrudedHeightReference, interval, sourceUri, entityCollection);\n        processPacketData(CornerType, corridor, 'cornerType', corridorData.cornerType, interval, sourceUri, entityCollection);\n        processPacketData(Number, corridor, 'granularity', corridorData.granularity, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, corridor, 'fill', corridorData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(corridor, 'material', corridorData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, corridor, 'outline', corridorData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, corridor, 'outlineColor', corridorData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, corridor, 'outlineWidth', corridorData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, corridor, 'shadows', corridorData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, corridor, 'distanceDisplayCondition', corridorData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(ClassificationType, corridor, 'classificationType', corridorData.classificationType, interval, sourceUri, entityCollection);\n        processPacketData(Number, corridor, 'zIndex', corridorData.zIndex, interval, sourceUri, entityCollection);\n    }\n\n    function processCylinder(entity, packet, entityCollection, sourceUri) {\n        var cylinderData = packet.cylinder;\n        if (!defined(cylinderData)) {\n            return;\n        }\n\n        var interval = intervalFromString(cylinderData.interval);\n        var cylinder = entity.cylinder;\n        if (!defined(cylinder)) {\n            entity.cylinder = cylinder = new CylinderGraphics();\n        }\n\n        processPacketData(Boolean, cylinder, 'show', cylinderData.show, interval, sourceUri, entityCollection);\n        processPacketData(Number, cylinder, 'length', cylinderData.length, interval, sourceUri, entityCollection);\n        processPacketData(Number, cylinder, 'topRadius', cylinderData.topRadius, interval, sourceUri, entityCollection);\n        processPacketData(Number, cylinder, 'bottomRadius', cylinderData.bottomRadius, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, cylinder, 'heightReference', cylinderData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, cylinder, 'fill', cylinderData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(cylinder, 'material', cylinderData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, cylinder, 'outline', cylinderData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, cylinder, 'outlineColor', cylinderData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, cylinder, 'outlineWidth', cylinderData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(Number, cylinder, 'numberOfVerticalLines', cylinderData.numberOfVerticalLines, interval, sourceUri, entityCollection);\n        processPacketData(Number, cylinder, 'slices', cylinderData.slices, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, cylinder, 'shadows', cylinderData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, cylinder, 'distanceDisplayCondition', cylinderData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n    }\n\n    function processDocument(packet, dataSource) {\n        var version = packet.version;\n        if (defined(version)) {\n            if (typeof version === 'string') {\n                var tokens = version.split('.');\n                if (tokens.length === 2) {\n                    if (tokens[0] !== '1') {\n                        throw new RuntimeError('Cesium only supports CZML version 1.');\n                    }\n                    dataSource._version = version;\n                }\n            }\n        }\n\n        if (!defined(dataSource._version)) {\n            throw new RuntimeError('CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.');\n        }\n\n        var documentPacket = dataSource._documentPacket;\n\n        if (defined(packet.name)) {\n            documentPacket.name = packet.name;\n        }\n\n        var clockPacket = packet.clock;\n        if (defined(clockPacket)) {\n            var clock = documentPacket.clock;\n            if (!defined(clock)) {\n                documentPacket.clock = {\n                    interval : clockPacket.interval,\n                    currentTime : clockPacket.currentTime,\n                    range : clockPacket.range,\n                    step : clockPacket.step,\n                    multiplier : clockPacket.multiplier\n                };\n            } else {\n                clock.interval = defaultValue(clockPacket.interval, clock.interval);\n                clock.currentTime = defaultValue(clockPacket.currentTime, clock.currentTime);\n                clock.range = defaultValue(clockPacket.range, clock.range);\n                clock.step = defaultValue(clockPacket.step, clock.step);\n                clock.multiplier = defaultValue(clockPacket.multiplier, clock.multiplier);\n            }\n        }\n    }\n\n    function processEllipse(entity, packet, entityCollection, sourceUri) {\n        var ellipseData = packet.ellipse;\n        if (!defined(ellipseData)) {\n            return;\n        }\n\n        var interval = intervalFromString(ellipseData.interval);\n        var ellipse = entity.ellipse;\n        if (!defined(ellipse)) {\n            entity.ellipse = ellipse = new EllipseGraphics();\n        }\n\n        processPacketData(Boolean, ellipse, 'show', ellipseData.show, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'semiMajorAxis', ellipseData.semiMajorAxis, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'semiMinorAxis', ellipseData.semiMinorAxis, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'height', ellipseData.height, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, ellipse, 'heightReference', ellipseData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'extrudedHeight', ellipseData.extrudedHeight, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, ellipse, 'extrudedHeightReference', ellipseData.extrudedHeightReference, interval, sourceUri, entityCollection);\n        processPacketData(Rotation, ellipse, 'rotation', ellipseData.rotation, interval, sourceUri, entityCollection);\n        processPacketData(Rotation, ellipse, 'stRotation', ellipseData.stRotation, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'granularity', ellipseData.granularity, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, ellipse, 'fill', ellipseData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(ellipse, 'material', ellipseData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, ellipse, 'outline', ellipseData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, ellipse, 'outlineColor', ellipseData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'outlineWidth', ellipseData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'numberOfVerticalLines', ellipseData.numberOfVerticalLines, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, ellipse, 'shadows', ellipseData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, ellipse, 'distanceDisplayCondition', ellipseData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(ClassificationType, ellipse, 'classificationType', ellipseData.classificationType, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipse, 'zIndex', ellipseData.zIndex, interval, sourceUri, entityCollection);\n    }\n\n    function processEllipsoid(entity, packet, entityCollection, sourceUri) {\n        var ellipsoidData = packet.ellipsoid;\n        if (!defined(ellipsoidData)) {\n            return;\n        }\n\n        var interval = intervalFromString(ellipsoidData.interval);\n        var ellipsoid = entity.ellipsoid;\n        if (!defined(ellipsoid)) {\n            entity.ellipsoid = ellipsoid = new EllipsoidGraphics();\n        }\n\n        processPacketData(Boolean, ellipsoid, 'show', ellipsoidData.show, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian3, ellipsoid, 'radii', ellipsoidData.radii, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, ellipsoid, 'heightReference', ellipsoidData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, ellipsoid, 'fill', ellipsoidData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(ellipsoid, 'material', ellipsoidData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, ellipsoid, 'outline', ellipsoidData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, ellipsoid, 'outlineColor', ellipsoidData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipsoid, 'outlineWidth', ellipsoidData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipsoid, 'stackPartitions', ellipsoidData.stackPartitions, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipsoid, 'slicePartitions', ellipsoidData.slicePartitions, interval, sourceUri, entityCollection);\n        processPacketData(Number, ellipsoid, 'subdivisions', ellipsoidData.subdivisions, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, ellipsoid, 'shadows', ellipsoidData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, ellipsoid, 'distanceDisplayCondition', ellipsoidData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n    }\n\n    function processLabel(entity, packet, entityCollection, sourceUri) {\n        var labelData = packet.label;\n        if (!defined(labelData)) {\n            return;\n        }\n\n        var interval = intervalFromString(labelData.interval);\n        var label = entity.label;\n        if (!defined(label)) {\n            entity.label = label = new LabelGraphics();\n        }\n\n        processPacketData(Boolean, label, 'show', labelData.show, interval, sourceUri, entityCollection);\n        processPacketData(String, label, 'text', labelData.text, interval, sourceUri, entityCollection);\n        processPacketData(String, label, 'font', labelData.font, interval, sourceUri, entityCollection);\n        processPacketData(LabelStyle, label, 'style', labelData.style, interval, sourceUri, entityCollection);\n        processPacketData(Number, label, 'scale', labelData.scale, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, label, 'showBackground', labelData.showBackground, interval, sourceUri, entityCollection);\n        processPacketData(Color, label, 'backgroundColor', labelData.backgroundColor, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian2, label, 'backgroundPadding', labelData.backgroundPadding, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian2, label, 'pixelOffset', labelData.pixelOffset, interval, sourceUri, entityCollection);\n        processPacketData(Cartesian3, label, 'eyeOffset', labelData.eyeOffset, interval, sourceUri, entityCollection);\n        processPacketData(HorizontalOrigin, label, 'horizontalOrigin', labelData.horizontalOrigin, interval, sourceUri, entityCollection);\n        processPacketData(VerticalOrigin, label, 'verticalOrigin', labelData.verticalOrigin, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, label, 'heightReference', labelData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Color, label, 'fillColor', labelData.fillColor, interval, sourceUri, entityCollection);\n        processPacketData(Color, label, 'outlineColor', labelData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, label, 'outlineWidth', labelData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, label, 'translucencyByDistance', labelData.translucencyByDistance, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, label, 'pixelOffsetScaleByDistance', labelData.pixelOffsetScaleByDistance, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, label, 'scaleByDistance', labelData.scaleByDistance, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, label, 'distanceDisplayCondition', labelData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(Number, label, 'disableDepthTestDistance', labelData.disableDepthTestDistance, interval, sourceUri, entityCollection);\n    }\n\n    function processModel(entity, packet, entityCollection, sourceUri) {\n        var modelData = packet.model;\n        if (!defined(modelData)) {\n            return;\n        }\n\n        var interval = intervalFromString(modelData.interval);\n        var model = entity.model;\n        if (!defined(model)) {\n            entity.model = model = new ModelGraphics();\n        }\n\n        processPacketData(Boolean, model, 'show', modelData.show, interval, sourceUri, entityCollection);\n        processPacketData(Uri, model, 'uri', modelData.gltf, interval, sourceUri, entityCollection);\n        processPacketData(Number, model, 'scale', modelData.scale, interval, sourceUri, entityCollection);\n        processPacketData(Number, model, 'minimumPixelSize', modelData.minimumPixelSize, interval, sourceUri, entityCollection);\n        processPacketData(Number, model, 'maximumScale', modelData.maximumScale, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, model, 'incrementallyLoadTextures', modelData.incrementallyLoadTextures, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, model, 'runAnimations', modelData.runAnimations, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, model, 'clampAnimations', modelData.clampAnimations, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, model, 'shadows', modelData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, model, 'heightReference', modelData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Color, model, 'silhouetteColor', modelData.silhouetteColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, model, 'silhouetteSize', modelData.silhouetteSize, interval, sourceUri, entityCollection);\n        processPacketData(Color, model, 'color', modelData.color, interval, sourceUri, entityCollection);\n        processPacketData(ColorBlendMode, model, 'colorBlendMode', modelData.colorBlendMode, interval, sourceUri, entityCollection);\n        processPacketData(Number, model, 'colorBlendAmount', modelData.colorBlendAmount, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, model, 'distanceDisplayCondition', modelData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n\n        var i, len;\n        var nodeTransformationsData = modelData.nodeTransformations;\n        if (defined(nodeTransformationsData)) {\n            if (isArray(nodeTransformationsData)) {\n                for (i = 0, len = nodeTransformationsData.length; i < len; ++i) {\n                    processNodeTransformations(model, nodeTransformationsData[i], interval, sourceUri, entityCollection);\n                }\n            } else {\n                processNodeTransformations(model, nodeTransformationsData, interval, sourceUri, entityCollection);\n            }\n        }\n\n        var articulationsData = modelData.articulations;\n        if (defined(articulationsData)) {\n            if (isArray(articulationsData)) {\n                for (i = 0, len = articulationsData.length; i < len; ++i) {\n                    processArticulations(model, articulationsData[i], interval, sourceUri, entityCollection);\n                }\n            } else {\n                processArticulations(model, articulationsData, interval, sourceUri, entityCollection);\n            }\n        }\n    }\n\n    function processNodeTransformations(model, nodeTransformationsData, constrainedInterval, sourceUri, entityCollection) {\n        var combinedInterval = intervalFromString(nodeTransformationsData.interval);\n        if (defined(constrainedInterval)) {\n            if (defined(combinedInterval)) {\n                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n            } else {\n                combinedInterval = constrainedInterval;\n            }\n        }\n\n        var nodeTransformations = model.nodeTransformations;\n        var nodeNames = Object.keys(nodeTransformationsData);\n        for (var i = 0, len = nodeNames.length; i < len; ++i) {\n            var nodeName = nodeNames[i];\n            if (nodeName === 'interval') {\n                continue;\n            }\n\n            var nodeTransformationData = nodeTransformationsData[nodeName];\n            if (!defined(nodeTransformationData)) {\n                continue;\n            }\n\n            if (!defined(nodeTransformations)) {\n                model.nodeTransformations = nodeTransformations = new PropertyBag();\n            }\n\n            if (!nodeTransformations.hasProperty(nodeName)) {\n                nodeTransformations.addProperty(nodeName);\n            }\n\n            var nodeTransformation = nodeTransformations[nodeName];\n            if (!defined(nodeTransformation)) {\n                nodeTransformations[nodeName] = nodeTransformation = new NodeTransformationProperty();\n            }\n\n            processPacketData(Cartesian3, nodeTransformation, 'translation', nodeTransformationData.translation, combinedInterval, sourceUri, entityCollection);\n            processPacketData(Quaternion, nodeTransformation, 'rotation', nodeTransformationData.rotation, combinedInterval, sourceUri, entityCollection);\n            processPacketData(Cartesian3, nodeTransformation, 'scale', nodeTransformationData.scale, combinedInterval, sourceUri, entityCollection);\n        }\n    }\n\n    function processArticulations(model, articulationsData, constrainedInterval, sourceUri, entityCollection) {\n        var combinedInterval = intervalFromString(articulationsData.interval);\n        if (defined(constrainedInterval)) {\n            if (defined(combinedInterval)) {\n                combinedInterval = TimeInterval.intersect(combinedInterval, constrainedInterval, scratchTimeInterval);\n            } else {\n                combinedInterval = constrainedInterval;\n            }\n        }\n\n        var articulations = model.articulations;\n        var keys = Object.keys(articulationsData);\n        for (var i = 0, len = keys.length; i < len; ++i) {\n            var key = keys[i];\n            if (key === 'interval') {\n                continue;\n            }\n\n            var articulationStageData = articulationsData[key];\n            if (!defined(articulationStageData)) {\n                continue;\n            }\n\n            if (!defined(articulations)) {\n                model.articulations = articulations = new PropertyBag();\n            }\n\n            if (!articulations.hasProperty(key)) {\n                articulations.addProperty(key);\n            }\n\n            processPacketData(Number, articulations, key, articulationStageData, combinedInterval, sourceUri, entityCollection);\n        }\n    }\n\n    function processPath(entity, packet, entityCollection, sourceUri) {\n        var pathData = packet.path;\n        if (!defined(pathData)) {\n            return;\n        }\n\n        var interval = intervalFromString(pathData.interval);\n        var path = entity.path;\n        if (!defined(path)) {\n            entity.path = path = new PathGraphics();\n        }\n\n        processPacketData(Boolean, path, 'show', pathData.show, interval, sourceUri, entityCollection);\n        processPacketData(Number, path, 'leadTime', pathData.leadTime, interval, sourceUri, entityCollection);\n        processPacketData(Number, path, 'trailTime', pathData.trailTime, interval, sourceUri, entityCollection);\n        processPacketData(Number, path, 'width', pathData.width, interval, sourceUri, entityCollection);\n        processPacketData(Number, path, 'resolution', pathData.resolution, interval, sourceUri, entityCollection);\n        processMaterialPacketData(path, 'material', pathData.material, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, path, 'distanceDisplayCondition', pathData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n    }\n\n    function processPoint(entity, packet, entityCollection, sourceUri) {\n        var pointData = packet.point;\n        if (!defined(pointData)) {\n            return;\n        }\n\n        var interval = intervalFromString(pointData.interval);\n        var point = entity.point;\n        if (!defined(point)) {\n            entity.point = point = new PointGraphics();\n        }\n\n        processPacketData(Boolean, point, 'show', pointData.show, interval, sourceUri, entityCollection);\n        processPacketData(Number, point, 'pixelSize', pointData.pixelSize, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, point, 'heightReference', pointData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Color, point, 'color', pointData.color, interval, sourceUri, entityCollection);\n        processPacketData(Color, point, 'outlineColor', pointData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, point, 'outlineWidth', pointData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, point, 'scaleByDistance', pointData.scaleByDistance, interval, sourceUri, entityCollection);\n        processPacketData(NearFarScalar, point, 'translucencyByDistance', pointData.translucencyByDistance, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, point, 'distanceDisplayCondition', pointData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(Number, point, 'disableDepthTestDistance', pointData.disableDepthTestDistance, interval, sourceUri, entityCollection);\n    }\n\n    function PolygonHierarchyProperty(polygon) {\n        this.polygon = polygon;\n        this._definitionChanged = new Event();\n    }\n\n    defineProperties(PolygonHierarchyProperty.prototype, {\n        isConstant : {\n            get : function() {\n                var positions = this.polygon._positions;\n                var holes = this.polygon._holes;\n                return (!defined(positions) || positions.isConstant) &&\n                       (!defined(holes) || holes.isConstant);\n            }\n        },\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        }\n    });\n\n    PolygonHierarchyProperty.prototype.getValue = function(time, result) {\n        var positions;\n        if (defined(this.polygon._positions)) {\n            positions = this.polygon._positions.getValue(time);\n        }\n\n        var holes;\n        if (defined(this.polygon._holes)) {\n            holes = this.polygon._holes.getValue(time);\n            if (defined(holes)) {\n                holes = holes.map(function(holePositions) {\n                    return new PolygonHierarchy(holePositions);\n                });\n            }\n        }\n\n        if (!defined(result)) {\n            return new PolygonHierarchy(positions, holes);\n        }\n\n        result.positions = positions;\n        result.holes = holes;\n        return result;\n    };\n\n    PolygonHierarchyProperty.prototype.equals = function(other) {\n        return this === other ||\n               (other instanceof PolygonHierarchyProperty &&\n                Property.equals(this.polygon._positions, other.polygon._positions) &&\n                Property.equals(this.polygon._holes, other.polygon._holes));\n    };\n\n    function processPolygon(entity, packet, entityCollection, sourceUri) {\n        var polygonData = packet.polygon;\n        if (!defined(polygonData)) {\n            return;\n        }\n\n        var interval = intervalFromString(polygonData.interval);\n        var polygon = entity.polygon;\n        if (!defined(polygon)) {\n            entity.polygon = polygon = new PolygonGraphics();\n        }\n\n        processPacketData(Boolean, polygon, 'show', polygonData.show, interval, sourceUri, entityCollection);\n\n        // adapt 'position' property producing Cartesian[]\n        // and 'holes' property producing Cartesian[][]\n        // to a single property producing PolygonHierarchy\n        processPositionArray(polygon, '_positions', polygonData.positions, entityCollection);\n        processPositionArrayOfArrays(polygon, '_holes', polygonData.holes, entityCollection);\n        if (defined(polygon._positions) || defined(polygon._holes)) {\n            polygon.hierarchy = new PolygonHierarchyProperty(polygon);\n        }\n\n        processPacketData(Number, polygon, 'height', polygonData.height, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, polygon, 'heightReference', polygonData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Number, polygon, 'extrudedHeight', polygonData.extrudedHeight, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, polygon, 'extrudedHeightReference', polygonData.extrudedHeightReference, interval, sourceUri, entityCollection);\n        processPacketData(Rotation, polygon, 'stRotation', polygonData.stRotation, interval, sourceUri, entityCollection);\n        processPacketData(Number, polygon, 'granularity', polygonData.granularity, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, polygon, 'fill', polygonData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(polygon, 'material', polygonData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, polygon, 'outline', polygonData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, polygon, 'outlineColor', polygonData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, polygon, 'outlineWidth', polygonData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, polygon, 'perPositionHeight', polygonData.perPositionHeight, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, polygon, 'closeTop', polygonData.closeTop, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, polygon, 'closeBottom', polygonData.closeBottom, interval, sourceUri, entityCollection);\n        processPacketData(ArcType, polygon, 'arcType', polygonData.arcType, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, polygon, 'shadows', polygonData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, polygon, 'distanceDisplayCondition', polygonData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(ClassificationType, polygon, 'classificationType', polygonData.classificationType, interval, sourceUri, entityCollection);\n        processPacketData(Number, polygon, 'zIndex', polygonData.zIndex, interval, sourceUri, entityCollection);\n    }\n\n    function adaptFollowSurfaceToArcType(followSurface) {\n        return followSurface ? ArcType.GEODESIC : ArcType.NONE;\n    }\n\n    function processPolyline(entity, packet, entityCollection, sourceUri) {\n        var polylineData = packet.polyline;\n        if (!defined(polylineData)) {\n            return;\n        }\n\n        var interval = intervalFromString(polylineData.interval);\n        var polyline = entity.polyline;\n        if (!defined(polyline)) {\n            entity.polyline = polyline = new PolylineGraphics();\n        }\n\n        processPacketData(Boolean, polyline, 'show', polylineData.show, interval, sourceUri, entityCollection);\n        processPositionArray(polyline, 'positions', polylineData.positions, entityCollection);\n        processPacketData(Number, polyline, 'width', polylineData.width, interval, sourceUri, entityCollection);\n        processPacketData(Number, polyline, 'granularity', polylineData.granularity, interval, sourceUri, entityCollection);\n        processMaterialPacketData(polyline, 'material', polylineData.material, interval, sourceUri, entityCollection);\n        processMaterialPacketData(polyline, 'depthFailMaterial', polylineData.depthFailMaterial, interval, sourceUri, entityCollection);\n        processPacketData(ArcType, polyline, 'arcType', polylineData.arcType, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, polyline, 'clampToGround', polylineData.clampToGround, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, polyline, 'shadows', polylineData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, polyline, 'distanceDisplayCondition', polylineData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(ClassificationType, polyline, 'classificationType', polylineData.classificationType, interval, sourceUri, entityCollection);\n        processPacketData(Number, polyline, 'zIndex', polylineData.zIndex, interval, sourceUri, entityCollection);\n\n        // for backwards compatibility, adapt CZML followSurface to arcType.\n        if (defined(polylineData.followSurface) && !defined(polylineData.arcType)) {\n            var tempObj = {};\n            processPacketData(Boolean, tempObj, 'followSurface', polylineData.followSurface, interval, sourceUri, entityCollection);\n            polyline.arcType = createAdapterProperty(tempObj.followSurface, adaptFollowSurfaceToArcType);\n        }\n    }\n\n    function processRectangle(entity, packet, entityCollection, sourceUri) {\n        var rectangleData = packet.rectangle;\n        if (!defined(rectangleData)) {\n            return;\n        }\n\n        var interval = intervalFromString(rectangleData.interval);\n        var rectangle = entity.rectangle;\n        if (!defined(rectangle)) {\n            entity.rectangle = rectangle = new RectangleGraphics();\n        }\n\n        processPacketData(Boolean, rectangle, 'show', rectangleData.show, interval, sourceUri, entityCollection);\n        processPacketData(Rectangle, rectangle, 'coordinates', rectangleData.coordinates, interval, sourceUri, entityCollection);\n        processPacketData(Number, rectangle, 'height', rectangleData.height, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, rectangle, 'heightReference', rectangleData.heightReference, interval, sourceUri, entityCollection);\n        processPacketData(Number, rectangle, 'extrudedHeight', rectangleData.extrudedHeight, interval, sourceUri, entityCollection);\n        processPacketData(HeightReference, rectangle, 'extrudedHeightReference', rectangleData.extrudedHeightReference, interval, sourceUri, entityCollection);\n        processPacketData(Rotation, rectangle, 'rotation', rectangleData.rotation, interval, sourceUri, entityCollection);\n        processPacketData(Rotation, rectangle, 'stRotation', rectangleData.stRotation, interval, sourceUri, entityCollection);\n        processPacketData(Number, rectangle, 'granularity', rectangleData.granularity, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, rectangle, 'fill', rectangleData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(rectangle, 'material', rectangleData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, rectangle, 'outline', rectangleData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, rectangle, 'outlineColor', rectangleData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, rectangle, 'outlineWidth', rectangleData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, rectangle, 'shadows', rectangleData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, rectangle, 'distanceDisplayCondition', rectangleData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n        processPacketData(ClassificationType, rectangle, 'classificationType', rectangleData.classificationType, interval, sourceUri, entityCollection);\n        processPacketData(Number, rectangle, 'zIndex', rectangleData.zIndex, interval, sourceUri, entityCollection);\n    }\n\n    function processWall(entity, packet, entityCollection, sourceUri) {\n        var wallData = packet.wall;\n        if (!defined(wallData)) {\n            return;\n        }\n\n        var interval = intervalFromString(wallData.interval);\n        var wall = entity.wall;\n        if (!defined(wall)) {\n            entity.wall = wall = new WallGraphics();\n        }\n\n        processPacketData(Boolean, wall, 'show', wallData.show, interval, sourceUri, entityCollection);\n        processPositionArray(wall, 'positions', wallData.positions, entityCollection);\n        processArray(wall, 'minimumHeights', wallData.minimumHeights, entityCollection);\n        processArray(wall, 'maximumHeights', wallData.maximumHeights, entityCollection);\n        processPacketData(Number, wall, 'granularity', wallData.granularity, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, wall, 'fill', wallData.fill, interval, sourceUri, entityCollection);\n        processMaterialPacketData(wall, 'material', wallData.material, interval, sourceUri, entityCollection);\n        processPacketData(Boolean, wall, 'outline', wallData.outline, interval, sourceUri, entityCollection);\n        processPacketData(Color, wall, 'outlineColor', wallData.outlineColor, interval, sourceUri, entityCollection);\n        processPacketData(Number, wall, 'outlineWidth', wallData.outlineWidth, interval, sourceUri, entityCollection);\n        processPacketData(ShadowMode, wall, 'shadows', wallData.shadows, interval, sourceUri, entityCollection);\n        processPacketData(DistanceDisplayCondition, wall, 'distanceDisplayCondition', wallData.distanceDisplayCondition, interval, sourceUri, entityCollection);\n    }\n\n    function processCzmlPacket(packet, entityCollection, updaterFunctions, sourceUri, dataSource) {\n        var objectId = packet.id;\n        if (!defined(objectId)) {\n            objectId = createGuid();\n        }\n\n        currentId = objectId;\n\n        if (!defined(dataSource._version) && objectId !== 'document') {\n            throw new RuntimeError('The first CZML packet is required to be the document object.');\n        }\n\n        if (packet['delete'] === true) {\n            entityCollection.removeById(objectId);\n        } else if (objectId === 'document') {\n            processDocument(packet, dataSource);\n        } else {\n            var entity = entityCollection.getOrCreateEntity(objectId);\n\n            var parentId = packet.parent;\n            if (defined(parentId)) {\n                entity.parent = entityCollection.getOrCreateEntity(parentId);\n            }\n\n            for (var i = updaterFunctions.length - 1; i > -1; i--) {\n                updaterFunctions[i](entity, packet, entityCollection, sourceUri);\n            }\n        }\n\n        currentId = undefined;\n    }\n\n    function updateClock(dataSource) {\n        var clock;\n        var clockPacket = dataSource._documentPacket.clock;\n        if (!defined(clockPacket)) {\n            if (!defined(dataSource._clock)) {\n                var availability = dataSource._entityCollection.computeAvailability();\n                if (!availability.start.equals(Iso8601.MINIMUM_VALUE)) {\n                    var startTime = availability.start;\n                    var stopTime = availability.stop;\n                    var totalSeconds = JulianDate.secondsDifference(stopTime, startTime);\n                    var multiplier = Math.round(totalSeconds / 120.0);\n\n                    clock = new DataSourceClock();\n                    clock.startTime = JulianDate.clone(startTime);\n                    clock.stopTime = JulianDate.clone(stopTime);\n                    clock.clockRange = ClockRange.LOOP_STOP;\n                    clock.multiplier = multiplier;\n                    clock.currentTime = JulianDate.clone(startTime);\n                    clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n                    dataSource._clock = clock;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (defined(dataSource._clock)) {\n            clock = dataSource._clock.clone();\n        } else {\n            clock = new DataSourceClock();\n            clock.startTime = Iso8601.MINIMUM_VALUE.clone();\n            clock.stopTime = Iso8601.MAXIMUM_VALUE.clone();\n            clock.currentTime = Iso8601.MINIMUM_VALUE.clone();\n            clock.clockRange = ClockRange.LOOP_STOP;\n            clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n            clock.multiplier = 1.0;\n        }\n\n        var interval = intervalFromString(clockPacket.interval);\n        if (defined(interval)) {\n            clock.startTime = interval.start;\n            clock.stopTime = interval.stop;\n        }\n\n        if (defined(clockPacket.currentTime)) {\n            clock.currentTime = JulianDate.fromIso8601(clockPacket.currentTime);\n        }\n        if (defined(clockPacket.range)) {\n            clock.clockRange = defaultValue(ClockRange[clockPacket.range], ClockRange.LOOP_STOP);\n        }\n        if (defined(clockPacket.step)) {\n            clock.clockStep = defaultValue(ClockStep[clockPacket.step], ClockStep.SYSTEM_CLOCK_MULTIPLIER);\n        }\n        if (defined(clockPacket.multiplier)) {\n            clock.multiplier = clockPacket.multiplier;\n        }\n\n        if (!clock.equals(dataSource._clock)) {\n            dataSource._clock = clock.clone(dataSource._clock);\n            return true;\n        }\n\n        return false;\n    }\n\n    function load(dataSource, czml, options, clear) {\n        \n\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var promise = czml;\n        var sourceUri = options.sourceUri;\n\n        // If the czml is a URL\n        if (typeof czml === 'string' || (czml instanceof Resource)) {\n            czml = Resource.createIfNeeded(czml);\n            promise = czml.fetchJson();\n            sourceUri = defaultValue(sourceUri, czml.clone());\n        }\n\n        sourceUri = Resource.createIfNeeded(sourceUri);\n\n        DataSource.setLoading(dataSource, true);\n\n        return when(promise, function(czml) {\n            return loadCzml(dataSource, czml, sourceUri, clear);\n        }).otherwise(function(error) {\n            DataSource.setLoading(dataSource, false);\n            dataSource._error.raiseEvent(dataSource, error);\n            console.log(error);\n            return when.reject(error);\n        });\n    }\n\n    function loadCzml(dataSource, czml, sourceUri, clear) {\n        DataSource.setLoading(dataSource, true);\n        var entityCollection = dataSource._entityCollection;\n\n        if (clear) {\n            dataSource._version = undefined;\n            dataSource._documentPacket = new DocumentPacket();\n            entityCollection.removeAll();\n        }\n\n        CzmlDataSource._processCzml(czml, entityCollection, sourceUri, undefined, dataSource);\n\n        var raiseChangedEvent = updateClock(dataSource);\n\n        var documentPacket = dataSource._documentPacket;\n        if (defined(documentPacket.name) && dataSource._name !== documentPacket.name) {\n            dataSource._name = documentPacket.name;\n            raiseChangedEvent = true;\n        } else if (!defined(dataSource._name) && defined(sourceUri)) {\n            dataSource._name = getFilenameFromUri(sourceUri.getUrlComponent());\n            raiseChangedEvent = true;\n        }\n\n        DataSource.setLoading(dataSource, false);\n        if (raiseChangedEvent) {\n            dataSource._changed.raiseEvent(dataSource);\n        }\n\n        return dataSource;\n    }\n\n    function DocumentPacket() {\n        this.name = undefined;\n        this.clock = undefined;\n    }\n\n    /**\n     * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Guide|CZML}.\n     * @alias CzmlDataSource\n     * @constructor\n     *\n     * @param {String} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}\n     */\n    function CzmlDataSource(name) {\n        this._name = name;\n        this._changed = new Event();\n        this._error = new Event();\n        this._isLoading = false;\n        this._loading = new Event();\n        this._clock = undefined;\n        this._documentPacket = new DocumentPacket();\n        this._version = undefined;\n        this._entityCollection = new EntityCollection(this);\n        this._entityCluster = new EntityCluster();\n    }\n\n    /**\n     * Creates a Promise to a new instance loaded with the provided CZML data.\n     *\n     * @param {Resource|String|Object} czml A url or CZML object to be processed.\n     * @param {Object} [options] An object with the following properties:\n     * @param {Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links.\n     * @returns {Promise.<CzmlDataSource>} A promise that resolves to the new instance once the data is processed.\n     */\n    CzmlDataSource.load = function(czml, options) {\n        return new CzmlDataSource().load(czml, options);\n    };\n\n    defineProperties(CzmlDataSource.prototype, {\n        /**\n         * Gets a human-readable name for this instance.\n         * @memberof CzmlDataSource.prototype\n         * @type {String}\n         */\n        name : {\n            get : function() {\n                return this._name;\n            }\n        },\n        /**\n         * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly\n         * defined in the CZML, the combined availability of all objects is returned.  If\n         * only static data exists, this value is undefined.\n         * @memberof CzmlDataSource.prototype\n         * @type {DataSourceClock}\n         */\n        clock : {\n            get : function() {\n                return this._clock;\n            }\n        },\n        /**\n         * Gets the collection of {@link Entity} instances.\n         * @memberof CzmlDataSource.prototype\n         * @type {EntityCollection}\n         */\n        entities : {\n            get : function() {\n                return this._entityCollection;\n            }\n        },\n        /**\n         * Gets a value indicating if the data source is currently loading data.\n         * @memberof CzmlDataSource.prototype\n         * @type {Boolean}\n         */\n        isLoading : {\n            get : function() {\n                return this._isLoading;\n            }\n        },\n        /**\n         * Gets an event that will be raised when the underlying data changes.\n         * @memberof CzmlDataSource.prototype\n         * @type {Event}\n         */\n        changedEvent : {\n            get : function() {\n                return this._changed;\n            }\n        },\n        /**\n         * Gets an event that will be raised if an error is encountered during processing.\n         * @memberof CzmlDataSource.prototype\n         * @type {Event}\n         */\n        errorEvent : {\n            get : function() {\n                return this._error;\n            }\n        },\n        /**\n         * Gets an event that will be raised when the data source either starts or stops loading.\n         * @memberof CzmlDataSource.prototype\n         * @type {Event}\n         */\n        loadingEvent : {\n            get : function() {\n                return this._loading;\n            }\n        },\n        /**\n         * Gets whether or not this data source should be displayed.\n         * @memberof CzmlDataSource.prototype\n         * @type {Boolean}\n         */\n        show : {\n            get : function() {\n                return this._entityCollection.show;\n            },\n            set : function(value) {\n                this._entityCollection.show = value;\n            }\n        },\n\n        /**\n         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n         *\n         * @memberof CzmlDataSource.prototype\n         * @type {EntityCluster}\n         */\n        clustering : {\n            get : function() {\n                return this._entityCluster;\n            },\n            set : function(value) {\n                \n                this._entityCluster = value;\n            }\n        }\n    });\n\n    /**\n     * Gets the array of CZML processing functions.\n     * @memberof CzmlDataSource\n     * @type Array\n     */\n    CzmlDataSource.updaters = [\n        processBillboard, //\n        processBox, //\n        processCorridor, //\n        processCylinder, //\n        processEllipse, //\n        processEllipsoid, //\n        processLabel, //\n        processModel, //\n        processName, //\n        processDescription, //\n        processPath, //\n        processPoint, //\n        processPolygon, //\n        processPolyline, //\n        processProperties, //\n        processRectangle, //\n        processPosition, //\n        processViewFrom, //\n        processWall, //\n        processOrientation, //\n        processAvailability];\n\n    /**\n     * Processes the provided url or CZML object without clearing any existing data.\n     *\n     * @param {Resource|String|Object} czml A url or CZML object to be processed.\n     * @param {Object} [options] An object with the following properties:\n     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.\n     * @returns {Promise.<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n     */\n    CzmlDataSource.prototype.process = function(czml, options) {\n        return load(this, czml, options, false);\n    };\n\n    /**\n     * Loads the provided url or CZML object, replacing any existing data.\n     *\n     * @param {Resource|String|Object} czml A url or CZML object to be processed.\n     * @param {Object} [options] An object with the following properties:\n     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.\n     * @returns {Promise.<CzmlDataSource>} A promise that resolves to this instances once the data is processed.\n     */\n    CzmlDataSource.prototype.load = function(czml, options) {\n        return load(this, czml, options, true);\n    };\n\n    /**\n     * A helper function used by custom CZML updater functions\n     * which creates or updates a {@link Property} from a CZML packet.\n     * @function\n     *\n     * @param {Function} type The constructor function for the property being processed.\n     * @param {Object} object The object on which the property will be added or updated.\n     * @param {String} propertyName The name of the property on the object.\n     * @param {Object} packetData The CZML packet being processed.\n     * @param {TimeInterval} interval A constraining interval for which the data is valid.\n     * @param {String} sourceUri The originating uri of the data being processed.\n     * @param {EntityCollection} entityCollection The collection being processsed.\n     */\n    CzmlDataSource.processPacketData = processPacketData;\n\n    /**\n     * A helper function used by custom CZML updater functions\n     * which creates or updates a {@link PositionProperty} from a CZML packet.\n     * @function\n     *\n     * @param {Object} object The object on which the property will be added or updated.\n     * @param {String} propertyName The name of the property on the object.\n     * @param {Object} packetData The CZML packet being processed.\n     * @param {TimeInterval} interval A constraining interval for which the data is valid.\n     * @param {String} sourceUri The originating uri of the data being processed.\n     * @param {EntityCollection} entityCollection The collection being processsed.\n     */\n    CzmlDataSource.processPositionPacketData = processPositionPacketData;\n\n    /**\n     * A helper function used by custom CZML updater functions\n     * which creates or updates a {@link MaterialProperty} from a CZML packet.\n     * @function\n     *\n     * @param {Object} object The object on which the property will be added or updated.\n     * @param {String} propertyName The name of the property on the object.\n     * @param {Object} packetData The CZML packet being processed.\n     * @param {TimeInterval} interval A constraining interval for which the data is valid.\n     * @param {String} sourceUri The originating uri of the data being processed.\n     * @param {EntityCollection} entityCollection The collection being processsed.\n     */\n    CzmlDataSource.processMaterialPacketData = processMaterialPacketData;\n\n    CzmlDataSource._processCzml = function(czml, entityCollection, sourceUri, updaterFunctions, dataSource) {\n        updaterFunctions = defaultValue(updaterFunctions, CzmlDataSource.updaters);\n\n        if (isArray(czml)) {\n            for (var i = 0, len = czml.length; i < len; ++i) {\n                processCzmlPacket(czml[i], entityCollection, updaterFunctions, sourceUri, dataSource);\n            }\n        } else {\n            processCzmlPacket(czml, entityCollection, updaterFunctions, sourceUri, dataSource);\n        }\n    };\n\n    return CzmlDataSource;\n});\n","define([\n        '../Core/Cartesian2',\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Event',\n        './createPropertyDescriptor',\n        './Property'\n    ], function(\n        Cartesian2,\n        Color,\n        defaultValue,\n        defined,\n        defineProperties,\n        Event,\n        createPropertyDescriptor,\n        Property) {\n    'use strict';\n\n    var defaultColor = Color.WHITE;\n    var defaultCellAlpha = 0.1;\n    var defaultLineCount = new Cartesian2(8, 8);\n    var defaultLineOffset = new Cartesian2(0, 0);\n    var defaultLineThickness = new Cartesian2(1, 1);\n\n    /**\n     * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.\n     * @alias GridMaterialProperty\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Property} [options.color=Color.WHITE] A Property specifying the grid {@link Color}.\n     * @param {Property} [options.cellAlpha=0.1] A numeric Property specifying cell alpha values.\n     * @param {Property} [options.lineCount=new Cartesian2(8, 8)] A {@link Cartesian2} Property specifying the number of grid lines along each axis.\n     * @param {Property} [options.lineThickness=new Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.\n     * @param {Property} [options.lineOffset=new Cartesian2(0.0, 0.0)] A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.\n     *\n     * @constructor\n     */\n    function GridMaterialProperty(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._definitionChanged = new Event();\n        this._color = undefined;\n        this._colorSubscription = undefined;\n        this._cellAlpha = undefined;\n        this._cellAlphaSubscription = undefined;\n        this._lineCount = undefined;\n        this._lineCountSubscription = undefined;\n        this._lineThickness = undefined;\n        this._lineThicknessSubscription = undefined;\n        this._lineOffset = undefined;\n        this._lineOffsetSubscription = undefined;\n\n        this.color = options.color;\n        this.cellAlpha = options.cellAlpha;\n        this.lineCount = options.lineCount;\n        this.lineThickness = options.lineThickness;\n        this.lineOffset = options.lineOffset;\n    }\n\n    defineProperties(GridMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof GridMaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._color) &&\n                       Property.isConstant(this._cellAlpha) &&\n                       Property.isConstant(this._lineCount) &&\n                       Property.isConstant(this._lineThickness) &&\n                       Property.isConstant(this._lineOffset);\n            }\n        },\n\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof GridMaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n\n        /**\n         * Gets or sets the Property specifying the grid {@link Color}.\n         * @memberof GridMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.WHITE\n         */\n        color : createPropertyDescriptor('color'),\n\n        /**\n         * Gets or sets the numeric Property specifying cell alpha values.\n         * @memberof GridMaterialProperty.prototype\n         * @type {Property}\n         * @default 0.1\n         */\n        cellAlpha : createPropertyDescriptor('cellAlpha'),\n\n        /**\n         * Gets or sets the {@link Cartesian2} Property specifying the number of grid lines along each axis.\n         * @memberof GridMaterialProperty.prototype\n         * @type {Property}\n         * @default new Cartesian2(8.0, 8.0)\n         */\n        lineCount : createPropertyDescriptor('lineCount'),\n\n        /**\n         * Gets or sets the {@link Cartesian2} Property specifying the thickness of grid lines along each axis.\n         * @memberof GridMaterialProperty.prototype\n         * @type {Property}\n         * @default new Cartesian2(1.0, 1.0)\n         */\n        lineThickness : createPropertyDescriptor('lineThickness'),\n\n        /**\n         * Gets or sets the {@link Cartesian2} Property specifying the starting offset of grid lines along each axis.\n         * @memberof GridMaterialProperty.prototype\n         * @type {Property}\n         * @default new Cartesian2(0.0, 0.0)\n         */\n        lineOffset : createPropertyDescriptor('lineOffset')\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    GridMaterialProperty.prototype.getType = function(time) {\n        return 'Grid';\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    GridMaterialProperty.prototype.getValue = function(time, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);\n        result.cellAlpha = Property.getValueOrDefault(this._cellAlpha, time, defaultCellAlpha);\n        result.lineCount = Property.getValueOrClonedDefault(this._lineCount, time, defaultLineCount, result.lineCount);\n        result.lineThickness = Property.getValueOrClonedDefault(this._lineThickness, time, defaultLineThickness, result.lineThickness);\n        result.lineOffset = Property.getValueOrClonedDefault(this._lineOffset, time, defaultLineOffset, result.lineOffset);\n        return result;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    GridMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n        (other instanceof GridMaterialProperty && //\n        Property.equals(this._color, other._color) && //\n        Property.equals(this._cellAlpha, other._cellAlpha) && //\n        Property.equals(this._lineCount, other._lineCount) && //\n        Property.equals(this._lineThickness, other._lineThickness) && //\n        Property.equals(this._lineOffset, other._lineOffset));\n    };\n\n    return GridMaterialProperty;\n});\n","define([], function() {\n    'use strict';\n    /**\n     * Representation of <Camera> from KML\n     * @alias KmlCamera\n     * @constructor\n     *\n     * @param {Cartesian3} position camera position\n     * @param {HeadingPitchRoll} headingPitchRoll camera orientation\n     */\n    function KmlCamera(position, headingPitchRoll) {\n        this.position = position;\n        this.headingPitchRoll = headingPitchRoll;\n    }\n\n    return KmlCamera;\n});\n","define([\n        '../Core/ArcType',\n        '../Core/AssociativeArray',\n        '../Core/BoundingRectangle',\n        '../Core/Cartesian2',\n        '../Core/Cartesian3',\n        '../Core/Cartographic',\n        '../Core/ClockRange',\n        '../Core/ClockStep',\n        '../Core/Color',\n        '../Core/createGuid',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Ellipsoid',\n        '../Core/Event',\n        '../Core/getExtensionFromUri',\n        '../Core/getFilenameFromUri',\n        '../Core/HeadingPitchRange',\n        '../Core/HeadingPitchRoll',\n        '../Core/Iso8601',\n        '../Core/JulianDate',\n        '../Core/Math',\n        '../Core/NearFarScalar',\n        '../Core/objectToQuery',\n        '../Core/oneTimeWarning',\n        '../Core/PinBuilder',\n        '../Core/PolygonHierarchy',\n        '../Core/queryToObject',\n        '../Core/Rectangle',\n        '../Core/Resource',\n        '../Core/RuntimeError',\n        '../Core/TimeInterval',\n        '../Core/TimeIntervalCollection',\n        '../Scene/HeightReference',\n        '../Scene/HorizontalOrigin',\n        '../Scene/LabelStyle',\n        '../Scene/SceneMode',\n        '../ThirdParty/Autolinker',\n        '../ThirdParty/Uri',\n        '../ThirdParty/when',\n        '../ThirdParty/zip',\n        './BillboardGraphics',\n        './CompositePositionProperty',\n        './DataSource',\n        './DataSourceClock',\n        './Entity',\n        './EntityCluster',\n        './EntityCollection',\n        './KmlCamera',\n        './KmlLookAt',\n        './KmlTour',\n        './KmlTourFlyTo',\n        './KmlTourWait',\n        './LabelGraphics',\n        './PathGraphics',\n        './PolygonGraphics',\n        './PolylineGraphics',\n        './PositionPropertyArray',\n        './RectangleGraphics',\n        './ReferenceProperty',\n        './SampledPositionProperty',\n        './ScaledPositionProperty',\n        './TimeIntervalCollectionProperty',\n        './WallGraphics'\n    ], function(\n        ArcType,\n        AssociativeArray,\n        BoundingRectangle,\n        Cartesian2,\n        Cartesian3,\n        Cartographic,\n        ClockRange,\n        ClockStep,\n        Color,\n        createGuid,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid,\n        Event,\n        getExtensionFromUri,\n        getFilenameFromUri,\n        HeadingPitchRange,\n        HeadingPitchRoll,\n        Iso8601,\n        JulianDate,\n        CesiumMath,\n        NearFarScalar,\n        objectToQuery,\n        oneTimeWarning,\n        PinBuilder,\n        PolygonHierarchy,\n        queryToObject,\n        Rectangle,\n        Resource,\n        RuntimeError,\n        TimeInterval,\n        TimeIntervalCollection,\n        HeightReference,\n        HorizontalOrigin,\n        LabelStyle,\n        SceneMode,\n        Autolinker,\n        Uri,\n        when,\n        zip,\n        BillboardGraphics,\n        CompositePositionProperty,\n        DataSource,\n        DataSourceClock,\n        Entity,\n        EntityCluster,\n        EntityCollection,\n        KmlCamera,\n        KmlLookAt,\n        KmlTour,\n        KmlTourFlyTo,\n        KmlTourWait,\n        LabelGraphics,\n        PathGraphics,\n        PolygonGraphics,\n        PolylineGraphics,\n        PositionPropertyArray,\n        RectangleGraphics,\n        ReferenceProperty,\n        SampledPositionProperty,\n        ScaledPositionProperty,\n        TimeIntervalCollectionProperty,\n        WallGraphics) {\n    'use strict';\n\n    // IE 8 doesn't have a DOM parser and can't run Cesium anyway, so just bail.\n    if (typeof DOMParser === 'undefined') {\n        return {};\n    }\n\n    //This is by no means an exhaustive list of MIME types.\n    //The purpose of this list is to be able to accurately identify content embedded\n    //in KMZ files. Eventually, we can make this configurable by the end user so they can add\n    //there own content types if they have KMZ files that require it.\n    var MimeTypes = {\n        avi : 'video/x-msvideo',\n        bmp : 'image/bmp',\n        bz2 : 'application/x-bzip2',\n        chm : 'application/vnd.ms-htmlhelp',\n        css : 'text/css',\n        csv : 'text/csv',\n        doc : 'application/msword',\n        dvi : 'application/x-dvi',\n        eps : 'application/postscript',\n        flv : 'video/x-flv',\n        gif : 'image/gif',\n        gz : 'application/x-gzip',\n        htm : 'text/html',\n        html : 'text/html',\n        ico : 'image/vnd.microsoft.icon',\n        jnlp : 'application/x-java-jnlp-file',\n        jpeg : 'image/jpeg',\n        jpg : 'image/jpeg',\n        m3u : 'audio/x-mpegurl',\n        m4v : 'video/mp4',\n        mathml : 'application/mathml+xml',\n        mid : 'audio/midi',\n        midi : 'audio/midi',\n        mov : 'video/quicktime',\n        mp3 : 'audio/mpeg',\n        mp4 : 'video/mp4',\n        mp4v : 'video/mp4',\n        mpeg : 'video/mpeg',\n        mpg : 'video/mpeg',\n        odp : 'application/vnd.oasis.opendocument.presentation',\n        ods : 'application/vnd.oasis.opendocument.spreadsheet',\n        odt : 'application/vnd.oasis.opendocument.text',\n        ogg : 'application/ogg',\n        pdf : 'application/pdf',\n        png : 'image/png',\n        pps : 'application/vnd.ms-powerpoint',\n        ppt : 'application/vnd.ms-powerpoint',\n        ps : 'application/postscript',\n        qt : 'video/quicktime',\n        rdf : 'application/rdf+xml',\n        rss : 'application/rss+xml',\n        rtf : 'application/rtf',\n        svg : 'image/svg+xml',\n        swf : 'application/x-shockwave-flash',\n        text : 'text/plain',\n        tif : 'image/tiff',\n        tiff : 'image/tiff',\n        txt : 'text/plain',\n        wav : 'audio/x-wav',\n        wma : 'audio/x-ms-wma',\n        wmv : 'video/x-ms-wmv',\n        xml : 'application/xml',\n        zip : 'application/zip',\n\n        detectFromFilename : function(filename) {\n            var ext = filename.toLowerCase();\n            ext = getExtensionFromUri(ext);\n            return MimeTypes[ext];\n        }\n    };\n\n    var parser = new DOMParser();\n    var autolinker = new Autolinker({\n        stripPrefix : false,\n        twitter : false,\n        email : false,\n        replaceFn : function(linker, match) {\n            if (!match.protocolUrlMatch) {\n                //Prevent matching of non-explicit urls.\n                //i.e. foo.id won't match but http://foo.id will\n                return false;\n            }\n        }\n    });\n\n    var BILLBOARD_SIZE = 32;\n\n    var BILLBOARD_NEAR_DISTANCE = 2414016;\n    var BILLBOARD_NEAR_RATIO = 1.0;\n    var BILLBOARD_FAR_DISTANCE = 1.6093e+7;\n    var BILLBOARD_FAR_RATIO = 0.1;\n\n    function isZipFile(blob) {\n        var magicBlob = blob.slice(0, Math.min(4, blob.size));\n        var deferred = when.defer();\n        var reader = new FileReader();\n        reader.addEventListener('load', function() {\n            deferred.resolve(new DataView(reader.result).getUint32(0, false) === 0x504b0304);\n        });\n        reader.addEventListener('error', function() {\n            deferred.reject(reader.error);\n        });\n        reader.readAsArrayBuffer(magicBlob);\n        return deferred.promise;\n    }\n\n    function readBlobAsText(blob) {\n        var deferred = when.defer();\n        var reader = new FileReader();\n        reader.addEventListener('load', function() {\n            deferred.resolve(reader.result);\n        });\n        reader.addEventListener('error', function() {\n            deferred.reject(reader.error);\n        });\n        reader.readAsText(blob);\n        return deferred.promise;\n    }\n\n    function insertNamespaces(text) {\n        var namespaceMap = {\n            xsi : 'http://www.w3.org/2001/XMLSchema-instance'\n        };\n        var firstPart, lastPart, reg, declaration;\n\n        for (var key in namespaceMap) {\n            if (namespaceMap.hasOwnProperty(key)) {\n                reg = RegExp('[< ]' + key + ':');\n                declaration = 'xmlns:' + key + '=';\n                if (reg.test(text) && text.indexOf(declaration) === -1) {\n                    if (!defined(firstPart)) {\n                        firstPart = text.substr(0, text.indexOf('<kml') + 4);\n                        lastPart = text.substr(firstPart.length);\n                    }\n                    firstPart += ' ' + declaration + '\"' + namespaceMap[key] + '\"';\n                }\n            }\n        }\n\n        if (defined(firstPart)) {\n            text = firstPart + lastPart;\n        }\n\n        return text;\n    }\n\n    function removeDuplicateNamespaces(text) {\n        var index = text.indexOf('xmlns:');\n        var endDeclaration = text.indexOf('>', index);\n        var namespace, startIndex, endIndex;\n\n        while ((index !== -1) && (index < endDeclaration)) {\n            namespace = text.slice(index, text.indexOf('\\\"', index));\n            startIndex = index;\n            index = text.indexOf(namespace, index + 1);\n            if (index !== -1) {\n                endIndex = text.indexOf('\\\"', (text.indexOf('\\\"', index) + 1));\n                text = text.slice(0, index -1) + text.slice(endIndex + 1, text.length);\n                index = text.indexOf('xmlns:', startIndex - 1);\n            } else {\n                index = text.indexOf('xmlns:', startIndex + 1);\n            }\n        }\n\n        return text;\n    }\n\n    function loadXmlFromZip(entry, uriResolver, deferred) {\n        entry.getData(new zip.TextWriter(), function(text) {\n            text = insertNamespaces(text);\n            text = removeDuplicateNamespaces(text);\n            uriResolver.kml = parser.parseFromString(text, 'application/xml');\n            deferred.resolve();\n        });\n    }\n\n    function loadDataUriFromZip(entry, uriResolver, deferred) {\n        var mimeType = defaultValue(MimeTypes.detectFromFilename(entry.filename), 'application/octet-stream');\n        entry.getData(new zip.Data64URIWriter(mimeType), function(dataUri) {\n            uriResolver[entry.filename] = dataUri;\n            deferred.resolve();\n        });\n    }\n\n    function embedDataUris(div, elementType, attributeName, uriResolver) {\n        var keys = uriResolver.keys;\n        var baseUri = new Uri('.');\n        var elements = div.querySelectorAll(elementType);\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var value = element.getAttribute(attributeName);\n            var uri = new Uri(value).resolve(baseUri).toString();\n            var index = keys.indexOf(uri);\n            if (index !== -1) {\n                var key = keys[index];\n                element.setAttribute(attributeName, uriResolver[key]);\n                if (elementType === 'a' && element.getAttribute('download') === null) {\n                    element.setAttribute('download', key);\n                }\n            }\n        }\n    }\n\n    function applyBasePath(div, elementType, attributeName, sourceResource) {\n        var elements = div.querySelectorAll(elementType);\n        for (var i = 0; i < elements.length; i++) {\n            var element = elements[i];\n            var value = element.getAttribute(attributeName);\n            var resource = resolveHref(value, sourceResource);\n            element.setAttribute(attributeName, resource.url);\n        }\n    }\n\n    // an optional context is passed to allow for some malformed kmls (those with multiple geometries with same ids) to still parse\n    // correctly, as they do in Google Earth.\n    function createEntity(node, entityCollection, context) {\n        var id = queryStringAttribute(node, 'id');\n        id = defined(id) && id.length !== 0 ? id : createGuid();\n        if (defined(context)) {\n            id = context + id;\n        }\n\n        // If we have a duplicate ID just generate one.\n        // This isn't valid KML but Google Earth handles this case.\n        var entity = entityCollection.getById(id);\n        if (defined(entity)) {\n            id = createGuid();\n            if (defined(context)) {\n                id = context + id;\n            }\n        }\n\n        entity = entityCollection.add(new Entity({id : id}));\n        if (!defined(entity.kml)) {\n            entity.addProperty('kml');\n            entity.kml = new KmlFeatureData();\n        }\n        return entity;\n    }\n\n    function isExtrudable(altitudeMode, gxAltitudeMode) {\n        return altitudeMode === 'absolute' || altitudeMode === 'relativeToGround' || gxAltitudeMode === 'relativeToSeaFloor';\n    }\n\n    function readCoordinate(value, ellipsoid) {\n        //Google Earth treats empty or missing coordinates as 0.\n        if (!defined(value)) {\n            return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n        }\n\n        var digits = value.match(/[^\\s,\\n]+/g);\n        if (!defined(digits)) {\n            return Cartesian3.fromDegrees(0, 0, 0, ellipsoid);\n        }\n\n        var longitude = parseFloat(digits[0]);\n        var latitude = parseFloat(digits[1]);\n        var height = parseFloat(digits[2]);\n\n        longitude = isNaN(longitude) ? 0.0 : longitude;\n        latitude = isNaN(latitude) ? 0.0 : latitude;\n        height = isNaN(height) ? 0.0 : height;\n\n        return Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid);\n    }\n\n    function readCoordinates(element, ellipsoid) {\n        if (!defined(element)) {\n            return undefined;\n        }\n\n        var tuples = element.textContent.match(/[^\\s\\n]+/g);\n        if (!defined(tuples)) {\n            return undefined;\n        }\n\n        var length = tuples.length;\n        var result = new Array(length);\n        var resultIndex = 0;\n        for (var i = 0; i < length; i++) {\n            result[resultIndex++] = readCoordinate(tuples[i], ellipsoid);\n        }\n        return result;\n    }\n\n    var kmlNamespaces = [null, undefined, 'http://www.opengis.net/kml/2.2', 'http://earth.google.com/kml/2.2', 'http://earth.google.com/kml/2.1', 'http://earth.google.com/kml/2.0'];\n    var gxNamespaces = ['http://www.google.com/kml/ext/2.2'];\n    var atomNamespaces = ['http://www.w3.org/2005/Atom'];\n    var namespaces = {\n        kml : kmlNamespaces,\n        gx : gxNamespaces,\n        atom : atomNamespaces,\n        kmlgx : kmlNamespaces.concat(gxNamespaces)\n    };\n\n    function queryNumericAttribute(node, attributeName) {\n        if (!defined(node)) {\n            return undefined;\n        }\n\n        var value = node.getAttribute(attributeName);\n        if (value !== null) {\n            var result = parseFloat(value);\n            return !isNaN(result) ? result : undefined;\n        }\n        return undefined;\n    }\n\n    function queryStringAttribute(node, attributeName) {\n        if (!defined(node)) {\n            return undefined;\n        }\n        var value = node.getAttribute(attributeName);\n        return value !== null ? value : undefined;\n    }\n\n    function queryFirstNode(node, tagName, namespace) {\n        if (!defined(node)) {\n            return undefined;\n        }\n        var childNodes = node.childNodes;\n        var length = childNodes.length;\n        for (var q = 0; q < length; q++) {\n            var child = childNodes[q];\n            if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n                return child;\n            }\n        }\n        return undefined;\n    }\n\n    function queryNodes(node, tagName, namespace) {\n        if (!defined(node)) {\n            return undefined;\n        }\n        var result = [];\n        var childNodes = node.getElementsByTagNameNS('*', tagName);\n        var length = childNodes.length;\n        for (var q = 0; q < length; q++) {\n            var child = childNodes[q];\n            if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n                result.push(child);\n            }\n        }\n        return result;\n    }\n\n    function queryChildNodes(node, tagName, namespace) {\n        if (!defined(node)) {\n            return [];\n        }\n        var result = [];\n        var childNodes = node.childNodes;\n        var length = childNodes.length;\n        for (var q = 0; q < length; q++) {\n            var child = childNodes[q];\n            if (child.localName === tagName && namespace.indexOf(child.namespaceURI) !== -1) {\n                result.push(child);\n            }\n        }\n        return result;\n    }\n\n    function queryNumericValue(node, tagName, namespace) {\n        var resultNode = queryFirstNode(node, tagName, namespace);\n        if (defined(resultNode)) {\n            var result = parseFloat(resultNode.textContent);\n            return !isNaN(result) ? result : undefined;\n        }\n        return undefined;\n    }\n\n    function queryStringValue(node, tagName, namespace) {\n        var result = queryFirstNode(node, tagName, namespace);\n        if (defined(result)) {\n            return result.textContent.trim();\n        }\n        return undefined;\n    }\n\n    function queryBooleanValue(node, tagName, namespace) {\n        var result = queryFirstNode(node, tagName, namespace);\n        if (defined(result)) {\n            var value = result.textContent.trim();\n            return value === '1' || /^true$/i.test(value);\n        }\n        return undefined;\n    }\n\n    function resolveHref(href, sourceResource, uriResolver) {\n        if (!defined(href)) {\n            return undefined;\n        }\n\n        var resource;\n        if (defined(uriResolver)) {\n            var blob = uriResolver[href];\n            if (defined(blob)) {\n                resource = new Resource({\n                    url: blob\n                });\n            } else {\n                // Needed for multiple levels of KML files in a KMZ\n                var baseUri = new Uri(sourceResource.getUrlComponent());\n                var uri = new Uri(href);\n                blob = uriResolver[uri.resolve(baseUri)];\n                if (defined(blob)) {\n                    resource = new Resource({\n                        url: blob\n                    });\n                }\n            }\n        }\n\n        if (!defined(resource)) {\n            resource = sourceResource.getDerivedResource({\n                url: href\n            });\n        }\n\n        return resource;\n    }\n\n    var colorOptions = {\n        maximumRed : undefined,\n        red : undefined,\n        maximumGreen : undefined,\n        green : undefined,\n        maximumBlue : undefined,\n        blue : undefined\n    };\n\n    function parseColorString(value, isRandom) {\n        if (!defined(value) || /^\\s*$/gm.test(value)) {\n            return undefined;\n        }\n\n        if (value[0] === '#') {\n            value = value.substring(1);\n        }\n\n        var alpha = parseInt(value.substring(0, 2), 16) / 255.0;\n        var blue = parseInt(value.substring(2, 4), 16) / 255.0;\n        var green = parseInt(value.substring(4, 6), 16) / 255.0;\n        var red = parseInt(value.substring(6, 8), 16) / 255.0;\n\n        if (!isRandom) {\n            return new Color(red, green, blue, alpha);\n        }\n\n        if (red > 0) {\n            colorOptions.maximumRed = red;\n            colorOptions.red = undefined;\n        } else {\n            colorOptions.maximumRed = undefined;\n            colorOptions.red = 0;\n        }\n        if (green > 0) {\n            colorOptions.maximumGreen = green;\n            colorOptions.green = undefined;\n        } else {\n            colorOptions.maximumGreen = undefined;\n            colorOptions.green = 0;\n        }\n        if (blue > 0) {\n            colorOptions.maximumBlue = blue;\n            colorOptions.blue = undefined;\n        } else {\n            colorOptions.maximumBlue = undefined;\n            colorOptions.blue = 0;\n        }\n        colorOptions.alpha = alpha;\n        return Color.fromRandom(colorOptions);\n    }\n\n    function queryColorValue(node, tagName, namespace) {\n        var value = queryStringValue(node, tagName, namespace);\n        if (!defined(value)) {\n            return undefined;\n        }\n        return parseColorString(value, queryStringValue(node, 'colorMode', namespace) === 'random');\n    }\n\n    function processTimeStamp(featureNode) {\n        var node = queryFirstNode(featureNode, 'TimeStamp', namespaces.kmlgx);\n        var whenString = queryStringValue(node, 'when', namespaces.kmlgx);\n\n        if (!defined(node) || !defined(whenString) || whenString.length === 0) {\n            return undefined;\n        }\n\n        //According to the KML spec, a TimeStamp represents a \"single moment in time\"\n        //However, since Cesium animates much differently than Google Earth, that doesn't\n        //Make much sense here.  Instead, we use the TimeStamp as the moment the feature\n        //comes into existence.  This works much better and gives a similar feel to\n        //GE's experience.\n        var when = JulianDate.fromIso8601(whenString);\n        var result = new TimeIntervalCollection();\n        result.addInterval(new TimeInterval({\n            start : when,\n            stop : Iso8601.MAXIMUM_VALUE\n        }));\n        return result;\n    }\n\n    function processTimeSpan(featureNode) {\n        var node = queryFirstNode(featureNode, 'TimeSpan', namespaces.kmlgx);\n        if (!defined(node)) {\n            return undefined;\n        }\n        var result;\n\n        var beginNode = queryFirstNode(node, 'begin', namespaces.kmlgx);\n        var beginDate = defined(beginNode) ? JulianDate.fromIso8601(beginNode.textContent) : undefined;\n\n        var endNode = queryFirstNode(node, 'end', namespaces.kmlgx);\n        var endDate = defined(endNode) ? JulianDate.fromIso8601(endNode.textContent) : undefined;\n\n        if (defined(beginDate) && defined(endDate)) {\n            if (JulianDate.lessThan(endDate, beginDate)) {\n                var tmp = beginDate;\n                beginDate = endDate;\n                endDate = tmp;\n            }\n            result = new TimeIntervalCollection();\n            result.addInterval(new TimeInterval({\n                start : beginDate,\n                stop : endDate\n            }));\n        } else if (defined(beginDate)) {\n            result = new TimeIntervalCollection();\n            result.addInterval(new TimeInterval({\n                start : beginDate,\n                stop : Iso8601.MAXIMUM_VALUE\n            }));\n        } else if (defined(endDate)) {\n            result = new TimeIntervalCollection();\n            result.addInterval(new TimeInterval({\n                start : Iso8601.MINIMUM_VALUE,\n                stop : endDate\n            }));\n        }\n\n        return result;\n    }\n\n    function createDefaultBillboard() {\n        var billboard = new BillboardGraphics();\n        billboard.width = BILLBOARD_SIZE;\n        billboard.height = BILLBOARD_SIZE;\n        billboard.scaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n        billboard.pixelOffsetScaleByDistance = new NearFarScalar(BILLBOARD_NEAR_DISTANCE, BILLBOARD_NEAR_RATIO, BILLBOARD_FAR_DISTANCE, BILLBOARD_FAR_RATIO);\n        return billboard;\n    }\n\n    function createDefaultPolygon() {\n        var polygon = new PolygonGraphics();\n        polygon.outline = true;\n        polygon.outlineColor = Color.WHITE;\n        return polygon;\n    }\n\n    function createDefaultLabel() {\n        var label = new LabelGraphics();\n        label.translucencyByDistance = new NearFarScalar(3000000, 1.0, 5000000, 0.0);\n        label.pixelOffset = new Cartesian2(17, 0);\n        label.horizontalOrigin = HorizontalOrigin.LEFT;\n        label.font = '16px sans-serif';\n        label.style = LabelStyle.FILL_AND_OUTLINE;\n        return label;\n    }\n\n    function getIconHref(iconNode, dataSource, sourceResource, uriResolver, canRefresh) {\n        var href = queryStringValue(iconNode, 'href', namespaces.kml);\n        if (!defined(href) || (href.length === 0)) {\n            return undefined;\n        }\n\n        if (href.indexOf('root://icons/palette-') === 0) {\n            var palette = href.charAt(21);\n\n            // Get the icon number\n            var x = defaultValue(queryNumericValue(iconNode, 'x', namespaces.gx), 0);\n            var y = defaultValue(queryNumericValue(iconNode, 'y', namespaces.gx), 0);\n            x = Math.min(x / 32, 7);\n            y = 7 - Math.min(y / 32, 7);\n            var iconNum = (8 * y) + x;\n\n            href = 'https://maps.google.com/mapfiles/kml/pal' + palette + '/icon' + iconNum + '.png';\n        }\n\n        var hrefResource = resolveHref(href, sourceResource, uriResolver);\n\n        if (canRefresh) {\n            var refreshMode = queryStringValue(iconNode, 'refreshMode', namespaces.kml);\n            var viewRefreshMode = queryStringValue(iconNode, 'viewRefreshMode', namespaces.kml);\n            if (refreshMode === 'onInterval' || refreshMode === 'onExpire') {\n                oneTimeWarning('kml-refreshMode-' + refreshMode, 'KML - Unsupported Icon refreshMode: ' + refreshMode);\n            } else if (viewRefreshMode === 'onStop' || viewRefreshMode === 'onRegion') {\n                oneTimeWarning('kml-refreshMode-' + viewRefreshMode, 'KML - Unsupported Icon viewRefreshMode: ' + viewRefreshMode);\n            }\n\n            var viewBoundScale = defaultValue(queryStringValue(iconNode, 'viewBoundScale', namespaces.kml), 1.0);\n            var defaultViewFormat = (viewRefreshMode === 'onStop') ? 'BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]' : '';\n            var viewFormat = defaultValue(queryStringValue(iconNode, 'viewFormat', namespaces.kml), defaultViewFormat);\n            var httpQuery = queryStringValue(iconNode, 'httpQuery', namespaces.kml);\n            if (defined(viewFormat)) {\n                hrefResource.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n            }\n            if (defined(httpQuery)) {\n                hrefResource.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n            }\n\n            var ellipsoid = dataSource._ellipsoid;\n            processNetworkLinkQueryString(hrefResource, dataSource._camera, dataSource._canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);\n\n            return hrefResource;\n        }\n\n        return hrefResource;\n    }\n\n    function processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver) {\n        var scale = queryNumericValue(node, 'scale', namespaces.kml);\n        var heading = queryNumericValue(node, 'heading', namespaces.kml);\n        var color = queryColorValue(node, 'color', namespaces.kml);\n\n        var iconNode = queryFirstNode(node, 'Icon', namespaces.kml);\n        var icon = getIconHref(iconNode, dataSource, sourceResource, uriResolver, false);\n\n        // If icon tags are present but blank, we do not want to show an icon\n        if (defined(iconNode) && !defined(icon)) {\n            icon = false;\n        }\n\n        var x = queryNumericValue(iconNode, 'x', namespaces.gx);\n        var y = queryNumericValue(iconNode, 'y', namespaces.gx);\n        var w = queryNumericValue(iconNode, 'w', namespaces.gx);\n        var h = queryNumericValue(iconNode, 'h', namespaces.gx);\n\n        var hotSpotNode = queryFirstNode(node, 'hotSpot', namespaces.kml);\n        var hotSpotX = queryNumericAttribute(hotSpotNode, 'x');\n        var hotSpotY = queryNumericAttribute(hotSpotNode, 'y');\n        var hotSpotXUnit = queryStringAttribute(hotSpotNode, 'xunits');\n        var hotSpotYUnit = queryStringAttribute(hotSpotNode, 'yunits');\n\n        var billboard = targetEntity.billboard;\n        if (!defined(billboard)) {\n            billboard = createDefaultBillboard();\n            targetEntity.billboard = billboard;\n        }\n\n        billboard.image = icon;\n        billboard.scale = scale;\n        billboard.color = color;\n\n        if (defined(x) || defined(y) || defined(w) || defined(h)) {\n            billboard.imageSubRegion = new BoundingRectangle(x, y, w, h);\n        }\n\n        //GE treats a heading of zero as no heading\n        //You can still point north using a 360 degree angle (or any multiple of 360)\n        if (defined(heading) && heading !== 0) {\n            billboard.rotation = CesiumMath.toRadians(-heading);\n            billboard.alignedAxis = Cartesian3.UNIT_Z;\n        }\n\n        //Hotpot is the KML equivalent of pixel offset\n        //The hotspot origin is the lower left, but we leave\n        //our billboard origin at the center and simply\n        //modify the pixel offset to take this into account\n        scale = defaultValue(scale, 1.0);\n\n        var xOffset;\n        var yOffset;\n        if (defined(hotSpotX)) {\n            if (hotSpotXUnit === 'pixels') {\n                xOffset = -hotSpotX * scale;\n            } else if (hotSpotXUnit === 'insetPixels') {\n                xOffset = (hotSpotX - BILLBOARD_SIZE) * scale;\n            } else if (hotSpotXUnit === 'fraction') {\n                xOffset = -hotSpotX * BILLBOARD_SIZE * scale;\n            }\n            xOffset += BILLBOARD_SIZE * 0.5 * scale;\n        }\n\n        if (defined(hotSpotY)) {\n            if (hotSpotYUnit === 'pixels') {\n                yOffset = hotSpotY * scale;\n            } else if (hotSpotYUnit === 'insetPixels') {\n                yOffset = (-hotSpotY + BILLBOARD_SIZE) * scale;\n            } else if (hotSpotYUnit === 'fraction') {\n                yOffset = hotSpotY * BILLBOARD_SIZE * scale;\n            }\n\n            yOffset -= BILLBOARD_SIZE * 0.5 * scale;\n        }\n\n        if (defined(xOffset) || defined(yOffset)) {\n            billboard.pixelOffset = new Cartesian2(xOffset, yOffset);\n        }\n    }\n\n    function applyStyle(dataSource, styleNode, targetEntity, sourceResource, uriResolver) {\n        for (var i = 0, len = styleNode.childNodes.length; i < len; i++) {\n            var node = styleNode.childNodes.item(i);\n            if (node.localName === 'IconStyle') {\n                processBillboardIcon(dataSource, node, targetEntity, sourceResource, uriResolver);\n            } else if (node.localName === 'LabelStyle') {\n                var label = targetEntity.label;\n                if (!defined(label)) {\n                    label = createDefaultLabel();\n                    targetEntity.label = label;\n                }\n                label.scale = defaultValue(queryNumericValue(node, 'scale', namespaces.kml), label.scale);\n                label.fillColor = defaultValue(queryColorValue(node, 'color', namespaces.kml), label.fillColor);\n                label.text = targetEntity.name;\n            } else if (node.localName === 'LineStyle') {\n                var polyline = targetEntity.polyline;\n                if (!defined(polyline)) {\n                    polyline = new PolylineGraphics();\n                    targetEntity.polyline = polyline;\n                }\n                polyline.width = queryNumericValue(node, 'width', namespaces.kml);\n                polyline.material = queryColorValue(node, 'color', namespaces.kml);\n                if (defined(queryColorValue(node, 'outerColor', namespaces.gx))) {\n                    oneTimeWarning('kml-gx:outerColor', 'KML - gx:outerColor is not supported in a LineStyle');\n                }\n                if (defined(queryNumericValue(node, 'outerWidth', namespaces.gx))) {\n                    oneTimeWarning('kml-gx:outerWidth', 'KML - gx:outerWidth is not supported in a LineStyle');\n                }\n                if (defined(queryNumericValue(node, 'physicalWidth', namespaces.gx))) {\n                    oneTimeWarning('kml-gx:physicalWidth', 'KML - gx:physicalWidth is not supported in a LineStyle');\n                }\n                if (defined(queryBooleanValue(node, 'labelVisibility', namespaces.gx))) {\n                    oneTimeWarning('kml-gx:labelVisibility', 'KML - gx:labelVisibility is not supported in a LineStyle');\n                }\n            } else if (node.localName === 'PolyStyle') {\n                var polygon = targetEntity.polygon;\n                if (!defined(polygon)) {\n                    polygon = createDefaultPolygon();\n                    targetEntity.polygon = polygon;\n                }\n                polygon.material = defaultValue(queryColorValue(node, 'color', namespaces.kml), polygon.material);\n                polygon.fill = defaultValue(queryBooleanValue(node, 'fill', namespaces.kml), polygon.fill);\n                polygon.outline = defaultValue(queryBooleanValue(node, 'outline', namespaces.kml), polygon.outline);\n            } else if (node.localName === 'BalloonStyle') {\n                var bgColor = defaultValue(parseColorString(queryStringValue(node, 'bgColor', namespaces.kml)), Color.WHITE);\n                var textColor = defaultValue(parseColorString(queryStringValue(node, 'textColor', namespaces.kml)), Color.BLACK);\n                var text = queryStringValue(node, 'text', namespaces.kml);\n\n                //This is purely an internal property used in style processing,\n                //it never ends up on the final entity.\n                targetEntity.addProperty('balloonStyle');\n                targetEntity.balloonStyle = {\n                    bgColor : bgColor,\n                    textColor : textColor,\n                    text : text\n                };\n            } else if (node.localName === 'ListStyle') {\n                var listItemType = queryStringValue(node, 'listItemType', namespaces.kml);\n                if (listItemType === 'radioFolder' || listItemType === 'checkOffOnly') {\n                    oneTimeWarning('kml-listStyle-' + listItemType, 'KML - Unsupported ListStyle with listItemType: ' + listItemType);\n                }\n            }\n        }\n    }\n\n    //Processes and merges any inline styles for the provided node into the provided entity.\n    function computeFinalStyle(dataSource, placeMark, styleCollection, sourceResource, uriResolver) {\n        var result = new Entity();\n        var styleEntity;\n\n        //Google earth seems to always use the last inline Style/StyleMap only\n        var styleIndex = -1;\n        var childNodes = placeMark.childNodes;\n        var length = childNodes.length;\n        for (var q = 0; q < length; q++) {\n            var child = childNodes[q];\n            if (child.localName === 'Style' || child.localName === 'StyleMap') {\n                styleIndex = q;\n            }\n        }\n\n        if (styleIndex !== -1) {\n            var inlineStyleNode = childNodes[styleIndex];\n            if (inlineStyleNode.localName === 'Style') {\n                applyStyle(dataSource, inlineStyleNode, result, sourceResource, uriResolver);\n            } else { // StyleMap\n                var pairs = queryChildNodes(inlineStyleNode, 'Pair', namespaces.kml);\n                for (var p = 0; p < pairs.length; p++) {\n                    var pair = pairs[p];\n                    var key = queryStringValue(pair, 'key', namespaces.kml);\n                    if (key === 'normal') {\n                        var styleUrl = queryStringValue(pair, 'styleUrl', namespaces.kml);\n                        if (defined(styleUrl)) {\n                            styleEntity = styleCollection.getById(styleUrl);\n                            if (!defined(styleEntity)) {\n                                styleEntity = styleCollection.getById('#' + styleUrl);\n                            }\n                            if (defined(styleEntity)) {\n                                result.merge(styleEntity);\n                            }\n                        } else {\n                            var node = queryFirstNode(pair, 'Style', namespaces.kml);\n                            applyStyle(dataSource, node, result, sourceResource, uriResolver);\n                        }\n                    } else {\n                        oneTimeWarning('kml-styleMap-' + key, 'KML - Unsupported StyleMap key: ' + key);\n                    }\n                }\n            }\n        }\n\n        //Google earth seems to always use the first external style only.\n        var externalStyle = queryStringValue(placeMark, 'styleUrl', namespaces.kml);\n        if (defined(externalStyle)) {\n            var id = externalStyle;\n            if (externalStyle[0] !== '#' && externalStyle.indexOf('#') !== -1) {\n                var tokens = externalStyle.split('#');\n                var uri = tokens[0];\n                var resource = sourceResource.getDerivedResource({\n                    url: uri\n                });\n\n                id = resource.getUrlComponent() + '#' + tokens[1];\n            }\n\n            styleEntity = styleCollection.getById(id);\n            if (!defined(styleEntity)) {\n                styleEntity = styleCollection.getById('#' + id);\n            }\n            if (defined(styleEntity)) {\n                result.merge(styleEntity);\n            }\n        }\n\n        return result;\n    }\n\n    //Asynchronously processes an external style file.\n    function processExternalStyles(dataSource, resource, styleCollection) {\n        return resource.fetchXML().then(function(styleKml) {\n            return processStyles(dataSource, styleKml, styleCollection, resource, true);\n        });\n    }\n\n    //Processes all shared and external styles and stores\n    //their id into the provided styleCollection.\n    //Returns an array of promises that will resolve when\n    //each style is loaded.\n    function processStyles(dataSource, kml, styleCollection, sourceResource, isExternal, uriResolver) {\n        var i;\n        var id;\n        var styleEntity;\n\n        var node;\n        var styleNodes = queryNodes(kml, 'Style', namespaces.kml);\n        if (defined(styleNodes)) {\n            var styleNodesLength = styleNodes.length;\n            for (i = 0; i < styleNodesLength; i++) {\n                node = styleNodes[i];\n                id = queryStringAttribute(node, 'id');\n                if (defined(id)) {\n                    id = '#' + id;\n                    if (isExternal && defined(sourceResource)) {\n                        id = sourceResource.getUrlComponent() + id;\n                    }\n                    if (!defined(styleCollection.getById(id))) {\n                        styleEntity = new Entity({\n                            id : id\n                        });\n                        styleCollection.add(styleEntity);\n                        applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);\n                    }\n                }\n            }\n        }\n\n        var styleMaps = queryNodes(kml, 'StyleMap', namespaces.kml);\n        if (defined(styleMaps)) {\n            var styleMapsLength = styleMaps.length;\n            for (i = 0; i < styleMapsLength; i++) {\n                var styleMap = styleMaps[i];\n                id = queryStringAttribute(styleMap, 'id');\n                if (defined(id)) {\n                    var pairs = queryChildNodes(styleMap, 'Pair', namespaces.kml);\n                    for (var p = 0; p < pairs.length; p++) {\n                        var pair = pairs[p];\n                        var key = queryStringValue(pair, 'key', namespaces.kml);\n                        if (key === 'normal') {\n                            id = '#' + id;\n                            if (isExternal && defined(sourceResource)) {\n                                id = sourceResource.getUrlComponent() + id;\n                            }\n                            if (!defined(styleCollection.getById(id))) {\n                                styleEntity = styleCollection.getOrCreateEntity(id);\n\n                                var styleUrl = queryStringValue(pair, 'styleUrl', namespaces.kml);\n                                if (defined(styleUrl)) {\n                                    if (styleUrl[0] !== '#') {\n                                        styleUrl = '#' + styleUrl;\n                                    }\n\n                                    if (isExternal && defined(sourceResource)) {\n                                        styleUrl = sourceResource.getUrlComponent() + styleUrl;\n                                    }\n                                    var base = styleCollection.getById(styleUrl);\n\n                                    if (defined(base)) {\n                                        styleEntity.merge(base);\n                                    }\n                                } else {\n                                    node = queryFirstNode(pair, 'Style', namespaces.kml);\n                                    applyStyle(dataSource, node, styleEntity, sourceResource, uriResolver);\n                                }\n                            }\n                        } else {\n                            oneTimeWarning('kml-styleMap-' + key, 'KML - Unsupported StyleMap key: ' + key);\n                        }\n                    }\n                }\n            }\n        }\n\n        var promises = [];\n        var styleUrlNodes = kml.getElementsByTagName('styleUrl');\n        var styleUrlNodesLength = styleUrlNodes.length;\n        for (i = 0; i < styleUrlNodesLength; i++) {\n            var styleReference = styleUrlNodes[i].textContent;\n            if (styleReference[0] !== '#') {\n                //According to the spec, all local styles should start with a #\n                //and everything else is an external style that has a # seperating\n                //the URL of the document and the style.  However, Google Earth\n                //also accepts styleUrls without a # as meaning a local style.\n                var tokens = styleReference.split('#');\n                if (tokens.length === 2) {\n                    var uri = tokens[0];\n                    var resource = sourceResource.getDerivedResource({\n                        url: uri\n                    });\n\n                    promises.push(processExternalStyles(dataSource, resource, styleCollection));\n                }\n            }\n        }\n\n        return promises;\n    }\n\n    function createDropLine(entityCollection, entity, styleEntity) {\n        var entityPosition = new ReferenceProperty(entityCollection, entity.id, ['position']);\n        var surfacePosition = new ScaledPositionProperty(entity.position);\n        entity.polyline = defined(styleEntity.polyline) ? styleEntity.polyline.clone() : new PolylineGraphics();\n        entity.polyline.positions = new PositionPropertyArray([entityPosition, surfacePosition]);\n    }\n\n    function heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode) {\n        if (!defined(altitudeMode) && !defined(gxAltitudeMode) || altitudeMode === 'clampToGround') {\n            return HeightReference.CLAMP_TO_GROUND;\n        }\n\n        if (altitudeMode === 'relativeToGround') {\n            return HeightReference.RELATIVE_TO_GROUND;\n        }\n\n        if (altitudeMode === 'absolute') {\n            return HeightReference.NONE;\n        }\n\n        if (gxAltitudeMode === 'clampToSeaFloor') {\n            oneTimeWarning('kml-gx:altitudeMode-clampToSeaFloor', 'KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround.');\n            return HeightReference.CLAMP_TO_GROUND;\n        }\n\n        if (gxAltitudeMode === 'relativeToSeaFloor') {\n            oneTimeWarning('kml-gx:altitudeMode-relativeToSeaFloor', 'KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround.');\n            return HeightReference.RELATIVE_TO_GROUND;\n        }\n\n        if (defined(altitudeMode)) {\n            oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown <kml:altitudeMode>:' + altitudeMode + ', using <kml:altitudeMode>:CLAMP_TO_GROUND.');\n        } else {\n            oneTimeWarning('kml-gx:altitudeMode-unknown', 'KML - Unknown <gx:altitudeMode>:' + gxAltitudeMode + ', using <kml:altitudeMode>:CLAMP_TO_GROUND.');\n        }\n\n        // Clamp to ground is the default\n        return HeightReference.CLAMP_TO_GROUND;\n    }\n\n    function createPositionPropertyFromAltitudeMode(property, altitudeMode, gxAltitudeMode) {\n        if (gxAltitudeMode === 'relativeToSeaFloor' || altitudeMode === 'absolute' || altitudeMode === 'relativeToGround') {\n            //Just return the ellipsoid referenced property until we support MSL\n            return property;\n        }\n\n        if ((defined(altitudeMode) && altitudeMode !== 'clampToGround') || //\n            (defined(gxAltitudeMode) && gxAltitudeMode !== 'clampToSeaFloor')) {\n            oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + defaultValue(altitudeMode, gxAltitudeMode));\n        }\n\n        // Clamp to ground is the default\n        return new ScaledPositionProperty(property);\n    }\n\n    function createPositionPropertyArrayFromAltitudeMode(properties, altitudeMode, gxAltitudeMode, ellipsoid) {\n        if (!defined(properties)) {\n            return undefined;\n        }\n\n        if (gxAltitudeMode === 'relativeToSeaFloor' || altitudeMode === 'absolute' || altitudeMode === 'relativeToGround') {\n            //Just return the ellipsoid referenced property until we support MSL\n            return properties;\n        }\n\n        if ((defined(altitudeMode) && altitudeMode !== 'clampToGround') || //\n            (defined(gxAltitudeMode) && gxAltitudeMode !== 'clampToSeaFloor')) {\n            oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + defaultValue(altitudeMode, gxAltitudeMode));\n        }\n\n        // Clamp to ground is the default\n        var propertiesLength = properties.length;\n        for (var i = 0; i < propertiesLength; i++) {\n            var property = properties[i];\n            ellipsoid.scaleToGeodeticSurface(property, property);\n        }\n        return properties;\n    }\n\n    function processPositionGraphics(dataSource, entity, styleEntity, heightReference) {\n        var label = entity.label;\n        if (!defined(label)) {\n            label = defined(styleEntity.label) ? styleEntity.label.clone() : createDefaultLabel();\n            entity.label = label;\n        }\n        label.text = entity.name;\n\n        var billboard = entity.billboard;\n        if (!defined(billboard)) {\n            billboard = defined(styleEntity.billboard) ? styleEntity.billboard.clone() : createDefaultBillboard();\n            entity.billboard = billboard;\n        }\n\n        if (!defined(billboard.image)) {\n            billboard.image = dataSource._pinBuilder.fromColor(Color.YELLOW, 64);\n\n        // If there were empty <Icon> tags in the KML, then billboard.image was set to false above\n        // However, in this case, the false value would have been converted to a property afterwards\n        // Thus, we check if billboard.image is defined with value of false\n        } else if (!billboard.image.getValue()) {\n            billboard.image = undefined;\n        }\n\n        var scale = 1.0;\n        if (defined(billboard.scale)) {\n            scale = billboard.scale.getValue();\n            if (scale !== 0) {\n                label.pixelOffset = new Cartesian2((scale * 16) + 1, 0);\n            } else {\n                //Minor tweaks to better match Google Earth.\n                label.pixelOffset = undefined;\n                label.horizontalOrigin = undefined;\n            }\n        }\n\n        if (defined(heightReference) && dataSource._clampToGround) {\n            billboard.heightReference = heightReference;\n            label.heightReference = heightReference;\n        }\n    }\n\n    function processPathGraphics(entity, styleEntity) {\n        var path = entity.path;\n        if (!defined(path)) {\n            path = new PathGraphics();\n            path.leadTime = 0;\n            entity.path = path;\n        }\n\n        var polyline = styleEntity.polyline;\n        if (defined(polyline)) {\n            path.material = polyline.material;\n            path.width = polyline.width;\n        }\n    }\n\n    function processPoint(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n        var coordinatesString = queryStringValue(geometryNode, 'coordinates', namespaces.kml);\n        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);\n        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);\n        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);\n        var ellipsoid = dataSource._ellipsoid;\n        var position = readCoordinate(coordinatesString, ellipsoid);\n\n        entity.position = position;\n        processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));\n\n        if (extrude && isExtrudable(altitudeMode, gxAltitudeMode)) {\n            createDropLine(entityCollection, entity, styleEntity);\n        }\n\n        return true;\n    }\n\n    function processLineStringOrLinearRing(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n        var coordinatesNode = queryFirstNode(geometryNode, 'coordinates', namespaces.kml);\n        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);\n        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);\n        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);\n        var tessellate = queryBooleanValue(geometryNode, 'tessellate', namespaces.kml);\n        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n        var zIndex = queryNumericValue(geometryNode, 'drawOrder', namespaces.gx);\n\n        var ellipsoid = dataSource._ellipsoid;\n        var coordinates = readCoordinates(coordinatesNode, ellipsoid);\n        var polyline = styleEntity.polyline;\n        if (canExtrude && extrude) {\n            var wall = new WallGraphics();\n            entity.wall = wall;\n            wall.positions = coordinates;\n            var polygon = styleEntity.polygon;\n\n            if (defined(polygon)) {\n                wall.fill = polygon.fill;\n                wall.material = polygon.material;\n            }\n\n            //Always outline walls so they show up in 2D.\n            wall.outline = true;\n            if (defined(polyline)) {\n                wall.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;\n                wall.outlineWidth = polyline.width;\n            } else if (defined(polygon)) {\n                wall.outlineColor = defined(polygon.material) ? polygon.material.color : Color.WHITE;\n            }\n        } else if (dataSource._clampToGround && !canExtrude && tessellate) {\n            var polylineGraphics = new PolylineGraphics();\n            polylineGraphics.clampToGround = true;\n            entity.polyline = polylineGraphics;\n            polylineGraphics.positions = coordinates;\n            if (defined(polyline)) {\n                polylineGraphics.material = defined(polyline.material) ? polyline.material.color.getValue(Iso8601.MINIMUM_VALUE) : Color.WHITE;\n                polylineGraphics.width = defaultValue(polyline.width, 1.0);\n            } else {\n                polylineGraphics.material = Color.WHITE;\n                polylineGraphics.width = 1.0;\n            }\n            polylineGraphics.zIndex = zIndex;\n        } else {\n            if (defined(zIndex)) {\n                oneTimeWarning('kml-gx:drawOrder', 'KML - gx:drawOrder is not supported in LineStrings when clampToGround is false');\n            }\n\n            polyline = defined(polyline) ? polyline.clone() : new PolylineGraphics();\n            entity.polyline = polyline;\n            polyline.positions = createPositionPropertyArrayFromAltitudeMode(coordinates, altitudeMode, gxAltitudeMode, ellipsoid);\n            if (!tessellate || canExtrude) {\n                polyline.arcType = ArcType.NONE;\n            }\n        }\n\n        return true;\n    }\n\n    function processPolygon(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n        var outerBoundaryIsNode = queryFirstNode(geometryNode, 'outerBoundaryIs', namespaces.kml);\n        var linearRingNode = queryFirstNode(outerBoundaryIsNode, 'LinearRing', namespaces.kml);\n        var coordinatesNode = queryFirstNode(linearRingNode, 'coordinates', namespaces.kml);\n        var ellipsoid = dataSource._ellipsoid;\n        var coordinates = readCoordinates(coordinatesNode, ellipsoid);\n        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);\n        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);\n        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);\n        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n\n        var polygon = defined(styleEntity.polygon) ? styleEntity.polygon.clone() : createDefaultPolygon();\n\n        var polyline = styleEntity.polyline;\n        if (defined(polyline)) {\n            polygon.outlineColor = defined(polyline.material) ? polyline.material.color : Color.WHITE;\n            polygon.outlineWidth = polyline.width;\n        }\n        entity.polygon = polygon;\n\n        if (canExtrude) {\n            polygon.perPositionHeight = true;\n            polygon.extrudedHeight = extrude ? 0 : undefined;\n        } else if (!dataSource._clampToGround) {\n            polygon.height = 0;\n        }\n\n        if (defined(coordinates)) {\n            var hierarchy = new PolygonHierarchy(coordinates);\n            var innerBoundaryIsNodes = queryChildNodes(geometryNode, 'innerBoundaryIs', namespaces.kml);\n            for (var j = 0; j < innerBoundaryIsNodes.length; j++) {\n                linearRingNode = queryChildNodes(innerBoundaryIsNodes[j], 'LinearRing', namespaces.kml);\n                for (var k = 0; k < linearRingNode.length; k++) {\n                    coordinatesNode = queryFirstNode(linearRingNode[k], 'coordinates', namespaces.kml);\n                    coordinates = readCoordinates(coordinatesNode, ellipsoid);\n                    if (defined(coordinates)) {\n                        hierarchy.holes.push(new PolygonHierarchy(coordinates));\n                    }\n                }\n            }\n            polygon.hierarchy = hierarchy;\n        }\n\n        return true;\n    }\n\n    function processTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n        var altitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.kml);\n        var gxAltitudeMode = queryStringValue(geometryNode, 'altitudeMode', namespaces.gx);\n        var coordNodes = queryChildNodes(geometryNode, 'coord', namespaces.gx);\n        var angleNodes = queryChildNodes(geometryNode, 'angles', namespaces.gx);\n        var timeNodes = queryChildNodes(geometryNode, 'when', namespaces.kml);\n        var extrude = queryBooleanValue(geometryNode, 'extrude', namespaces.kml);\n        var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n        var ellipsoid = dataSource._ellipsoid;\n\n        if (angleNodes.length > 0) {\n            oneTimeWarning('kml-gx:angles', 'KML - gx:angles are not supported in gx:Tracks');\n        }\n\n        var length = Math.min(coordNodes.length, timeNodes.length);\n        var coordinates = [];\n        var times = [];\n        for (var i = 0; i < length; i++) {\n            var position = readCoordinate(coordNodes[i].textContent, ellipsoid);\n            coordinates.push(position);\n            times.push(JulianDate.fromIso8601(timeNodes[i].textContent));\n        }\n        var property = new SampledPositionProperty();\n        property.addSamples(times, coordinates);\n        entity.position = property;\n        processPositionGraphics(dataSource, entity, styleEntity, heightReferenceFromAltitudeMode(altitudeMode, gxAltitudeMode));\n        processPathGraphics(entity, styleEntity);\n\n        entity.availability = new TimeIntervalCollection();\n\n        if (timeNodes.length > 0) {\n            entity.availability.addInterval(new TimeInterval({\n                start : times[0],\n                stop : times[times.length - 1]\n            }));\n        }\n\n        if (canExtrude && extrude) {\n            createDropLine(entityCollection, entity, styleEntity);\n        }\n\n        return true;\n    }\n\n    function addToMultiTrack(times, positions, composite, availability, dropShowProperty, extrude, altitudeMode, gxAltitudeMode, includeEndPoints) {\n        var start = times[0];\n        var stop = times[times.length - 1];\n\n        var data = new SampledPositionProperty();\n        data.addSamples(times, positions);\n\n        composite.intervals.addInterval(new TimeInterval({\n            start : start,\n            stop : stop,\n            isStartIncluded : includeEndPoints,\n            isStopIncluded : includeEndPoints,\n            data : createPositionPropertyFromAltitudeMode(data, altitudeMode, gxAltitudeMode)\n        }));\n        availability.addInterval(new TimeInterval({\n            start : start,\n            stop : stop,\n            isStartIncluded : includeEndPoints,\n            isStopIncluded : includeEndPoints\n        }));\n        dropShowProperty.intervals.addInterval(new TimeInterval({\n            start : start,\n            stop : stop,\n            isStartIncluded : includeEndPoints,\n            isStopIncluded : includeEndPoints,\n            data : extrude\n        }));\n    }\n\n    function processMultiTrack(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n        // Multitrack options do not work in GE as detailed in the spec,\n        // rather than altitudeMode being at the MultiTrack level,\n        // GE just defers all settings to the underlying track.\n\n        var interpolate = queryBooleanValue(geometryNode, 'interpolate', namespaces.gx);\n        var trackNodes = queryChildNodes(geometryNode, 'Track', namespaces.gx);\n\n        var times;\n        var lastStop;\n        var lastStopPosition;\n        var needDropLine = false;\n        var dropShowProperty = new TimeIntervalCollectionProperty();\n        var availability = new TimeIntervalCollection();\n        var composite = new CompositePositionProperty();\n        var ellipsoid = dataSource._ellipsoid;\n        for (var i = 0, len = trackNodes.length; i < len; i++) {\n            var trackNode = trackNodes[i];\n            var timeNodes = queryChildNodes(trackNode, 'when', namespaces.kml);\n            var coordNodes = queryChildNodes(trackNode, 'coord', namespaces.gx);\n            var altitudeMode = queryStringValue(trackNode, 'altitudeMode', namespaces.kml);\n            var gxAltitudeMode = queryStringValue(trackNode, 'altitudeMode', namespaces.gx);\n            var canExtrude = isExtrudable(altitudeMode, gxAltitudeMode);\n            var extrude = queryBooleanValue(trackNode, 'extrude', namespaces.kml);\n\n            var length = Math.min(coordNodes.length, timeNodes.length);\n\n            var positions = [];\n            times = [];\n            for (var x = 0; x < length; x++) {\n                var position = readCoordinate(coordNodes[x].textContent, ellipsoid);\n                positions.push(position);\n                times.push(JulianDate.fromIso8601(timeNodes[x].textContent));\n            }\n\n            if (interpolate) {\n                //If we are interpolating, then we need to fill in the end of\n                //the last track and the beginning of this one with a sampled\n                //property.  From testing in Google Earth, this property\n                //is never extruded and always absolute.\n                if (defined(lastStop)) {\n                    addToMultiTrack([lastStop, times[0]], [lastStopPosition, positions[0]], composite, availability, dropShowProperty, false, 'absolute', undefined, false);\n                }\n                lastStop = times[length - 1];\n                lastStopPosition = positions[positions.length - 1];\n            }\n\n            addToMultiTrack(times, positions, composite, availability, dropShowProperty, canExtrude && extrude, altitudeMode, gxAltitudeMode, true);\n            needDropLine = needDropLine || (canExtrude && extrude);\n        }\n\n        entity.availability = availability;\n        entity.position = composite;\n        processPositionGraphics(dataSource, entity, styleEntity);\n        processPathGraphics(entity, styleEntity);\n        if (needDropLine) {\n            createDropLine(entityCollection, entity, styleEntity);\n            entity.polyline.show = dropShowProperty;\n        }\n\n        return true;\n    }\n\n    var geometryTypes = {\n        Point : processPoint,\n        LineString : processLineStringOrLinearRing,\n        LinearRing : processLineStringOrLinearRing,\n        Polygon : processPolygon,\n        Track : processTrack,\n        MultiTrack : processMultiTrack,\n        MultiGeometry : processMultiGeometry,\n        Model : processUnsupportedGeometry\n    };\n\n    function processMultiGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity, context) {\n        var childNodes = geometryNode.childNodes;\n        var hasGeometry = false;\n        for (var i = 0, len = childNodes.length; i < len; i++) {\n            var childNode = childNodes.item(i);\n            var geometryProcessor = geometryTypes[childNode.localName];\n            if (defined(geometryProcessor)) {\n                var childEntity = createEntity(childNode, entityCollection, context);\n                childEntity.parent = entity;\n                childEntity.name = entity.name;\n                childEntity.availability = entity.availability;\n                childEntity.description = entity.description;\n                childEntity.kml = entity.kml;\n                if (geometryProcessor(dataSource, entityCollection, childNode, childEntity, styleEntity)) {\n                    hasGeometry = true;\n                }\n            }\n        }\n\n        return hasGeometry;\n    }\n\n    function processUnsupportedGeometry(dataSource, entityCollection, geometryNode, entity, styleEntity) {\n        oneTimeWarning('kml-unsupportedGeometry', 'KML - Unsupported geometry: ' + geometryNode.localName);\n        return false;\n    }\n\n    function processExtendedData(node, entity) {\n        var extendedDataNode = queryFirstNode(node, 'ExtendedData', namespaces.kml);\n\n        if (!defined(extendedDataNode)) {\n            return undefined;\n        }\n\n        if (defined(queryFirstNode(extendedDataNode, 'SchemaData', namespaces.kml))) {\n            oneTimeWarning('kml-schemaData', 'KML - SchemaData is unsupported');\n        }\n        if (defined(queryStringAttribute(extendedDataNode, 'xmlns:prefix'))) {\n            oneTimeWarning('kml-extendedData', 'KML - ExtendedData with xmlns:prefix is unsupported');\n        }\n\n        var result = {};\n        var dataNodes = queryChildNodes(extendedDataNode, 'Data', namespaces.kml);\n        if (defined(dataNodes)) {\n            var length = dataNodes.length;\n            for (var i = 0; i < length; i++) {\n                var dataNode = dataNodes[i];\n                var name = queryStringAttribute(dataNode, 'name');\n                if (defined(name)) {\n                    result[name] = {\n                        displayName : queryStringValue(dataNode, 'displayName', namespaces.kml),\n                        value : queryStringValue(dataNode, 'value', namespaces.kml)\n                    };\n                }\n            }\n        }\n        entity.kml.extendedData = result;\n    }\n\n    var scratchDiv = document.createElement('div');\n\n    function processDescription(node, entity, styleEntity, uriResolver, sourceResource) {\n        var i;\n        var key;\n        var keys;\n\n        var kmlData = entity.kml;\n        var extendedData = kmlData.extendedData;\n        var description = queryStringValue(node, 'description', namespaces.kml);\n\n        var balloonStyle = defaultValue(entity.balloonStyle, styleEntity.balloonStyle);\n\n        var background = Color.WHITE;\n        var foreground = Color.BLACK;\n        var text = description;\n\n        if (defined(balloonStyle)) {\n            background = defaultValue(balloonStyle.bgColor, Color.WHITE);\n            foreground = defaultValue(balloonStyle.textColor, Color.BLACK);\n            text = defaultValue(balloonStyle.text, description);\n        }\n\n        var value;\n        if (defined(text)) {\n            text = text.replace('$[name]', defaultValue(entity.name, ''));\n            text = text.replace('$[description]', defaultValue(description, ''));\n            text = text.replace('$[address]', defaultValue(kmlData.address, ''));\n            text = text.replace('$[Snippet]', defaultValue(kmlData.snippet, ''));\n            text = text.replace('$[id]', entity.id);\n\n            //While not explicitly defined by the OGC spec, in Google Earth\n            //The appearance of geDirections adds the directions to/from links\n            //We simply replace this string with nothing.\n            text = text.replace('$[geDirections]', '');\n\n            if (defined(extendedData)) {\n                var matches = text.match(/\\$\\[.+?\\]/g);\n                if (matches !== null) {\n                    for (i = 0; i < matches.length; i++) {\n                        var token = matches[i];\n                        var propertyName = token.substr(2, token.length - 3);\n                        var isDisplayName = /\\/displayName$/.test(propertyName);\n                        propertyName = propertyName.replace(/\\/displayName$/, '');\n\n                        value = extendedData[propertyName];\n                        if (defined(value)) {\n                            value = isDisplayName ? value.displayName : value.value;\n                        }\n                        if (defined(value)) {\n                            text = text.replace(token, defaultValue(value, ''));\n                        }\n                    }\n                }\n            }\n        } else if (defined(extendedData)) {\n            //If no description exists, build a table out of the extended data\n            keys = Object.keys(extendedData);\n            if (keys.length > 0) {\n                text = '<table class=\"cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter\"><tbody>';\n                for (i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    value = extendedData[key];\n                    text += '<tr><th>' + defaultValue(value.displayName, key) + '</th><td>' + defaultValue(value.value, '') + '</td></tr>';\n                }\n                text += '</tbody></table>';\n            }\n        }\n\n        if (!defined(text)) {\n            //No description\n            return;\n        }\n\n        //Turns non-explicit links into clickable links.\n        text = autolinker.link(text);\n\n        //Use a temporary div to manipulate the links\n        //so that they open in a new window.\n        scratchDiv.innerHTML = text;\n        var links = scratchDiv.querySelectorAll('a');\n        for (i = 0; i < links.length; i++) {\n            links[i].setAttribute('target', '_blank');\n        }\n\n        //Rewrite any KMZ embedded urls\n        if (defined(uriResolver) && uriResolver.keys.length > 1) {\n            embedDataUris(scratchDiv, 'a', 'href', uriResolver);\n            embedDataUris(scratchDiv, 'img', 'src', uriResolver);\n        }\n\n        //Make relative urls absolute using the sourceResource\n        applyBasePath(scratchDiv, 'a', 'href', sourceResource);\n        applyBasePath(scratchDiv, 'img', 'src', sourceResource);\n\n        var tmp = '<div class=\"cesium-infoBox-description-lighter\" style=\"';\n        tmp += 'overflow:auto;';\n        tmp += 'word-wrap:break-word;';\n        tmp += 'background-color:' + background.toCssColorString() + ';';\n        tmp += 'color:' + foreground.toCssColorString() + ';';\n        tmp += '\">';\n        tmp += scratchDiv.innerHTML + '</div>';\n        scratchDiv.innerHTML = '';\n\n        //Set the final HTML as the description.\n        entity.description = tmp;\n    }\n\n    function processFeature(dataSource, parent, featureNode, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var entity = createEntity(featureNode, entityCollection, context);\n        var kmlData = entity.kml;\n        var styleEntity = computeFinalStyle(dataSource, featureNode, styleCollection, sourceResource, uriResolver);\n\n        var name = queryStringValue(featureNode, 'name', namespaces.kml);\n        entity.name = name;\n        entity.parent = parent;\n\n        var availability = processTimeSpan(featureNode);\n        if (!defined(availability)) {\n            availability = processTimeStamp(featureNode);\n        }\n        entity.availability = availability;\n\n        mergeAvailabilityWithParent(entity);\n\n        // Per KML spec \"A Feature is visible only if it and all its ancestors are visible.\"\n        function ancestryIsVisible(parentEntity) {\n            if (!parentEntity) {\n                return true;\n            }\n            return parentEntity.show && ancestryIsVisible(parentEntity.parent);\n        }\n\n        var visibility = queryBooleanValue(featureNode, 'visibility', namespaces.kml);\n        entity.show = ancestryIsVisible(parent) && defaultValue(visibility, true);\n        //var open = queryBooleanValue(featureNode, 'open', namespaces.kml);\n\n        var authorNode = queryFirstNode(featureNode, 'author', namespaces.atom);\n        var author = kmlData.author;\n        author.name = queryStringValue(authorNode, 'name', namespaces.atom);\n        author.uri = queryStringValue(authorNode, 'uri', namespaces.atom);\n        author.email = queryStringValue(authorNode, 'email', namespaces.atom);\n\n        var linkNode = queryFirstNode(featureNode, 'link', namespaces.atom);\n        var link = kmlData.link;\n        link.href = queryStringAttribute(linkNode, 'href');\n        link.hreflang = queryStringAttribute(linkNode, 'hreflang');\n        link.rel = queryStringAttribute(linkNode, 'rel');\n        link.type = queryStringAttribute(linkNode, 'type');\n        link.title = queryStringAttribute(linkNode, 'title');\n        link.length = queryStringAttribute(linkNode, 'length');\n\n        kmlData.address = queryStringValue(featureNode, 'address', namespaces.kml);\n        kmlData.phoneNumber = queryStringValue(featureNode, 'phoneNumber', namespaces.kml);\n        kmlData.snippet = queryStringValue(featureNode, 'Snippet', namespaces.kml);\n\n        processExtendedData(featureNode, entity);\n        processDescription(featureNode, entity, styleEntity, uriResolver, sourceResource);\n\n        var ellipsoid = dataSource._ellipsoid;\n        processLookAt(featureNode, entity, ellipsoid);\n        processCamera(featureNode, entity, ellipsoid);\n\n        if (defined(queryFirstNode(featureNode, 'Region', namespaces.kml))) {\n            oneTimeWarning('kml-region', 'KML - Placemark Regions are unsupported');\n        }\n\n        return {\n            entity : entity,\n            styleEntity : styleEntity\n        };\n    }\n\n    // Ensure Specs/Data/KML/unsupported.kml is kept up to date with these supported types\n    var featureTypes = {\n        Document : processDocument,\n        Folder : processFolder,\n        Placemark : processPlacemark,\n        NetworkLink : processNetworkLink,\n        GroundOverlay : processGroundOverlay,\n        PhotoOverlay : processUnsupportedFeature,\n        ScreenOverlay : processUnsupportedFeature,\n        Tour : processTour\n    };\n\n    function processDocument(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var featureTypeNames = Object.keys(featureTypes);\n        var featureTypeNamesLength = featureTypeNames.length;\n\n        for (var i = 0; i < featureTypeNamesLength; i++) {\n            var featureName = featureTypeNames[i];\n            var processFeatureNode = featureTypes[featureName];\n\n            var childNodes = node.childNodes;\n            var length = childNodes.length;\n            for (var q = 0; q < length; q++) {\n                var child = childNodes[q];\n                if (child.localName === featureName &&\n                    ((namespaces.kml.indexOf(child.namespaceURI) !== -1) || (namespaces.gx.indexOf(child.namespaceURI) !== -1))) {\n                    processFeatureNode(dataSource, parent, child, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n                }\n            }\n        }\n    }\n\n    function processFolder(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var r = processFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n        processDocument(dataSource, r.entity, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n    }\n\n    function processPlacemark(dataSource, parent, placemark, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var r = processFeature(dataSource, parent, placemark, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n        var entity = r.entity;\n        var styleEntity = r.styleEntity;\n\n        var hasGeometry = false;\n        var childNodes = placemark.childNodes;\n        for (var i = 0, len = childNodes.length; i < len && !hasGeometry; i++) {\n            var childNode = childNodes.item(i);\n            var geometryProcessor = geometryTypes[childNode.localName];\n            if (defined(geometryProcessor)) {\n                // pass the placemark entity id as a context for case of defining multiple child entities together to handle case\n                // where some malformed kmls reuse the same id across placemarks, which works in GE, but is not technically to spec.\n                geometryProcessor(dataSource, entityCollection, childNode, entity, styleEntity, entity.id);\n                hasGeometry = true;\n            }\n        }\n\n        if (!hasGeometry) {\n            entity.merge(styleEntity);\n            processPositionGraphics(dataSource, entity, styleEntity);\n        }\n    }\n\n    var playlistNodeProcessors = {\n        FlyTo: processTourFlyTo,\n        Wait: processTourWait,\n        SoundCue: processTourUnsupportedNode,\n        AnimatedUpdate: processTourUnsupportedNode,\n        TourControl: processTourUnsupportedNode\n    };\n\n    function processTour(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var name = queryStringValue(node, 'name', namespaces.kml);\n        var id = queryStringAttribute(node, 'id');\n        var tour = new KmlTour(name, id);\n\n        var playlistNode = queryFirstNode(node, 'Playlist', namespaces.gx);\n        if(playlistNode) {\n            var ellipsoid = dataSource._ellipsoid;\n            var childNodes = playlistNode.childNodes;\n            for(var i = 0; i < childNodes.length; i++) {\n                var entryNode = childNodes[i];\n                if (entryNode.localName) {\n                    var playlistNodeProcessor = playlistNodeProcessors[entryNode.localName];\n                    if (playlistNodeProcessor) {\n                        playlistNodeProcessor(tour, entryNode, ellipsoid);\n                    }\n                    else {\n                        console.log('Unknown KML Tour playlist entry type ' + entryNode.localName);\n                    }\n                }\n            }\n        }\n\n        if (!defined(dataSource.kmlTours)) {\n            dataSource.kmlTours = [];\n        }\n\n        dataSource.kmlTours.push(tour);\n    }\n\n    function processTourUnsupportedNode(tour, entryNode) {\n        oneTimeWarning('KML Tour unsupported node ' + entryNode.localName);\n    }\n\n    function processTourWait(tour, entryNode) {\n        var duration = queryNumericValue(entryNode, 'duration', namespaces.gx);\n        tour.addPlaylistEntry(new KmlTourWait(duration));\n    }\n\n    function processTourFlyTo(tour, entryNode, ellipsoid) {\n        var duration = queryNumericValue(entryNode, 'duration', namespaces.gx);\n        var flyToMode = queryStringValue(entryNode, 'flyToMode', namespaces.gx);\n\n        var t = {kml: {}};\n\n        processLookAt(entryNode, t, ellipsoid);\n        processCamera(entryNode, t, ellipsoid);\n\n        var view = t.kml.lookAt || t.kml.camera;\n\n        var flyto = new KmlTourFlyTo(duration, flyToMode, view);\n        tour.addPlaylistEntry(flyto);\n    }\n\n    function processCamera(featureNode, entity, ellipsoid) {\n        var camera = queryFirstNode(featureNode, 'Camera', namespaces.kml);\n        if(defined(camera)) {\n            var lon = defaultValue(queryNumericValue(camera, 'longitude', namespaces.kml), 0.0);\n            var lat = defaultValue(queryNumericValue(camera, 'latitude', namespaces.kml), 0.0);\n            var altitude = defaultValue(queryNumericValue(camera, 'altitude', namespaces.kml), 0.0);\n\n            var heading = defaultValue(queryNumericValue(camera, 'heading', namespaces.kml), 0.0);\n            var tilt = defaultValue(queryNumericValue(camera, 'tilt', namespaces.kml), 0.0);\n            var roll = defaultValue(queryNumericValue(camera, 'roll', namespaces.kml), 0.0);\n\n            var position = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n            var hpr = HeadingPitchRoll.fromDegrees(heading, tilt - 90.0, roll);\n\n            entity.kml.camera = new KmlCamera(position, hpr);\n        }\n    }\n\n    function processLookAt(featureNode, entity, ellipsoid) {\n        var lookAt = queryFirstNode(featureNode, 'LookAt', namespaces.kml);\n        if(defined(lookAt)) {\n            var lon = defaultValue(queryNumericValue(lookAt, 'longitude', namespaces.kml), 0.0);\n            var lat = defaultValue(queryNumericValue(lookAt, 'latitude', namespaces.kml), 0.0);\n            var altitude = defaultValue(queryNumericValue(lookAt, 'altitude', namespaces.kml), 0.0);\n            var heading = queryNumericValue(lookAt, 'heading', namespaces.kml);\n            var tilt = queryNumericValue(lookAt, 'tilt', namespaces.kml);\n            var range = defaultValue(queryNumericValue(lookAt, 'range', namespaces.kml), 0.0);\n\n            tilt = CesiumMath.toRadians(defaultValue(tilt, 0.0));\n            heading = CesiumMath.toRadians(defaultValue(heading, 0.0));\n\n            var hpr = new HeadingPitchRange(heading, tilt - CesiumMath.PI_OVER_TWO, range);\n            var viewPoint = Cartesian3.fromDegrees(lon, lat, altitude, ellipsoid);\n\n            entity.kml.lookAt = new KmlLookAt(viewPoint, hpr);\n        }\n    }\n\n    function processGroundOverlay(dataSource, parent, groundOverlay, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var r = processFeature(dataSource, parent, groundOverlay, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n        var entity = r.entity;\n\n        var geometry;\n        var isLatLonQuad = false;\n\n        var ellipsoid = dataSource._ellipsoid;\n        var positions = readCoordinates(queryFirstNode(groundOverlay, 'LatLonQuad', namespaces.gx), ellipsoid);\n        var zIndex = queryNumericValue(groundOverlay, 'drawOrder', namespaces.kml);\n        if (defined(positions)) {\n            geometry = createDefaultPolygon();\n            geometry.hierarchy = new PolygonHierarchy(positions);\n            geometry.zIndex = zIndex;\n            entity.polygon = geometry;\n            isLatLonQuad = true;\n        } else {\n            geometry = new RectangleGraphics();\n            geometry.zIndex = zIndex;\n            entity.rectangle = geometry;\n\n            var latLonBox = queryFirstNode(groundOverlay, 'LatLonBox', namespaces.kml);\n            if (defined(latLonBox)) {\n                var west = queryNumericValue(latLonBox, 'west', namespaces.kml);\n                var south = queryNumericValue(latLonBox, 'south', namespaces.kml);\n                var east = queryNumericValue(latLonBox, 'east', namespaces.kml);\n                var north = queryNumericValue(latLonBox, 'north', namespaces.kml);\n\n                if (defined(west)) {\n                    west = CesiumMath.negativePiToPi(CesiumMath.toRadians(west));\n                }\n                if (defined(south)) {\n                    south = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(south));\n                }\n                if (defined(east)) {\n                    east = CesiumMath.negativePiToPi(CesiumMath.toRadians(east));\n                }\n                if (defined(north)) {\n                    north = CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(north));\n                }\n                geometry.coordinates = new Rectangle(west, south, east, north);\n\n                var rotation = queryNumericValue(latLonBox, 'rotation', namespaces.kml);\n                if (defined(rotation)) {\n                    var rotationRadians = CesiumMath.toRadians(rotation);\n                    geometry.rotation = rotationRadians;\n                    geometry.stRotation = rotationRadians;\n                }\n            }\n        }\n\n        var iconNode = queryFirstNode(groundOverlay, 'Icon', namespaces.kml);\n        var href = getIconHref(iconNode, dataSource, sourceResource, uriResolver, true);\n        if (defined(href)) {\n            if (isLatLonQuad) {\n                oneTimeWarning('kml-gx:LatLonQuad', 'KML - gx:LatLonQuad Icon does not support texture projection.');\n            }\n            var x = queryNumericValue(iconNode, 'x', namespaces.gx);\n            var y = queryNumericValue(iconNode, 'y', namespaces.gx);\n            var w = queryNumericValue(iconNode, 'w', namespaces.gx);\n            var h = queryNumericValue(iconNode, 'h', namespaces.gx);\n\n            if (defined(x) || defined(y) || defined(w) || defined(h)) {\n                oneTimeWarning('kml-groundOverlay-xywh', 'KML - gx:x, gx:y, gx:w, gx:h aren\\'t supported for GroundOverlays');\n            }\n\n            geometry.material = href;\n            geometry.material.color = queryColorValue(groundOverlay, 'color', namespaces.kml);\n            geometry.material.transparent = true;\n        } else {\n            geometry.material = queryColorValue(groundOverlay, 'color', namespaces.kml);\n        }\n\n        var altitudeMode = queryStringValue(groundOverlay, 'altitudeMode', namespaces.kml);\n\n        if (defined(altitudeMode)) {\n            if (altitudeMode === 'absolute') {\n                //Use height above ellipsoid until we support MSL.\n                geometry.height = queryNumericValue(groundOverlay, 'altitude', namespaces.kml);\n                geometry.zIndex = undefined;\n            } else if (altitudeMode !== 'clampToGround') {\n                oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + altitudeMode);\n            }\n            // else just use the default of 0 until we support 'clampToGround'\n        } else {\n            altitudeMode = queryStringValue(groundOverlay, 'altitudeMode', namespaces.gx);\n            if (altitudeMode === 'relativeToSeaFloor') {\n                oneTimeWarning('kml-altitudeMode-relativeToSeaFloor', 'KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute.');\n                geometry.height = queryNumericValue(groundOverlay, 'altitude', namespaces.kml);\n                geometry.zIndex = undefined;\n            } else if (altitudeMode === 'clampToSeaFloor') {\n                oneTimeWarning('kml-altitudeMode-clampToSeaFloor', 'KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround.');\n            } else if (defined(altitudeMode)) {\n                oneTimeWarning('kml-altitudeMode-unknown', 'KML - Unknown altitudeMode: ' + altitudeMode);\n            }\n        }\n    }\n\n    function processUnsupportedFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        dataSource._unsupportedNode.raiseEvent(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver);\n        oneTimeWarning('kml-unsupportedFeature-' + node.nodeName, 'KML - Unsupported feature: ' + node.nodeName);\n    }\n\n    var RefreshMode = {\n        INTERVAL : 0,\n        EXPIRE : 1,\n        STOP : 2\n    };\n\n    function cleanupString(s) {\n        if (!defined(s) || s.length === 0) {\n            return '';\n        }\n\n        var sFirst = s[0];\n        if (sFirst === '&' || sFirst === '?') {\n            s = s.substring(1);\n        }\n\n        return s;\n    }\n\n    var zeroRectangle = new Rectangle();\n    var scratchCartographic = new Cartographic();\n    var scratchCartesian2 = new Cartesian2();\n    var scratchCartesian3 = new Cartesian3();\n\n    function processNetworkLinkQueryString(resource, camera, canvas, viewBoundScale, bbox, ellipsoid) {\n        function fixLatitude(value) {\n            if (value < -CesiumMath.PI_OVER_TWO) {\n                return -CesiumMath.PI_OVER_TWO;\n            } else if (value > CesiumMath.PI_OVER_TWO) {\n                return CesiumMath.PI_OVER_TWO;\n            }\n            return value;\n        }\n\n        function fixLongitude(value) {\n            if (value > CesiumMath.PI) {\n                return value - CesiumMath.TWO_PI;\n            } else if (value < -CesiumMath.PI) {\n                return value + CesiumMath.TWO_PI;\n            }\n\n            return value;\n        }\n\n        var queryString = objectToQuery(resource.queryParameters);\n\n        // objectToQuery escapes [ and ], so fix that\n        queryString = queryString.replace(/%5B/g, '[').replace(/%5D/g, ']');\n\n        if (defined(camera) && camera._mode !== SceneMode.MORPHING) {\n            var centerCartesian;\n            var centerCartographic;\n\n            bbox = defaultValue(bbox, zeroRectangle);\n            if (defined(canvas)) {\n                scratchCartesian2.x = canvas.clientWidth * 0.5;\n                scratchCartesian2.y = canvas.clientHeight * 0.5;\n                centerCartesian = camera.pickEllipsoid(scratchCartesian2, ellipsoid, scratchCartesian3);\n            }\n\n            if (defined(centerCartesian)) {\n                centerCartographic = ellipsoid.cartesianToCartographic(centerCartesian, scratchCartographic);\n            } else {\n                centerCartographic = Rectangle.center(bbox, scratchCartographic);\n                centerCartesian = ellipsoid.cartographicToCartesian(centerCartographic);\n            }\n\n            if (defined(viewBoundScale) && !CesiumMath.equalsEpsilon(viewBoundScale, 1.0, CesiumMath.EPSILON9)) {\n                var newHalfWidth = bbox.width * viewBoundScale * 0.5;\n                var newHalfHeight = bbox.height * viewBoundScale * 0.5;\n                bbox = new Rectangle(fixLongitude(centerCartographic.longitude - newHalfWidth),\n                    fixLatitude(centerCartographic.latitude - newHalfHeight),\n                    fixLongitude(centerCartographic.longitude + newHalfWidth),\n                    fixLatitude(centerCartographic.latitude + newHalfHeight)\n                );\n            }\n\n            queryString = queryString.replace('[bboxWest]', CesiumMath.toDegrees(bbox.west).toString());\n            queryString = queryString.replace('[bboxSouth]', CesiumMath.toDegrees(bbox.south).toString());\n            queryString = queryString.replace('[bboxEast]', CesiumMath.toDegrees(bbox.east).toString());\n            queryString = queryString.replace('[bboxNorth]', CesiumMath.toDegrees(bbox.north).toString());\n\n            var lon = CesiumMath.toDegrees(centerCartographic.longitude).toString();\n            var lat = CesiumMath.toDegrees(centerCartographic.latitude).toString();\n            queryString = queryString.replace('[lookatLon]', lon);\n            queryString = queryString.replace('[lookatLat]', lat);\n            queryString = queryString.replace('[lookatTilt]', CesiumMath.toDegrees(camera.pitch).toString());\n            queryString = queryString.replace('[lookatHeading]', CesiumMath.toDegrees(camera.heading).toString());\n            queryString = queryString.replace('[lookatRange]', Cartesian3.distance(camera.positionWC, centerCartesian));\n            queryString = queryString.replace('[lookatTerrainLon]', lon);\n            queryString = queryString.replace('[lookatTerrainLat]', lat);\n            queryString = queryString.replace('[lookatTerrainAlt]', centerCartographic.height.toString());\n\n            ellipsoid.cartesianToCartographic(camera.positionWC, scratchCartographic);\n            queryString = queryString.replace('[cameraLon]', CesiumMath.toDegrees(scratchCartographic.longitude).toString());\n            queryString = queryString.replace('[cameraLat]', CesiumMath.toDegrees(scratchCartographic.latitude).toString());\n            queryString = queryString.replace('[cameraAlt]', CesiumMath.toDegrees(scratchCartographic.height).toString());\n\n            var frustum = camera.frustum;\n            var aspectRatio = frustum.aspectRatio;\n            var horizFov = '';\n            var vertFov = '';\n            if (defined(aspectRatio)) {\n                var fov = CesiumMath.toDegrees(frustum.fov);\n                if (aspectRatio > 1.0) {\n                    horizFov = fov;\n                    vertFov = fov / aspectRatio;\n                } else {\n                    vertFov = fov;\n                    horizFov = fov * aspectRatio;\n                }\n            }\n            queryString = queryString.replace('[horizFov]', horizFov.toString());\n            queryString = queryString.replace('[vertFov]', vertFov.toString());\n        } else {\n            queryString = queryString.replace('[bboxWest]', '-180');\n            queryString = queryString.replace('[bboxSouth]', '-90');\n            queryString = queryString.replace('[bboxEast]', '180');\n            queryString = queryString.replace('[bboxNorth]', '90');\n\n            queryString = queryString.replace('[lookatLon]', '');\n            queryString = queryString.replace('[lookatLat]', '');\n            queryString = queryString.replace('[lookatRange]', '');\n            queryString = queryString.replace('[lookatTilt]', '');\n            queryString = queryString.replace('[lookatHeading]', '');\n            queryString = queryString.replace('[lookatTerrainLon]', '');\n            queryString = queryString.replace('[lookatTerrainLat]', '');\n            queryString = queryString.replace('[lookatTerrainAlt]', '');\n\n            queryString = queryString.replace('[cameraLon]', '');\n            queryString = queryString.replace('[cameraLat]', '');\n            queryString = queryString.replace('[cameraAlt]', '');\n            queryString = queryString.replace('[horizFov]', '');\n            queryString = queryString.replace('[vertFov]', '');\n        }\n\n        if (defined(canvas)) {\n            queryString = queryString.replace('[horizPixels]', canvas.clientWidth);\n            queryString = queryString.replace('[vertPixels]', canvas.clientHeight);\n        } else {\n            queryString = queryString.replace('[horizPixels]', '');\n            queryString = queryString.replace('[vertPixels]', '');\n        }\n\n        queryString = queryString.replace('[terrainEnabled]', '1');\n        queryString = queryString.replace('[clientVersion]', '1');\n        queryString = queryString.replace('[kmlVersion]', '2.2');\n        queryString = queryString.replace('[clientName]', 'Cesium');\n        queryString = queryString.replace('[language]', 'English');\n\n        resource.setQueryParameters(queryToObject(queryString));\n    }\n\n    function processNetworkLink(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var r = processFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n        var networkEntity = r.entity;\n\n        var link = queryFirstNode(node, 'Link', namespaces.kml);\n\n        if (!defined(link)) {\n            link = queryFirstNode(node, 'Url', namespaces.kml);\n        }\n        if (defined(link)) {\n            var href = queryStringValue(link, 'href', namespaces.kml);\n            var viewRefreshMode;\n            var viewBoundScale;\n            if (defined(href)) {\n                var newSourceUri = href;\n                href = resolveHref(href, sourceResource, uriResolver);\n\n                // We need to pass in the original path if resolveHref returns a data uri because the network link\n                //  references a document in a KMZ archive\n                if (/^data:/.test(href.getUrlComponent())) {\n                    // So if sourceUri isn't the kmz file, then its another kml in the archive, so resolve it\n                    if (!/\\.kmz/i.test(sourceResource.getUrlComponent())) {\n                        newSourceUri = sourceResource.getDerivedResource({\n                            url: newSourceUri\n                        });\n                    }\n                } else {\n                    newSourceUri = href.clone(); // Not a data uri so use the fully qualified uri\n                    viewRefreshMode = queryStringValue(link, 'viewRefreshMode', namespaces.kml);\n                    viewBoundScale = defaultValue(queryStringValue(link, 'viewBoundScale', namespaces.kml), 1.0);\n                    var defaultViewFormat = (viewRefreshMode === 'onStop') ? 'BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]' : '';\n                    var viewFormat = defaultValue(queryStringValue(link, 'viewFormat', namespaces.kml), defaultViewFormat);\n                    var httpQuery = queryStringValue(link, 'httpQuery', namespaces.kml);\n                    if (defined(viewFormat)) {\n                        href.setQueryParameters(queryToObject(cleanupString(viewFormat)));\n                    }\n                    if (defined(httpQuery)) {\n                        href.setQueryParameters(queryToObject(cleanupString(httpQuery)));\n                    }\n\n                    var ellipsoid = dataSource._ellipsoid;\n                    processNetworkLinkQueryString(href, dataSource._camera, dataSource._canvas, viewBoundScale, dataSource._lastCameraView.bbox, ellipsoid);\n                }\n\n                var options = {\n                    sourceUri : newSourceUri,\n                    uriResolver : uriResolver,\n                    context : networkEntity.id\n                };\n                var networkLinkCollection = new EntityCollection();\n                var promise = load(dataSource, networkLinkCollection, href, options).then(function(rootElement) {\n                    var entities = dataSource._entityCollection;\n                    var newEntities = networkLinkCollection.values;\n                    entities.suspendEvents();\n                    for (var i = 0; i < newEntities.length; i++) {\n                        var newEntity = newEntities[i];\n                        if (!defined(newEntity.parent)) {\n                            newEntity.parent = networkEntity;\n                            mergeAvailabilityWithParent(newEntity);\n                        }\n\n                        entities.add(newEntity);\n                    }\n                    entities.resumeEvents();\n\n                    // Add network links to a list if we need they will need to be updated\n                    var refreshMode = queryStringValue(link, 'refreshMode', namespaces.kml);\n                    var refreshInterval = defaultValue(queryNumericValue(link, 'refreshInterval', namespaces.kml), 0);\n                    if ((refreshMode === 'onInterval' && refreshInterval > 0 ) || (refreshMode === 'onExpire') || (viewRefreshMode === 'onStop')) {\n                        var networkLinkControl = queryFirstNode(rootElement, 'NetworkLinkControl', namespaces.kml);\n                        var hasNetworkLinkControl = defined(networkLinkControl);\n\n                        var now = JulianDate.now();\n                        var networkLinkInfo = {\n                            id : createGuid(),\n                            href : href,\n                            cookie : {},\n                            lastUpdated : now,\n                            updating : false,\n                            entity : networkEntity,\n                            viewBoundScale : viewBoundScale,\n                            needsUpdate : false,\n                            cameraUpdateTime : now\n                        };\n\n                        var minRefreshPeriod = 0;\n                        if (hasNetworkLinkControl) {\n                            networkLinkInfo.cookie = queryToObject(defaultValue(queryStringValue(networkLinkControl, 'cookie', namespaces.kml), ''));\n                            minRefreshPeriod = defaultValue(queryNumericValue(networkLinkControl, 'minRefreshPeriod', namespaces.kml), 0);\n                        }\n\n                        if (refreshMode === 'onInterval') {\n                            if (hasNetworkLinkControl) {\n                                refreshInterval = Math.max(minRefreshPeriod, refreshInterval);\n                            }\n                            networkLinkInfo.refreshMode = RefreshMode.INTERVAL;\n                            networkLinkInfo.time = refreshInterval;\n                        } else if (refreshMode === 'onExpire') {\n                            var expires;\n                            if (hasNetworkLinkControl) {\n                                expires = queryStringValue(networkLinkControl, 'expires', namespaces.kml);\n                            }\n                            if (defined(expires)) {\n                                try {\n                                    var date = JulianDate.fromIso8601(expires);\n                                    var diff = JulianDate.secondsDifference(date, now);\n                                    if (diff > 0 && diff < minRefreshPeriod) {\n                                        JulianDate.addSeconds(now, minRefreshPeriod, date);\n                                    }\n                                    networkLinkInfo.refreshMode = RefreshMode.EXPIRE;\n                                    networkLinkInfo.time = date;\n                                } catch (e) {\n                                    oneTimeWarning('kml-refreshMode-onInterval-onExpire', 'KML - NetworkLinkControl expires is not a valid date');\n                                }\n                            } else {\n                                oneTimeWarning('kml-refreshMode-onExpire', 'KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element');\n                            }\n                        } else if (dataSource._camera) { // Only allow onStop refreshes if we have a camera\n                            networkLinkInfo.refreshMode = RefreshMode.STOP;\n                            networkLinkInfo.time = defaultValue(queryNumericValue(link, 'viewRefreshTime', namespaces.kml), 0);\n                        } else {\n                            oneTimeWarning('kml-refrehMode-onStop-noCamera', 'A NetworkLink with viewRefreshMode=onStop requires a camera be passed in when creating the KmlDataSource');\n                        }\n\n                        if (defined(networkLinkInfo.refreshMode)) {\n                            dataSource._networkLinks.set(networkLinkInfo.id, networkLinkInfo);\n                        }\n                    } else if (viewRefreshMode === 'onRegion') {\n                        oneTimeWarning('kml-refrehMode-onRegion', 'KML - Unsupported viewRefreshMode: onRegion');\n                    }\n                }).otherwise(function(error) {\n                    oneTimeWarning('An error occured during loading ' + href.url);\n                    dataSource._error.raiseEvent(dataSource, error);\n                });\n\n                promises.push(promise);\n            }\n        }\n    }\n\n    function processFeatureNode(dataSource, node, parent, entityCollection, styleCollection, sourceResource, uriResolver, promises, context) {\n        var featureProcessor = featureTypes[node.localName];\n        if (defined(featureProcessor)) {\n            featureProcessor(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n        } else {\n            processUnsupportedFeature(dataSource, parent, node, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n        }\n    }\n\n    function loadKml(dataSource, entityCollection, kml, sourceResource, uriResolver, context) {\n        entityCollection.removeAll();\n\n        var promises = [];\n        var documentElement = kml.documentElement;\n        var document = documentElement.localName === 'Document' ? documentElement : queryFirstNode(documentElement, 'Document', namespaces.kml);\n        var name = queryStringValue(document, 'name', namespaces.kml);\n        if (!defined(name)) {\n            name = getFilenameFromUri(sourceResource.getUrlComponent());\n        }\n\n        // Only set the name from the root document\n        if (!defined(dataSource._name)) {\n            dataSource._name = name;\n        }\n\n        var styleCollection = new EntityCollection(dataSource);\n        return when.all(processStyles(dataSource, kml, styleCollection, sourceResource, false, uriResolver)).then(function() {\n            var element = kml.documentElement;\n            if (element.localName === 'kml') {\n                var childNodes = element.childNodes;\n                for (var i = 0; i < childNodes.length; i++) {\n                    var tmp = childNodes[i];\n                    if (defined(featureTypes[tmp.localName])) {\n                        element = tmp;\n                        break;\n                    }\n                }\n            }\n            entityCollection.suspendEvents();\n            processFeatureNode(dataSource, element, undefined, entityCollection, styleCollection, sourceResource, uriResolver, promises, context);\n            entityCollection.resumeEvents();\n\n            return when.all(promises).then(function() {\n                return kml.documentElement;\n            });\n        });\n    }\n\n    function loadKmz(dataSource, entityCollection, blob, sourceResource) {\n        var deferred = when.defer();\n        zip.createReader(new zip.BlobReader(blob), function(reader) {\n            reader.getEntries(function(entries) {\n                var promises = [];\n                var uriResolver = {};\n                var docEntry;\n                var docDefer;\n                for (var i = 0; i < entries.length; i++) {\n                    var entry = entries[i];\n                    if (!entry.directory) {\n                        var innerDefer = when.defer();\n                        promises.push(innerDefer.promise);\n                        if (/\\.kml$/i.test(entry.filename)) {\n                            // We use the first KML document we come across\n                            //  https://developers.google.com/kml/documentation/kmzarchives\n                            // Unless we come across a .kml file at the root of the archive because GE does this\n                            if (!defined(docEntry) || !/\\//i.test(entry.filename)) {\n                                if (defined(docEntry)) {\n                                    // We found one at the root so load the initial kml as a data uri\n                                    loadDataUriFromZip(docEntry, uriResolver, docDefer);\n                                }\n                                docEntry = entry;\n                                docDefer = innerDefer;\n                            } else {\n                                // Wasn't the first kml and wasn't at the root\n                                loadDataUriFromZip(entry, uriResolver, innerDefer);\n                            }\n                        } else {\n                            loadDataUriFromZip(entry, uriResolver, innerDefer);\n                        }\n                    }\n                }\n\n                // Now load the root KML document\n                if (defined(docEntry)) {\n                    loadXmlFromZip(docEntry, uriResolver, docDefer);\n                }\n                when.all(promises).then(function() {\n                    reader.close();\n                    if (!defined(uriResolver.kml)) {\n                        deferred.reject(new RuntimeError('KMZ file does not contain a KML document.'));\n                        return;\n                    }\n                    uriResolver.keys = Object.keys(uriResolver);\n                    return loadKml(dataSource, entityCollection, uriResolver.kml, sourceResource, uriResolver);\n                }).then(deferred.resolve).otherwise(deferred.reject);\n            });\n        }, function(e) {\n            deferred.reject(e);\n        });\n\n        return deferred.promise;\n    }\n\n    function load(dataSource, entityCollection, data, options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var sourceUri = options.sourceUri;\n        var uriResolver = options.uriResolver;\n        var context = options.context;\n\n        var promise = data;\n        if (typeof data === 'string' || (data instanceof Resource)) {\n            data = Resource.createIfNeeded(data);\n            promise = data.fetchBlob();\n            sourceUri = defaultValue(sourceUri, data.clone());\n        } else {\n            sourceUri = defaultValue(sourceUri, Resource.DEFAULT.clone());\n        }\n\n        sourceUri = Resource.createIfNeeded(sourceUri);\n\n        return when(promise)\n            .then(function(dataToLoad) {\n                if (dataToLoad instanceof Blob) {\n                    return isZipFile(dataToLoad).then(function(isZip) {\n                        if (isZip) {\n                            return loadKmz(dataSource, entityCollection, dataToLoad, sourceUri);\n                        }\n                        return readBlobAsText(dataToLoad).then(function(text) {\n                            //There's no official way to validate if a parse was successful.\n                            //The following check detects the error on various browsers.\n\n                            //Insert missing namespaces\n                            text = insertNamespaces(text);\n\n                            //Remove Duplicate Namespaces\n                            text = removeDuplicateNamespaces(text);\n\n                            //IE raises an exception\n                            var kml;\n                            var error;\n                            try {\n                                kml = parser.parseFromString(text, 'application/xml');\n                            } catch (e) {\n                                error = e.toString();\n                            }\n\n                            //The parse succeeds on Chrome and Firefox, but the error\n                            //handling is different in each.\n                            if (defined(error) || kml.body || kml.documentElement.tagName === 'parsererror') {\n                                //Firefox has error information as the firstChild nodeValue.\n                                var msg = defined(error) ? error : kml.documentElement.firstChild.nodeValue;\n\n                                //Chrome has it in the body text.\n                                if (!msg) {\n                                    msg = kml.body.innerText;\n                                }\n\n                                //Return the error\n                                throw new RuntimeError(msg);\n                            }\n                            return loadKml(dataSource, entityCollection, kml, sourceUri, uriResolver, context);\n                        });\n                    });\n                }\n                return loadKml(dataSource, entityCollection, dataToLoad, sourceUri, uriResolver, context);\n            })\n            .otherwise(function(error) {\n                dataSource._error.raiseEvent(dataSource, error);\n                console.log(error);\n                return when.reject(error);\n            });\n    }\n\n    /**\n     * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).\n     * <p>\n     * KML support in Cesium is incomplete, but a large amount of the standard,\n     * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue\n     * {@link https://github.com/AnalyticalGraphicsInc/cesium/issues/873|#873} for a\n     * detailed list of what is and isn't support. Cesium will also write information to the\n     * console when it encounters most unsupported features.\n     * </p>\n     * <p>\n     * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>\n     * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}\n     * under the <code>kml</code> property.\n     * </p>\n     *\n     * @alias KmlDataSource\n     * @constructor\n     *\n     * @param {Object} options An object with the following properties:\n     * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.\n     * @param {Canvas} options.canvas The canvas that is used for sending viewer properties to network links.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.\n     *\n     * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}\n     * @see {@link https://developers.google.com/kml/|Google KML Documentation}\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=KML.html|Cesium Sandcastle KML Demo}\n     *\n     * @example\n     * var viewer = new Cesium.Viewer('cesiumContainer');\n     * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',\n     *      {\n     *           camera: viewer.scene.camera,\n     *           canvas: viewer.scene.canvas\n     *      })\n     * );\n     */\n    function KmlDataSource(options) {\n        options = defaultValue(options, {});\n        var camera = options.camera;\n        var canvas = options.canvas;\n\n        \n\n        this._changed = new Event();\n        this._error = new Event();\n        this._loading = new Event();\n        this._refresh = new Event();\n        this._unsupportedNode = new Event();\n\n        this._clock = undefined;\n        this._entityCollection = new EntityCollection(this);\n        this._name = undefined;\n        this._isLoading = false;\n        this._pinBuilder = new PinBuilder();\n        this._networkLinks = new AssociativeArray();\n        this._entityCluster = new EntityCluster();\n\n        this._canvas = canvas;\n        this._camera = camera;\n        this._lastCameraView = {\n            position : defined(camera) ? Cartesian3.clone(camera.positionWC) : undefined,\n            direction : defined(camera) ? Cartesian3.clone(camera.directionWC) : undefined,\n            up : defined(camera) ? Cartesian3.clone(camera.upWC) : undefined,\n            bbox : defined(camera) ? camera.computeViewRectangle() : Rectangle.clone(Rectangle.MAX_VALUE)\n        };\n\n        this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n    }\n\n    /**\n     * Creates a Promise to a new instance loaded with the provided KML data.\n     *\n     * @param {Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n     * @param {Object} options An object with the following properties:\n     * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.\n     * @param {Canvas} options.canvas The canvas that is used for sending viewer properties to network links.\n     * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n     * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.\n     *\n     * @returns {Promise.<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.\n     */\n    KmlDataSource.load = function(data, options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var dataSource = new KmlDataSource(options);\n        return dataSource.load(data, options);\n    };\n\n    defineProperties(KmlDataSource.prototype, {\n        /**\n         * Gets or sets a human-readable name for this instance.\n         * This will be automatically be set to the KML document name on load.\n         * @memberof KmlDataSource.prototype\n         * @type {String}\n         */\n        name : {\n            get : function() {\n                return this._name;\n            },\n            set : function(value) {\n                if (this._name !== value) {\n                    this._name = value;\n                    this._changed.raiseEvent(this);\n                }\n            }\n        },\n        /**\n         * Gets the clock settings defined by the loaded KML. This represents the total\n         * availability interval for all time-dynamic data. If the KML does not contain\n         * time-dynamic data, this value is undefined.\n         * @memberof KmlDataSource.prototype\n         * @type {DataSourceClock}\n         */\n        clock : {\n            get : function() {\n                return this._clock;\n            }\n        },\n        /**\n         * Gets the collection of {@link Entity} instances.\n         * @memberof KmlDataSource.prototype\n         * @type {EntityCollection}\n         */\n        entities : {\n            get : function() {\n                return this._entityCollection;\n            }\n        },\n        /**\n         * Gets a value indicating if the data source is currently loading data.\n         * @memberof KmlDataSource.prototype\n         * @type {Boolean}\n         */\n        isLoading : {\n            get : function() {\n                return this._isLoading;\n            }\n        },\n        /**\n         * Gets an event that will be raised when the underlying data changes.\n         * @memberof KmlDataSource.prototype\n         * @type {Event}\n         */\n        changedEvent : {\n            get : function() {\n                return this._changed;\n            }\n        },\n        /**\n         * Gets an event that will be raised if an error is encountered during processing.\n         * @memberof KmlDataSource.prototype\n         * @type {Event}\n         */\n        errorEvent : {\n            get : function() {\n                return this._error;\n            }\n        },\n        /**\n         * Gets an event that will be raised when the data source either starts or stops loading.\n         * @memberof KmlDataSource.prototype\n         * @type {Event}\n         */\n        loadingEvent : {\n            get : function() {\n                return this._loading;\n            }\n        },\n        /**\n         * Gets an event that will be raised when the data source refreshes a network link.\n         * @memberof KmlDataSource.prototype\n         * @type {Event}\n         */\n        refreshEvent : {\n            get : function() {\n                return this._refresh;\n            }\n        },\n        /**\n         * Gets an event that will be raised when the data source finds an unsupported node type.\n         * @memberof KmlDataSource.prototype\n         * @type {Event}\n         */\n        unsupportedNodeEvent : {\n            get : function() {\n                return this._unsupportedNode;\n            }\n        },\n        /**\n         * Gets whether or not this data source should be displayed.\n         * @memberof KmlDataSource.prototype\n         * @type {Boolean}\n         */\n        show : {\n            get : function() {\n                return this._entityCollection.show;\n            },\n            set : function(value) {\n                this._entityCollection.show = value;\n            }\n        },\n\n        /**\n         * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n         *\n         * @memberof KmlDataSource.prototype\n         * @type {EntityCluster}\n         */\n        clustering : {\n            get : function() {\n                return this._entityCluster;\n            },\n            set : function(value) {\n                \n                this._entityCluster = value;\n            }\n        }\n    });\n\n    /**\n     * Asynchronously loads the provided KML data, replacing any existing data.\n     *\n     * @param {Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.\n     * @param {Object} [options] An object with the following properties:\n     * @param {Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.\n     * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground. If true, lines will use corridors so use Entity.corridor instead of Entity.polyline.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.\n     *\n     * @returns {Promise.<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.\n     */\n    KmlDataSource.prototype.load = function(data, options) {\n        \n\n        options = defaultValue(options, {});\n        DataSource.setLoading(this, true);\n\n        var oldName = this._name;\n        this._name = undefined;\n        this._clampToGround = defaultValue(options.clampToGround, false);\n\n        var that = this;\n        return load(this, this._entityCollection, data, options).then(function() {\n            var clock;\n\n            var availability = that._entityCollection.computeAvailability();\n\n            var start = availability.start;\n            var stop = availability.stop;\n            var isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n            var isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n            if (!isMinStart || !isMaxStop) {\n                var date;\n\n                //If start is min time just start at midnight this morning, local time\n                if (isMinStart) {\n                    date = new Date();\n                    date.setHours(0, 0, 0, 0);\n                    start = JulianDate.fromDate(date);\n                }\n\n                //If stop is max value just stop at midnight tonight, local time\n                if (isMaxStop) {\n                    date = new Date();\n                    date.setHours(24, 0, 0, 0);\n                    stop = JulianDate.fromDate(date);\n                }\n\n                clock = new DataSourceClock();\n                clock.startTime = start;\n                clock.stopTime = stop;\n                clock.currentTime = JulianDate.clone(start);\n                clock.clockRange = ClockRange.LOOP_STOP;\n                clock.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER;\n                clock.multiplier = Math.round(Math.min(Math.max(JulianDate.secondsDifference(stop, start) / 60, 1), 3.15569e7));\n            }\n\n            var changed = false;\n            if (clock !== that._clock) {\n                that._clock = clock;\n                changed = true;\n            }\n\n            if (oldName !== that._name) {\n                changed = true;\n            }\n\n            if (changed) {\n                that._changed.raiseEvent(that);\n            }\n\n            DataSource.setLoading(that, false);\n\n            return that;\n        }).otherwise(function(error) {\n            DataSource.setLoading(that, false);\n            that._error.raiseEvent(that, error);\n            console.log(error);\n            return when.reject(error);\n        });\n    };\n\n    function mergeAvailabilityWithParent(child) {\n        var parent = child.parent;\n        if (defined(parent)) {\n            var parentAvailability = parent.availability;\n            if (defined(parentAvailability)) {\n                var childAvailability = child.availability;\n                if (defined(childAvailability)) {\n                    childAvailability.intersect(parentAvailability);\n                } else {\n                    child.availability = parentAvailability;\n                }\n            }\n        }\n    }\n\n    function getNetworkLinkUpdateCallback(dataSource, networkLink, newEntityCollection, networkLinks, processedHref) {\n        return function(rootElement) {\n            if (!networkLinks.contains(networkLink.id)) {\n                // Got into the odd case where a parent network link was updated while a child\n                //  network link update was in flight, so just throw it away.\n                return;\n            }\n            var remove = false;\n            var networkLinkControl = queryFirstNode(rootElement, 'NetworkLinkControl', namespaces.kml);\n            var hasNetworkLinkControl = defined(networkLinkControl);\n\n            var minRefreshPeriod = 0;\n            if (hasNetworkLinkControl) {\n                if (defined(queryFirstNode(networkLinkControl, 'Update', namespaces.kml))) {\n                    oneTimeWarning('kml-networkLinkControl-update', 'KML - NetworkLinkControl updates aren\\'t supported.');\n                    networkLink.updating = false;\n                    networkLinks.remove(networkLink.id);\n                    return;\n                }\n                networkLink.cookie = queryToObject(defaultValue(queryStringValue(networkLinkControl, 'cookie', namespaces.kml), ''));\n                minRefreshPeriod = defaultValue(queryNumericValue(networkLinkControl, 'minRefreshPeriod', namespaces.kml), 0);\n            }\n\n            var now = JulianDate.now();\n            var refreshMode = networkLink.refreshMode;\n            if (refreshMode === RefreshMode.INTERVAL) {\n                if (defined(networkLinkControl)) {\n                    networkLink.time = Math.max(minRefreshPeriod, networkLink.time);\n                }\n            } else if (refreshMode === RefreshMode.EXPIRE) {\n                var expires;\n                if (defined(networkLinkControl)) {\n                    expires = queryStringValue(networkLinkControl, 'expires', namespaces.kml);\n                }\n                if (defined(expires)) {\n                    try {\n                        var date = JulianDate.fromIso8601(expires);\n                        var diff = JulianDate.secondsDifference(date, now);\n                        if (diff > 0 && diff < minRefreshPeriod) {\n                            JulianDate.addSeconds(now, minRefreshPeriod, date);\n                        }\n                        networkLink.time = date;\n                    } catch (e) {\n                        oneTimeWarning('kml-networkLinkControl-expires', 'KML - NetworkLinkControl expires is not a valid date');\n                        remove = true;\n                    }\n                } else {\n                    oneTimeWarning('kml-refreshMode-onExpire', 'KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element');\n                    remove = true;\n                }\n            }\n\n            var networkLinkEntity = networkLink.entity;\n            var entityCollection = dataSource._entityCollection;\n            var newEntities = newEntityCollection.values;\n\n            function removeChildren(entity) {\n                entityCollection.remove(entity);\n                var children = entity._children;\n                var count = children.length;\n                for (var i = 0; i < count; ++i) {\n                    removeChildren(children[i]);\n                }\n            }\n\n            // Remove old entities\n            entityCollection.suspendEvents();\n            var entitiesCopy = entityCollection.values.slice();\n            var i;\n            for (i = 0; i < entitiesCopy.length; ++i) {\n                var entityToRemove = entitiesCopy[i];\n                if (entityToRemove.parent === networkLinkEntity) {\n                    entityToRemove.parent = undefined;\n                    removeChildren(entityToRemove);\n                }\n            }\n            entityCollection.resumeEvents();\n\n            // Add new entities\n            entityCollection.suspendEvents();\n            for (i = 0; i < newEntities.length; i++) {\n                var newEntity = newEntities[i];\n                if (!defined(newEntity.parent)) {\n                    newEntity.parent = networkLinkEntity;\n                    mergeAvailabilityWithParent(newEntity);\n                }\n                entityCollection.add(newEntity);\n            }\n            entityCollection.resumeEvents();\n\n            // No refresh information remove it, otherwise update lastUpdate time\n            if (remove) {\n                networkLinks.remove(networkLink.id);\n            } else {\n                networkLink.lastUpdated = now;\n            }\n\n            var availability = entityCollection.computeAvailability();\n\n            var start = availability.start;\n            var stop = availability.stop;\n            var isMinStart = JulianDate.equals(start, Iso8601.MINIMUM_VALUE);\n            var isMaxStop = JulianDate.equals(stop, Iso8601.MAXIMUM_VALUE);\n            if (!isMinStart || !isMaxStop) {\n                var clock = dataSource._clock;\n\n                if (clock.startTime !== start || clock.stopTime !== stop) {\n                    clock.startTime = start;\n                    clock.stopTime = stop;\n                    dataSource._changed.raiseEvent(dataSource);\n                }\n            }\n\n            networkLink.updating = false;\n            networkLink.needsUpdate = false;\n            dataSource._refresh.raiseEvent(dataSource, processedHref.getUrlComponent(true));\n        };\n    }\n\n    var entitiesToIgnore = new AssociativeArray();\n\n    /**\n     * Updates any NetworkLink that require updating\n     * @function\n     *\n     * @param {JulianDate} time The simulation time.\n     * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n     */\n    KmlDataSource.prototype.update = function(time) {\n        var networkLinks = this._networkLinks;\n        if (networkLinks.length === 0) {\n            return true;\n        }\n\n        var now = JulianDate.now();\n        var that = this;\n\n        entitiesToIgnore.removeAll();\n\n        function recurseIgnoreEntities(entity) {\n            var children = entity._children;\n            var count = children.length;\n            for (var i = 0; i < count; ++i) {\n                var child = children[i];\n                entitiesToIgnore.set(child.id, child);\n                recurseIgnoreEntities(child);\n            }\n        }\n\n        var cameraViewUpdate = false;\n        var lastCameraView = this._lastCameraView;\n        var camera = this._camera;\n        if (defined(camera) &&\n            !(camera.positionWC.equalsEpsilon(lastCameraView.position, CesiumMath.EPSILON7) &&\n            camera.directionWC.equalsEpsilon(lastCameraView.direction, CesiumMath.EPSILON7) &&\n            camera.upWC.equalsEpsilon(lastCameraView.up, CesiumMath.EPSILON7))) {\n\n            // Camera has changed so update the last view\n            lastCameraView.position = Cartesian3.clone(camera.positionWC);\n            lastCameraView.direction = Cartesian3.clone(camera.directionWC);\n            lastCameraView.up = Cartesian3.clone(camera.upWC);\n            lastCameraView.bbox = camera.computeViewRectangle();\n            cameraViewUpdate = true;\n        }\n\n        var newNetworkLinks = new AssociativeArray();\n        var changed = false;\n        networkLinks.values.forEach(function(networkLink) {\n            var entity = networkLink.entity;\n            if (entitiesToIgnore.contains(entity.id)) {\n                return;\n            }\n\n            if (!networkLink.updating) {\n                var doUpdate = false;\n                if (networkLink.refreshMode === RefreshMode.INTERVAL) {\n                    if (JulianDate.secondsDifference(now, networkLink.lastUpdated) > networkLink.time) {\n                        doUpdate = true;\n                    }\n                }\n                else if (networkLink.refreshMode === RefreshMode.EXPIRE) {\n                    if (JulianDate.greaterThan(now, networkLink.time)) {\n                        doUpdate = true;\n                    }\n\n                } else if (networkLink.refreshMode === RefreshMode.STOP) {\n                    if (cameraViewUpdate) {\n                        networkLink.needsUpdate = true;\n                        networkLink.cameraUpdateTime = now;\n                    }\n\n                    if (networkLink.needsUpdate && JulianDate.secondsDifference(now, networkLink.cameraUpdateTime) >= networkLink.time) {\n                        doUpdate = true;\n                    }\n                }\n\n                if (doUpdate) {\n                    recurseIgnoreEntities(entity);\n                    networkLink.updating = true;\n                    var newEntityCollection = new EntityCollection();\n                    var href = networkLink.href.clone();\n\n                    href.setQueryParameters(networkLink.cookie);\n                    var ellipsoid = defaultValue(that._ellipsoid, Ellipsoid.WGS84);\n                    processNetworkLinkQueryString(href, that._camera, that._canvas, networkLink.viewBoundScale, lastCameraView.bbox, ellipsoid);\n\n                    load(that, newEntityCollection, href, {context : entity.id})\n                        .then(getNetworkLinkUpdateCallback(that, networkLink, newEntityCollection, newNetworkLinks, href))\n                        .otherwise(function(error) {\n                            var msg = 'NetworkLink ' + networkLink.href + ' refresh failed: ' + error;\n                            console.log(msg);\n                            that._error.raiseEvent(that, msg);\n                        });\n                    changed = true;\n                }\n            }\n            newNetworkLinks.set(networkLink.id, networkLink);\n        });\n\n        if (changed) {\n            this._networkLinks = newNetworkLinks;\n            this._changed.raiseEvent(this);\n        }\n\n        return true;\n    };\n\n    /**\n     * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.\n     * @alias KmlFeatureData\n     * @constructor\n     */\n    function KmlFeatureData() {\n        /**\n         * Gets the atom syndication format author field.\n         * @type Object\n         */\n        this.author = {\n            /**\n             * Gets the name.\n             * @type String\n             * @alias author.name\n             * @memberof! KmlFeatureData#\n             * @property author.name\n             */\n            name : undefined,\n            /**\n             * Gets the URI.\n             * @type String\n             * @alias author.uri\n             * @memberof! KmlFeatureData#\n             * @property author.uri\n             */\n            uri : undefined,\n            /**\n             * Gets the email.\n             * @type String\n             * @alias author.email\n             * @memberof! KmlFeatureData#\n             * @property author.email\n             */\n            email : undefined\n        };\n\n        /**\n         * Gets the link.\n         * @type Object\n         */\n        this.link = {\n            /**\n             * Gets the href.\n             * @type String\n             * @alias link.href\n             * @memberof! KmlFeatureData#\n             * @property link.href\n             */\n            href : undefined,\n            /**\n             * Gets the language of the linked resource.\n             * @type String\n             * @alias link.hreflang\n             * @memberof! KmlFeatureData#\n             * @property link.hreflang\n             */\n            hreflang : undefined,\n            /**\n             * Gets the link relation.\n             * @type String\n             * @alias link.rel\n             * @memberof! KmlFeatureData#\n             * @property link.rel\n             */\n            rel : undefined,\n            /**\n             * Gets the link type.\n             * @type String\n             * @alias link.type\n             * @memberof! KmlFeatureData#\n             * @property link.type\n             */\n            type : undefined,\n            /**\n             * Gets the link title.\n             * @type String\n             * @alias link.title\n             * @memberof! KmlFeatureData#\n             * @property link.title\n             */\n            title : undefined,\n            /**\n             * Gets the link length.\n             * @type String\n             * @alias link.length\n             * @memberof! KmlFeatureData#\n             * @property link.length\n             */\n            length : undefined\n        };\n\n        /**\n         * Gets the unstructured address field.\n         * @type String\n         */\n        this.address = undefined;\n        /**\n         * Gets the phone number.\n         * @type String\n         */\n        this.phoneNumber = undefined;\n        /**\n         * Gets the snippet.\n         * @type String\n         */\n        this.snippet = undefined;\n        /**\n         * Gets the extended data, parsed into a JSON object.\n         * Currently only the <code>Data</code> property is supported.\n         * <code>SchemaData</code> and custom data are ignored.\n         * @type String\n         */\n        this.extendedData = undefined;\n    }\n\n    return KmlDataSource;\n});\n","define([], function() {\n    'use strict';\n    /**\n     * @alias KmlLookAt\n     * @constructor\n     *\n     * @param {Cartesian3} position camera position\n     * @param {HeadingPitchRange} headingPitchRange camera orientation\n     */\n    function KmlLookAt(position, headingPitchRange) {\n        this.position = position;\n        this.headingPitchRange = headingPitchRange;\n    }\n\n    return KmlLookAt;\n});\n","define([\n        '../Core/defined',\n        '../Core/Event'\n    ], function(\n        defined,\n        Event) {\n    'use strict';\n    /**\n     * @alias KmlTour\n     * @constructor\n     *\n     * @param {String} name name parsed from KML\n     * @param {String} id id parsed from KML\n     * @param {Array} playlist array with KMLTourFlyTos, KMLTourWaits and KMLTourSoundCues\n     */\n    function KmlTour(name, id) {\n        /**\n         * Id of kml gx:Tour entry\n         * @type String\n         */\n        this.id = id;\n        /**\n         * Tour name\n         * @type String\n         */\n        this.name = name;\n        /**\n         * Index of current entry from playlist\n         * @type Number\n         */\n        this.playlistIndex = 0;\n        /**\n         * Array of playlist entries\n         * @type Array\n         */\n        this.playlist = [];\n        /**\n         * Event will be called when tour starts to play,\n         * before any playlist entry starts to play.\n         * @type Event\n         */\n        this.tourStart = new Event();\n        /**\n         * Event will be called when all playlist entries are\n         * played, or tour playback being canceled.\n         *\n         * If tour playback was terminated, event callback will\n         * be called with terminated=true parameter.\n         * @type Event\n         */\n        this.tourEnd = new Event();\n        /**\n         * Event will be called when entry from playlist starts to play.\n         *\n         * Event callback will be called with curent entry as first parameter.\n         * @type Event\n         */\n        this.entryStart = new Event();\n        /**\n         * Event will be called when entry from playlist ends to play.\n         *\n         * Event callback will be called with following parameters:\n         * 1. entry - entry\n         * 2. terminated - true if playback was terminated by calling {@link KmlTour#stop}\n         * @type Event\n         */\n        this.entryEnd = new Event();\n\n        this._activeEntries = [];\n    }\n\n    /**\n     * Add entry to this tour playlist.\n     *\n     * @param {KmlTourFlyTo|KmlTourWait} entry an entry to add to the playlist.\n     */\n    KmlTour.prototype.addPlaylistEntry = function(entry) {\n        this.playlist.push(entry);\n    };\n\n    /**\n     * Play this tour.\n     *\n     * @param {Viewer} viewer viewer widget.\n     * @param {Object} [cameraOptions] these options will be merged with {@link Camera#flyTo}\n     * options for FlyTo playlist entries.\n     */\n    KmlTour.prototype.play = function(viewer, cameraOptions) {\n        this.tourStart.raiseEvent();\n\n        var tour = this;\n        playEntry.call(this, viewer, cameraOptions, function(terminated) {\n            tour.playlistIndex = 0;\n            // Stop nonblocking entries\n            if (!terminated) {\n                cancelAllEntries(tour._activeEntries);\n            }\n            tour.tourEnd.raiseEvent(terminated);\n        });\n    };\n\n    /**\n     * Stop curently playing tour.\n     */\n    KmlTour.prototype.stop = function() {\n        cancelAllEntries(this._activeEntries);\n    };\n\n    // Stop all activeEntries.\n    function cancelAllEntries(activeEntries) {\n        for(var entry = activeEntries.pop(); entry !== undefined; entry = activeEntries.pop()) {\n            entry.stop();\n        }\n    }\n\n    // Play playlist entry.\n    // This function is called recursevly with playNext and iterates over all entries from playlist.\n    function playEntry(viewer, cameraOptions, allDone) {\n        var entry = this.playlist[this.playlistIndex];\n        if (entry) {\n            var _playNext = playNext.bind(this, viewer, cameraOptions, allDone);\n            this._activeEntries.push(entry);\n            this.entryStart.raiseEvent(entry);\n            if (entry.blocking) {\n                entry.play(_playNext, viewer.scene.camera, cameraOptions);\n            }\n            else {\n                var tour = this;\n                entry.play(function() {\n                    tour.entryEnd.raiseEvent(entry);\n                    var indx = tour._activeEntries.indexOf(entry);\n                    if (indx >= 0) {\n                        tour._activeEntries.splice(indx, 1);\n                    }\n                });\n                _playNext(viewer, cameraOptions, allDone);\n            }\n        }\n        else if(defined(allDone)) {\n            allDone(false);\n        }\n    }\n\n    // Increment playlistIndex and call playEntry if terminated isn't true.\n    function playNext(viewer, cameraOptions, allDone, terminated) {\n        var entry = this.playlist[this.playlistIndex];\n        this.entryEnd.raiseEvent(entry, terminated);\n\n        if (terminated) {\n            allDone(terminated);\n        }\n        else {\n            var indx = this._activeEntries.indexOf(entry);\n            if (indx >= 0) {\n                this._activeEntries.splice(indx, 1);\n            }\n            this.playlistIndex++;\n            playEntry.call(this, viewer, cameraOptions, allDone);\n        }\n    }\n\n    return KmlTour;\n});\n","define([\n        '../Core/BoundingSphere',\n        '../Core/combine',\n        '../Core/defined',\n        '../Core/EasingFunction'\n    ], function(\n        BoundingSphere,\n        combine,\n        defined,\n        EasingFunction) {\n    'use strict';\n    /**\n     * @alias KmlTourFlyTo\n     * @constructor\n     *\n     * @param {Number} duration entry duration\n     * @param {String} flyToMode KML fly to mode: bounce, smooth, etc\n     * @param {KmlCamera|KmlLookAt} view KmlCamera or KmlLookAt\n     */\n    function KmlTourFlyTo(duration, flyToMode, view) {\n        this.type = 'KmlTourFlyTo';\n        this.blocking = true;\n        this.activeCamera = null;\n        this.activeCallback = null;\n\n        this.duration = duration;\n        this.view = view;\n        this.flyToMode = flyToMode;\n    }\n\n    /**\n     * Play this playlist entry\n     *\n     * @param {KmlTourFlyTo~DoneCallback} done function which will be called when playback ends\n     * @param {Camera} camera Cesium camera\n     * @param {Object} [cameraOptions] which will be merged with camera flyTo options. See {@link Camera#flyTo}\n     */\n    KmlTourFlyTo.prototype.play = function(done, camera, cameraOptions) {\n        this.activeCamera = camera;\n        if (defined(done) && done !== null) {\n            var self = this;\n            this.activeCallback = function(terminated) {\n                delete self.activeCallback;\n                delete self.activeCamera;\n                done(defined(terminated) ? false : terminated);\n            };\n        }\n\n        var options = this.getCameraOptions(cameraOptions);\n        if (this.view.headingPitchRoll) {\n            camera.flyTo(options);\n        }\n        else if (this.view.headingPitchRange) {\n            var target = new BoundingSphere(this.view.position);\n            camera.flyToBoundingSphere(target, options);\n        }\n    };\n\n    /**\n     * Stop execution of curent entry. Cancel camera flyTo\n     */\n    KmlTourFlyTo.prototype.stop = function() {\n        if (defined(this.activeCamera)) {\n            this.activeCamera.cancelFlight();\n        }\n        if (defined(this.activeCallback)) {\n            this.activeCallback(true);\n        }\n    };\n\n    /**\n     * Returns options for {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere}\n     * depends on this.view type.\n     *\n     * @param {Object} cameraOptions options to merge with generated. See {@link Camera#flyTo}\n     * @returns {Object} {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere} options\n     */\n    KmlTourFlyTo.prototype.getCameraOptions = function(cameraOptions) {\n        var options = {\n            duration: this.duration\n        };\n\n        if (defined(this.activeCallback)) {\n            options.complete = this.activeCallback;\n        }\n\n        if (this.flyToMode === 'smooth' ) {\n            options.easingFunction = EasingFunction.LINEAR_NONE;\n        }\n\n        if (this.view.headingPitchRoll) {\n            options.destination = this.view.position;\n            options.orientation = this.view.headingPitchRoll;\n        }\n        else if (this.view.headingPitchRange) {\n            options.offset = this.view.headingPitchRange;\n        }\n\n        if (defined(cameraOptions)) {\n            options = combine(options, cameraOptions);\n        }\n        return options;\n    };\n\n    /**\n     * A function that will be executed when the flight completes.\n     * @callback KmlTourFlyTo~DoneCallback\n     *\n     * @param {Boolean} terminated true if {@link KmlTourFlyTo#stop} was\n     * called before entry done playback.\n     */\n\n    return KmlTourFlyTo;\n});\n","define([\n        '../Core/defined'\n    ], function(\n        defined) {\n    'use strict';\n    /**\n     * @alias KmlTourWait\n     * @constructor\n     *\n     * @param {Number} duration entry duration\n     */\n    function KmlTourWait(duration) {\n        this.type = 'KmlTourWait';\n        this.blocking = true;\n        this.duration = duration;\n\n        this.timeout = null;\n    }\n\n    /**\n     * Play this playlist entry\n     *\n     * @param {KmlTourWait~DoneCallback} done function which will be called when playback ends\n     */\n    KmlTourWait.prototype.play = function(done) {\n        var self = this;\n        this.activeCallback = done;\n        this.timeout = setTimeout(function() {\n            delete self.activeCallback;\n            done(false);\n        }, this.duration * 1000);\n    };\n\n    /**\n     * Stop execution of curent entry, cancel curent timeout\n     */\n    KmlTourWait.prototype.stop = function() {\n        clearTimeout(this.timeout);\n        if (defined(this.activeCallback)) {\n            this.activeCallback(true);\n        }\n    };\n\n    /**\n     * A function which will be called when playback ends.\n     *\n     * @callback KmlTourWait~DoneCallback\n     * @param {Boolean} terminated true if {@link KmlTourWait#stop} was\n     * called before entry done playback.\n     */\n\n    return KmlTourWait;\n});\n","define([\n        '../Core/Color',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Event',\n        './createPropertyDescriptor',\n        './Property'\n    ], function(\n        Color,\n        defined,\n        defineProperties,\n        Event,\n        createPropertyDescriptor,\n        Property) {\n    'use strict';\n\n    /**\n     * A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.\n     *\n     * @param {Property} [color=Color.WHITE] The {@link Color} Property to be used.\n     *\n     * @alias PolylineArrowMaterialProperty\n     * @constructor\n     */\n    function PolylineArrowMaterialProperty(color) {\n        this._definitionChanged = new Event();\n        this._color = undefined;\n        this._colorSubscription = undefined;\n\n        this.color = color;\n    }\n\n    defineProperties(PolylineArrowMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof PolylineArrowMaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._color);\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof PolylineArrowMaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets or sets the {@link Color} {@link Property}.\n         * @memberof PolylineArrowMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.WHITE\n         */\n        color : createPropertyDescriptor('color')\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    PolylineArrowMaterialProperty.prototype.getType = function(time) {\n        return 'PolylineArrow';\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    PolylineArrowMaterialProperty.prototype.getValue = function(time, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n        result.color = Property.getValueOrClonedDefault(this._color, time, Color.WHITE, result.color);\n        return result;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    PolylineArrowMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof PolylineArrowMaterialProperty && //\n                Property.equals(this._color, other._color));\n    };\n\n    return PolylineArrowMaterialProperty;\n});\n","define([\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Event',\n        './createPropertyDescriptor',\n        './Property'\n    ], function(\n        Color,\n        defaultValue,\n        defined,\n        defineProperties,\n        Event,\n        createPropertyDescriptor,\n        Property) {\n    'use strict';\n\n    var defaultColor = Color.WHITE;\n    var defaultGapColor = Color.TRANSPARENT;\n    var defaultDashLength = 16.0;\n    var defaultDashPattern = 255.0;\n\n    /**\n     * A {@link MaterialProperty} that maps to polyline dash {@link Material} uniforms.\n     * @alias PolylineDashMaterialProperty\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.\n     * @param {Property} [options.gapColor=Color.TRANSPARENT] A Property specifying the {@link Color} of the gaps in the line.\n     * @param {Property} [options.dashLength=16.0] A numeric Property specifying the length of the dash pattern in pixel.s\n     * @param {Property} [options.dashPattern=255.0] A numeric Property specifying a 16 bit pattern for the dash\n     */\n    function PolylineDashMaterialProperty(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._definitionChanged = new Event();\n        this._color = undefined;\n        this._colorSubscription = undefined;\n        this._gapColor = undefined;\n        this._gapColorSubscription = undefined;\n        this._dashLength = undefined;\n        this._dashLengthSubscription = undefined;\n        this._dashPattern = undefined;\n        this._dashPatternSubscription = undefined;\n\n        this.color = options.color;\n        this.gapColor = options.gapColor;\n        this.dashLength = options.dashLength;\n        this.dashPattern = options.dashPattern;\n    }\n\n    defineProperties(PolylineDashMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof PolylineDashMaterialProperty.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return (Property.isConstant(this._color) &&\n                        Property.isConstant(this._gapColor) &&\n                        Property.isConstant(this._dashLength) &&\n                        Property.isConstant(this._dashPattern));\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof PolylineDashMaterialProperty.prototype\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets or sets the Property specifying the {@link Color} of the line.\n         * @memberof PolylineDashMaterialProperty.prototype\n         * @type {Property}\n         */\n        color : createPropertyDescriptor('color'),\n\n        /**\n         * Gets or sets the Property specifying the {@link Color} of the gaps in the line.\n         * @memberof PolylineDashMaterialProperty.prototype\n         * @type {Property}\n         */\n        gapColor : createPropertyDescriptor('gapColor'),\n\n        /**\n         * Gets or sets the numeric Property specifying the length of a dash cycle\n         * @memberof PolylineDashMaterialProperty.prototype\n         * @type {Property}\n         */\n        dashLength : createPropertyDescriptor('dashLength'),\n\n        /**\n         * Gets or sets the numeric Property specifying a dash pattern\n         * @memberof PolylineDashMaterialProperty.prototype\n         * @type {Property}\n         */\n        dashPattern : createPropertyDescriptor('dashPattern')\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    PolylineDashMaterialProperty.prototype.getType = function(time) {\n        return 'PolylineDash';\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    PolylineDashMaterialProperty.prototype.getValue = function(time, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);\n        result.gapColor = Property.getValueOrClonedDefault(this._gapColor, time, defaultGapColor, result.gapColor);\n        result.dashLength = Property.getValueOrDefault(this._dashLength, time, defaultDashLength, result.dashLength);\n        result.dashPattern = Property.getValueOrDefault(this._dashPattern, time, defaultDashPattern, result.dashPattern);\n        return result;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    PolylineDashMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof PolylineDashMaterialProperty &&\n                Property.equals(this._color, other._color) &&\n                Property.equals(this._gapColor, other._gapColor) &&\n                Property.equals(this._dashLength, other._dashLength) &&\n                Property.equals(this._dashPattern, other._dashPattern));\n    };\n\n    return PolylineDashMaterialProperty;\n});\n","define([\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Event',\n        './createPropertyDescriptor',\n        './Property'\n    ], function(\n        Color,\n        defaultValue,\n        defined,\n        defineProperties,\n        Event,\n        createPropertyDescriptor,\n        Property) {\n    'use strict';\n\n    var defaultColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 1.0;\n\n    /**\n     * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.\n     * @alias PolylineOutlineMaterialProperty\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.\n     * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.\n     * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline, in pixels.\n     */\n    function PolylineOutlineMaterialProperty(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._definitionChanged = new Event();\n        this._color = undefined;\n        this._colorSubscription = undefined;\n        this._outlineColor = undefined;\n        this._outlineColorSubscription = undefined;\n        this._outlineWidth = undefined;\n        this._outlineWidthSubscription = undefined;\n\n        this.color = options.color;\n        this.outlineColor = options.outlineColor;\n        this.outlineWidth = options.outlineWidth;\n    }\n\n    defineProperties(PolylineOutlineMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof PolylineOutlineMaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._color) && Property.isConstant(this._outlineColor) && Property.isConstant(this._outlineWidth);\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof PolylineOutlineMaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets or sets the Property specifying the {@link Color} of the line.\n         * @memberof PolylineOutlineMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.WHITE\n         */\n        color : createPropertyDescriptor('color'),\n\n        /**\n         * Gets or sets the Property specifying the {@link Color} of the outline.\n         * @memberof PolylineOutlineMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.BLACK\n         */\n        outlineColor : createPropertyDescriptor('outlineColor'),\n\n        /**\n         * Gets or sets the numeric Property specifying the width of the outline.\n         * @memberof PolylineOutlineMaterialProperty.prototype\n         * @type {Property}\n         * @default 1.0\n         */\n        outlineWidth : createPropertyDescriptor('outlineWidth')\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    PolylineOutlineMaterialProperty.prototype.getType = function(time) {\n        return 'PolylineOutline';\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    PolylineOutlineMaterialProperty.prototype.getValue = function(time, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n        result.color = Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);\n        result.outlineColor = Property.getValueOrClonedDefault(this._outlineColor, time, defaultOutlineColor, result.outlineColor);\n        result.outlineWidth = Property.getValueOrDefault(this._outlineWidth, time, defaultOutlineWidth);\n        return result;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    PolylineOutlineMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof PolylineOutlineMaterialProperty && //\n                Property.equals(this._color, other._color) && //\n                Property.equals(this._outlineColor, other._outlineColor) && //\n                Property.equals(this._outlineWidth, other._outlineWidth));\n    };\n\n    return PolylineOutlineMaterialProperty;\n});\n","define([\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        '../Core/EventHelper',\n        '../Core/ReferenceFrame',\n        './Property'\n    ], function(\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        EventHelper,\n        ReferenceFrame,\n        Property) {\n    'use strict';\n\n    /**\n     * A {@link PositionProperty} whose value is an array whose items are the computed value\n     * of other PositionProperty instances.\n     *\n     * @alias PositionPropertyArray\n     * @constructor\n     *\n     * @param {Property[]} [value] An array of Property instances.\n     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n     */\n    function PositionPropertyArray(value, referenceFrame) {\n        this._value = undefined;\n        this._definitionChanged = new Event();\n        this._eventHelper = new EventHelper();\n        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n        this.setValue(value);\n    }\n\n    defineProperties(PositionPropertyArray.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  This property\n         * is considered constant if all property items in the array are constant.\n         * @memberof PositionPropertyArray.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                var value = this._value;\n                if (!defined(value)) {\n                    return true;\n                }\n\n                var length = value.length;\n                for (var i = 0; i < length; i++) {\n                    if (!Property.isConstant(value[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value or one of the properties in the array also changes.\n         * @memberof PositionPropertyArray.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the reference frame in which the position is defined.\n         * @memberof PositionPropertyArray.prototype\n         * @type {ReferenceFrame}\n         * @default ReferenceFrame.FIXED;\n         */\n        referenceFrame : {\n            get : function() {\n                return this._referenceFrame;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Cartesian3[]} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3[]} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    PositionPropertyArray.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3[]} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3[]} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    PositionPropertyArray.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        var value = this._value;\n        if (!defined(value)) {\n            return undefined;\n        }\n\n        var length = value.length;\n        if (!defined(result)) {\n            result = new Array(length);\n        }\n        var i = 0;\n        var x = 0;\n        while (i < length) {\n            var property = value[i];\n            var itemValue = property.getValueInReferenceFrame(time, referenceFrame, result[i]);\n            if (defined(itemValue)) {\n                result[x] = itemValue;\n                x++;\n            }\n            i++;\n        }\n        result.length = x;\n        return result;\n    };\n\n    /**\n     * Sets the value of the property.\n     *\n     * @param {Property[]} value An array of Property instances.\n     */\n    PositionPropertyArray.prototype.setValue = function(value) {\n        var eventHelper = this._eventHelper;\n        eventHelper.removeAll();\n\n        if (defined(value)) {\n            this._value = value.slice();\n            var length = value.length;\n            for (var i = 0; i < length; i++) {\n                var property = value[i];\n                if (defined(property)) {\n                    eventHelper.add(property.definitionChanged, PositionPropertyArray.prototype._raiseDefinitionChanged, this);\n                }\n            }\n        } else {\n            this._value = undefined;\n        }\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    PositionPropertyArray.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof PositionPropertyArray && //\n                this._referenceFrame === other._referenceFrame && //\n                Property.arrayEquals(this._value, other._value));\n    };\n\n    PositionPropertyArray.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    return PositionPropertyArray;\n});\n","define([\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        '../Core/EventHelper',\n        './Property'\n    ], function(\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        EventHelper,\n        Property) {\n    'use strict';\n\n    /**\n     * A {@link Property} whose value is an array whose items are the computed value\n     * of other property instances.\n     *\n     * @alias PropertyArray\n     * @constructor\n     *\n     * @param {Property[]} [value] An array of Property instances.\n     */\n    function PropertyArray(value) {\n        this._value = undefined;\n        this._definitionChanged = new Event();\n        this._eventHelper = new EventHelper();\n        this.setValue(value);\n    }\n\n    defineProperties(PropertyArray.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  This property\n         * is considered constant if all property items in the array are constant.\n         * @memberof PropertyArray.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                var value = this._value;\n                if (!defined(value)) {\n                    return true;\n                }\n                var length = value.length;\n                for (var i = 0; i < length; i++) {\n                    if (!Property.isConstant(value[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value or one of the properties in the array also changes.\n         * @memberof PropertyArray.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object[]} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object[]} The modified result parameter, which is an array of values produced by evaluating each of the contained properties at the given time or a new instance if the result parameter was not supplied.\n     */\n    PropertyArray.prototype.getValue = function(time, result) {\n        \n\n        var value = this._value;\n        if (!defined(value)) {\n            return undefined;\n        }\n\n        var length = value.length;\n        if (!defined(result)) {\n            result = new Array(length);\n        }\n        var i = 0;\n        var x = 0;\n        while (i < length) {\n            var property = this._value[i];\n            var itemValue = property.getValue(time, result[i]);\n            if (defined(itemValue)) {\n                result[x] = itemValue;\n                x++;\n            }\n            i++;\n        }\n        result.length = x;\n        return result;\n    };\n\n    /**\n     * Sets the value of the property.\n     *\n     * @param {Property[]} value An array of Property instances.\n     */\n    PropertyArray.prototype.setValue = function(value) {\n        var eventHelper = this._eventHelper;\n        eventHelper.removeAll();\n\n        if (defined(value)) {\n            this._value = value.slice();\n            var length = value.length;\n            for (var i = 0; i < length; i++) {\n                var property = value[i];\n                if (defined(property)) {\n                    eventHelper.add(property.definitionChanged, PropertyArray.prototype._raiseDefinitionChanged, this);\n                }\n            }\n        } else {\n            this._value = undefined;\n        }\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    PropertyArray.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof PropertyArray && //\n                Property.arrayEquals(this._value, other._value));\n    };\n\n    PropertyArray.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    return PropertyArray;\n});\n","define([\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/Math'\n    ], function(\n        defaultValue,\n        defined,\n        DeveloperError,\n        CesiumMath) {\n    'use strict';\n\n    /**\n     * Represents a {@link Packable} number that always interpolates values\n     * towards the shortest angle of rotation. This object is never used directly\n     * but is instead passed to the constructor of {@link SampledProperty}\n     * in order to represent a two-dimensional angle of rotation.\n     *\n     * @exports Rotation\n     *\n     *\n     * @example\n     * var time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');\n     * var time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');\n     * var time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');\n     *\n     * var property = new Cesium.SampledProperty(Cesium.Rotation);\n     * property.addSample(time1, 0);\n     * property.addSample(time3, Cesium.Math.toRadians(350));\n     *\n     * //Getting the value at time2 will equal 355 degrees instead\n     * //of 175 degrees (which is what you get if you construct\n     * //a SampledProperty(Number) instead.  Note, the actual\n     * //return value is in radians, not degrees.\n     * property.getValue(time2);\n     *\n     * @see PackableForInterpolation\n     */\n    var Rotation = {\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        packedLength : 1,\n\n        /**\n         * Stores the provided instance into the provided array.\n         *\n         * @param {Rotation} value The value to pack.\n         * @param {Number[]} array The array to pack into.\n         * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n         *\n         * @returns {Number[]} The array that was packed into\n         */\n        pack : function(value, array, startingIndex) {\n            \n\n            startingIndex = defaultValue(startingIndex, 0);\n            array[startingIndex] = value;\n\n            return array;\n        },\n\n        /**\n         * Retrieves an instance from a packed array.\n         *\n         * @param {Number[]} array The packed array.\n         * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n         * @param {Rotation} [result] The object into which to store the result.\n         * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n         */\n        unpack : function(array, startingIndex, result) {\n            \n\n            startingIndex = defaultValue(startingIndex, 0);\n            return array[startingIndex];\n        },\n\n        /**\n         * Converts a packed array into a form suitable for interpolation.\n         *\n         * @param {Number[]} packedArray The packed array.\n         * @param {Number} [startingIndex=0] The index of the first element to be converted.\n         * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.\n         * @param {Number[]} result The object into which to store the result.\n         */\n        convertPackedArrayForInterpolation : function(packedArray, startingIndex, lastIndex, result) {\n            \n\n            startingIndex = defaultValue(startingIndex, 0);\n            lastIndex = defaultValue(lastIndex, packedArray.length);\n\n            var previousValue;\n            for (var i = 0, len = lastIndex - startingIndex + 1; i < len; i++) {\n                var value = packedArray[startingIndex + i];\n                if (i === 0 || Math.abs(previousValue - value) < Math.PI) {\n                    result[i] = value;\n                } else {\n                    result[i] = value - CesiumMath.TWO_PI;\n                }\n                previousValue = value;\n            }\n        },\n\n        /**\n         * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.\n         *\n         * @param {Number[]} array The array previously packed for interpolation.\n         * @param {Number[]} sourceArray The original packed array.\n         * @param {Number} [firstIndex=0] The firstIndex used to convert the array.\n         * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.\n         * @param {Rotation} [result] The object into which to store the result.\n         * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.\n         */\n        unpackInterpolationResult : function(array, sourceArray, firstIndex, lastIndex, result) {\n            \n\n            result = array[0];\n            if (result < 0) {\n                return result + CesiumMath.TWO_PI;\n            }\n            return result;\n        }\n    };\n\n    return Rotation;\n});\n","define([\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Event',\n        './createPropertyDescriptor',\n        './Property',\n        './StripeOrientation'\n    ], function(\n        Color,\n        defaultValue,\n        defined,\n        defineProperties,\n        Event,\n        createPropertyDescriptor,\n        Property,\n        StripeOrientation) {\n    'use strict';\n\n    var defaultOrientation = StripeOrientation.HORIZONTAL;\n    var defaultEvenColor = Color.WHITE;\n    var defaultOddColor = Color.BLACK;\n    var defaultOffset = 0;\n    var defaultRepeat = 1;\n\n    /**\n     * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.\n     * @alias StripeMaterialProperty\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Property} [options.orientation=StripeOrientation.HORIZONTAL] A Property specifying the {@link StripeOrientation}.\n     * @param {Property} [options.evenColor=Color.WHITE] A Property specifying the first {@link Color}.\n     * @param {Property} [options.oddColor=Color.BLACK] A Property specifying the second {@link Color}.\n     * @param {Property} [options.offset=0] A numeric Property specifying how far into the pattern to start the material.\n     * @param {Property} [options.repeat=1] A numeric Property specifying how many times the stripes repeat.\n     */\n    function StripeMaterialProperty(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        this._definitionChanged = new Event();\n        this._orientation = undefined;\n        this._orientationSubscription = undefined;\n        this._evenColor = undefined;\n        this._evenColorSubscription = undefined;\n        this._oddColor = undefined;\n        this._oddColorSubscription = undefined;\n        this._offset = undefined;\n        this._offsetSubscription = undefined;\n        this._repeat = undefined;\n        this._repeatSubscription = undefined;\n\n        this.orientation = options.orientation;\n        this.evenColor = options.evenColor;\n        this.oddColor = options.oddColor;\n        this.offset = options.offset;\n        this.repeat = options.repeat;\n    }\n\n    defineProperties(StripeMaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof StripeMaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._orientation) && //\n                       Property.isConstant(this._evenColor) && //\n                       Property.isConstant(this._oddColor) && //\n                       Property.isConstant(this._offset) && //\n                       Property.isConstant(this._repeat);\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof StripeMaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n\n        /**\n         * Gets or sets the Property specifying the {@link StripeOrientation}/\n         * @memberof StripeMaterialProperty.prototype\n         * @type {Property}\n         * @default StripeOrientation.HORIZONTAL\n         */\n        orientation : createPropertyDescriptor('orientation'),\n\n        /**\n         * Gets or sets the Property specifying the first {@link Color}.\n         * @memberof StripeMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.WHITE\n         */\n        evenColor : createPropertyDescriptor('evenColor'),\n\n        /**\n         * Gets or sets the Property specifying the second {@link Color}.\n         * @memberof StripeMaterialProperty.prototype\n         * @type {Property}\n         * @default Color.BLACK\n         */\n        oddColor : createPropertyDescriptor('oddColor'),\n\n        /**\n         * Gets or sets the numeric Property specifying the point into the pattern\n         * to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning\n         * of the odd color, 2.0 being the even color again, and any multiple or fractional values\n         * being in between.\n         * @memberof StripeMaterialProperty.prototype\n         * @type {Property}\n         * @default 0.0\n         */\n        offset : createPropertyDescriptor('offset'),\n\n        /**\n         * Gets or sets the numeric Property specifying how many times the stripes repeat.\n         * @memberof StripeMaterialProperty.prototype\n         * @type {Property}\n         * @default 1.0\n         */\n        repeat : createPropertyDescriptor('repeat')\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    StripeMaterialProperty.prototype.getType = function(time) {\n        return 'Stripe';\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    StripeMaterialProperty.prototype.getValue = function(time, result) {\n        if (!defined(result)) {\n            result = {};\n        }\n        result.horizontal = Property.getValueOrDefault(this._orientation, time, defaultOrientation) === StripeOrientation.HORIZONTAL;\n        result.evenColor = Property.getValueOrClonedDefault(this._evenColor, time, defaultEvenColor, result.evenColor);\n        result.oddColor = Property.getValueOrClonedDefault(this._oddColor, time, defaultOddColor, result.oddColor);\n        result.offset = Property.getValueOrDefault(this._offset, time, defaultOffset);\n        result.repeat = Property.getValueOrDefault(this._repeat, time, defaultRepeat);\n        return result;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    StripeMaterialProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof StripeMaterialProperty && //\n                       Property.equals(this._orientation, other._orientation) && //\n                       Property.equals(this._evenColor, other._evenColor) && //\n                       Property.equals(this._oddColor, other._oddColor) && //\n                       Property.equals(this._offset, other._offset) && //\n                       Property.equals(this._repeat, other._repeat));\n    };\n\n    return StripeMaterialProperty;\n});\n","define([\n        '../Core/freezeObject'\n    ], function(\n        freezeObject) {\n    'use strict';\n\n    /**\n     * Defined the orientation of stripes in {@link StripeMaterialProperty}.\n     *\n     * @exports StripeOrientation\n     */\n    var StripeOrientation = {\n        /**\n         * Horizontal orientation.\n         * @type {Number}\n         */\n        HORIZONTAL : 0,\n\n        /**\n         * Vertical orientation.\n         * @type {Number}\n         */\n        VERTICAL : 1\n    };\n\n    return freezeObject(StripeOrientation);\n});\n","define([\n        '../Core/Cartesian3',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/Ellipsoid',\n        '../Core/Event',\n        '../Core/Matrix3',\n        '../Core/Quaternion',\n        '../Core/Transforms',\n        './Property',\n        './VelocityVectorProperty'\n    ], function(\n        Cartesian3,\n        defaultValue,\n        defined,\n        defineProperties,\n        Ellipsoid,\n        Event,\n        Matrix3,\n        Quaternion,\n        Transforms,\n        Property,\n        VelocityVectorProperty) {\n    'use strict';\n\n    /**\n     * A {@link Property} which evaluates to a {@link Quaternion} rotation\n     * based on the velocity of the provided {@link PositionProperty}.\n     *\n     * @alias VelocityOrientationProperty\n     * @constructor\n     *\n     * @param {Property} [position] The position property used to compute the orientation.\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine which way is up.\n     *\n     * @example\n     * //Create an entity with position and orientation.\n     * var position = new Cesium.SampledProperty();\n     * position.addSamples(...);\n     * var entity = viewer.entities.add({\n     *   position : position,\n     *   orientation : new Cesium.VelocityOrientationProperty(position)\n     * }));\n     */\n    function VelocityOrientationProperty(position, ellipsoid) {\n        this._velocityVectorProperty = new VelocityVectorProperty(position, true);\n        this._subscription = undefined;\n        this._ellipsoid = undefined;\n        this._definitionChanged = new Event();\n\n        this.ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n        var that = this;\n        this._velocityVectorProperty.definitionChanged.addEventListener(function() {\n            that._definitionChanged.raiseEvent(that);\n        });\n    }\n\n    defineProperties(VelocityOrientationProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof VelocityOrientationProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._velocityVectorProperty);\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * @memberof VelocityOrientationProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets or sets the position property used to compute orientation.\n         * @memberof VelocityOrientationProperty.prototype\n         *\n         * @type {Property}\n         */\n        position : {\n            get : function() {\n                return this._velocityVectorProperty.position;\n            },\n            set : function(value) {\n                this._velocityVectorProperty.position = value;\n            }\n        },\n        /**\n         * Gets or sets the ellipsoid used to determine which way is up.\n         * @memberof VelocityOrientationProperty.prototype\n         *\n         * @type {Property}\n         */\n        ellipsoid : {\n            get : function() {\n                return this._ellipsoid;\n            },\n            set : function(value) {\n                var oldValue = this._ellipsoid;\n                if (oldValue !== value) {\n                    this._ellipsoid = value;\n                    this._definitionChanged.raiseEvent(this);\n                }\n            }\n        }\n    });\n\n    var positionScratch = new Cartesian3();\n    var velocityScratch = new Cartesian3();\n    var rotationScratch = new Matrix3();\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} [time] The time for which to retrieve the value.\n     * @param {Quaternion} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Quaternion} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    VelocityOrientationProperty.prototype.getValue = function(time, result) {\n        var velocity = this._velocityVectorProperty._getValue(time, velocityScratch, positionScratch);\n\n        if (!defined(velocity)) {\n            return undefined;\n        }\n\n        Transforms.rotationMatrixFromPositionVelocity(positionScratch, velocity, this._ellipsoid, rotationScratch);\n        return Quaternion.fromRotationMatrix(rotationScratch, result);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    VelocityOrientationProperty.prototype.equals = function(other) {\n        return this === other ||//\n               (other instanceof VelocityOrientationProperty &&\n                Property.equals(this._velocityVectorProperty, other._velocityVectorProperty) &&\n                (this._ellipsoid === other._ellipsoid ||\n                 this._ellipsoid.equals(other._ellipsoid)));\n    };\n\n    return VelocityOrientationProperty;\n});\n","define([\n        '../Core/Cartesian3',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        '../Core/JulianDate',\n        './Property'\n    ], function(\n        Cartesian3,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        JulianDate,\n        Property) {\n    'use strict';\n\n    /**\n     * A {@link Property} which evaluates to a {@link Cartesian3} vector\n     * based on the velocity of the provided {@link PositionProperty}.\n     *\n     * @alias VelocityVectorProperty\n     * @constructor\n     *\n     * @param {Property} [position] The position property used to compute the velocity.\n     * @param {Boolean} [normalize=true] Whether to normalize the computed velocity vector.\n     *\n     * @example\n     * //Create an entity with a billboard rotated to match its velocity.\n     * var position = new Cesium.SampledProperty();\n     * position.addSamples(...);\n     * var entity = viewer.entities.add({\n     *   position : position,\n     *   billboard : {\n     *     image : 'image.png',\n     *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector\n     *   }\n     * }));\n     */\n    function VelocityVectorProperty(position, normalize) {\n        this._position = undefined;\n        this._subscription = undefined;\n        this._definitionChanged = new Event();\n        this._normalize = defaultValue(normalize, true);\n\n        this.position = position;\n    }\n\n    defineProperties(VelocityVectorProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof VelocityVectorProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._position);\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * @memberof VelocityVectorProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets or sets the position property used to compute the velocity vector.\n         * @memberof VelocityVectorProperty.prototype\n         *\n         * @type {Property}\n         */\n        position : {\n            get : function() {\n                return this._position;\n            },\n            set : function(value) {\n                var oldValue = this._position;\n                if (oldValue !== value) {\n                    if (defined(oldValue)) {\n                        this._subscription();\n                    }\n\n                    this._position = value;\n\n                    if (defined(value)) {\n                        this._subscription = value._definitionChanged.addEventListener(function() {\n                            this._definitionChanged.raiseEvent(this);\n                        }, this);\n                    }\n\n                    this._definitionChanged.raiseEvent(this);\n                }\n            }\n        },\n        /**\n         * Gets or sets whether the vector produced by this property\n         * will be normalized or not.\n         * @memberof VelocityVectorProperty.prototype\n         *\n         * @type {Boolean}\n         */\n        normalize : {\n            get : function() {\n                return this._normalize;\n            },\n            set : function(value) {\n                if (this._normalize === value) {\n                    return;\n                }\n\n                this._normalize = value;\n                this._definitionChanged.raiseEvent(this);\n            }\n        }\n    });\n\n    var position1Scratch = new Cartesian3();\n    var position2Scratch = new Cartesian3();\n    var timeScratch = new JulianDate();\n    var step = 1.0 / 60.0;\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} [time] The time for which to retrieve the value.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    VelocityVectorProperty.prototype.getValue = function(time, result) {\n        return this._getValue(time, result);\n    };\n\n    /**\n     * @private\n     */\n    VelocityVectorProperty.prototype._getValue = function(time, velocityResult, positionResult) {\n        \n\n        if (!defined(velocityResult)) {\n            velocityResult = new Cartesian3();\n        }\n\n        var property = this._position;\n        if (Property.isConstant(property)) {\n            return this._normalize ? undefined : Cartesian3.clone(Cartesian3.ZERO, velocityResult);\n        }\n\n        var position1 = property.getValue(time, position1Scratch);\n        var position2 = property.getValue(JulianDate.addSeconds(time, step, timeScratch), position2Scratch);\n\n        //If we don't have a position for now, return undefined.\n        if (!defined(position1)) {\n            return undefined;\n        }\n\n        //If we don't have a position for now + step, see if we have a position for now - step.\n        if (!defined(position2)) {\n            position2 = position1;\n            position1 = property.getValue(JulianDate.addSeconds(time, -step, timeScratch), position2Scratch);\n\n            if (!defined(position1)) {\n                return undefined;\n            }\n        }\n\n        if (Cartesian3.equals(position1, position2)) {\n            return this._normalize ? undefined : Cartesian3.clone(Cartesian3.ZERO, velocityResult);\n        }\n\n        if (defined(positionResult)) {\n            position1.clone(positionResult);\n        }\n\n        var velocity = Cartesian3.subtract(position2, position1, velocityResult);\n        if (this._normalize) {\n            return Cartesian3.normalize(velocity, velocityResult);\n        }\n\n        return Cartesian3.divideByScalar(velocity, step, velocityResult);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    VelocityVectorProperty.prototype.equals = function(other) {\n        return this === other ||//\n               (other instanceof VelocityVectorProperty &&\n                Property.equals(this._position, other._position));\n    };\n\n    return VelocityVectorProperty;\n});\n","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module unless amdModuleId is set\n    define([], function () {\n      return (root['Autolinker'] = factory());\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    root['Autolinker'] = factory();\n  }\n}(this, function () {\n\n/*!\n * Autolinker.js\n * 0.17.1\n *\n * Copyright(c) 2015 Gregory Jacobs <greg@greg-jacobs.com>\n * MIT Licensed. http-colon-slashslash www.opensource.org/licenses/mit-license.php\n *\n * https-colon-slashslash github.com/gregjacobs/Autolinker.js\n */\n/**\n * @class Autolinker\n * @extends Object\n *\n * Utility class used to process a given string of text, and wrap the matches in\n * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n *\n * Any of the configuration options may be provided in an Object (map) provided\n * to the Autolinker constructor, which will configure how the {@link #link link()}\n * method will process the links.\n *\n * For example:\n *\n *     var autolinker = new Autolinker( {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n *\n *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n *     // produces: 'Joe went to <a href=\"http-colon-slashslash www.yahoo.com\">yahoo.com</a>'\n *\n *\n * The {@link #static-link static link()} method may also be used to inline options into a single call, which may\n * be more convenient for one-off uses. For example:\n *\n *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n *     // produces: 'Joe went to <a href=\"http-colon-slashslash www.yahoo.com\">yahoo.com</a>'\n *\n *\n * ## Custom Replacements of Links\n *\n * If the configuration options do not provide enough flexibility, a {@link #replaceFn}\n * may be provided to fully customize the output of Autolinker. This function is\n * called once for each URL/Email/Phone#/Twitter Handle/Hashtag match that is\n * encountered.\n *\n * For example:\n *\n *     var input = \"...\";  // string with URLs, Email Addresses, Phone #s, Twitter Handles, and Hashtags\n *\n *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( autolinker, match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *\n *             switch( match.getType() ) {\n *                 case 'url' :\n *                     console.log( \"url: \", match.getUrl() );\n *\n *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n *                         var tag = autolinker.getTagBuilder().build( match );  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n *                         tag.setAttr( 'rel', 'nofollow' );\n *                         tag.addClass( 'external-link' );\n *\n *                         return tag;\n *\n *                     } else {\n *                         return true;  // let Autolinker perform its normal anchor tag replacement\n *                     }\n *\n *                 case 'email' :\n *                     var email = match.getEmail();\n *                     console.log( \"email: \", email );\n *\n *                     if( email === \"my@own.address\" ) {\n *                         return false;  // don't auto-link this particular email address; leave as-is\n *                     } else {\n *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n *                     }\n *\n *                 case 'phone' :\n *                     var phoneNumber = match.getPhoneNumber();\n *                     console.log( phoneNumber );\n *\n *                     return '<a href=\"http-colon-slashslash newplace.to.link.phone.numbers.to/\">' + phoneNumber + '</a>';\n *\n *                 case 'twitter' :\n *                     var twitterHandle = match.getTwitterHandle();\n *                     console.log( twitterHandle );\n *\n *                     return '<a href=\"http-colon-slashslash newplace.to.link.twitter.handles.to/\">' + twitterHandle + '</a>';\n *\n *                 case 'hashtag' :\n *                     var hashtag = match.getHashtag();\n *                     console.log( hashtag );\n *\n *                     return '<a href=\"http-colon-slashslash newplace.to.link.hashtag.handles.to/\">' + hashtag + '</a>';\n *             }\n *         }\n *     } );\n *\n *\n * The function may return the following values:\n *\n * - `true` (Boolean): Allow Autolinker to replace the match as it normally would.\n * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n * - Any String: If a string is returned from the function, the string will be used directly as the replacement HTML for\n *   the match.\n * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify an HTML tag before writing out its HTML text.\n *\n * @constructor\n * @param {Object} [config] The configuration options for the Autolinker instance, specified in an Object (map).\n */\nvar Autolinker = function( cfg ) {\n\tAutolinker.Util.assign( this, cfg );  // assign the properties of `cfg` onto the Autolinker instance. Prototype properties will be used for missing configs.\n\n\t// Validate the value of the `hashtag` cfg.\n\tvar hashtag = this.hashtag;\n\tif( hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' ) {\n\t\tthrow new Error( \"invalid `hashtag` cfg - see docs\" );\n\t}\n};\n\nAutolinker.prototype = {\n\tconstructor : Autolinker,  // fix constructor property\n\n\t/**\n\t * @cfg {Boolean} urls\n\t *\n\t * `true` if miscellaneous URLs should be automatically linked, `false` if they should not be.\n\t */\n\turls : true,\n\n\t/**\n\t * @cfg {Boolean} email\n\t *\n\t * `true` if email addresses should be automatically linked, `false` if they should not be.\n\t */\n\temail : true,\n\n\t/**\n\t * @cfg {Boolean} twitter\n\t *\n\t * `true` if Twitter handles (\"@example\") should be automatically linked, `false` if they should not be.\n\t */\n\ttwitter : true,\n\n\t/**\n\t * @cfg {Boolean} phone\n\t *\n\t * `true` if Phone numbers (\"(555)555-5555\") should be automatically linked, `false` if they should not be.\n\t */\n\tphone: true,\n\n\t/**\n\t * @cfg {Boolean/String} hashtag\n\t *\n\t * A string for the service name to have hashtags (ex: \"#myHashtag\")\n\t * auto-linked to. The currently-supported values are:\n\t *\n\t * - 'twitter'\n\t * - 'facebook'\n\t *\n\t * Pass `false` to skip auto-linking of hashtags.\n\t */\n\thashtag : false,\n\n\t/**\n\t * @cfg {Boolean} newWindow\n\t *\n\t * `true` if the links should open in a new window, `false` otherwise.\n\t */\n\tnewWindow : true,\n\n\t/**\n\t * @cfg {Boolean} stripPrefix\n\t *\n\t * `true` if 'http-colon-slashslash ' or 'https-colon-slashslash ' and/or the 'www.' should be stripped\n\t * from the beginning of URL links' text, `false` otherwise.\n\t */\n\tstripPrefix : true,\n\n\t/**\n\t * @cfg {Number} truncate\n\t *\n\t * A number for how many characters long matched text should be truncated to inside the text of\n\t * a link. If the matched text is over this number of characters, it will be truncated to this length by\n\t * adding a two period ellipsis ('..') to the end of the string.\n\t *\n\t * For example: A url like 'http-colon-slashslash www.yahoo.com/some/long/path/to/a/file' truncated to 25 characters might look\n\t * something like this: 'yahoo.com/some/long/pat..'\n\t */\n\ttruncate : undefined,\n\n\t/**\n\t * @cfg {String} className\n\t *\n\t * A CSS class name to add to the generated links. This class will be added to all links, as well as this class\n\t * plus match suffixes for styling url/email/phone/twitter/hashtag links differently.\n\t *\n\t * For example, if this config is provided as \"myLink\", then:\n\t *\n\t * - URL links will have the CSS classes: \"myLink myLink-url\"\n\t * - Email links will have the CSS classes: \"myLink myLink-email\", and\n\t * - Twitter links will have the CSS classes: \"myLink myLink-twitter\"\n\t * - Phone links will have the CSS classes: \"myLink myLink-phone\"\n\t * - Hashtag links will have the CSS classes: \"myLink myLink-hashtag\"\n\t */\n\tclassName : \"\",\n\n\t/**\n\t * @cfg {Function} replaceFn\n\t *\n\t * A function to individually process each match found in the input string.\n\t *\n\t * See the class's description for usage.\n\t *\n\t * This function is called with the following parameters:\n\t *\n\t * @cfg {Autolinker} replaceFn.autolinker The Autolinker instance, which may be used to retrieve child objects from (such\n\t *   as the instance's {@link #getTagBuilder tag builder}).\n\t * @cfg {Autolinker.match.Match} replaceFn.match The Match instance which can be used to retrieve information about the\n\t *   match that the `replaceFn` is currently processing. See {@link Autolinker.match.Match} subclasses for details.\n\t */\n\n\n\t/**\n\t * @private\n\t * @property {Autolinker.htmlParser.HtmlParser} htmlParser\n\t *\n\t * The HtmlParser instance used to skip over HTML tags, while finding text nodes to process. This is lazily instantiated\n\t * in the {@link #getHtmlParser} method.\n\t */\n\thtmlParser : undefined,\n\n\t/**\n\t * @private\n\t * @property {Autolinker.matchParser.MatchParser} matchParser\n\t *\n\t * The MatchParser instance used to find matches in the text nodes of an input string passed to\n\t * {@link #link}. This is lazily instantiated in the {@link #getMatchParser} method.\n\t */\n\tmatchParser : undefined,\n\n\t/**\n\t * @private\n\t * @property {Autolinker.AnchorTagBuilder} tagBuilder\n\t *\n\t * The AnchorTagBuilder instance used to build match replacement anchor tags. Note: this is lazily instantiated\n\t * in the {@link #getTagBuilder} method.\n\t */\n\ttagBuilder : undefined,\n\n\t/**\n\t * Automatically links URLs, Email addresses, Phone numbers, Twitter\n\t * handles, and Hashtags found in the given chunk of HTML. Does not link\n\t * URLs found within HTML tags.\n\t *\n\t * For instance, if given the text: `You should go to http-colon-slashslash www.yahoo.com`,\n\t * then the result will be `You should go to\n\t * &lt;a href=\"http-colon-slashslash www.yahoo.com\"&gt;http-colon-slashslash www.yahoo.com&lt;/a&gt;`\n\t *\n\t * This method finds the text around any HTML elements in the input\n\t * `textOrHtml`, which will be the text that is processed. Any original HTML\n\t * elements will be left as-is, as well as the text that is already wrapped\n\t * in anchor (&lt;a&gt;) tags.\n\t *\n\t * @param {String} textOrHtml The HTML or text to autolink matches within\n\t *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n\t *   {@link #twitter}, and {@link #hashtag} options are enabled).\n\t * @return {String} The HTML, with matches automatically linked.\n\t */\n\tlink : function( textOrHtml ) {\n\t\tvar htmlParser = this.getHtmlParser(),\n\t\t    htmlNodes = htmlParser.parse( textOrHtml ),\n\t\t    anchorTagStackCount = 0,  // used to only process text around anchor tags, and any inner text/html they may have\n\t\t    resultHtml = [];\n\n\t\tfor( var i = 0, len = htmlNodes.length; i < len; i++ ) {\n\t\t\tvar node = htmlNodes[ i ],\n\t\t\t    nodeType = node.getType(),\n\t\t\t    nodeText = node.getText();\n\n\t\t\tif( nodeType === 'element' ) {\n\t\t\t\t// Process HTML nodes in the input `textOrHtml`\n\t\t\t\tif( node.getTagName() === 'a' ) {\n\t\t\t\t\tif( !node.isClosing() ) {  // it's the start <a> tag\n\t\t\t\t\t\tanchorTagStackCount++;\n\t\t\t\t\t} else {   // it's the end </a> tag\n\t\t\t\t\t\tanchorTagStackCount = Math.max( anchorTagStackCount - 1, 0 );  // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresultHtml.push( nodeText );  // now add the text of the tag itself verbatim\n\n\t\t\t} else if( nodeType === 'entity' || nodeType === 'comment' ) {\n\t\t\t\tresultHtml.push( nodeText );  // append HTML entity nodes (such as '&nbsp;') or HTML comments (such as '<!-- Comment -->') verbatim\n\n\t\t\t} else {\n\t\t\t\t// Process text nodes in the input `textOrHtml`\n\t\t\t\tif( anchorTagStackCount === 0 ) {\n\t\t\t\t\t// If we're not within an <a> tag, process the text node to linkify\n\t\t\t\t\tvar linkifiedStr = this.linkifyStr( nodeText );\n\t\t\t\t\tresultHtml.push( linkifiedStr );\n\n\t\t\t\t} else {\n\t\t\t\t\t// `text` is within an <a> tag, simply append the text - we do not want to autolink anything\n\t\t\t\t\t// already within an <a>...</a> tag\n\t\t\t\t\tresultHtml.push( nodeText );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn resultHtml.join( \"\" );\n\t},\n\n\t/**\n\t * Process the text that lies in between HTML tags, performing the anchor\n\t * tag replacements for the matches, and returns the string with the\n\t * replacements made.\n\t *\n\t * This method does the actual wrapping of matches with anchor tags.\n\t *\n\t * @private\n\t * @param {String} str The string of text to auto-link.\n\t * @return {String} The text with anchor tags auto-filled.\n\t */\n\tlinkifyStr : function( str ) {\n\t\treturn this.getMatchParser().replace( str, this.createMatchReturnVal, this );\n\t},\n\n\n\t/**\n\t * Creates the return string value for a given match in the input string,\n\t * for the {@link #linkifyStr} method.\n\t *\n\t * This method handles the {@link #replaceFn}, if one was provided.\n\t *\n\t * @private\n\t * @param {Autolinker.match.Match} match The Match object that represents the match.\n\t * @return {String} The string that the `match` should be replaced with. This is usually the anchor tag string, but\n\t *   may be the `matchStr` itself if the match is not to be replaced.\n\t */\n\tcreateMatchReturnVal : function( match ) {\n\t\t// Handle a custom `replaceFn` being provided\n\t\tvar replaceFnResult;\n\t\tif( this.replaceFn ) {\n\t\t\treplaceFnResult = this.replaceFn.call( this, this, match );  // Autolinker instance is the context, and the first arg\n\t\t}\n\n\t\tif( typeof replaceFnResult === 'string' ) {\n\t\t\treturn replaceFnResult;  // `replaceFn` returned a string, use that\n\n\t\t} else if( replaceFnResult === false ) {\n\t\t\treturn match.getMatchedText();  // no replacement for the match\n\n\t\t} else if( replaceFnResult instanceof Autolinker.HtmlTag ) {\n\t\t\treturn replaceFnResult.toAnchorString();\n\n\t\t} else {  // replaceFnResult === true, or no/unknown return value from function\n\t\t\t// Perform Autolinker's default anchor tag generation\n\t\t\tvar tagBuilder = this.getTagBuilder(),\n\t\t\t    anchorTag = tagBuilder.build( match );  // returns an Autolinker.HtmlTag instance\n\n\t\t\treturn anchorTag.toAnchorString();\n\t\t}\n\t},\n\n\n\t/**\n\t * Lazily instantiates and returns the {@link #htmlParser} instance for this Autolinker instance.\n\t *\n\t * @protected\n\t * @return {Autolinker.htmlParser.HtmlParser}\n\t */\n\tgetHtmlParser : function() {\n\t\tvar htmlParser = this.htmlParser;\n\n\t\tif( !htmlParser ) {\n\t\t\thtmlParser = this.htmlParser = new Autolinker.htmlParser.HtmlParser();\n\t\t}\n\n\t\treturn htmlParser;\n\t},\n\n\n\t/**\n\t * Lazily instantiates and returns the {@link #matchParser} instance for this Autolinker instance.\n\t *\n\t * @protected\n\t * @return {Autolinker.matchParser.MatchParser}\n\t */\n\tgetMatchParser : function() {\n\t\tvar matchParser = this.matchParser;\n\n\t\tif( !matchParser ) {\n\t\t\tmatchParser = this.matchParser = new Autolinker.matchParser.MatchParser( {\n\t\t\t\turls        : this.urls,\n\t\t\t\temail       : this.email,\n\t\t\t\ttwitter     : this.twitter,\n\t\t\t\tphone       : this.phone,\n\t\t\t\thashtag     : this.hashtag,\n\t\t\t\tstripPrefix : this.stripPrefix\n\t\t\t} );\n\t\t}\n\n\t\treturn matchParser;\n\t},\n\n\n\t/**\n\t * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n\t * if it does not yet exist.\n\t *\n\t * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n\t * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n\t *\n\t *     var html = Autolinker.link( \"Test google.com\", {\n\t *         replaceFn : function( autolinker, match ) {\n\t *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n\t *             tag.setAttr( 'rel', 'nofollow' );\n\t *\n\t *             return tag;\n\t *         }\n\t *     } );\n\t *\n\t *     // generated html:\n\t *     //   Test <a href=\"http-colon-slashslash google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n\t *\n\t * @return {Autolinker.AnchorTagBuilder}\n\t */\n\tgetTagBuilder : function() {\n\t\tvar tagBuilder = this.tagBuilder;\n\n\t\tif( !tagBuilder ) {\n\t\t\ttagBuilder = this.tagBuilder = new Autolinker.AnchorTagBuilder( {\n\t\t\t\tnewWindow   : this.newWindow,\n\t\t\t\ttruncate    : this.truncate,\n\t\t\t\tclassName   : this.className\n\t\t\t} );\n\t\t}\n\n\t\treturn tagBuilder;\n\t}\n\n};\n\n\n/**\n * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,\n * and Hashtags found in the given chunk of HTML. Does not link URLs found\n * within HTML tags.\n *\n * For instance, if given the text: `You should go to http-colon-slashslash www.yahoo.com`,\n * then the result will be `You should go to &lt;a href=\"http-colon-slashslash www.yahoo.com\"&gt;http-colon-slashslash www.yahoo.com&lt;/a&gt;`\n *\n * Example:\n *\n *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n *     // Produces: \"Go to <a href=\"http-colon-slashslash google.com\">google.com</a>\"\n *\n * @static\n * @param {String} textOrHtml The HTML or text to find matches within (depending\n *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #twitter},\n *   and {@link #hashtag} options are enabled).\n * @param {Object} [options] Any of the configuration options for the Autolinker\n *   class, specified in an Object (map). See the class description for an\n *   example call.\n * @return {String} The HTML text, with matches automatically linked.\n */\nAutolinker.link = function( textOrHtml, options ) {\n\tvar autolinker = new Autolinker( options );\n\treturn autolinker.link( textOrHtml );\n};\n\n\n// Autolinker Namespaces\nAutolinker.match = {};\nAutolinker.htmlParser = {};\nAutolinker.matchParser = {};\n\n/*global Autolinker */\n/*jshint eqnull:true, boss:true */\n/**\n * @class Autolinker.Util\n * @singleton\n *\n * A few utility methods for Autolinker.\n */\nAutolinker.Util = {\n\n\t/**\n\t * @property {Function} abstractMethod\n\t *\n\t * A function object which represents an abstract method.\n\t */\n\tabstractMethod : function() { throw \"abstract\"; },\n\n\n\t/**\n\t * @private\n\t * @property {RegExp} trimRegex\n\t *\n\t * The regular expression used to trim the leading and trailing whitespace\n\t * from a string.\n\t */\n\ttrimRegex : /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\n\t/**\n\t * Assigns (shallow copies) the properties of `src` onto `dest`.\n\t *\n\t * @param {Object} dest The destination object.\n\t * @param {Object} src The source object.\n\t * @return {Object} The destination object (`dest`)\n\t */\n\tassign : function( dest, src ) {\n\t\tfor( var prop in src ) {\n\t\t\tif( src.hasOwnProperty( prop ) ) {\n\t\t\t\tdest[ prop ] = src[ prop ];\n\t\t\t}\n\t\t}\n\n\t\treturn dest;\n\t},\n\n\n\t/**\n\t * Extends `superclass` to create a new subclass, adding the `protoProps` to the new subclass's prototype.\n\t *\n\t * @param {Function} superclass The constructor function for the superclass.\n\t * @param {Object} protoProps The methods/properties to add to the subclass's prototype. This may contain the\n\t *   special property `constructor`, which will be used as the new subclass's constructor function.\n\t * @return {Function} The new subclass function.\n\t */\n\textend : function( superclass, protoProps ) {\n\t\tvar superclassProto = superclass.prototype;\n\n\t\tvar F = function() {};\n\t\tF.prototype = superclassProto;\n\n\t\tvar subclass;\n\t\tif( protoProps.hasOwnProperty( 'constructor' ) ) {\n\t\t\tsubclass = protoProps.constructor;\n\t\t} else {\n\t\t\tsubclass = function() { superclassProto.constructor.apply( this, arguments ); };\n\t\t}\n\n\t\tvar subclassProto = subclass.prototype = new F();  // set up prototype chain\n\t\tsubclassProto.constructor = subclass;  // fix constructor property\n\t\tsubclassProto.superclass = superclassProto;\n\n\t\tdelete protoProps.constructor;  // don't re-assign constructor property to the prototype, since a new function may have been created (`subclass`), which is now already there\n\t\tAutolinker.Util.assign( subclassProto, protoProps );\n\n\t\treturn subclass;\n\t},\n\n\n\t/**\n\t * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n\t * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n\t * `len`, the string will be returned unchanged.\n\t *\n\t * @param {String} str The string to truncate and add an ellipsis to.\n\t * @param {Number} truncateLen The length to truncate the string at.\n\t * @param {String} [ellipsisChars=..] The ellipsis character(s) to add to the end of `str`\n\t *   when truncated. Defaults to '..'\n\t */\n\tellipsis : function( str, truncateLen, ellipsisChars ) {\n\t\tif( str.length > truncateLen ) {\n\t\t\tellipsisChars = ( ellipsisChars == null ) ? '..' : ellipsisChars;\n\t\t\tstr = str.substring( 0, truncateLen - ellipsisChars.length ) + ellipsisChars;\n\t\t}\n\t\treturn str;\n\t},\n\n\n\t/**\n\t * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n\t *\n\t * @param {Array} arr The array to find an element of.\n\t * @param {*} element The element to find in the array, and return the index of.\n\t * @return {Number} The index of the `element`, or -1 if it was not found.\n\t */\n\tindexOf : function( arr, element ) {\n\t\tif( Array.prototype.indexOf ) {\n\t\t\treturn arr.indexOf( element );\n\n\t\t} else {\n\t\t\tfor( var i = 0, len = arr.length; i < len; i++ ) {\n\t\t\t\tif( arr[ i ] === element ) return i;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t},\n\n\n\n\t/**\n\t * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n\t * with a regular expression that contains capturing parenthesis.\n\t *\n\t * For example:\n\t *\n\t *     // Modern browsers:\n\t *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n\t *\n\t *     // Old IE (including IE8):\n\t *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n\t *\n\t * This method emulates the functionality of modern browsers for the old IE case.\n\t *\n\t * @param {String} str The string to split.\n\t * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n\t *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n\t *   description of this method.\n\t *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n\t *   Note #2: for simplicity's sake, the regular expression does not need\n\t *   to contain capturing parenthesis - it will be assumed that any match has them.\n\t * @return {String[]} The split array of strings, with the splitting character(s) included.\n\t */\n\tsplitAndCapture : function( str, splitRegex ) {\n\t\tif( !splitRegex.global ) throw new Error( \"`splitRegex` must have the 'g' flag set\" );\n\n\t\tvar result = [],\n\t\t    lastIdx = 0,\n\t\t    match;\n\n\t\twhile( match = splitRegex.exec( str ) ) {\n\t\t\tresult.push( str.substring( lastIdx, match.index ) );\n\t\t\tresult.push( match[ 0 ] );  // push the splitting char(s)\n\n\t\t\tlastIdx = match.index + match[ 0 ].length;\n\t\t}\n\t\tresult.push( str.substring( lastIdx ) );\n\n\t\treturn result;\n\t},\n\n\n\t/**\n\t * Trims the leading and trailing whitespace from a string.\n\t *\n\t * @param {String} str The string to trim.\n\t * @return {String}\n\t */\n\ttrim : function( str ) {\n\t\treturn str.replace( this.trimRegex, '' );\n\t}\n\n};\n/*global Autolinker */\n/*jshint boss:true */\n/**\n * @class Autolinker.HtmlTag\n * @extends Object\n *\n * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n *\n * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n *\n * ## Examples\n *\n * Example instantiation:\n *\n *     var tag = new Autolinker.HtmlTag( {\n *         tagName : 'a',\n *         attrs   : { 'href': 'http-colon-slashslash google.com', 'class': 'external-link' },\n *         innerHtml : 'Google'\n *     } );\n *\n *     tag.toAnchorString();  // <a href=\"http-colon-slashslash google.com\" class=\"external-link\">Google</a>\n *\n *     // Individual accessor methods\n *     tag.getTagName();                 // 'a'\n *     tag.getAttr( 'href' );            // 'http-colon-slashslash google.com'\n *     tag.hasClass( 'external-link' );  // true\n *\n *\n * Using mutator methods (which may be used in combination with instantiation config properties):\n *\n *     var tag = new Autolinker.HtmlTag();\n *     tag.setTagName( 'a' );\n *     tag.setAttr( 'href', 'http-colon-slashslash google.com' );\n *     tag.addClass( 'external-link' );\n *     tag.setInnerHtml( 'Google' );\n *\n *     tag.getTagName();                 // 'a'\n *     tag.getAttr( 'href' );            // 'http-colon-slashslash google.com'\n *     tag.hasClass( 'external-link' );  // true\n *\n *     tag.toAnchorString();  // <a href=\"http-colon-slashslash google.com\" class=\"external-link\">Google</a>\n *\n *\n * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <a href=\"http-colon-slashslash google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n *\n *\n * ## Example use with a new tag for the replacement\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = new Autolinker.HtmlTag( {\n *                 tagName : 'button',\n *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n *             } );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <button title=\"Load URL: http-colon-slashslash google.com\">Load URL: google.com</button>\n */\nAutolinker.HtmlTag = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {String} tagName\n\t *\n\t * The tag name. Ex: 'a', 'button', etc.\n\t *\n\t * Not required at instantiation time, but should be set using {@link #setTagName} before {@link #toAnchorString}\n\t * is executed.\n\t */\n\n\t/**\n\t * @cfg {Object.<String, String>} attrs\n\t *\n\t * An key/value Object (map) of attributes to create the tag with. The keys are the attribute names, and the\n\t * values are the attribute values.\n\t */\n\n\t/**\n\t * @cfg {String} innerHtml\n\t *\n\t * The inner HTML for the tag.\n\t *\n\t * Note the camel case name on `innerHtml`. Acronyms are camelCased in this utility (such as not to run into the acronym\n\t * naming inconsistency that the DOM developers created with `XMLHttpRequest`). You may alternatively use {@link #innerHTML}\n\t * if you prefer, but this one is recommended.\n\t */\n\n\t/**\n\t * @cfg {String} innerHTML\n\t *\n\t * Alias of {@link #innerHtml}, accepted for consistency with the browser DOM api, but prefer the camelCased version\n\t * for acronym names.\n\t */\n\n\n\t/**\n\t * @protected\n\t * @property {RegExp} whitespaceRegex\n\t *\n\t * Regular expression used to match whitespace in a string of CSS classes.\n\t */\n\twhitespaceRegex : /\\s+/,\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\n\t\tthis.innerHtml = this.innerHtml || this.innerHTML;  // accept either the camelCased form or the fully capitalized acronym\n\t},\n\n\n\t/**\n\t * Sets the tag name that will be used to generate the tag with.\n\t *\n\t * @param {String} tagName\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetTagName : function( tagName ) {\n\t\tthis.tagName = tagName;\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves the tag name.\n\t *\n\t * @return {String}\n\t */\n\tgetTagName : function() {\n\t\treturn this.tagName || \"\";\n\t},\n\n\n\t/**\n\t * Sets an attribute on the HtmlTag.\n\t *\n\t * @param {String} attrName The attribute name to set.\n\t * @param {String} attrValue The attribute value to set.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetAttr : function( attrName, attrValue ) {\n\t\tvar tagAttrs = this.getAttrs();\n\t\ttagAttrs[ attrName ] = attrValue;\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n\t *\n\t * @param {String} name The attribute name to retrieve.\n\t * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n\t */\n\tgetAttr : function( attrName ) {\n\t\treturn this.getAttrs()[ attrName ];\n\t},\n\n\n\t/**\n\t * Sets one or more attributes on the HtmlTag.\n\t *\n\t * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetAttrs : function( attrs ) {\n\t\tvar tagAttrs = this.getAttrs();\n\t\tAutolinker.Util.assign( tagAttrs, attrs );\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves the attributes Object (map) for the HtmlTag.\n\t *\n\t * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n\t */\n\tgetAttrs : function() {\n\t\treturn this.attrs || ( this.attrs = {} );\n\t},\n\n\n\t/**\n\t * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n\t *\n\t * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetClass : function( cssClass ) {\n\t\treturn this.setAttr( 'class', cssClass );\n\t},\n\n\n\t/**\n\t * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n\t *\n\t * @param {String} cssClass One or more space-separated CSS classes to add.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\taddClass : function( cssClass ) {\n\t\tvar classAttr = this.getClass(),\n\t\t    whitespaceRegex = this.whitespaceRegex,\n\t\t    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n\t\t    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n\t\t    newClasses = cssClass.split( whitespaceRegex ),\n\t\t    newClass;\n\n\t\twhile( newClass = newClasses.shift() ) {\n\t\t\tif( indexOf( classes, newClass ) === -1 ) {\n\t\t\t\tclasses.push( newClass );\n\t\t\t}\n\t\t}\n\n\t\tthis.getAttrs()[ 'class' ] = classes.join( \" \" );\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convenience method to remove one or more CSS classes from the HtmlTag.\n\t *\n\t * @param {String} cssClass One or more space-separated CSS classes to remove.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tremoveClass : function( cssClass ) {\n\t\tvar classAttr = this.getClass(),\n\t\t    whitespaceRegex = this.whitespaceRegex,\n\t\t    indexOf = Autolinker.Util.indexOf,  // to support IE8 and below\n\t\t    classes = ( !classAttr ) ? [] : classAttr.split( whitespaceRegex ),\n\t\t    removeClasses = cssClass.split( whitespaceRegex ),\n\t\t    removeClass;\n\n\t\twhile( classes.length && ( removeClass = removeClasses.shift() ) ) {\n\t\t\tvar idx = indexOf( classes, removeClass );\n\t\t\tif( idx !== -1 ) {\n\t\t\t\tclasses.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\n\t\tthis.getAttrs()[ 'class' ] = classes.join( \" \" );\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n\t * there are multiple.\n\t *\n\t * @return {String}\n\t */\n\tgetClass : function() {\n\t\treturn this.getAttrs()[ 'class' ] || \"\";\n\t},\n\n\n\t/**\n\t * Convenience method to check if the tag has a CSS class or not.\n\t *\n\t * @param {String} cssClass The CSS class to check for.\n\t * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n\t */\n\thasClass : function( cssClass ) {\n\t\treturn ( ' ' + this.getClass() + ' ' ).indexOf( ' ' + cssClass + ' ' ) !== -1;\n\t},\n\n\n\t/**\n\t * Sets the inner HTML for the tag.\n\t *\n\t * @param {String} html The inner HTML to set.\n\t * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n\t */\n\tsetInnerHtml : function( html ) {\n\t\tthis.innerHtml = html;\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Retrieves the inner HTML for the tag.\n\t *\n\t * @return {String}\n\t */\n\tgetInnerHtml : function() {\n\t\treturn this.innerHtml || \"\";\n\t},\n\n\n\t/**\n\t * Override of superclass method used to generate the HTML string for the tag.\n\t *\n\t * @return {String}\n\t */\n\ttoAnchorString : function() {\n\t\tvar tagName = this.getTagName(),\n\t\t    attrsStr = this.buildAttrsStr();\n\n\t\tattrsStr = ( attrsStr ) ? ' ' + attrsStr : '';  // prepend a space if there are actually attributes\n\n\t\treturn [ '<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>' ].join( \"\" );\n\t},\n\n\n\t/**\n\t * Support method for {@link #toAnchorString}, returns the string space-separated key=\"value\" pairs, used to populate\n\t * the stringified HtmlTag.\n\t *\n\t * @protected\n\t * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n\t */\n\tbuildAttrsStr : function() {\n\t\tif( !this.attrs ) return \"\";  // no `attrs` Object (map) has been set, return empty string\n\n\t\tvar attrs = this.getAttrs(),\n\t\t    attrsArr = [];\n\n\t\tfor( var prop in attrs ) {\n\t\t\tif( attrs.hasOwnProperty( prop ) ) {\n\t\t\t\tattrsArr.push( prop + '=\"' + attrs[ prop ] + '\"' );\n\t\t\t}\n\t\t}\n\t\treturn attrsArr.join( \" \" );\n\t}\n\n} );\n\n/*global Autolinker */\n/*jshint sub:true */\n/**\n * @protected\n * @class Autolinker.AnchorTagBuilder\n * @extends Object\n *\n * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is found.\n *\n * Normally this class is instantiated, configured, and used internally by an {@link Autolinker} instance, but may\n * actually be retrieved in a {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag} instances\n * which may be modified before returning from the {@link Autolinker#replaceFn replaceFn}. For example:\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( autolinker, match ) {\n *             var tag = autolinker.getTagBuilder().build( match );  // returns an {@link Autolinker.HtmlTag} instance\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <a href=\"http-colon-slashslash google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n */\nAutolinker.AnchorTagBuilder = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {Boolean} newWindow\n\t * @inheritdoc Autolinker#newWindow\n\t */\n\n\t/**\n\t * @cfg {Number} truncate\n\t * @inheritdoc Autolinker#truncate\n\t */\n\n\t/**\n\t * @cfg {String} className\n\t * @inheritdoc Autolinker#className\n\t */\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\t},\n\n\n\t/**\n\t * Generates the actual anchor (&lt;a&gt;) tag to use in place of the\n\t * matched text, via its `match` object.\n\t *\n\t * @param {Autolinker.match.Match} match The Match instance to generate an\n\t *   anchor tag from.\n\t * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n\t */\n\tbuild : function( match ) {\n\t\tvar tag = new Autolinker.HtmlTag( {\n\t\t\ttagName   : 'a',\n\t\t\tattrs     : this.createAttrs( match.getType(), match.getAnchorHref() ),\n\t\t\tinnerHtml : this.processAnchorText( match.getAnchorText() )\n\t\t} );\n\n\t\treturn tag;\n\t},\n\n\n\t/**\n\t * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)\n\t *   tag being generated.\n\t *\n\t * @protected\n\t * @param {\"url\"/\"email\"/\"phone\"/\"twitter\"/\"hashtag\"} matchType The type of\n\t *   match that an anchor tag is being generated for.\n\t * @param {String} href The href for the anchor tag.\n\t * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n\t */\n\tcreateAttrs : function( matchType, anchorHref ) {\n\t\tvar attrs = {\n\t\t\t'href' : anchorHref  // we'll always have the `href` attribute\n\t\t};\n\n\t\tvar cssClass = this.createCssClass( matchType );\n\t\tif( cssClass ) {\n\t\t\tattrs[ 'class' ] = cssClass;\n\t\t}\n\t\tif( this.newWindow ) {\n\t\t\tattrs[ 'target' ] = \"_blank\";\n\t\t}\n\n\t\treturn attrs;\n\t},\n\n\n\t/**\n\t * Creates the CSS class that will be used for a given anchor tag, based on\n\t * the `matchType` and the {@link #className} config.\n\t *\n\t * @private\n\t * @param {\"url\"/\"email\"/\"phone\"/\"twitter\"/\"hashtag\"} matchType The type of\n\t *   match that an anchor tag is being generated for.\n\t * @return {String} The CSS class string for the link. Example return:\n\t *   \"myLink myLink-url\". If no {@link #className} was configured, returns\n\t *   an empty string.\n\t */\n\tcreateCssClass : function( matchType ) {\n\t\tvar className = this.className;\n\n\t\tif( !className )\n\t\t\treturn \"\";\n\t\telse\n\t\t\treturn className + \" \" + className + \"-\" + matchType;  // ex: \"myLink myLink-url\", \"myLink myLink-email\", \"myLink myLink-phone\", \"myLink myLink-twitter\", or \"myLink myLink-hashtag\"\n\t},\n\n\n\t/**\n\t * Processes the `anchorText` by truncating the text according to the\n\t * {@link #truncate} config.\n\t *\n\t * @private\n\t * @param {String} anchorText The anchor tag's text (i.e. what will be\n\t *   displayed).\n\t * @return {String} The processed `anchorText`.\n\t */\n\tprocessAnchorText : function( anchorText ) {\n\t\tanchorText = this.doTruncate( anchorText );\n\n\t\treturn anchorText;\n\t},\n\n\n\t/**\n\t * Performs the truncation of the `anchorText`, if the `anchorText` is\n\t * longer than the {@link #truncate} option. Truncates the text to 2\n\t * characters fewer than the {@link #truncate} option, and adds \"..\" to the\n\t * end.\n\t *\n\t * @private\n\t * @param {String} text The anchor tag's text (i.e. what will be displayed).\n\t * @return {String} The truncated anchor text.\n\t */\n\tdoTruncate : function( anchorText ) {\n\t\treturn Autolinker.Util.ellipsis( anchorText, this.truncate || Number.POSITIVE_INFINITY );\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @private\n * @class Autolinker.htmlParser.HtmlParser\n * @extends Object\n *\n * An HTML parser implementation which simply walks an HTML string and returns an array of\n * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n *\n * Autolinker uses this to only link URLs/emails/Twitter handles within text nodes, effectively ignoring / \"walking\n * around\" HTML tags.\n */\nAutolinker.htmlParser.HtmlParser = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @private\n\t * @property {RegExp} htmlRegex\n\t *\n\t * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n\t * attribute names, as specified by http-colon-slashslash www.w3.org/TR/html-markup/syntax.html.\n\t *\n\t * Capturing groups:\n\t *\n\t * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n\t * 2. If it is an end tag, this group will have the '/'.\n\t * 3. If it is a comment tag, this group will hold the comment text (i.e.\n\t *    the text inside the `&lt;!--` and `--&gt;`.\n\t * 4. The tag name for all tags (other than the &lt;!DOCTYPE&gt; tag)\n\t */\n\thtmlRegex : (function() {\n\t\tvar commentTagRegex = /!--([\\s\\S]+?)--/,\n\t\t    tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/,\n\t\t    attrNameRegex = /[^\\s\\0\"'>\\/=\\x01-\\x1F\\x7F]+/,   // the unicode range accounts for excluding control chars, and the delete char\n\t\t    attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n\t\t    nameEqualsValueRegex = attrNameRegex.source + '(?:\\\\s*=\\\\s*' + attrValueRegex.source + ')?';  // optional '=[value]'\n\n\t\treturn new RegExp( [\n\t\t\t// for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t'(?:',\n\t\t\t\t'<(!DOCTYPE)',  // *** Capturing Group 1 - If it's a doctype tag\n\n\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t'(?:',\n\t\t\t\t\t\t'\\\\s+',  // one or more whitespace chars before an attribute\n\n\t\t\t\t\t\t// Either:\n\t\t\t\t\t\t// A. attr=\"value\", or\n\t\t\t\t\t\t// B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n\t\t\t\t\t\t'(?:', nameEqualsValueRegex, '|', attrValueRegex.source + ')',\n\t\t\t\t\t')*',\n\t\t\t\t'>',\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t// All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n\t\t\t'(?:',\n\t\t\t\t'<(/)?',  // Beginning of a tag or comment. Either '<' for a start tag, or '</' for an end tag.\n\t\t\t\t          // *** Capturing Group 2: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n\n\t\t\t\t\t'(?:',\n\t\t\t\t\t\tcommentTagRegex.source,  // *** Capturing Group 3 - A Comment Tag's Text\n\n\t\t\t\t\t\t'|',\n\n\t\t\t\t\t\t'(?:',\n\n\t\t\t\t\t\t\t// *** Capturing Group 4 - The tag name\n\t\t\t\t\t\t\t'(' + tagNameRegex.source + ')',\n\n\t\t\t\t\t\t\t// Zero or more attributes following the tag name\n\t\t\t\t\t\t\t'(?:',\n\t\t\t\t\t\t\t\t'\\\\s+',                // one or more whitespace chars before an attribute\n\t\t\t\t\t\t\t\tnameEqualsValueRegex,  // attr=\"value\" (with optional =\"value\" part)\n\t\t\t\t\t\t\t')*',\n\n\t\t\t\t\t\t\t'\\\\s*/?',  // any trailing spaces and optional '/' before the closing '>'\n\n\t\t\t\t\t\t')',\n\t\t\t\t\t')',\n\t\t\t\t'>',\n\t\t\t')'\n\t\t].join( \"\" ), 'gi' );\n\t} )(),\n\n\t/**\n\t * @private\n\t * @property {RegExp} htmlCharacterEntitiesRegex\n\t *\n\t * The regular expression that matches common HTML character entities.\n\t *\n\t * Ignoring &amp; as it could be part of a query string -- handling it separately.\n\t */\n\thtmlCharacterEntitiesRegex: /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,\n\n\n\t/**\n\t * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}\n\t * to represent the HTML structure of the input string.\n\t *\n\t * @param {String} html The HTML to parse.\n\t * @return {Autolinker.htmlParser.HtmlNode[]}\n\t */\n\tparse : function( html ) {\n\t\tvar htmlRegex = this.htmlRegex,\n\t\t    currentResult,\n\t\t    lastIndex = 0,\n\t\t    textAndEntityNodes,\n\t\t    nodes = [];  // will be the result of the method\n\n\t\twhile( ( currentResult = htmlRegex.exec( html ) ) !== null ) {\n\t\t\tvar tagText = currentResult[ 0 ],\n\t\t\t    commentText = currentResult[ 3 ], // if we've matched a comment\n\t\t\t    tagName = currentResult[ 1 ] || currentResult[ 4 ],  // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n\t\t\t    isClosingTag = !!currentResult[ 2 ],\n\t\t\t    inBetweenTagsText = html.substring( lastIndex, currentResult.index );\n\n\t\t\t// Push TextNodes and EntityNodes for any text found between tags\n\t\t\tif( inBetweenTagsText ) {\n\t\t\t\ttextAndEntityNodes = this.parseTextAndEntityNodes( inBetweenTagsText );\n\t\t\t\tnodes.push.apply( nodes, textAndEntityNodes );\n\t\t\t}\n\n\t\t\t// Push the CommentNode or ElementNode\n\t\t\tif( commentText ) {\n\t\t\t\tnodes.push( this.createCommentNode( tagText, commentText ) );\n\t\t\t} else {\n\t\t\t\tnodes.push( this.createElementNode( tagText, tagName, isClosingTag ) );\n\t\t\t}\n\n\t\t\tlastIndex = currentResult.index + tagText.length;\n\t\t}\n\n\t\t// Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n\t\tif( lastIndex < html.length ) {\n\t\t\tvar text = html.substring( lastIndex );\n\n\t\t\t// Push TextNodes and EntityNodes for any text found between tags\n\t\t\tif( text ) {\n\t\t\t\ttextAndEntityNodes = this.parseTextAndEntityNodes( text );\n\t\t\t\tnodes.push.apply( nodes, textAndEntityNodes );\n\t\t\t}\n\t\t}\n\n\t\treturn nodes;\n\t},\n\n\n\t/**\n\t * Parses text and HTML entity nodes from a given string. The input string\n\t * should not have any HTML tags (elements) within it.\n\t *\n\t * @private\n\t * @param {String} text The text to parse.\n\t * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to\n\t *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and\n\t *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n\t */\n\tparseTextAndEntityNodes : function( text ) {\n\t\tvar nodes = [],\n\t\t    textAndEntityTokens = Autolinker.Util.splitAndCapture( text, this.htmlCharacterEntitiesRegex );  // split at HTML entities, but include the HTML entities in the results array\n\n\t\t// Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n\t\t// For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n\t\t//   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n\t\tfor( var i = 0, len = textAndEntityTokens.length; i < len; i += 2 ) {\n\t\t\tvar textToken = textAndEntityTokens[ i ],\n\t\t\t    entityToken = textAndEntityTokens[ i + 1 ];\n\n\t\t\tif( textToken ) nodes.push( this.createTextNode( textToken ) );\n\t\t\tif( entityToken ) nodes.push( this.createEntityNode( entityToken ) );\n\t\t}\n\t\treturn nodes;\n\t},\n\n\n\t/**\n\t * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.\n\t *\n\t * @private\n\t * @param {String} tagText The full text of the tag (comment) that was\n\t *   matched, including its &lt;!-- and --&gt;.\n\t * @param {String} comment The full text of the comment that was matched.\n\t */\n\tcreateCommentNode : function( tagText, commentText ) {\n\t\treturn new Autolinker.htmlParser.CommentNode( {\n\t\t\ttext: tagText,\n\t\t\tcomment: Autolinker.Util.trim( commentText )\n\t\t} );\n\t},\n\n\n\t/**\n\t * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n\t *\n\t * @private\n\t * @param {String} tagText The full text of the tag (element) that was\n\t *   matched, including its attributes.\n\t * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would\n\t *   be passed to this method as \"img\".\n\t * @param {Boolean} isClosingTag `true` if it's a closing tag, false\n\t *   otherwise.\n\t * @return {Autolinker.htmlParser.ElementNode}\n\t */\n\tcreateElementNode : function( tagText, tagName, isClosingTag ) {\n\t\treturn new Autolinker.htmlParser.ElementNode( {\n\t\t\ttext    : tagText,\n\t\t\ttagName : tagName.toLowerCase(),\n\t\t\tclosing : isClosingTag\n\t\t} );\n\t},\n\n\n\t/**\n\t * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n\t *\n\t * @private\n\t * @param {String} text The text that was matched for the HTML entity (such\n\t *   as '&amp;nbsp;').\n\t * @return {Autolinker.htmlParser.EntityNode}\n\t */\n\tcreateEntityNode : function( text ) {\n\t\treturn new Autolinker.htmlParser.EntityNode( { text: text } );\n\t},\n\n\n\t/**\n\t * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n\t *\n\t * @private\n\t * @param {String} text The text that was matched.\n\t * @return {Autolinker.htmlParser.TextNode}\n\t */\n\tcreateTextNode : function( text ) {\n\t\treturn new Autolinker.htmlParser.TextNode( { text: text } );\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @abstract\n * @class Autolinker.htmlParser.HtmlNode\n * \n * Represents an HTML node found in an input string. An HTML node is one of the following:\n * \n * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents HTML tags.\n * 2. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text outside or within HTML tags.\n * 3. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents one of the known HTML\n *    entities that Autolinker looks for. This includes common ones such as &amp;quot; and &amp;nbsp;\n */\nAutolinker.htmlParser.HtmlNode = Autolinker.Util.extend( Object, {\n\t\n\t/**\n\t * @cfg {String} text (required)\n\t * \n\t * The original text that was matched for the HtmlNode. \n\t * \n\t * - In the case of an {@link Autolinker.htmlParser.ElementNode ElementNode}, this will be the tag's\n\t *   text.\n\t * - In the case of a {@link Autolinker.htmlParser.TextNode TextNode}, this will be the text itself.\n\t * - In the case of a {@link Autolinker.htmlParser.EntityNode EntityNode}, this will be the text of\n\t *   the HTML entity.\n\t */\n\ttext : \"\",\n\t\n\t\n\t/**\n\t * @constructor\n\t * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\t},\n\n\t\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetType : Autolinker.Util.abstractMethod,\n\t\n\t\n\t/**\n\t * Retrieves the {@link #text} for the HtmlNode.\n\t * \n\t * @return {String}\n\t */\n\tgetText : function() {\n\t\treturn this.text;\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.CommentNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML comment node that has been parsed by the\n * {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nAutolinker.htmlParser.CommentNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\n\t/**\n\t * @cfg {String} comment (required)\n\t *\n\t * The text inside the comment tag. This text is stripped of any leading or\n\t * trailing whitespace.\n\t */\n\tcomment : '',\n\n\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'comment';\n\t},\n\n\n\t/**\n\t * Returns the comment inside the comment tag.\n\t *\n\t * @return {String}\n\t */\n\tgetComment : function() {\n\t\treturn this.comment;\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.ElementNode\n * @extends Autolinker.htmlParser.HtmlNode\n * \n * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n * \n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n */\nAutolinker.htmlParser.ElementNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\t\n\t/**\n\t * @cfg {String} tagName (required)\n\t * \n\t * The name of the tag that was matched.\n\t */\n\ttagName : '',\n\t\n\t/**\n\t * @cfg {Boolean} closing (required)\n\t * \n\t * `true` if the element (tag) is a closing tag, `false` if its an opening tag.\n\t */\n\tclosing : false,\n\n\t\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'element';\n\t},\n\t\n\n\t/**\n\t * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag, returns \"img\".\n\t * \n\t * @return {String}\n\t */\n\tgetTagName : function() {\n\t\treturn this.tagName;\n\t},\n\t\n\t\n\t/**\n\t * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt; returns\n\t * `false`, while &lt;/div&gt; returns `true`.\n\t * \n\t * @return {Boolean}\n\t */\n\tisClosing : function() {\n\t\treturn this.closing;\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.EntityNode\n * @extends Autolinker.htmlParser.HtmlNode\n * \n * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText} method.\n * \n * Note that this class will only be returned from the HtmlParser for the set of checked HTML entity nodes \n * defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.\n * \n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n */\nAutolinker.htmlParser.EntityNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\t\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'entity';\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.htmlParser.TextNode\n * @extends Autolinker.htmlParser.HtmlNode\n * \n * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n * \n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more details.\n */\nAutolinker.htmlParser.TextNode = Autolinker.Util.extend( Autolinker.htmlParser.HtmlNode, {\n\t\n\t/**\n\t * Returns a string name for the type of node that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'text';\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @private\n * @class Autolinker.matchParser.MatchParser\n * @extends Object\n *\n * Used by Autolinker to parse potential matches, given an input string of text.\n *\n * The MatchParser is fed a non-HTML string in order to search for matches.\n * Autolinker first uses the {@link Autolinker.htmlParser.HtmlParser} to \"walk\n * around\" HTML tags, and then the text around the HTML tags is passed into the\n * MatchParser in order to find the actual matches.\n */\nAutolinker.matchParser.MatchParser = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @cfg {Boolean} urls\n\t * @inheritdoc Autolinker#urls\n\t */\n\turls : true,\n\n\t/**\n\t * @cfg {Boolean} email\n\t * @inheritdoc Autolinker#email\n\t */\n\temail : true,\n\n\t/**\n\t * @cfg {Boolean} twitter\n\t * @inheritdoc Autolinker#twitter\n\t */\n\ttwitter : true,\n\n\t/**\n\t * @cfg {Boolean} phone\n\t * @inheritdoc Autolinker#phone\n\t */\n\tphone: true,\n\n\t/**\n\t * @cfg {Boolean/String} hashtag\n\t * @inheritdoc Autolinker#hashtag\n\t */\n\thashtag : false,\n\n\t/**\n\t * @cfg {Boolean} stripPrefix\n\t * @inheritdoc Autolinker#stripPrefix\n\t */\n\tstripPrefix : true,\n\n\n\t/**\n\t * @private\n\t * @property {RegExp} matcherRegex\n\t *\n\t * The regular expression that matches URLs, email addresses, phone #s,\n\t * Twitter handles, and Hashtags.\n\t *\n\t * This regular expression has the following capturing groups:\n\t *\n\t * 1.  Group that is used to determine if there is a Twitter handle match\n\t *     (i.e. \\@someTwitterUser). Simply check for its existence to determine\n\t *     if there is a Twitter handle match. The next couple of capturing\n\t *     groups give information about the Twitter handle match.\n\t * 2.  The whitespace character before the \\@sign in a Twitter handle. This\n\t *     is needed because there are no lookbehinds in JS regular expressions,\n\t *     and can be used to reconstruct the original string in a replace().\n\t * 3.  The Twitter handle itself in a Twitter match. If the match is\n\t *     '@someTwitterUser', the handle is 'someTwitterUser'.\n\t * 4.  Group that matches an email address. Used to determine if the match\n\t *     is an email address, as well as holding the full address. Ex:\n\t *     'me@my.com'\n\t * 5.  Group that matches a URL in the input text. Ex: 'http-colon-slashslash google.com',\n\t *     'www.google.com', or just 'google.com'. This also includes a path,\n\t *     url parameters, or hash anchors. Ex: google.com/path/to/file?q1=1&q2=2#myAnchor\n\t * 6.  Group that matches a protocol URL (i.e. 'http-colon-slashslash google.com'). This is\n\t *     used to match protocol URLs with just a single word, like 'http-colon-slashslash localhost',\n\t *     where we won't double check that the domain name has at least one '.'\n\t *     in it.\n\t * 7.  A protocol-relative ('//') match for the case of a 'www.' prefixed\n\t *     URL. Will be an empty string if it is not a protocol-relative match.\n\t *     We need to know the character before the '//' in order to determine\n\t *     if it is a valid match or the // was in a string we don't want to\n\t *     auto-link.\n\t * 8.  A protocol-relative ('//') match for the case of a known TLD prefixed\n\t *     URL. Will be an empty string if it is not a protocol-relative match.\n\t *     See #6 for more info.\n\t * 9.  Group that is used to determine if there is a phone number match. The\n\t *     next 3 groups give segments of the phone number.\n\t * 10. Group that is used to determine if there is a Hashtag match\n\t *     (i.e. \\#someHashtag). Simply check for its existence to determine if\n\t *     there is a Hashtag match. The next couple of capturing groups give\n\t *     information about the Hashtag match.\n\t * 11. The whitespace character before the #sign in a Hashtag handle. This\n\t *     is needed because there are no look-behinds in JS regular\n\t *     expressions, and can be used to reconstruct the original string in a\n\t *     replace().\n\t * 12. The Hashtag itself in a Hashtag match. If the match is\n\t *     '#someHashtag', the hashtag is 'someHashtag'.\n\t */\n\tmatcherRegex : (function() {\n\t\tvar twitterRegex = /(^|[^\\w])@(\\w{1,15})/,              // For matching a twitter handle. Ex: @gregory_jacobs\n\n\t\t    hashtagRegex = /(^|[^\\w])#(\\w{1,15})/,              // For matching a Hashtag. Ex: #games\n\n\t\t    emailRegex = /(?:[\\-;:&=\\+\\$,\\w\\.]+@)/,             // something@ for email addresses (a.k.a. local-part)\n\t\t    phoneRegex = /(?:\\+?\\d{1,3}[-\\s.])?\\(?\\d{3}\\)?[-\\s.]?\\d{3}[-\\s.]\\d{4}/,  // ex: (123) 456-7890, 123 456 7890, 123-456-7890, etc.\n\t\t    protocolRegex = /(?:[A-Za-z][-.+A-Za-z0-9]+:(?![A-Za-z][-.+A-Za-z0-9]+:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/,  // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n\t\t    wwwRegex = /(?:www\\.)/,                             // starting with 'www.'\n\t\t    domainNameRegex = /[A-Za-z0-9\\.\\-]*[A-Za-z0-9\\-]/,  // anything looking at all like a domain, non-unicode domains, not ending in a period\n\t\t    tldRegex = /\\.(?:international|construction|contractors|enterprises|photography|productions|foundation|immobilien|industries|management|properties|technology|christmas|community|directory|education|equipment|institute|marketing|solutions|vacations|bargains|boutique|builders|catering|cleaning|clothing|computer|democrat|diamonds|graphics|holdings|lighting|partners|plumbing|supplies|training|ventures|academy|careers|company|cruises|domains|exposed|flights|florist|gallery|guitars|holiday|kitchen|neustar|okinawa|recipes|rentals|reviews|shiksha|singles|support|systems|agency|berlin|camera|center|coffee|condos|dating|estate|events|expert|futbol|kaufen|luxury|maison|monash|museum|nagoya|photos|repair|report|social|supply|tattoo|tienda|travel|viajes|villas|vision|voting|voyage|actor|build|cards|cheap|codes|dance|email|glass|house|mango|ninja|parts|photo|shoes|solar|today|tokyo|tools|watch|works|aero|arpa|asia|best|bike|blue|buzz|camp|club|cool|coop|farm|fish|gift|guru|info|jobs|kiwi|kred|land|limo|link|menu|mobi|moda|name|pics|pink|post|qpon|rich|ruhr|sexy|tips|vote|voto|wang|wien|wiki|zone|bar|bid|biz|cab|cat|ceo|com|edu|gov|int|kim|mil|net|onl|org|pro|pub|red|tel|uno|wed|xxx|xyz|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw)\\b/,   // match our known top level domains (TLDs)\n\n\t\t    // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n\t\t    // http://blog.codinghorror.com/the-problem-with-urls/\n\t\t    urlSuffixRegex = /[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]?!:,.;]*[\\-A-Za-z0-9+&@#\\/%=~_()|'$*\\[\\]]/;\n\n\t\treturn new RegExp( [\n\t\t\t'(',  // *** Capturing group $1, which can be used to check for a twitter handle match. Use group $3 for the actual twitter handle though. $2 may be used to reconstruct the original string in a replace()\n\t\t\t\t// *** Capturing group $2, which matches the whitespace character before the '@' sign (needed because of no lookbehinds), and\n\t\t\t\t// *** Capturing group $3, which matches the actual twitter handle\n\t\t\t\ttwitterRegex.source,\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t'(',  // *** Capturing group $4, which is used to determine an email match\n\t\t\t\temailRegex.source,\n\t\t\t\tdomainNameRegex.source,\n\t\t\t\ttldRegex.source,\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t'(',  // *** Capturing group $5, which is used to match a URL\n\t\t\t\t'(?:', // parens to cover match for protocol (optional), and domain\n\t\t\t\t\t'(',  // *** Capturing group $6, for a protocol-prefixed url (ex: http://google.com)\n\t\t\t\t\t\tprotocolRegex.source,\n\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t')',\n\n\t\t\t\t\t'|',\n\n\t\t\t\t\t'(?:',  // non-capturing paren for a 'www.' prefixed url (ex: www.google.com)\n\t\t\t\t\t\t'(.?//)?',  // *** Capturing group $7 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n\t\t\t\t\t\twwwRegex.source,\n\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t')',\n\n\t\t\t\t\t'|',\n\n\t\t\t\t\t'(?:',  // non-capturing paren for known a TLD url (ex: google.com)\n\t\t\t\t\t\t'(.?//)?',  // *** Capturing group $8 for an optional protocol-relative URL. Must be at the beginning of the string or start with a non-word character\n\t\t\t\t\t\tdomainNameRegex.source,\n\t\t\t\t\t\ttldRegex.source,\n\t\t\t\t\t')',\n\t\t\t\t')',\n\n\t\t\t\t'(?:' + urlSuffixRegex.source + ')?',  // match for path, query string, and/or hash anchor - optional\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t// this setup does not scale well for open extension :( Need to rethink design of autolinker...\n\t\t\t// ***  Capturing group $9, which matches a (USA for now) phone number\n\t\t\t'(',\n\t\t\t\tphoneRegex.source,\n\t\t\t')',\n\n\t\t\t'|',\n\n\t\t\t'(',  // *** Capturing group $10, which can be used to check for a Hashtag match. Use group $12 for the actual Hashtag though. $11 may be used to reconstruct the original string in a replace()\n\t\t\t\t// *** Capturing group $11, which matches the whitespace character before the '#' sign (needed because of no lookbehinds), and\n\t\t\t\t// *** Capturing group $12, which matches the actual Hashtag\n\t\t\t\thashtagRegex.source,\n\t\t\t')'\n\t\t].join( \"\" ), 'gi' );\n\t} )(),\n\n\t/**\n\t * @private\n\t * @property {RegExp} charBeforeProtocolRelMatchRegex\n\t *\n\t * The regular expression used to retrieve the character before a\n\t * protocol-relative URL match.\n\t *\n\t * This is used in conjunction with the {@link #matcherRegex}, which needs\n\t * to grab the character before a protocol-relative '//' due to the lack of\n\t * a negative look-behind in JavaScript regular expressions. The character\n\t * before the match is stripped from the URL.\n\t */\n\tcharBeforeProtocolRelMatchRegex : /^(.)?\\/\\//,\n\n\t/**\n\t * @private\n\t * @property {Autolinker.MatchValidator} matchValidator\n\t *\n\t * The MatchValidator object, used to filter out any false positives from\n\t * the {@link #matcherRegex}. See {@link Autolinker.MatchValidator} for details.\n\t */\n\n\n\t/**\n\t * @constructor\n\t * @param {Object} [cfg] The configuration options for the AnchorTagBuilder\n\t * instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\n\t\tthis.matchValidator = new Autolinker.MatchValidator();\n\t},\n\n\n\t/**\n\t * Parses the input `text` to search for matches, and calls the `replaceFn`\n\t * to allow replacements of the matches. Returns the `text` with matches\n\t * replaced.\n\t *\n\t * @param {String} text The text to search and repace matches in.\n\t * @param {Function} replaceFn The iterator function to handle the\n\t *   replacements. The function takes a single argument, a {@link Autolinker.match.Match}\n\t *   object, and should return the text that should make the replacement.\n\t * @param {Object} [contextObj=window] The context object (\"scope\") to run\n\t *   the `replaceFn` in.\n\t * @return {String}\n\t */\n\treplace : function( text, replaceFn, contextObj ) {\n\t\tvar me = this;  // for closure\n\n\t\treturn text.replace( this.matcherRegex, function( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 ) {\n\t\t\tvar matchDescObj = me.processCandidateMatch( matchStr, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12 );  // \"match description\" object\n\n\t\t\t// Return out with no changes for match types that are disabled (url,\n\t\t\t// email, phone, etc.), or for matches that are invalid (false\n\t\t\t// positives from the matcherRegex, which can't use look-behinds\n\t\t\t// since they are unavailable in JS).\n\t\t\tif( !matchDescObj ) {\n\t\t\t\treturn matchStr;\n\n\t\t\t} else {\n\t\t\t\t// Generate replacement text for the match from the `replaceFn`\n\t\t\t\tvar replaceStr = replaceFn.call( contextObj, matchDescObj.match );\n\t\t\t\treturn matchDescObj.prefixStr + replaceStr + matchDescObj.suffixStr;\n\t\t\t}\n\t\t} );\n\t},\n\n\n\t/**\n\t * Processes a candidate match from the {@link #matcherRegex}.\n\t *\n\t * Not all matches found by the regex are actual URL/Email/Phone/Twitter/Hashtag\n\t * matches, as determined by the {@link #matchValidator}. In this case, the\n\t * method returns `null`. Otherwise, a valid Object with `prefixStr`,\n\t * `match`, and `suffixStr` is returned.\n\t *\n\t * @private\n\t * @param {String} matchStr The full match that was found by the\n\t *   {@link #matcherRegex}.\n\t * @param {String} twitterMatch The matched text of a Twitter handle, if the\n\t *   match is a Twitter match.\n\t * @param {String} twitterHandlePrefixWhitespaceChar The whitespace char\n\t *   before the @ sign in a Twitter handle match. This is needed because of\n\t *   no lookbehinds in JS regexes, and is need to re-include the character\n\t *   for the anchor tag replacement.\n\t * @param {String} twitterHandle The actual Twitter user (i.e the word after\n\t *   the @ sign in a Twitter match).\n\t * @param {String} emailAddressMatch The matched email address for an email\n\t *   address match.\n\t * @param {String} urlMatch The matched URL string for a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http-colon-slashslash yahoo.com'. This is used to match something like\n\t *   'http-colon-slashslash localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @param {String} wwwProtocolRelativeMatch The '//' for a protocol-relative\n\t *   match from a 'www' url, with the character that comes before the '//'.\n\t * @param {String} tldProtocolRelativeMatch The '//' for a protocol-relative\n\t *   match from a TLD (top level domain) match, with the character that\n\t *   comes before the '//'.\n\t * @param {String} phoneMatch The matched text of a phone number\n\t * @param {String} hashtagMatch The matched text of a Twitter\n\t *   Hashtag, if the match is a Hashtag match.\n\t * @param {String} hashtagPrefixWhitespaceChar The whitespace char\n\t *   before the # sign in a Hashtag match. This is needed because of no\n\t *   lookbehinds in JS regexes, and is need to re-include the character for\n\t *   the anchor tag replacement.\n\t * @param {String} hashtag The actual Hashtag (i.e the word\n\t *   after the # sign in a Hashtag match).\n\t *\n\t * @return {Object} A \"match description object\". This will be `null` if the\n\t *   match was invalid, or if a match type is disabled. Otherwise, this will\n\t *   be an Object (map) with the following properties:\n\t * @return {String} return.prefixStr The char(s) that should be prepended to\n\t *   the replacement string. These are char(s) that were needed to be\n\t *   included from the regex match that were ignored by processing code, and\n\t *   should be re-inserted into the replacement stream.\n\t * @return {String} return.suffixStr The char(s) that should be appended to\n\t *   the replacement string. These are char(s) that were needed to be\n\t *   included from the regex match that were ignored by processing code, and\n\t *   should be re-inserted into the replacement stream.\n\t * @return {Autolinker.match.Match} return.match The Match object that\n\t *   represents the match that was found.\n\t */\n\tprocessCandidateMatch : function(\n\t\tmatchStr, twitterMatch, twitterHandlePrefixWhitespaceChar, twitterHandle,\n\t\temailAddressMatch, urlMatch, protocolUrlMatch, wwwProtocolRelativeMatch,\n\t\ttldProtocolRelativeMatch, phoneMatch, hashtagMatch,\n\t\thashtagPrefixWhitespaceChar, hashtag\n\t) {\n\t\t// Note: The `matchStr` variable wil be fixed up to remove characters that are no longer needed (which will\n\t\t// be added to `prefixStr` and `suffixStr`).\n\n\t\tvar protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch,\n\t\t    match,  // Will be an Autolinker.match.Match object\n\n\t\t    prefixStr = \"\",  // A string to use to prefix the anchor tag that is created. This is needed for the Twitter and Hashtag matches.\n\t\t    suffixStr = \"\";  // A string to suffix the anchor tag that is created. This is used if there is a trailing parenthesis that should not be auto-linked.\n\n\t\t// Return out with `null` for match types that are disabled (url, email,\n\t\t// twitter, hashtag), or for matches that are invalid (false positives\n\t\t// from the matcherRegex, which can't use look-behinds since they are\n\t\t// unavailable in JS).\n\t\tif(\n\t\t\t( urlMatch && !this.urls ) ||\n\t\t\t( emailAddressMatch && !this.email ) ||\n\t\t\t( phoneMatch && !this.phone ) ||\n\t\t\t( twitterMatch && !this.twitter ) ||\n\t\t\t( hashtagMatch && !this.hashtag ) ||\n\t\t\t!this.matchValidator.isValidMatch( urlMatch, protocolUrlMatch, protocolRelativeMatch )\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Handle a closing parenthesis at the end of the match, and exclude it\n\t\t// if there is not a matching open parenthesis\n\t\t// in the match itself.\n\t\tif( this.matchHasUnbalancedClosingParen( matchStr ) ) {\n\t\t\tmatchStr = matchStr.substr( 0, matchStr.length - 1 );  // remove the trailing \")\"\n\t\t\tsuffixStr = \")\";  // this will be added after the generated <a> tag\n\t\t}\n\n\t\tif( emailAddressMatch ) {\n\t\t\tmatch = new Autolinker.match.Email( { matchedText: matchStr, email: emailAddressMatch } );\n\n\t\t} else if( twitterMatch ) {\n\t\t\t// fix up the `matchStr` if there was a preceding whitespace char,\n\t\t\t// which was needed to determine the match itself (since there are\n\t\t\t// no look-behinds in JS regexes)\n\t\t\tif( twitterHandlePrefixWhitespaceChar ) {\n\t\t\t\tprefixStr = twitterHandlePrefixWhitespaceChar;\n\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match\n\t\t\t}\n\t\t\tmatch = new Autolinker.match.Twitter( { matchedText: matchStr, twitterHandle: twitterHandle } );\n\n\t\t} else if( phoneMatch ) {\n\t\t\t// remove non-numeric values from phone number string\n\t\t\tvar cleanNumber = matchStr.replace( /\\D/g, '' );\n \t\t\tmatch = new Autolinker.match.Phone( { matchedText: matchStr, number: cleanNumber } );\n\n\t\t} else if( hashtagMatch ) {\n\t\t\t// fix up the `matchStr` if there was a preceding whitespace char,\n\t\t\t// which was needed to determine the match itself (since there are\n\t\t\t// no look-behinds in JS regexes)\n\t\t\tif( hashtagPrefixWhitespaceChar ) {\n\t\t\t\tprefixStr = hashtagPrefixWhitespaceChar;\n\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed whitespace char from the match\n\t\t\t}\n\t\t\tmatch = new Autolinker.match.Hashtag( { matchedText: matchStr, serviceName: this.hashtag, hashtag: hashtag } );\n\n\t\t} else {  // url match\n\t\t\t// If it's a protocol-relative '//' match, remove the character\n\t\t\t// before the '//' (which the matcherRegex needed to match due to\n\t\t\t// the lack of a negative look-behind in JavaScript regular\n\t\t\t// expressions)\n\t\t\tif( protocolRelativeMatch ) {\n\t\t\t\tvar charBeforeMatch = protocolRelativeMatch.match( this.charBeforeProtocolRelMatchRegex )[ 1 ] || \"\";\n\n\t\t\t\tif( charBeforeMatch ) {  // fix up the `matchStr` if there was a preceding char before a protocol-relative match, which was needed to determine the match itself (since there are no look-behinds in JS regexes)\n\t\t\t\t\tprefixStr = charBeforeMatch;\n\t\t\t\t\tmatchStr = matchStr.slice( 1 );  // remove the prefixed char from the match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmatch = new Autolinker.match.Url( {\n\t\t\t\tmatchedText : matchStr,\n\t\t\t\turl : matchStr,\n\t\t\t\tprotocolUrlMatch : !!protocolUrlMatch,\n\t\t\t\tprotocolRelativeMatch : !!protocolRelativeMatch,\n\t\t\t\tstripPrefix : this.stripPrefix\n\t\t\t} );\n\t\t}\n\n\t\treturn {\n\t\t\tprefixStr : prefixStr,\n\t\t\tsuffixStr : suffixStr,\n\t\t\tmatch     : match\n\t\t};\n\t},\n\n\n\t/**\n\t * Determines if a match found has an unmatched closing parenthesis. If so,\n\t * this parenthesis will be removed from the match itself, and appended\n\t * after the generated anchor tag in {@link #processCandidateMatch}.\n\t *\n\t * A match may have an extra closing parenthesis at the end of the match\n\t * because the regular expression must include parenthesis for URLs such as\n\t * \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n\t *\n\t * However, an extra parenthesis *will* be included when the URL itself is\n\t * wrapped in parenthesis, such as in the case of \"(wikipedia.com/something_(disambiguation))\".\n\t * In this case, the last closing parenthesis should *not* be part of the\n\t * URL itself, and this method will return `true`.\n\t *\n\t * @private\n\t * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n\t * @return {Boolean} `true` if there is an unbalanced closing parenthesis at\n\t *   the end of the `matchStr`, `false` otherwise.\n\t */\n\tmatchHasUnbalancedClosingParen : function( matchStr ) {\n\t\tvar lastChar = matchStr.charAt( matchStr.length - 1 );\n\n\t\tif( lastChar === ')' ) {\n\t\t\tvar openParensMatch = matchStr.match( /\\(/g ),\n\t\t\t    closeParensMatch = matchStr.match( /\\)/g ),\n\t\t\t    numOpenParens = ( openParensMatch && openParensMatch.length ) || 0,\n\t\t\t    numCloseParens = ( closeParensMatch && closeParensMatch.length ) || 0;\n\n\t\t\tif( numOpenParens < numCloseParens ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n} );\n/*global Autolinker */\n/*jshint scripturl:true */\n/**\n * @private\n * @class Autolinker.MatchValidator\n * @extends Object\n *\n * Used by Autolinker to filter out false positives from the\n * {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n *\n * Due to the limitations of regular expressions (including the missing feature\n * of look-behinds in JS regular expressions), we cannot always determine the\n * validity of a given match. This class applies a bit of additional logic to\n * filter out any false positives that have been matched by the\n * {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n */\nAutolinker.MatchValidator = Autolinker.Util.extend( Object, {\n\n\t/**\n\t * @private\n\t * @property {RegExp} invalidProtocolRelMatchRegex\n\t *\n\t * The regular expression used to check a potential protocol-relative URL\n\t * match, coming from the {@link Autolinker.matchParser.MatchParser#matcherRegex}.\n\t * A protocol-relative URL is, for example, \"//yahoo.com\"\n\t *\n\t * This regular expression checks to see if there is a word character before\n\t * the '//' match in order to determine if we should actually autolink a\n\t * protocol-relative URL. This is needed because there is no negative\n\t * look-behind in JavaScript regular expressions.\n\t *\n\t * For instance, we want to autolink something like \"Go to: //google.com\",\n\t * but we don't want to autolink something like \"abc//google.com\"\n\t */\n\tinvalidProtocolRelMatchRegex : /^[\\w]\\/\\//,\n\n\t/**\n\t * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http-colon-slashslash '\n\t *\n\t * @private\n\t * @property {RegExp} hasFullProtocolRegex\n\t */\n\thasFullProtocolRegex : /^[A-Za-z][-.+A-Za-z0-9]+:\\/\\//,\n\n\t/**\n\t * Regex to find the URI scheme, such as 'mailto:'.\n\t *\n\t * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n\t *\n\t * @private\n\t * @property {RegExp} uriSchemeRegex\n\t */\n\turiSchemeRegex : /^[A-Za-z][-.+A-Za-z0-9]+:/,\n\n\t/**\n\t * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n\t *\n\t * @private\n\t * @property {RegExp} hasWordCharAfterProtocolRegex\n\t */\n\thasWordCharAfterProtocolRegex : /:[^\\s]*?[A-Za-z]/,\n\n\n\t/**\n\t * Determines if a given match found by the {@link Autolinker.matchParser.MatchParser}\n\t * is valid. Will return `false` for:\n\t *\n\t * 1) URL matches which do not have at least have one period ('.') in the\n\t *    domain name (effectively skipping over matches like \"abc:def\").\n\t *    However, URL matches with a protocol will be allowed (ex: 'http-colon-slashslash localhost')\n\t * 2) URL matches which do not have at least one word character in the\n\t *    domain name (effectively skipping over matches like \"git:1.0\").\n\t * 3) A protocol-relative url match (a URL beginning with '//') whose\n\t *    previous character is a word character (effectively skipping over\n\t *    strings like \"abc//google.com\")\n\t *\n\t * Otherwise, returns `true`.\n\t *\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http-colon-slashslash yahoo.com'. This is used to match something like\n\t *   'http-colon-slashslash localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @param {String} protocolRelativeMatch The protocol-relative string for a\n\t *   URL match (i.e. '//'), possibly with a preceding character (ex, a\n\t *   space, such as: ' //', or a letter, such as: 'a//'). The match is\n\t *   invalid if there is a word character preceding the '//'.\n\t * @return {Boolean} `true` if the match given is valid and should be\n\t *   processed, or `false` if the match is invalid and/or should just not be\n\t *   processed.\n\t */\n\tisValidMatch : function( urlMatch, protocolUrlMatch, protocolRelativeMatch ) {\n\t\tif(\n\t\t\t( protocolUrlMatch && !this.isValidUriScheme( protocolUrlMatch ) ) ||\n\t\t\tthis.urlMatchDoesNotHaveProtocolOrDot( urlMatch, protocolUrlMatch ) ||       // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n\t\t\tthis.urlMatchDoesNotHaveAtLeastOneWordChar( urlMatch, protocolUrlMatch ) ||  // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n\t\t\tthis.isInvalidProtocolRelativeMatch( protocolRelativeMatch )                 // A protocol-relative match which has a word character in front of it (so we can skip something like \"abc//google.com\")\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\n\t/**\n\t * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n\t * `false` if the scheme is 'javascript:' or 'vbscript:'\n\t *\n\t * @private\n\t * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n\t *   match. Ex: 'http-colon-slashslash yahoo.com' or 'mailto:a@a.com'.\n\t * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n\t */\n\tisValidUriScheme : function( uriSchemeMatch ) {\n\t\tvar uriScheme = uriSchemeMatch.match( this.uriSchemeRegex )[ 0 ].toLowerCase();\n\n\t\treturn ( uriScheme !== 'javascript:' && uriScheme !== 'vbscript:' );\n\t},\n\n\n\t/**\n\t * Determines if a URL match does not have either:\n\t *\n\t * a) a full protocol (i.e. 'http-colon-slashslash '), or\n\t * b) at least one dot ('.') in the domain name (for a non-full-protocol\n\t *    match).\n\t *\n\t * Either situation is considered an invalid URL (ex: 'git:d' does not have\n\t * either the '://' part, or at least one dot in the domain name. If the\n\t * match was 'git:abc.com', we would consider this valid.)\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http-colon-slashslash yahoo.com'. This is used to match something like\n\t *   'http-colon-slashslash localhost', where we won't double check that the domain name\n\t *   has at least one '.' in it.\n\t * @return {Boolean} `true` if the URL match does not have a full protocol,\n\t *   or at least one dot ('.') in a non-full-protocol match.\n\t */\n\turlMatchDoesNotHaveProtocolOrDot : function( urlMatch, protocolUrlMatch ) {\n\t\treturn ( !!urlMatch && ( !protocolUrlMatch || !this.hasFullProtocolRegex.test( protocolUrlMatch ) ) && urlMatch.indexOf( '.' ) === -1 );\n\t},\n\n\n\t/**\n\t * Determines if a URL match does not have at least one word character after\n\t * the protocol (i.e. in the domain name).\n\t *\n\t * At least one letter character must exist in the domain name after a\n\t * protocol match. Ex: skip over something like \"git:1.0\"\n\t *\n\t * @private\n\t * @param {String} urlMatch The matched URL, if there was one. Will be an\n\t *   empty string if the match is not a URL match.\n\t * @param {String} protocolUrlMatch The match URL string for a protocol\n\t *   match. Ex: 'http-colon-slashslash yahoo.com'. This is used to know whether or not we\n\t *   have a protocol in the URL string, in order to check for a word\n\t *   character after the protocol separator (':').\n\t * @return {Boolean} `true` if the URL match does not have at least one word\n\t *   character in it after the protocol, `false` otherwise.\n\t */\n\turlMatchDoesNotHaveAtLeastOneWordChar : function( urlMatch, protocolUrlMatch ) {\n\t\tif( urlMatch && protocolUrlMatch ) {\n\t\t\treturn !this.hasWordCharAfterProtocolRegex.test( urlMatch );\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\n\n\t/**\n\t * Determines if a protocol-relative match is an invalid one. This method\n\t * returns `true` if there is a `protocolRelativeMatch`, and that match\n\t * contains a word character before the '//' (i.e. it must contain\n\t * whitespace or nothing before the '//' in order to be considered valid).\n\t *\n\t * @private\n\t * @param {String} protocolRelativeMatch The protocol-relative string for a\n\t *   URL match (i.e. '//'), possibly with a preceding character (ex, a\n\t *   space, such as: ' //', or a letter, such as: 'a//'). The match is\n\t *   invalid if there is a word character preceding the '//'.\n\t * @return {Boolean} `true` if it is an invalid protocol-relative match,\n\t *   `false` otherwise.\n\t */\n\tisInvalidProtocolRelativeMatch : function( protocolRelativeMatch ) {\n\t\treturn ( !!protocolRelativeMatch && this.invalidProtocolRelMatchRegex.test( protocolRelativeMatch ) );\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @abstract\n * @class Autolinker.match.Match\n * \n * Represents a match found in an input string which should be Autolinked. A Match object is what is provided in a \n * {@link Autolinker#replaceFn replaceFn}, and may be used to query for details about the match.\n * \n * For example:\n * \n *     var input = \"...\";  // string with URLs, Email Addresses, and Twitter Handles\n *     \n *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( autolinker, match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *         \n *             switch( match.getType() ) {\n *                 case 'url' : \n *                     console.log( \"url: \", match.getUrl() );\n *                     \n *                 case 'email' :\n *                     console.log( \"email: \", match.getEmail() );\n *                     \n *                 case 'twitter' :\n *                     console.log( \"twitter: \", match.getTwitterHandle() );\n *             }\n *         }\n *     } );\n *     \n * See the {@link Autolinker} class for more details on using the {@link Autolinker#replaceFn replaceFn}.\n */\nAutolinker.match.Match = Autolinker.Util.extend( Object, {\n\t\n\t/**\n\t * @cfg {String} matchedText (required)\n\t * \n\t * The original text that was matched.\n\t */\n\t\n\t\n\t/**\n\t * @constructor\n\t * @param {Object} cfg The configuration properties for the Match instance, specified in an Object (map).\n\t */\n\tconstructor : function( cfg ) {\n\t\tAutolinker.Util.assign( this, cfg );\n\t},\n\n\t\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetType : Autolinker.Util.abstractMethod,\n\t\n\t\n\t/**\n\t * Returns the original text that was matched.\n\t * \n\t * @return {String}\n\t */\n\tgetMatchedText : function() {\n\t\treturn this.matchedText;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetAnchorHref : Autolinker.Util.abstractMethod,\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @abstract\n\t * @return {String}\n\t */\n\tgetAnchorText : Autolinker.Util.abstractMethod\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Email\n * @extends Autolinker.match.Match\n * \n * Represents a Email match found in an input string which should be Autolinked.\n * \n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nAutolinker.match.Email = Autolinker.Util.extend( Autolinker.match.Match, {\n\t\n\t/**\n\t * @cfg {String} email (required)\n\t * \n\t * The email address that was matched.\n\t */\n\t\n\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'email';\n\t},\n\t\n\t\n\t/**\n\t * Returns the email address that was matched.\n\t * \n\t * @return {String}\n\t */\n\tgetEmail : function() {\n\t\treturn this.email;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\treturn 'mailto:' + this.email;\n\t},\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn this.email;\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Hashtag\n * @extends Autolinker.match.Match\n *\n * Represents a Hashtag match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nAutolinker.match.Hashtag = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t/**\n\t * @cfg {String} serviceName (required)\n\t *\n\t * The service to point hashtag matches to. See {@link Autolinker#hashtag}\n\t * for available values.\n\t */\n\n\t/**\n\t * @cfg {String} hashtag (required)\n\t *\n\t * The Hashtag that was matched, without the '#'.\n\t */\n\n\n\t/**\n\t * Returns the type of match that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'hashtag';\n\t},\n\n\n\t/**\n\t * Returns the matched hashtag.\n\t *\n\t * @return {String}\n\t */\n\tgetHashtag : function() {\n\t\treturn this.hashtag;\n\t},\n\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\tvar serviceName = this.serviceName,\n\t\t    hashtag = this.hashtag;\n\n\t\tswitch( serviceName ) {\n\t\t\tcase 'twitter' :\n\t\t\t\treturn 'https://twitter.com/hashtag/' + hashtag;\n\t\t\tcase 'facebook' :\n\t\t\t\treturn 'https://www.facebook.com/hashtag/' + hashtag;\n\n\t\t\tdefault :  // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n\t\t\t\tthrow new Error( 'Unknown service name to point hashtag to: ', serviceName );\n\t\t}\n\t},\n\n\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn '#' + this.hashtag;\n\t}\n\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Phone\n * @extends Autolinker.match.Match\n *\n * Represents a Phone number match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nAutolinker.match.Phone = Autolinker.Util.extend( Autolinker.match.Match, {\n\n\t/**\n\t * @cfg {String} number (required)\n\t *\n\t * The phone number that was matched.\n\t */\n\n\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t *\n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'phone';\n\t},\n\n\n\t/**\n\t * Returns the phone number that was matched.\n\t *\n\t * @return {String}\n\t */\n\tgetNumber: function() {\n\t\treturn this.number;\n\t},\n\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\treturn 'tel:' + this.number;\n\t},\n\n\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t *\n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn this.matchedText;\n\t}\n\n} );\n\n/*global Autolinker */\n/**\n * @class Autolinker.match.Twitter\n * @extends Autolinker.match.Match\n * \n * Represents a Twitter match found in an input string which should be Autolinked.\n * \n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nAutolinker.match.Twitter = Autolinker.Util.extend( Autolinker.match.Match, {\n\t\n\t/**\n\t * @cfg {String} twitterHandle (required)\n\t * \n\t * The Twitter handle that was matched.\n\t */\n\t\n\n\t/**\n\t * Returns the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'twitter';\n\t},\n\t\n\t\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetTwitterHandle : function() {\n\t\treturn this.twitterHandle;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\treturn 'https://twitter.com/' + this.twitterHandle;\n\t},\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\treturn '@' + this.twitterHandle;\n\t}\n\t\n} );\n/*global Autolinker */\n/**\n * @class Autolinker.match.Url\n * @extends Autolinker.match.Match\n * \n * Represents a Url match found in an input string which should be Autolinked.\n * \n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nAutolinker.match.Url = Autolinker.Util.extend( Autolinker.match.Match, {\n\t\n\t/**\n\t * @cfg {String} url (required)\n\t * \n\t * The url that was matched.\n\t */\n\t\n\t/**\n\t * @cfg {Boolean} protocolUrlMatch (required)\n\t * \n\t * `true` if the URL is a match which already has a protocol (i.e. 'http-colon-slashslash '), `false` if the match was from a 'www' or\n\t * known TLD match.\n\t */\n\t\n\t/**\n\t * @cfg {Boolean} protocolRelativeMatch (required)\n\t * \n\t * `true` if the URL is a protocol-relative match. A protocol-relative match is a URL that starts with '//',\n\t * and will be either http-colon-slashslash  or https-colon-slashslash  based on the protocol that the site is loaded under.\n\t */\n\t\n\t/**\n\t * @cfg {Boolean} stripPrefix (required)\n\t * @inheritdoc Autolinker#stripPrefix\n\t */\n\t\n\n\t/**\n\t * @private\n\t * @property {RegExp} urlPrefixRegex\n\t * \n\t * A regular expression used to remove the 'http-colon-slashslash ' or 'https-colon-slashslash ' and/or the 'www.' from URLs.\n\t */\n\turlPrefixRegex: /^(https?:\\/\\/)?(www\\.)?/i,\n\t\n\t/**\n\t * @private\n\t * @property {RegExp} protocolRelativeRegex\n\t * \n\t * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n\t * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n\t */\n\tprotocolRelativeRegex : /^\\/\\//,\n\t\n\t/**\n\t * @private\n\t * @property {Boolean} protocolPrepended\n\t * \n\t * Will be set to `true` if the 'http-colon-slashslash ' protocol has been prepended to the {@link #url} (because the\n\t * {@link #url} did not have a protocol)\n\t */\n\tprotocolPrepended : false,\n\t\n\n\t/**\n\t * Returns a string name for the type of match that this class represents.\n\t * \n\t * @return {String}\n\t */\n\tgetType : function() {\n\t\treturn 'url';\n\t},\n\t\n\t\n\t/**\n\t * Returns the url that was matched, assuming the protocol to be 'http-colon-slashslash ' if the original\n\t * match was missing a protocol.\n\t * \n\t * @return {String}\n\t */\n\tgetUrl : function() {\n\t\tvar url = this.url;\n\t\t\n\t\t// if the url string doesn't begin with a protocol, assume 'http://'\n\t\tif( !this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended ) {\n\t\t\turl = this.url = 'http://' + url;\n\t\t\t\n\t\t\tthis.protocolPrepended = true;\n\t\t}\n\t\t\n\t\treturn url;\n\t},\n\t\n\n\t/**\n\t * Returns the anchor href that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorHref : function() {\n\t\tvar url = this.getUrl();\n\t\t\n\t\treturn url.replace( /&amp;/g, '&' );  // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html \n\t},\n\t\n\t\n\t/**\n\t * Returns the anchor text that should be generated for the match.\n\t * \n\t * @return {String}\n\t */\n\tgetAnchorText : function() {\n\t\tvar anchorText = this.getUrl();\n\t\t\n\t\tif( this.protocolRelativeMatch ) {\n\t\t\t// Strip off any protocol-relative '//' from the anchor text\n\t\t\tanchorText = this.stripProtocolRelativePrefix( anchorText );\n\t\t}\n\t\tif( this.stripPrefix ) {\n\t\t\tanchorText = this.stripUrlPrefix( anchorText );\n\t\t}\n\t\tanchorText = this.removeTrailingSlash( anchorText );  // remove trailing slash, if there is one\n\t\t\n\t\treturn anchorText;\n\t},\n\t\n\t\n\t// ---------------------------------------\n\t\n\t// Utility Functionality\n\t\n\t/**\n\t * Strips the URL prefix (such as \"http-colon-slashslash \" or \"https-colon-slashslash \") from the given text.\n\t * \n\t * @private\n\t * @param {String} text The text of the anchor that is being generated, for which to strip off the\n\t *   url prefix (such as stripping off \"http-colon-slashslash \")\n\t * @return {String} The `anchorText`, with the prefix stripped.\n\t */\n\tstripUrlPrefix : function( text ) {\n\t\treturn text.replace( this.urlPrefixRegex, '' );\n\t},\n\t\n\t\n\t/**\n\t * Strips any protocol-relative '//' from the anchor text.\n\t * \n\t * @private\n\t * @param {String} text The text of the anchor that is being generated, for which to strip off the\n\t *   protocol-relative prefix (such as stripping off \"//\")\n\t * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n\t */\n\tstripProtocolRelativePrefix : function( text ) {\n\t\treturn text.replace( this.protocolRelativeRegex, '' );\n\t},\n\t\n\t\n\t/**\n\t * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n\t * \n\t * @private\n\t * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n\t *   slash ('/') that may exist.\n\t * @return {String} The `anchorText`, with the trailing slash removed.\n\t */\n\tremoveTrailingSlash : function( anchorText ) {\n\t\tif( anchorText.charAt( anchorText.length - 1 ) === '/' ) {\n\t\t\tanchorText = anchorText.slice( 0, -1 );\n\t\t}\n\t\treturn anchorText;\n\t}\n\t\n} );\nreturn Autolinker;\n\n}));\n"],"sourceRoot":""}