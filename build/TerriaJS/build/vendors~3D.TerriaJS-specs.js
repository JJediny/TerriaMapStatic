(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~3D"],{

/***/ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingRectangle */ "./node_modules/terriajs-cesium/Source/Core/BoundingRectangle.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CoplanarPolygonGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ./GeometryPipeline */ "./node_modules/terriajs-cesium/Source/Core/GeometryPipeline.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./PolygonGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolygonGeometryLibrary.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayRemoveDuplicates,
        BoundingRectangle,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Check,
        ComponentDatatype,
        CoplanarPolygonGeometryLibrary,
        defaultValue,
        defined,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryInstance,
        GeometryPipeline,
        IndexDatatype,
        CesiumMath,
        Matrix3,
        PolygonGeometryLibrary,
        PolygonPipeline,
        PrimitiveType,
        Quaternion,
        VertexFormat) {
    'use strict';

    var scratchPosition = new Cartesian3();
    var scratchBR = new BoundingRectangle();
    var stScratch = new Cartesian2();
    var textureCoordinatesOrigin = new Cartesian2();
    var scratchNormal = new Cartesian3();
    var scratchTangent = new Cartesian3();
    var scratchBitangent = new Cartesian3();
    var centerScratch = new Cartesian3();
    var axis1Scratch = new Cartesian3();
    var axis2Scratch = new Cartesian3();
    var quaternionScratch = new Quaternion();
    var textureMatrixScratch = new Matrix3();
    var tangentRotationScratch = new Matrix3();
    var surfaceNormalScratch = new Cartesian3();

    function createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {
        var positions = polygon.positions;
        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);

        /* If polygon is completely unrenderable, just use the first three vertices */
        if (indices.length < 3) {
            indices = [0, 1, 2];
        }

        var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);
        newIndices.set(indices);

        var textureMatrix = textureMatrixScratch;
        if (stRotation !== 0.0) {
            var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);
            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);

            if (vertexFormat.tangent || vertexFormat.bitangent) {
                rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);
                var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);

                tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);
                if (vertexFormat.bitangent) {
                    bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);
                }
            }
        } else {
            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);
        }

        var stOrigin = textureCoordinatesOrigin;
        if (vertexFormat.st) {
            stOrigin.x = boundingRectangle.x;
            stOrigin.y = boundingRectangle.y;
        }

        var length = positions.length;
        var size = length * 3;
        var flatPositions = new Float64Array(size);
        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;
        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;
        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;
        var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;

        var positionIndex = 0;
        var normalIndex = 0;
        var bitangentIndex = 0;
        var tangentIndex = 0;
        var stIndex = 0;

        for (var i = 0; i < length; i++) {
            var position = positions[i];
            flatPositions[positionIndex++] = position.x;
            flatPositions[positionIndex++] = position.y;
            flatPositions[positionIndex++] = position.z;

            if (vertexFormat.st) {
                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);
                var st = projectPointTo2D(p, stScratch);
                Cartesian2.subtract(st, stOrigin, st);

                var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);
                var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);
                textureCoordinates[stIndex++] = stx;
                textureCoordinates[stIndex++] = sty;
            }

            if (vertexFormat.normal) {
                normals[normalIndex++] = normal.x;
                normals[normalIndex++] = normal.y;
                normals[normalIndex++] = normal.z;
            }

            if (vertexFormat.tangent) {
                tangents[tangentIndex++] = tangent.x;
                tangents[tangentIndex++] = tangent.y;
                tangents[tangentIndex++] = tangent.z;
            }

            if (vertexFormat.bitangent) {
                bitangents[bitangentIndex++] = bitangent.x;
                bitangents[bitangentIndex++] = bitangent.y;
                bitangents[bitangentIndex++] = bitangent.z;
            }
        }

        var attributes = new GeometryAttributes();

        if (vertexFormat.position) {
            attributes.position = new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : flatPositions
            });
        }

        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : normals
            });
        }

        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : tangents
            });
        }

        if (vertexFormat.bitangent) {
            attributes.bitangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : bitangents
            });
        }

        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : textureCoordinates
            });
        }

        return new Geometry({
            attributes : attributes,
            indices : newIndices,
            primitiveType : PrimitiveType.TRIANGLES
        });
    }

    /**
     * A description of a polygon composed of arbitrary coplanar positions.
     *
     * @alias CoplanarPolygonGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     *
     * @example
     * var polygon = new Cesium.CoplanarPolygonGeometry({
     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
     *      -90.0, 30.0, 0.0,
     *      -90.0, 30.0, 1000.0,
     *      -80.0, 30.0, 1000.0,
     *      -80.0, 30.0, 0.0
     *   ])
     * });
     * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);
     *
     * @see CoplanarPolygonGeometry.createGeometry
     */
    function CoplanarPolygonGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var polygonHierarchy = options.polygonHierarchy;
        

        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
        this._vertexFormat = VertexFormat.clone(vertexFormat);
        this._polygonHierarchy = polygonHierarchy;
        this._stRotation = defaultValue(options.stRotation, 0.0);
        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
        this._workerName = 'createCoplanarPolygonGeometry';

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;
    }

    /**
     * A description of a coplanar polygon from an array of positions.
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @returns {CoplanarPolygonGeometry}
     *
     * @example
     * // create a polygon from points
     * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0,
     *     -75.0, 30.0,
     *     -70.0, 30.0,
     *     -68.0, 40.0
     *   ])
     * });
     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);
     *
     * @see PolygonGeometry#createGeometry
     */
    CoplanarPolygonGeometry.fromPositions = function(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        

        var newOptions = {
            polygonHierarchy : {
                positions : options.positions
            },
            vertexFormat : options.vertexFormat,
            stRotation : options.stRotation,
            ellipsoid : options.ellipsoid
        };
        return new CoplanarPolygonGeometry(newOptions);
    };

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {CoplanarPolygonGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    CoplanarPolygonGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._stRotation;
        array[startingIndex] = value.packedLength;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        polygonHierarchy : {}
    };
    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.
     * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.
     */
    CoplanarPolygonGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
        startingIndex = polygonHierarchy.startingIndex;
        delete polygonHierarchy.startingIndex;

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var stRotation = array[startingIndex++];
        var packedLength = array[startingIndex];

        if (!defined(result)) {
            result = new CoplanarPolygonGeometry(scratchOptions);
        }

        result._polygonHierarchy = polygonHierarchy;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._stRotation = stRotation;
        result.packedLength = packedLength;
        return result;
    };

    /**
     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
     *
     * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    CoplanarPolygonGeometry.createGeometry = function(polygonGeometry) {
        var vertexFormat = polygonGeometry._vertexFormat;
        var polygonHierarchy = polygonGeometry._polygonHierarchy;
        var stRotation = polygonGeometry._stRotation;

        var outerPositions = polygonHierarchy.positions;
        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);
        if (outerPositions.length < 3) {
            return;
        }

        var normal = scratchNormal;
        var tangent = scratchTangent;
        var bitangent = scratchBitangent;
        var axis1 = axis1Scratch;
        var axis2 = axis2Scratch;

        var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);
        if (!validGeometry) {
            return undefined;
        }

        normal = Cartesian3.cross(axis1, axis2, normal);
        normal = Cartesian3.normalize(normal, normal);

        if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {
            var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);
            if (Cartesian3.dot(normal, surfaceNormal) < 0) {
                normal = Cartesian3.negate(normal, normal);
                axis1 = Cartesian3.negate(axis1, axis1);
            }
        }

        var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);
        var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);

        if (vertexFormat.tangent) {
            tangent = Cartesian3.clone(axis1, tangent);
        }
        if (vertexFormat.bitangent) {
            bitangent = Cartesian3.clone(axis2, bitangent);
        }

        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);
        var hierarchy = results.hierarchy;
        var polygons = results.polygons;

        if (hierarchy.length === 0) {
            return;
        }
        outerPositions = hierarchy[0].outerRing;

        var boundingSphere = BoundingSphere.fromPoints(outerPositions);
        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);

        var geometries = [];
        for (var i = 0; i < polygons.length; i++) {
            var geometryInstance = new GeometryInstance({
                geometry : createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)
            });

            geometries.push(geometryInstance);
        }

        var geometry = GeometryPipeline.combineInstances(geometries)[0];
        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);
        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);

        var attributes = geometry.attributes;
        if (!vertexFormat.position) {
            delete attributes.position;
        }
        return new Geometry({
            attributes : attributes,
            indices : geometry.indices,
            primitiveType : geometry.primitiveType,
            boundingSphere : boundingSphere
        });
    };

    return CoplanarPolygonGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js":
/*!************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./IntersectionTests */ "./node_modules/terriajs-cesium/Source/Core/IntersectionTests.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./OrientedBoundingBox */ "./node_modules/terriajs-cesium/Source/Core/OrientedBoundingBox.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        defined,
        Cartesian2,
        Cartesian3,
        Check,
        IntersectionTests,
        CesiumMath,
        Matrix3,
        OrientedBoundingBox
    ) {
    'use strict';

    /**
     * @private
     */
    var CoplanarPolygonGeometryLibrary = {};

    var scratchIntersectionPoint = new Cartesian3();
    var scratchXAxis = new Cartesian3();
    var scratchYAxis = new Cartesian3();
    var scratchZAxis = new Cartesian3();
    var obbScratch = new OrientedBoundingBox();

    CoplanarPolygonGeometryLibrary.validOutline = function(positions) {
        

        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);
        var halfAxes = orientedBoundingBox.halfAxes;
        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);
        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);
        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);

        var xMag = Cartesian3.magnitude(xAxis);
        var yMag = Cartesian3.magnitude(yAxis);
        var zMag = Cartesian3.magnitude(zAxis);

        // If all the points are on a line return undefined because we can't draw a polygon
        return !((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0));
    };

    // call after removeDuplicates
    CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function(positions, centerResult, planeAxis1Result, planeAxis2Result) {
        

        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);
        var halfAxes = orientedBoundingBox.halfAxes;
        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);
        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);
        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);

        var xMag = Cartesian3.magnitude(xAxis);
        var yMag = Cartesian3.magnitude(yAxis);
        var zMag = Cartesian3.magnitude(zAxis);
        var min = Math.min(xMag, yMag, zMag);

        // If all the points are on a line return undefined because we can't draw a polygon
        if ((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0)) {
            return false;
        }

        var planeAxis1;
        var planeAxis2;

        if (min === yMag || min === zMag) {
            planeAxis1 = xAxis;
        }
        if (min === xMag) {
            planeAxis1 = yAxis;
        } else if (min === zMag) {
            planeAxis2 = yAxis;
        }
        if (min === xMag || min === yMag) {
            planeAxis2 = zAxis;
        }

        Cartesian3.normalize(planeAxis1, planeAxis1Result);
        Cartesian3.normalize(planeAxis2, planeAxis2Result);
        Cartesian3.clone(orientedBoundingBox.center, centerResult);
        return true;
    };

    function projectTo2D(position, center, axis1, axis2, result) {
        var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);
        var x = Cartesian3.dot(axis1, v);
        var y = Cartesian3.dot(axis2, v);

        return Cartesian2.fromElements(x, y, result);
    }

    CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function(center, axis1, axis2) {
        return function(positions) {
            var positionResults = new Array(positions.length);
            for (var i = 0; i < positions.length; i++) {
                positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);
            }

            return positionResults;
        };
    };

    CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function(center, axis1, axis2) {
        return function(position, result) {
            return projectTo2D(position, center, axis1, axis2, result);
        };
    };

    return CoplanarPolygonGeometryLibrary;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js":
/*!************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
    __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
    __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
    __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
    __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
    __webpack_require__(/*! ./CoplanarPolygonGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js"),
    __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
    __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
    __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
    __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
    __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
    __webpack_require__(/*! ./GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
    __webpack_require__(/*! ./GeometryPipeline */ "./node_modules/terriajs-cesium/Source/Core/GeometryPipeline.js"),
    __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
    __webpack_require__(/*! ./PolygonGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolygonGeometryLibrary.js"),
    __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
    __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
    arrayRemoveDuplicates,
    BoundingSphere,
    Cartesian3,
    Check,
    ComponentDatatype,
    CoplanarPolygonGeometryLibrary,
    defaultValue,
    defined,
    Geometry,
    GeometryAttribute,
    GeometryAttributes,
    GeometryInstance,
    GeometryPipeline,
    IndexDatatype,
    PolygonGeometryLibrary,
    PolygonPipeline,
    PrimitiveType) {
    'use strict';

    function createGeometryFromPositions(positions){
        var length = positions.length;
        var flatPositions = new Float64Array(length * 3);
        var indices = IndexDatatype.createTypedArray(length, length * 2);

        var positionIndex = 0;
        var index = 0;

        for (var i = 0; i < length; i++) {
            var position = positions[i];
            flatPositions[positionIndex++] = position.x;
            flatPositions[positionIndex++] = position.y;
            flatPositions[positionIndex++] = position.z;

            indices[index++] = i;
            indices[index++] = (i + 1) % length;
        }

        var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : flatPositions
            })
        });

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.LINES
        });
    }

    /**
     * A description of the outline of a polygon composed of arbitrary coplanar positions.
     *
     * @alias CoplanarPolygonOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
     *
     * @see CoplanarPolygonOutlineGeometry.createGeometry
     *
     * @example
     * var polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({
     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
     *      -90.0, 30.0, 0.0,
     *      -90.0, 30.0, 1000.0,
     *      -80.0, 30.0, 1000.0,
     *      -80.0, 30.0, 0.0
     *   ])
     * });
     * var geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);
     */
    function CoplanarPolygonOutlineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var polygonHierarchy = options.polygonHierarchy;
        

        this._polygonHierarchy = polygonHierarchy;
        this._workerName = 'createCoplanarPolygonOutlineGeometry';

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + 1;
    }

    /**
     * A description of a coplanar polygon outline from an array of positions.
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
     * @returns {CoplanarPolygonOutlineGeometry}
     */
    CoplanarPolygonOutlineGeometry.fromPositions = function(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        

        var newOptions = {
            polygonHierarchy : {
                positions : options.positions
            }
        };
        return new CoplanarPolygonOutlineGeometry(newOptions);
    };

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {CoplanarPolygonOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    CoplanarPolygonOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);

        array[startingIndex] = value.packedLength;

        return array;
    };

    var scratchOptions = {
        polygonHierarchy : {}
    };
    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.
     * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.
     */
    CoplanarPolygonOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
        startingIndex = polygonHierarchy.startingIndex;
        delete polygonHierarchy.startingIndex;
        var packedLength = array[startingIndex];

        if (!defined(result)) {
            result = new CoplanarPolygonOutlineGeometry(scratchOptions);
        }

        result._polygonHierarchy = polygonHierarchy;
        result.packedLength = packedLength;

        return result;
    };

    /**
     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
     *
     * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    CoplanarPolygonOutlineGeometry.createGeometry = function(polygonGeometry) {
        var polygonHierarchy = polygonGeometry._polygonHierarchy;

        var outerPositions = polygonHierarchy.positions;
        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);
        if (outerPositions.length < 3) {
            return;
        }
        var isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);
        if (!isValid) {
            return undefined;
        }

        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, false);

        if (polygons.length === 0) {
            return undefined;
        }

        var geometries = [];

        for (var i = 0; i < polygons.length; i++) {
            var geometryInstance = new GeometryInstance({
                geometry : createGeometryFromPositions(polygons[i])
            });
            geometries.push(geometryInstance);
        }

        var geometry = GeometryPipeline.combineInstances(geometries)[0];
        var boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);

        return new Geometry({
            attributes : geometry.attributes,
            indices : geometry.indices,
            primitiveType : geometry.primitiveType,
            boundingSphere : boundingSphere
        });
    };

    return CoplanarPolygonOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CornerType */ "./node_modules/terriajs-cesium/Source/Core/CornerType.js"),
        __webpack_require__(/*! ./CorridorGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayFill,
        arrayRemoveDuplicates,
        BoundingSphere,
        Cartesian3,
        Cartographic,
        Check,
        ComponentDatatype,
        CornerType,
        CorridorGeometryLibrary,
        defaultValue,
        defined,
        defineProperties,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryOffsetAttribute,
        IndexDatatype,
        CesiumMath,
        PolygonPipeline,
        PrimitiveType,
        Rectangle,
        VertexFormat) {
    'use strict';

    var cartesian1 = new Cartesian3();
    var cartesian2 = new Cartesian3();
    var cartesian3 = new Cartesian3();
    var cartesian4 = new Cartesian3();
    var cartesian5 = new Cartesian3();
    var cartesian6 = new Cartesian3();

    var scratch1 = new Cartesian3();
    var scratch2 = new Cartesian3();

    function scaleToSurface(positions, ellipsoid) {
        for (var i = 0; i < positions.length; i++) {
            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);
        }
        return positions;
    }

    function addNormals(attr, normal, left, front, back, vertexFormat) {
        var normals = attr.normals;
        var tangents = attr.tangents;
        var bitangents = attr.bitangents;
        var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);
        if (vertexFormat.normal) {
            CorridorGeometryLibrary.addAttribute(normals, normal, front, back);
        }
        if (vertexFormat.tangent) {
            CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);
        }
        if (vertexFormat.bitangent) {
            CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);
        }
    }

    function combine(computedPositions, vertexFormat, ellipsoid) {
        var positions = computedPositions.positions;
        var corners = computedPositions.corners;
        var endPositions = computedPositions.endPositions;
        var computedLefts = computedPositions.lefts;
        var computedNormals = computedPositions.normals;
        var attributes = new GeometryAttributes();
        var corner;
        var leftCount = 0;
        var rightCount = 0;
        var i;
        var indicesLength = 0;
        var length;
        for (i = 0; i < positions.length; i += 2) {
            length = positions[i].length - 3;
            leftCount += length; //subtracting 3 to account for duplicate points at corners
            indicesLength += length*2;
            rightCount += positions[i + 1].length - 3;
        }
        leftCount += 3; //add back count for end positions
        rightCount += 3;
        for (i = 0; i < corners.length; i++) {
            corner = corners[i];
            var leftSide = corners[i].leftPositions;
            if (defined(leftSide)) {
                length = leftSide.length;
                leftCount += length;
                indicesLength += length;
            } else {
                length = corners[i].rightPositions.length;
                rightCount += length;
                indicesLength += length;
            }
        }

        var addEndPositions = defined(endPositions);
        var endPositionLength;
        if (addEndPositions) {
            endPositionLength = endPositions[0].length - 3;
            leftCount += endPositionLength;
            rightCount += endPositionLength;
            endPositionLength /= 3;
            indicesLength += endPositionLength * 6;
        }
        var size = leftCount + rightCount;
        var finalPositions = new Float64Array(size);
        var normals = (vertexFormat.normal) ? new Float32Array(size) : undefined;
        var tangents = (vertexFormat.tangent) ? new Float32Array(size) : undefined;
        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size) : undefined;
        var attr = {
            normals : normals,
            tangents : tangents,
            bitangents : bitangents
        };
        var front = 0;
        var back = size - 1;
        var UL, LL, UR, LR;
        var normal = cartesian1;
        var left = cartesian2;
        var rightPos, leftPos;
        var halfLength = endPositionLength / 2;

        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);
        var index = 0;
        if (addEndPositions) { // add rounded end
            leftPos = cartesian3;
            rightPos = cartesian4;
            var firstEndPositions = endPositions[0];
            normal = Cartesian3.fromArray(computedNormals, 0, normal);
            left = Cartesian3.fromArray(computedLefts, 0, left);
            for (i = 0; i < halfLength; i++) {
                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);
                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);
                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
                addNormals(attr, normal, left, front, back, vertexFormat);

                LL = front / 3;
                LR = LL + 1;
                UL = (back - 2) / 3;
                UR = UL - 1;
                indices[index++] = UL;
                indices[index++] = LL;
                indices[index++] = UR;
                indices[index++] = UR;
                indices[index++] = LL;
                indices[index++] = LR;

                front += 3;
                back -= 3;
            }
        }

        var posIndex = 0;
        var compIndex = 0;
        var rightEdge = positions[posIndex++]; //add first two edges
        var leftEdge = positions[posIndex++];
        finalPositions.set(rightEdge, front);
        finalPositions.set(leftEdge, back - leftEdge.length + 1);

        left = Cartesian3.fromArray(computedLefts, compIndex, left);
        var rightNormal;
        var leftNormal;
        length = leftEdge.length - 3;
        for (i = 0; i < length; i += 3) {
            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);
            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);
            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);
            addNormals(attr, normal, left, front, back, vertexFormat);

            LL = front / 3;
            LR = LL + 1;
            UL = (back - 2) / 3;
            UR = UL - 1;
            indices[index++] = UL;
            indices[index++] = LL;
            indices[index++] = UR;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;

            front += 3;
            back -= 3;
        }

        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);
        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);
        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);
        compIndex += 3;
        for (i = 0; i < corners.length; i++) {
            var j;
            corner = corners[i];
            var l = corner.leftPositions;
            var r = corner.rightPositions;
            var pivot;
            var start;
            var outsidePoint = cartesian6;
            var previousPoint = cartesian3;
            var nextPoint = cartesian4;
            normal = Cartesian3.fromArray(computedNormals, compIndex, normal);
            if (defined(l)) {
                addNormals(attr, normal, left, undefined, back, vertexFormat);
                back -= 3;
                pivot = LR;
                start = UR;
                for (j = 0; j < l.length / 3; j++) {
                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);
                    indices[index++] = pivot;
                    indices[index++] = start - j - 1;
                    indices[index++] = start - j;
                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);
                    previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);
                    nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);
                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);
                    addNormals(attr, normal, left, undefined, back, vertexFormat);
                    back -= 3;
                }
                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);
                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start) * 3, previousPoint), outsidePoint, previousPoint);
                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);
                left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);
                addNormals(attr, normal, left, front, undefined, vertexFormat);
                front += 3;
            } else {
                addNormals(attr, normal, left, front, undefined, vertexFormat);
                front += 3;
                pivot = UR;
                start = LR;
                for (j = 0; j < r.length / 3; j++) {
                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);
                    indices[index++] = pivot;
                    indices[index++] = start + j;
                    indices[index++] = start + j + 1;
                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);
                    previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);
                    nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);
                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);
                    addNormals(attr, normal, left, front, undefined, vertexFormat);
                    front += 3;
                }
                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);
                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);
                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);
                left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);
                addNormals(attr, normal, left, undefined, back, vertexFormat);
                back -= 3;
            }
            rightEdge = positions[posIndex++];
            leftEdge = positions[posIndex++];
            rightEdge.splice(0, 3); //remove duplicate points added by corner
            leftEdge.splice(leftEdge.length - 3, 3);
            finalPositions.set(rightEdge, front);
            finalPositions.set(leftEdge, back - leftEdge.length + 1);
            length = leftEdge.length - 3;

            compIndex += 3;
            left = Cartesian3.fromArray(computedLefts, compIndex, left);
            for (j = 0; j < leftEdge.length; j += 3) {
                rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);
                leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);
                normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);
                addNormals(attr, normal, left, front, back, vertexFormat);

                LR = front / 3;
                LL = LR - 1;
                UR = (back - 2) / 3;
                UL = UR + 1;
                indices[index++] = UL;
                indices[index++] = LL;
                indices[index++] = UR;
                indices[index++] = UR;
                indices[index++] = LL;
                indices[index++] = LR;

                front += 3;
                back -= 3;
            }
            front -= 3;
            back += 3;
        }
        normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);
        addNormals(attr, normal, left, front, back, vertexFormat);

        if (addEndPositions) { // add rounded end
            front += 3;
            back -= 3;
            leftPos = cartesian3;
            rightPos = cartesian4;
            var lastEndPositions = endPositions[1];
            for (i = 0; i < halfLength; i++) {
                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);
                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);
                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
                addNormals(attr, normal, left, front, back, vertexFormat);

                LR = front / 3;
                LL = LR - 1;
                UR = (back - 2) / 3;
                UL = UR + 1;
                indices[index++] = UL;
                indices[index++] = LL;
                indices[index++] = UR;
                indices[index++] = UR;
                indices[index++] = LL;
                indices[index++] = LR;

                front += 3;
                back -= 3;
            }
        }

        attributes.position = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : finalPositions
        });

        if (vertexFormat.st) {
            var st = new Float32Array(size / 3 * 2);
            var rightSt;
            var leftSt;
            var stIndex = 0;
            if (addEndPositions) {
                leftCount /= 3;
                rightCount /= 3;
                var theta = Math.PI / (endPositionLength + 1);
                leftSt = 1 / (leftCount - endPositionLength + 1);
                rightSt = 1 / (rightCount - endPositionLength + 1);
                var a;
                var halfEndPos = endPositionLength / 2;
                for (i = halfEndPos + 1; i < endPositionLength + 1; i++) { // lower left rounded end
                    a = CesiumMath.PI_OVER_TWO + theta * i;
                    st[stIndex++] = rightSt * (1 + Math.cos(a));
                    st[stIndex++] = 0.5 * (1 + Math.sin(a));
                }
                for (i = 1; i < rightCount - endPositionLength + 1; i++) { // bottom edge
                    st[stIndex++] = i * rightSt;
                    st[stIndex++] = 0;
                }
                for (i = endPositionLength; i > halfEndPos; i--) { // lower right rounded end
                    a = CesiumMath.PI_OVER_TWO - i * theta;
                    st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));
                    st[stIndex++] = 0.5 * (1 + Math.sin(a));
                }
                for (i = halfEndPos; i > 0; i--) { // upper right rounded end
                    a = CesiumMath.PI_OVER_TWO - theta * i;
                    st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));
                    st[stIndex++] = 0.5 * (1 + Math.sin(a));
                }
                for (i = leftCount - endPositionLength; i > 0; i--) { // top edge
                    st[stIndex++] = i * leftSt;
                    st[stIndex++] = 1;
                }
                for (i = 1; i < halfEndPos + 1; i++) { // upper left rounded end
                    a = CesiumMath.PI_OVER_TWO + theta * i;
                    st[stIndex++] = leftSt * (1 + Math.cos(a));
                    st[stIndex++] = 0.5 * (1 + Math.sin(a));
                }
            } else {
                leftCount /= 3;
                rightCount /= 3;
                leftSt = 1 / (leftCount - 1);
                rightSt = 1 / (rightCount - 1);
                for (i = 0; i < rightCount; i++) { // bottom edge
                    st[stIndex++] = i * rightSt;
                    st[stIndex++] = 0;
                }
                for (i = leftCount; i > 0; i--) { // top edge
                    st[stIndex++] = (i - 1) * leftSt;
                    st[stIndex++] = 1;
                }
            }

            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : st
            });
        }

        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : attr.normals
            });
        }

        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : attr.tangents
            });
        }

        if (vertexFormat.bitangent) {
            attributes.bitangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : attr.bitangents
            });
        }

        return {
            attributes : attributes,
            indices : indices
        };
    }

    function extrudedAttributes(attributes, vertexFormat) {
        if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {
            return attributes;
        }
        var positions = attributes.position.values;
        var topNormals;
        var topBitangents;
        if (vertexFormat.normal || vertexFormat.bitangent) {
            topNormals = attributes.normal.values;
            topBitangents = attributes.bitangent.values;
        }
        var size = attributes.position.values.length / 18;
        var threeSize = size * 3;
        var twoSize = size * 2;
        var sixSize = threeSize * 2;
        var i;
        if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {
            var normals = (vertexFormat.normal) ? new Float32Array(threeSize * 6) : undefined;
            var tangents = (vertexFormat.tangent) ? new Float32Array(threeSize * 6) : undefined;
            var bitangents = (vertexFormat.bitangent) ? new Float32Array(threeSize * 6) : undefined;
            var topPosition = cartesian1;
            var bottomPosition = cartesian2;
            var previousPosition = cartesian3;
            var normal = cartesian4;
            var tangent = cartesian5;
            var bitangent = cartesian6;
            var attrIndex = sixSize;
            for (i = 0; i < threeSize; i += 3) {
                var attrIndexOffset = attrIndex + sixSize;
                topPosition      = Cartesian3.fromArray(positions, i, topPosition);
                bottomPosition   = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);
                previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);
                bottomPosition   = Cartesian3.subtract(bottomPosition,   topPosition, bottomPosition);
                previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);
                normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);
                if (vertexFormat.normal) {
                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);
                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);
                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);
                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);
                }
                if (vertexFormat.tangent || vertexFormat.bitangent) {
                    bitangent = Cartesian3.fromArray(topNormals, i, bitangent);
                    if (vertexFormat.bitangent) {
                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);
                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);
                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);
                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);
                    }

                    if (vertexFormat.tangent) {
                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);
                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);
                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);
                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);
                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);
                    }
                }
                attrIndex += 6;
            }

            if (vertexFormat.normal) {
                normals.set(topNormals); //top
                for (i = 0; i < threeSize; i += 3) { //bottom normals
                    normals[i + threeSize] = -topNormals[i];
                    normals[i + threeSize + 1] = -topNormals[i + 1];
                    normals[i + threeSize + 2] = -topNormals[i + 2];
                }
                attributes.normal.values = normals;
            } else {
                attributes.normal = undefined;
            }

            if (vertexFormat.bitangent) {
                bitangents.set(topBitangents); //top
                bitangents.set(topBitangents, threeSize); //bottom
                attributes.bitangent.values = bitangents;
            } else {
                attributes.bitangent = undefined;
            }

            if (vertexFormat.tangent) {
                var topTangents = attributes.tangent.values;
                tangents.set(topTangents); //top
                tangents.set(topTangents, threeSize); //bottom
                attributes.tangent.values = tangents;
            }
        }
        if (vertexFormat.st) {
            var topSt = attributes.st.values;
            var st = new Float32Array(twoSize * 6);
            st.set(topSt); //top
            st.set(topSt, twoSize); //bottom
            var index = twoSize * 2;

            for ( var j = 0; j < 2; j++) {
                st[index++] = topSt[0];
                st[index++] = topSt[1];
                for (i = 2; i < twoSize; i += 2) {
                    var s = topSt[i];
                    var t = topSt[i + 1];
                    st[index++] = s;
                    st[index++] = t;
                    st[index++] = s;
                    st[index++] = t;
                }
                st[index++] = topSt[0];
                st[index++] = topSt[1];
            }
            attributes.st.values = st;
        }

        return attributes;
    }

    function addWallPositions(positions, index, wallPositions) {
        wallPositions[index++] = positions[0];
        wallPositions[index++] = positions[1];
        wallPositions[index++] = positions[2];
        for ( var i = 3; i < positions.length; i += 3) {
            var x = positions[i];
            var y = positions[i + 1];
            var z = positions[i + 2];
            wallPositions[index++] = x;
            wallPositions[index++] = y;
            wallPositions[index++] = z;
            wallPositions[index++] = x;
            wallPositions[index++] = y;
            wallPositions[index++] = z;
        }
        wallPositions[index++] = positions[0];
        wallPositions[index++] = positions[1];
        wallPositions[index++] = positions[2];

        return wallPositions;
    }

    function computePositionsExtruded(params, vertexFormat) {
        var topVertexFormat = new VertexFormat({
            position : vertexFormat.position,
            normal : (vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume),
            tangent : vertexFormat.tangent,
            bitangent : (vertexFormat.normal || vertexFormat.bitangent),
            st : vertexFormat.st
        });
        var ellipsoid = params.ellipsoid;
        var computedPositions = CorridorGeometryLibrary.computePositions(params);
        var attr = combine(computedPositions, topVertexFormat, ellipsoid);
        var height = params.height;
        var extrudedHeight = params.extrudedHeight;
        var attributes = attr.attributes;
        var indices = attr.indices;
        var positions = attributes.position.values;
        var length = positions.length;
        var newPositions = new Float64Array(length * 6);
        var extrudedPositions = new Float64Array(length);
        extrudedPositions.set(positions);
        var wallPositions = new Float64Array(length * 4);

        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);
        wallPositions = addWallPositions(positions, 0, wallPositions);
        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);
        wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);
        newPositions.set(positions);
        newPositions.set(extrudedPositions, length);
        newPositions.set(wallPositions, length * 2);
        attributes.position.values = newPositions;

        attributes = extrudedAttributes(attributes, vertexFormat);
        var i;
        var size = length / 3;
        if (params.shadowVolume) {
            var topNormals = attributes.normal.values;
            length = topNormals.length;

            var extrudeNormals = new Float32Array(length * 6);
            for (i = 0; i < length; i ++) {
                topNormals[i] = -topNormals[i];
            }
            //only get normals for bottom layer that's going to be pushed down
            extrudeNormals.set(topNormals, length); //bottom face
            extrudeNormals = addWallPositions(topNormals, length*4, extrudeNormals); //bottom wall
            attributes.extrudeDirection = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : extrudeNormals
            });
            if (!vertexFormat.normal) {
                attributes.normal = undefined;
            }
        }
        if (defined(params.offsetAttribute)) {
            var applyOffset = new Uint8Array(size * 6);
            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {
                applyOffset = arrayFill(applyOffset, 1, 0, size); // top face
                applyOffset = arrayFill(applyOffset, 1, size*2, size * 4); // top wall
            } else {
                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                applyOffset = arrayFill(applyOffset, applyOffsetValue);
            }
            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values: applyOffset
            });
        }

        var iLength = indices.length;
        var twoSize = size + size;
        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);
        newIndices.set(indices);
        var index = iLength;
        for (i = 0; i < iLength; i += 3) { // bottom indices
            var v0 = indices[i];
            var v1 = indices[i + 1];
            var v2 = indices[i + 2];
            newIndices[index++] = v2 + size;
            newIndices[index++] = v1 + size;
            newIndices[index++] = v0 + size;
        }

        var UL, LL, UR, LR;

        for (i = 0; i < twoSize; i += 2) { //wall indices
            UL = i + twoSize;
            LL = UL + twoSize;
            UR = UL + 1;
            LR = LL + 1;
            newIndices[index++] = UL;
            newIndices[index++] = LL;
            newIndices[index++] = UR;
            newIndices[index++] = UR;
            newIndices[index++] = LL;
            newIndices[index++] = LR;
        }

        return {
            attributes : attributes,
            indices : newIndices
        };
    }

    var scratchCartesian1 = new Cartesian3();
    var scratchCartesian2 = new Cartesian3();
    var scratchCartographic = new Cartographic();

    function computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {
        // Compute direction of offset the point
        var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);
        Cartesian3.normalize(direction, direction);
        var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);
        var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);
        Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);

        var minLat = min.latitude;
        var minLon = min.longitude;
        var maxLat = max.latitude;
        var maxLon = max.longitude;

        // Compute 2 offset points
        Cartesian3.add(position1, offsetDirection, scratchCartesian2);
        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);

        var lat = scratchCartographic.latitude;
        var lon = scratchCartographic.longitude;
        minLat = Math.min(minLat, lat);
        minLon = Math.min(minLon, lon);
        maxLat = Math.max(maxLat, lat);
        maxLon = Math.max(maxLon, lon);

        Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);
        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);

        lat = scratchCartographic.latitude;
        lon = scratchCartographic.longitude;
        minLat = Math.min(minLat, lat);
        minLon = Math.min(minLon, lon);
        maxLat = Math.max(maxLat, lat);
        maxLon = Math.max(maxLon, lon);

        min.latitude = minLat;
        min.longitude = minLon;
        max.latitude = maxLat;
        max.longitude = maxLon;
    }

    var scratchCartesianOffset = new Cartesian3();
    var scratchCartesianEnds = new Cartesian3();
    var scratchCartographicMin = new Cartographic();
    var scratchCartographicMax = new Cartographic();

    function computeRectangle(positions, ellipsoid, width, cornerType, result) {
        positions = scaleToSurface(positions, ellipsoid);
        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);
        var length = cleanPositions.length;
        if (length < 2 || width <= 0) {
            return new Rectangle();
        }
        var halfWidth = width * 0.5;

        scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;
        scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;
        scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;
        scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;

        var lat, lon;
        if (cornerType === CornerType.ROUNDED) {
            // Compute start cap
            var first = cleanPositions[0];
            Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);
            Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);
            Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);
            Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);

            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);
            lat = scratchCartographic.latitude;
            lon = scratchCartographic.longitude;
            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);
            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);
            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);
            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);
        }

        // Compute the rest
        for (var i = 0; i < length-1; ++i) {
            computeOffsetPoints(cleanPositions[i], cleanPositions[i+1], ellipsoid, halfWidth,
                scratchCartographicMin, scratchCartographicMax);
        }

        // Compute ending point
        var last = cleanPositions[length-1];
        Cartesian3.subtract(last, cleanPositions[length-2], scratchCartesianOffset);
        Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);
        Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);
        Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);
        computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth,
            scratchCartographicMin, scratchCartographicMax);

        if (cornerType === CornerType.ROUNDED) {
            // Compute end cap
            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);
            lat = scratchCartographic.latitude;
            lon = scratchCartographic.longitude;
            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);
            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);
            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);
            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);
        }

        var rectangle = defined(result) ? result : new Rectangle();
        rectangle.north = scratchCartographicMax.latitude;
        rectangle.south = scratchCartographicMin.latitude;
        rectangle.east = scratchCartographicMax.longitude;
        rectangle.west = scratchCartographicMin.longitude;

        return rectangle;
    }

    /**
     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     *
     * @alias CorridorGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.
     * @param {Number} options.width The distance between the edges of the corridor in meters.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.
     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
     *
     * @see CorridorGeometry.createGeometry
     * @see Packable
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}
     *
     * @example
     * var corridor = new Cesium.CorridorGeometry({
     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
     *   width : 100000
     * });
     */
    function CorridorGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.positions;
        var width = options.width;

        

        var height = defaultValue(options.height, 0.0);
        var extrudedHeight = defaultValue(options.extrudedHeight, height);

        this._positions = positions;
        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));
        this._width = width;
        this._height = Math.max(height, extrudedHeight);
        this._extrudedHeight = Math.min(height, extrudedHeight);
        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        this._shadowVolume = defaultValue(options.shadowVolume, false);
        this._workerName = 'createCorridorGeometry';
        this._offsetAttribute = options.offsetAttribute;
        this._rectangle = undefined;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {CorridorGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    CorridorGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._width;
        array[startingIndex++] = value._height;
        array[startingIndex++] = value._extrudedHeight;
        array[startingIndex++] = value._cornerType;
        array[startingIndex++] = value._granularity;
        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;
        array[startingIndex] = defaultValue(value._offsetAttribute, -1);

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        positions : undefined,
        ellipsoid : scratchEllipsoid,
        vertexFormat : scratchVertexFormat,
        width : undefined,
        height : undefined,
        extrudedHeight : undefined,
        cornerType : undefined,
        granularity : undefined,
        shadowVolume: undefined,
        offsetAttribute: undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {CorridorGeometry} [result] The object into which to store the result.
     * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.
     */
    CorridorGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var width = array[startingIndex++];
        var height = array[startingIndex++];
        var extrudedHeight = array[startingIndex++];
        var cornerType = array[startingIndex++];
        var granularity = array[startingIndex++];
        var shadowVolume = array[startingIndex++] === 1.0;
        var offsetAttribute = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.positions = positions;
            scratchOptions.width = width;
            scratchOptions.height = height;
            scratchOptions.extrudedHeight = extrudedHeight;
            scratchOptions.cornerType = cornerType;
            scratchOptions.granularity = granularity;
            scratchOptions.shadowVolume = shadowVolume;
            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

            return new CorridorGeometry(scratchOptions);
        }

        result._positions = positions;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._width = width;
        result._height = height;
        result._extrudedHeight = extrudedHeight;
        result._cornerType = cornerType;
        result._granularity = granularity;
        result._shadowVolume = shadowVolume;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

        return result;
    };

    /**
     * Computes the bounding rectangle given the provided options
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.
     * @param {Number} options.width The distance between the edges of the corridor in meters.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
     * @param {Rectangle} [result] An object in which to store the result.
     *
     * @returns {Rectangle} The result rectangle.
     */
    CorridorGeometry.computeRectangle = function(options, result) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.positions;
        var width = options.width;

        

        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
        var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);

        return computeRectangle(positions, ellipsoid, width, cornerType, result);
    };

    /**
     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
     *
     * @param {CorridorGeometry} corridorGeometry A description of the corridor.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    CorridorGeometry.createGeometry = function(corridorGeometry) {
        var positions = corridorGeometry._positions;
        var width = corridorGeometry._width;
        var ellipsoid = corridorGeometry._ellipsoid;

        positions = scaleToSurface(positions, ellipsoid);
        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);

        if ((cleanPositions.length < 2) || (width <= 0)) {
            return;
        }

        var height = corridorGeometry._height;
        var extrudedHeight = corridorGeometry._extrudedHeight;
        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);

        var vertexFormat = corridorGeometry._vertexFormat;
        var params = {
            ellipsoid : ellipsoid,
            positions : cleanPositions,
            width : width,
            cornerType : corridorGeometry._cornerType,
            granularity : corridorGeometry._granularity,
            saveAttributes: true
        };
        var attr;
        if (extrude) {
            params.height = height;
            params.extrudedHeight = extrudedHeight;
            params.shadowVolume = corridorGeometry._shadowVolume;
            params.offsetAttribute = corridorGeometry._offsetAttribute;
            attr = computePositionsExtruded(params, vertexFormat);
        } else {
            var computedPositions = CorridorGeometryLibrary.computePositions(params);
            attr = combine(computedPositions, vertexFormat, ellipsoid);
            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);

            if (defined(corridorGeometry._offsetAttribute)) {
                var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                var length = attr.attributes.position.values.length;
                var applyOffset = new Uint8Array(length / 3);
                arrayFill(applyOffset, applyOffsetValue);
                attr.attributes.applyOffset = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                    componentsPerAttribute : 1,
                    values: applyOffset
                });
            }
        }
        var attributes = attr.attributes;
        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);
        if (!vertexFormat.position) {
            attr.attributes.position.values = undefined;
        }

        return new Geometry({
            attributes : attributes,
            indices : attr.indices,
            primitiveType : PrimitiveType.TRIANGLES,
            boundingSphere : boundingSphere,
            offsetAttribute : corridorGeometry._offsetAttribute
        });
    };

    /**
     * @private
     */
    CorridorGeometry.createShadowVolume = function(corridorGeometry, minHeightFunc, maxHeightFunc) {
        var granularity = corridorGeometry._granularity;
        var ellipsoid = corridorGeometry._ellipsoid;

        var minHeight = minHeightFunc(granularity, ellipsoid);
        var maxHeight = maxHeightFunc(granularity, ellipsoid);

        return new CorridorGeometry({
            positions : corridorGeometry._positions,
            width : corridorGeometry._width,
            cornerType : corridorGeometry._cornerType,
            ellipsoid : ellipsoid,
            granularity : granularity,
            extrudedHeight : minHeight,
            height : maxHeight,
            vertexFormat : VertexFormat.POSITION_ONLY,
            shadowVolume: true
        });
    };

    defineProperties(CorridorGeometry.prototype, {
        /**
         * @private
         */
        rectangle : {
            get : function() {
                if (!defined(this._rectangle)) {
                    this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);
                }
                return this._rectangle;
            }
        },
        /**
         * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.
         *
         * Corridors don't support stRotation,
         * so just return the corners of the original system.
         * @private
         */
        textureCoordinateRotationPoints : {
            get : function() {
                return [0, 0, 0, 1, 1, 0];
            }
        }
    });

    return CorridorGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./CornerType */ "./node_modules/terriajs-cesium/Source/Core/CornerType.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./PolylinePipeline */ "./node_modules/terriajs-cesium/Source/Core/PolylinePipeline.js"),
        __webpack_require__(/*! ./PolylineVolumeGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js"),
        __webpack_require__(/*! ./Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartesian3,
        CornerType,
        defined,
        CesiumMath,
        Matrix3,
        PolylinePipeline,
        PolylineVolumeGeometryLibrary,
        Quaternion) {
    'use strict';

    /**
     * @private
     */
    var CorridorGeometryLibrary = {};

    var scratch1 = new Cartesian3();
    var scratch2 = new Cartesian3();
    var scratch3 = new Cartesian3();
    var scratch4 = new Cartesian3();

    var scaleArray2 = [new Cartesian3(), new Cartesian3()];

    var cartesian1 = new Cartesian3();
    var cartesian2 = new Cartesian3();
    var cartesian3 = new Cartesian3();
    var cartesian4 = new Cartesian3();
    var cartesian5 = new Cartesian3();
    var cartesian6 = new Cartesian3();
    var cartesian7 = new Cartesian3();
    var cartesian8 = new Cartesian3();
    var cartesian9 = new Cartesian3();
    var cartesian10 = new Cartesian3();

    var quaterion = new Quaternion();
    var rotMatrix = new Matrix3();
    function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {
        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));
        var granularity = (cornerType === CornerType.BEVELED) ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;

        var size = granularity * 3;
        var array = new Array(size);

        array[size - 3] = endPoint.x;
        array[size - 2] = endPoint.y;
        array[size - 1] = endPoint.z;

        var m;
        if (leftIsOutside) {
            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);
        } else {
            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);
        }

        var index = 0;
        startPoint = Cartesian3.clone(startPoint, scratch1);
        for (var i = 0; i < granularity; i++) {
            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);
            array[index++] = startPoint.x;
            array[index++] = startPoint.y;
            array[index++] = startPoint.z;
        }

        return array;
    }

    function addEndCaps(calculatedPositions) {
        var cornerPoint = cartesian1;
        var startPoint = cartesian2;
        var endPoint = cartesian3;

        var leftEdge = calculatedPositions[1];
        startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);
        endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);
        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);
        var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);

        var length = calculatedPositions.length - 1;
        var rightEdge = calculatedPositions[length - 1];
        leftEdge = calculatedPositions[length];
        startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);
        endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);
        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);
        var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);

        return [firstEndCap, lastEndCap];
    }

    function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {
        var cornerPoint = scratch1;
        if (leftIsOutside) {
            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);
        } else {
            leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);
            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);
        }
        return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];
    }

    function addShiftedPositions(positions, left, scalar, calculatedPositions) {
        var rightPositions = new Array(positions.length);
        var leftPositions = new Array(positions.length);
        var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);
        var scaledRight = Cartesian3.negate(scaledLeft, scratch2);
        var rightIndex = 0;
        var leftIndex = positions.length - 1;

        for (var i = 0; i < positions.length; i += 3) {
            var pos = Cartesian3.fromArray(positions, i, scratch3);
            var rightPos = Cartesian3.add(pos, scaledRight, scratch4);
            rightPositions[rightIndex++] = rightPos.x;
            rightPositions[rightIndex++] = rightPos.y;
            rightPositions[rightIndex++] = rightPos.z;

            var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);
            leftPositions[leftIndex--] = leftPos.z;
            leftPositions[leftIndex--] = leftPos.y;
            leftPositions[leftIndex--] = leftPos.x;
        }
        calculatedPositions.push(rightPositions, leftPositions);

        return calculatedPositions;
    }

    /**
     * @private
     */
    CorridorGeometryLibrary.addAttribute = function(attribute, value, front, back) {
        var x = value.x;
        var y = value.y;
        var z = value.z;
        if (defined(front)) {
            attribute[front] = x;
            attribute[front + 1] = y;
            attribute[front + 2] = z;
        }
        if (defined(back)) {
            attribute[back] = z;
            attribute[back - 1] = y;
            attribute[back - 2] = x;
        }
    };

    var scratchForwardProjection = new Cartesian3();
    var scratchBackwardProjection = new Cartesian3();

    /**
     * @private
     */
    CorridorGeometryLibrary.computePositions = function(params) {
        var granularity = params.granularity;
        var positions = params.positions;
        var ellipsoid = params.ellipsoid;
        var width = params.width / 2;
        var cornerType = params.cornerType;
        var saveAttributes = params.saveAttributes;
        var normal = cartesian1;
        var forward = cartesian2;
        var backward = cartesian3;
        var left = cartesian4;
        var cornerDirection = cartesian5;
        var startPoint = cartesian6;
        var previousPos = cartesian7;
        var rightPos = cartesian8;
        var leftPos = cartesian9;
        var center = cartesian10;
        var calculatedPositions = [];
        var calculatedLefts = (saveAttributes) ? [] : undefined;
        var calculatedNormals = (saveAttributes) ? [] : undefined;
        var position = positions[0]; //add first point
        var nextPosition = positions[1];

        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);
        normal = ellipsoid.geodeticSurfaceNormal(position, normal);
        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);
        if (saveAttributes) {
            calculatedLefts.push(left.x, left.y, left.z);
            calculatedNormals.push(normal.x, normal.y, normal.z);
        }
        previousPos = Cartesian3.clone(position, previousPos);
        position = nextPosition;
        backward = Cartesian3.negate(forward, backward);

        var subdividedPositions;
        var corners = [];
        var i;
        var length = positions.length;
        for (i = 1; i < length - 1; i++) { // add middle points and corners
            normal = ellipsoid.geodeticSurfaceNormal(position, normal);
            nextPosition = positions[i + 1];
            forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);
            cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);

            var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);
            Cartesian3.subtract(forward, forwardProjection, forwardProjection);
            Cartesian3.normalize(forwardProjection, forwardProjection);

            var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);
            Cartesian3.subtract(backward, backwardProjection, backwardProjection);
            Cartesian3.normalize(backwardProjection, backwardProjection);

            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);

            if (doCorner) {
                cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);
                cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);
                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);
                var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));
                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);
                cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);
                if (leftIsOutside) {
                    rightPos = Cartesian3.add(position, cornerDirection, rightPos);
                    center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);
                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);
                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);
                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);
                    subdividedPositions = PolylinePipeline.generateArc({
                        positions: scaleArray2,
                        granularity: granularity,
                        ellipsoid: ellipsoid
                    });
                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);
                    if (saveAttributes) {
                        calculatedLefts.push(left.x, left.y, left.z);
                        calculatedNormals.push(normal.x, normal.y, normal.z);
                    }
                    startPoint = Cartesian3.clone(leftPos, startPoint);
                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);
                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);
                    previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);
                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                        corners.push({
                            leftPositions : computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)
                        });
                    } else {
                        corners.push({
                            leftPositions : computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)
                        });
                    }
                } else {
                    leftPos = Cartesian3.add(position, cornerDirection, leftPos);
                    center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);
                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);
                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);
                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);
                    subdividedPositions = PolylinePipeline.generateArc({
                        positions: scaleArray2,
                        granularity: granularity,
                        ellipsoid: ellipsoid
                    });
                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);
                    if (saveAttributes) {
                        calculatedLefts.push(left.x, left.y, left.z);
                        calculatedNormals.push(normal.x, normal.y, normal.z);
                    }
                    startPoint = Cartesian3.clone(rightPos, startPoint);
                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);
                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);
                    previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);
                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                        corners.push({
                            rightPositions : computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)
                        });
                    } else {
                        corners.push({
                            rightPositions : computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)
                        });
                    }
                }
                backward = Cartesian3.negate(forward, backward);
            }
            position = nextPosition;
        }

        normal = ellipsoid.geodeticSurfaceNormal(position, normal);
        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);
        scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);
        subdividedPositions = PolylinePipeline.generateArc({
            positions: scaleArray2,
            granularity: granularity,
            ellipsoid: ellipsoid
        });
        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);
        if (saveAttributes) {
            calculatedLefts.push(left.x, left.y, left.z);
            calculatedNormals.push(normal.x, normal.y, normal.z);
        }

        var endPositions;
        if (cornerType === CornerType.ROUNDED) {
            endPositions = addEndCaps(calculatedPositions);
        }

        return {
            positions : calculatedPositions,
            corners : corners,
            lefts : calculatedLefts,
            normals : calculatedNormals,
            endPositions : endPositions
        };
    };

    return CorridorGeometryLibrary;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CornerType */ "./node_modules/terriajs-cesium/Source/Core/CornerType.js"),
        __webpack_require__(/*! ./CorridorGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayFill,
        arrayRemoveDuplicates,
        BoundingSphere,
        Cartesian3,
        Check,
        ComponentDatatype,
        CornerType,
        CorridorGeometryLibrary,
        defaultValue,
        defined,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryOffsetAttribute,
        IndexDatatype,
        CesiumMath,
        PolygonPipeline,
        PrimitiveType) {
    'use strict';

    var cartesian1 = new Cartesian3();
    var cartesian2 = new Cartesian3();
    var cartesian3 = new Cartesian3();

    function scaleToSurface(positions, ellipsoid) {
        for (var i = 0; i < positions.length; i++) {
            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);
        }
        return positions;
    }

    function combine(computedPositions, cornerType) {
        var wallIndices = [];
        var positions = computedPositions.positions;
        var corners = computedPositions.corners;
        var endPositions = computedPositions.endPositions;
        var attributes = new GeometryAttributes();
        var corner;
        var leftCount = 0;
        var rightCount = 0;
        var i;
        var indicesLength = 0;
        var length;
        for (i = 0; i < positions.length; i += 2) {
            length = positions[i].length - 3;
            leftCount += length; //subtracting 3 to account for duplicate points at corners
            indicesLength += length / 3 * 4;
            rightCount += positions[i + 1].length - 3;
        }
        leftCount += 3; //add back count for end positions
        rightCount += 3;
        for (i = 0; i < corners.length; i++) {
            corner = corners[i];
            var leftSide = corners[i].leftPositions;
            if (defined(leftSide)) {
                length = leftSide.length;
                leftCount += length;
                indicesLength += length / 3 * 2;
            } else {
                length = corners[i].rightPositions.length;
                rightCount += length;
                indicesLength += length / 3 * 2;
            }
        }

        var addEndPositions = defined(endPositions);
        var endPositionLength;
        if (addEndPositions) {
            endPositionLength = endPositions[0].length - 3;
            leftCount += endPositionLength;
            rightCount += endPositionLength;
            endPositionLength /= 3;
            indicesLength += endPositionLength * 4;
        }
        var size = leftCount + rightCount;
        var finalPositions = new Float64Array(size);
        var front = 0;
        var back = size - 1;
        var UL, LL, UR, LR;
        var rightPos, leftPos;
        var halfLength = endPositionLength / 2;

        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);
        var index = 0;

        indices[index++] = front / 3;
        indices[index++] = (back - 2) / 3;
        if (addEndPositions) { // add rounded end
            wallIndices.push(front / 3);
            leftPos = cartesian1;
            rightPos = cartesian2;
            var firstEndPositions = endPositions[0];
            for (i = 0; i < halfLength; i++) {
                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);
                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);
                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);
                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);

                LL = front / 3;
                LR = LL + 1;
                UL = (back - 2) / 3;
                UR = UL - 1;
                indices[index++] = UL;
                indices[index++] = UR;
                indices[index++] = LL;
                indices[index++] = LR;

                front += 3;
                back -= 3;
            }
        }

        var posIndex = 0;
        var rightEdge = positions[posIndex++]; //add first two edges
        var leftEdge = positions[posIndex++];
        finalPositions.set(rightEdge, front);
        finalPositions.set(leftEdge, back - leftEdge.length + 1);

        length = leftEdge.length - 3;
        wallIndices.push(front / 3, (back - 2) / 3);
        for (i = 0; i < length; i += 3) {
            LL = front / 3;
            LR = LL + 1;
            UL = (back - 2) / 3;
            UR = UL - 1;
            indices[index++] = UL;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;

            front += 3;
            back -= 3;
        }

        for (i = 0; i < corners.length; i++) {
            var j;
            corner = corners[i];
            var l = corner.leftPositions;
            var r = corner.rightPositions;
            var start;
            var outsidePoint = cartesian3;
            if (defined(l)) {
                back -= 3;
                start = UR;
                wallIndices.push(LR);
                for (j = 0; j < l.length / 3; j++) {
                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);
                    indices[index++] = start - j - 1;
                    indices[index++] = start - j;
                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);
                    back -= 3;
                }
                wallIndices.push(start - Math.floor(l.length / 6));
                if (cornerType === CornerType.BEVELED) {
                    wallIndices.push((back - 2) / 3 + 1);
                }
                front += 3;
            } else {
                front += 3;
                start = LR;
                wallIndices.push(UR);
                for (j = 0; j < r.length / 3; j++) {
                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);
                    indices[index++] = start + j;
                    indices[index++] = start + j + 1;
                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);
                    front += 3;
                }
                wallIndices.push(start + Math.floor(r.length / 6));
                if (cornerType === CornerType.BEVELED) {
                    wallIndices.push(front / 3 - 1);
                }
                back -= 3;
            }
            rightEdge = positions[posIndex++];
            leftEdge = positions[posIndex++];
            rightEdge.splice(0, 3); //remove duplicate points added by corner
            leftEdge.splice(leftEdge.length - 3, 3);
            finalPositions.set(rightEdge, front);
            finalPositions.set(leftEdge, back - leftEdge.length + 1);
            length = leftEdge.length - 3;

            for (j = 0; j < leftEdge.length; j += 3) {
                LR = front / 3;
                LL = LR - 1;
                UR = (back - 2) / 3;
                UL = UR + 1;
                indices[index++] = UL;
                indices[index++] = UR;
                indices[index++] = LL;
                indices[index++] = LR;
                front += 3;
                back -= 3;
            }
            front -= 3;
            back += 3;
            wallIndices.push(front / 3, (back - 2) / 3);
        }

        if (addEndPositions) { // add rounded end
            front += 3;
            back -= 3;
            leftPos = cartesian1;
            rightPos = cartesian2;
            var lastEndPositions = endPositions[1];
            for (i = 0; i < halfLength; i++) {
                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);
                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);
                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);
                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);

                LR = front / 3;
                LL = LR - 1;
                UR = (back - 2) / 3;
                UL = UR + 1;
                indices[index++] = UL;
                indices[index++] = UR;
                indices[index++] = LL;
                indices[index++] = LR;

                front += 3;
                back -= 3;
            }

            wallIndices.push(front / 3);
        } else {
            wallIndices.push(front / 3, (back - 2) / 3);
        }
        indices[index++] = front / 3;
        indices[index++] = (back - 2) / 3;

        attributes.position = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : finalPositions
        });

        return {
            attributes : attributes,
            indices : indices,
            wallIndices : wallIndices
        };
    }

    function computePositionsExtruded(params) {
        var ellipsoid = params.ellipsoid;
        var computedPositions = CorridorGeometryLibrary.computePositions(params);
        var attr = combine(computedPositions, params.cornerType);
        var wallIndices = attr.wallIndices;
        var height = params.height;
        var extrudedHeight = params.extrudedHeight;
        var attributes = attr.attributes;
        var indices = attr.indices;
        var positions = attributes.position.values;
        var length = positions.length;
        var extrudedPositions = new Float64Array(length);
        extrudedPositions.set(positions);
        var newPositions = new Float64Array(length * 2);

        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);
        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);
        newPositions.set(positions);
        newPositions.set(extrudedPositions, length);
        attributes.position.values = newPositions;

        length /= 3;
        if (defined(params.offsetAttribute)) {
            var applyOffset = new Uint8Array(length * 2);
            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {
                applyOffset = arrayFill(applyOffset, 1, 0, length);
            } else {
                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                applyOffset = arrayFill(applyOffset, applyOffsetValue);
            }

            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values: applyOffset
            });
        }

        var i;
        var iLength = indices.length;
        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);
        newIndices.set(indices);
        var index = iLength;
        for (i = 0; i < iLength; i += 2) { // bottom indices
            var v0 = indices[i];
            var v1 = indices[i + 1];
            newIndices[index++] = v0 + length;
            newIndices[index++] = v1 + length;
        }

        var UL, LL;
        for (i = 0; i < wallIndices.length; i++) { //wall indices
            UL = wallIndices[i];
            LL = UL + length;
            newIndices[index++] = UL;
            newIndices[index++] = LL;
        }

        return {
            attributes : attributes,
            indices : newIndices
        };
    }

    /**
     * A description of a corridor outline.
     *
     * @alias CorridorOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.
     * @param {Number} options.width The distance between the edges of the corridor outline.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.
     * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.
     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
     *
     * @see CorridorOutlineGeometry.createGeometry
     *
     * @example
     * var corridor = new Cesium.CorridorOutlineGeometry({
     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
     *   width : 100000
     * });
     */
    function CorridorOutlineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.positions;
        var width = options.width;

        

        var height = defaultValue(options.height, 0.0);
        var extrudedHeight = defaultValue(options.extrudedHeight, height);

        this._positions = positions;
        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
        this._width = width;
        this._height = Math.max(height, extrudedHeight);
        this._extrudedHeight = Math.min(height, extrudedHeight);
        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        this._offsetAttribute = options.offsetAttribute;
        this._workerName = 'createCorridorOutlineGeometry';

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {CorridorOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    CorridorOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        array[startingIndex++] = value._width;
        array[startingIndex++] = value._height;
        array[startingIndex++] = value._extrudedHeight;
        array[startingIndex++] = value._cornerType;
        array[startingIndex++] = value._granularity;
        array[startingIndex] = defaultValue(value._offsetAttribute, -1);

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchOptions = {
        positions : undefined,
        ellipsoid : scratchEllipsoid,
        width : undefined,
        height : undefined,
        extrudedHeight : undefined,
        cornerType : undefined,
        granularity : undefined,
        offsetAttribute: undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {CorridorOutlineGeometry} [result] The object into which to store the result.
     * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.
     */
    CorridorOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var width = array[startingIndex++];
        var height = array[startingIndex++];
        var extrudedHeight = array[startingIndex++];
        var cornerType = array[startingIndex++];
        var granularity = array[startingIndex++];
        var offsetAttribute = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.positions = positions;
            scratchOptions.width = width;
            scratchOptions.height = height;
            scratchOptions.extrudedHeight = extrudedHeight;
            scratchOptions.cornerType = cornerType;
            scratchOptions.granularity = granularity;
            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;
            return new CorridorOutlineGeometry(scratchOptions);
        }

        result._positions = positions;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._width = width;
        result._height = height;
        result._extrudedHeight = extrudedHeight;
        result._cornerType = cornerType;
        result._granularity = granularity;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

        return result;
    };

    /**
     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
     *
     * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    CorridorOutlineGeometry.createGeometry = function(corridorOutlineGeometry) {
        var positions = corridorOutlineGeometry._positions;
        var width = corridorOutlineGeometry._width;
        var ellipsoid = corridorOutlineGeometry._ellipsoid;

        positions = scaleToSurface(positions, ellipsoid);
        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);

        if ((cleanPositions.length < 2) || (width <= 0)) {
            return;
        }

        var height = corridorOutlineGeometry._height;
        var extrudedHeight = corridorOutlineGeometry._extrudedHeight;
        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);

        var params = {
            ellipsoid : ellipsoid,
            positions : cleanPositions,
            width : width,
            cornerType : corridorOutlineGeometry._cornerType,
            granularity : corridorOutlineGeometry._granularity,
            saveAttributes : false
        };
        var attr;
        if (extrude) {
            params.height = height;
            params.extrudedHeight = extrudedHeight;
            params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;
            attr = computePositionsExtruded(params);
        } else {
            var computedPositions = CorridorGeometryLibrary.computePositions(params);
            attr = combine(computedPositions, params.cornerType);
            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);

            if (defined(corridorOutlineGeometry._offsetAttribute)) {
                var length = attr.attributes.position.values.length;
                var applyOffset = new Uint8Array(length / 3);
                var offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                arrayFill(applyOffset, offsetValue);
                attr.attributes.applyOffset = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                    componentsPerAttribute : 1,
                    values: applyOffset
                });
            }
        }
        var attributes = attr.attributes;
        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);

        return new Geometry({
            attributes : attributes,
            indices : attr.indices,
            primitiveType : PrimitiveType.LINES,
            boundingSphere : boundingSphere,
            offsetAttribute : corridorOutlineGeometry._offsetAttribute
        });
    };

    return CorridorOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CylinderGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayFill,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        ComponentDatatype,
        CylinderGeometryLibrary,
        defaultValue,
        defined,
        DeveloperError,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryOffsetAttribute,
        IndexDatatype,
        CesiumMath,
        PrimitiveType,
        VertexFormat) {
    'use strict';

    var radiusScratch = new Cartesian2();
    var normalScratch = new Cartesian3();
    var bitangentScratch = new Cartesian3();
    var tangentScratch = new Cartesian3();
    var positionScratch = new Cartesian3();

    /**
     * A description of a cylinder.
     *
     * @alias CylinderGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Number} options.length The length of the cylinder.
     * @param {Number} options.topRadius The radius of the top of the cylinder.
     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.
     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     *
     * @exception {DeveloperError} options.slices must be greater than or equal to 3.
     *
     * @see CylinderGeometry.createGeometry
     *
     * @example
     * // create cylinder geometry
     * var cylinder = new Cesium.CylinderGeometry({
     *     length: 200000,
     *     topRadius: 80000,
     *     bottomRadius: 200000,
     * });
     * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);
     */
    function CylinderGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var length = options.length;
        var topRadius = options.topRadius;
        var bottomRadius = options.bottomRadius;
        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
        var slices = defaultValue(options.slices, 128);

        

        this._length = length;
        this._topRadius = topRadius;
        this._bottomRadius = bottomRadius;
        this._vertexFormat = VertexFormat.clone(vertexFormat);
        this._slices = slices;
        this._offsetAttribute = options.offsetAttribute;
        this._workerName = 'createCylinderGeometry';
    }

    /**
     * The number of elements used to pack the object into an array.
     * @type {Number}
     */
    CylinderGeometry.packedLength = VertexFormat.packedLength + 5;

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {CylinderGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    CylinderGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._length;
        array[startingIndex++] = value._topRadius;
        array[startingIndex++] = value._bottomRadius;
        array[startingIndex++] = value._slices;
        array[startingIndex] = defaultValue(value._offsetAttribute, -1);

        return array;
    };

    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        vertexFormat : scratchVertexFormat,
        length : undefined,
        topRadius : undefined,
        bottomRadius : undefined,
        slices : undefined,
        offsetAttribute : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {CylinderGeometry} [result] The object into which to store the result.
     * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.
     */
    CylinderGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var length = array[startingIndex++];
        var topRadius = array[startingIndex++];
        var bottomRadius = array[startingIndex++];
        var slices = array[startingIndex++];
        var offsetAttribute = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.length = length;
            scratchOptions.topRadius = topRadius;
            scratchOptions.bottomRadius = bottomRadius;
            scratchOptions.slices = slices;
            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;
            return new CylinderGeometry(scratchOptions);
        }

        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._length = length;
        result._topRadius = topRadius;
        result._bottomRadius = bottomRadius;
        result._slices = slices;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

        return result;
    };

    /**
     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.
     *
     * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    CylinderGeometry.createGeometry = function(cylinderGeometry) {
        var length = cylinderGeometry._length;
        var topRadius = cylinderGeometry._topRadius;
        var bottomRadius = cylinderGeometry._bottomRadius;
        var vertexFormat = cylinderGeometry._vertexFormat;
        var slices = cylinderGeometry._slices;

        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {
            return;
        }

        var twoSlices = slices + slices;
        var threeSlices = slices + twoSlices;
        var numVertices = twoSlices + twoSlices;

        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);

        var st = (vertexFormat.st) ? new Float32Array(numVertices * 2) : undefined;
        var normals = (vertexFormat.normal) ? new Float32Array(numVertices * 3) : undefined;
        var tangents = (vertexFormat.tangent) ? new Float32Array(numVertices * 3) : undefined;
        var bitangents = (vertexFormat.bitangent) ? new Float32Array(numVertices * 3) : undefined;

        var i;
        var computeNormal = (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent);

        if (computeNormal) {
            var computeTangent = (vertexFormat.tangent || vertexFormat.bitangent);

            var normalIndex = 0;
            var tangentIndex = 0;
            var bitangentIndex = 0;

            var theta = Math.atan2(bottomRadius - topRadius, length);
            var normal = normalScratch;
            normal.z = Math.sin(theta);
            var normalScale = Math.cos(theta);
            var tangent = tangentScratch;
            var bitangent = bitangentScratch;

            for (i = 0; i < slices; i++) {
                var angle = i / slices * CesiumMath.TWO_PI;
                var x = normalScale * Math.cos(angle);
                var y = normalScale * Math.sin(angle);
                if (computeNormal) {
                    normal.x = x;
                    normal.y = y;

                    if (computeTangent) {
                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);
                    }

                    if (vertexFormat.normal) {
                        normals[normalIndex++] = normal.x;
                        normals[normalIndex++] = normal.y;
                        normals[normalIndex++] = normal.z;
                        normals[normalIndex++] = normal.x;
                        normals[normalIndex++] = normal.y;
                        normals[normalIndex++] = normal.z;
                    }

                    if (vertexFormat.tangent) {
                        tangents[tangentIndex++] = tangent.x;
                        tangents[tangentIndex++] = tangent.y;
                        tangents[tangentIndex++] = tangent.z;
                        tangents[tangentIndex++] = tangent.x;
                        tangents[tangentIndex++] = tangent.y;
                        tangents[tangentIndex++] = tangent.z;
                    }

                    if (vertexFormat.bitangent) {
                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);
                        bitangents[bitangentIndex++] = bitangent.x;
                        bitangents[bitangentIndex++] = bitangent.y;
                        bitangents[bitangentIndex++] = bitangent.z;
                        bitangents[bitangentIndex++] = bitangent.x;
                        bitangents[bitangentIndex++] = bitangent.y;
                        bitangents[bitangentIndex++] = bitangent.z;
                    }
                }
            }

            for (i = 0; i < slices; i++) {
                if (vertexFormat.normal) {
                    normals[normalIndex++] = 0;
                    normals[normalIndex++] = 0;
                    normals[normalIndex++] = -1;
                }
                if (vertexFormat.tangent) {
                    tangents[tangentIndex++] = 1;
                    tangents[tangentIndex++] = 0;
                    tangents[tangentIndex++] = 0;
                }
                if (vertexFormat.bitangent) {
                    bitangents[bitangentIndex++] = 0;
                    bitangents[bitangentIndex++] = -1;
                    bitangents[bitangentIndex++] = 0;
                }
            }

            for (i = 0; i < slices; i++) {
                if (vertexFormat.normal) {
                    normals[normalIndex++] = 0;
                    normals[normalIndex++] = 0;
                    normals[normalIndex++] = 1;
                }
                if (vertexFormat.tangent) {
                    tangents[tangentIndex++] = 1;
                    tangents[tangentIndex++] = 0;
                    tangents[tangentIndex++] = 0;
                }
                if (vertexFormat.bitangent) {
                    bitangents[bitangentIndex++] = 0;
                    bitangents[bitangentIndex++] = 1;
                    bitangents[bitangentIndex++] = 0;
                }
            }
        }

        var numIndices = 12 * slices - 12;
        var indices = IndexDatatype.createTypedArray(numVertices, numIndices);
        var index = 0;
        var j = 0;
        for (i = 0; i < slices - 1; i++) {
            indices[index++] = j;
            indices[index++] = j + 2;
            indices[index++] = j + 3;

            indices[index++] = j;
            indices[index++] = j + 3;
            indices[index++] = j + 1;

            j += 2;
        }

        indices[index++] = twoSlices - 2;
        indices[index++] = 0;
        indices[index++] = 1;
        indices[index++] = twoSlices - 2;
        indices[index++] = 1;
        indices[index++] = twoSlices - 1;

        for (i = 1; i < slices - 1; i++) {
            indices[index++] = twoSlices + i + 1;
            indices[index++] = twoSlices + i;
            indices[index++] = twoSlices;
        }

        for (i = 1; i < slices - 1; i++) {
            indices[index++] = threeSlices;
            indices[index++] = threeSlices + i;
            indices[index++] = threeSlices + i + 1;
        }

        var textureCoordIndex = 0;
        if (vertexFormat.st) {
            var rad = Math.max(topRadius, bottomRadius);
            for (i = 0; i < numVertices; i++) {
                var position = Cartesian3.fromArray(positions, i * 3, positionScratch);
                st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);
                st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);
            }
        }

        var attributes = new GeometryAttributes();
        if (vertexFormat.position) {
            attributes.position = new GeometryAttribute({
                componentDatatype: ComponentDatatype.DOUBLE,
                componentsPerAttribute: 3,
                values: positions
            });
        }

        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : normals
            });
        }

        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : tangents
            });
        }

        if (vertexFormat.bitangent) {
            attributes.bitangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : bitangents
            });
        }

        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : st
            });
        }

        radiusScratch.x = length * 0.5;
        radiusScratch.y = Math.max(bottomRadius, topRadius);

        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));

        if (defined(cylinderGeometry._offsetAttribute)) {
            length = positions.length;
            var applyOffset = new Uint8Array(length / 3);
            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
            arrayFill(applyOffset, offsetValue);
            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values: applyOffset
            });
        }

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.TRIANGLES,
            boundingSphere : boundingSphere,
            offsetAttribute : cylinderGeometry._offsetAttribute
        });
    };

    var unitCylinderGeometry;

    /**
     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.
     * @returns {Geometry} The computed vertices and indices.
     *
     * @private
     */
    CylinderGeometry.getUnitCylinder = function() {
        if (!defined(unitCylinderGeometry)) {
            unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({
                topRadius : 1.0,
                bottomRadius : 1.0,
                length : 1.0,
                vertexFormat : VertexFormat.POSITION_ONLY
            }));
        }
        return unitCylinderGeometry;
    };

    return CylinderGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        CesiumMath) {
    'use strict';

    /**
     * @private
     */
    var CylinderGeometryLibrary = {};

    /**
     * @private
     */
    CylinderGeometryLibrary.computePositions = function(length, topRadius, bottomRadius, slices, fill){
        var topZ = length * 0.5;
        var bottomZ = -topZ;

        var twoSlice = slices + slices;
        var size = (fill) ? 2 * twoSlice : twoSlice;
        var positions = new Float64Array(size*3);
        var i;
        var index = 0;
        var tbIndex = 0;
        var bottomOffset = (fill) ? twoSlice*3 : 0;
        var topOffset = (fill) ? (twoSlice + slices)*3 : slices*3;

        for (i = 0; i < slices; i++) {
            var angle = i / slices * CesiumMath.TWO_PI;
            var x = Math.cos(angle);
            var y = Math.sin(angle);
            var bottomX = x * bottomRadius;
            var bottomY = y * bottomRadius;
            var topX = x * topRadius;
            var topY = y * topRadius;

            positions[tbIndex + bottomOffset] = bottomX;
            positions[tbIndex + bottomOffset + 1] = bottomY;
            positions[tbIndex + bottomOffset + 2] = bottomZ;

            positions[tbIndex + topOffset] = topX;
            positions[tbIndex + topOffset + 1] = topY;
            positions[tbIndex + topOffset + 2] = topZ;
            tbIndex += 3;
            if (fill) {
                positions[index++] = bottomX;
                positions[index++] = bottomY;
                positions[index++] = bottomZ;
                positions[index++] = topX;
                positions[index++] = topY;
                positions[index++] = topZ;
            }
        }

        return positions;
    };

    return CylinderGeometryLibrary;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CylinderGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayFill,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Check,
        ComponentDatatype,
        CylinderGeometryLibrary,
        defaultValue,
        defined,
        DeveloperError,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryOffsetAttribute,
        IndexDatatype,
        PrimitiveType) {
    'use strict';

    var radiusScratch = new Cartesian2();

    /**
     * A description of the outline of a cylinder.
     *
     * @alias CylinderOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Number} options.length The length of the cylinder.
     * @param {Number} options.topRadius The radius of the top of the cylinder.
     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.
     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.
     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.
     *
     * @exception {DeveloperError} options.length must be greater than 0.
     * @exception {DeveloperError} options.topRadius must be greater than 0.
     * @exception {DeveloperError} options.bottomRadius must be greater than 0.
     * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.
     * @exception {DeveloperError} options.slices must be greater than or equal to 3.
     *
     * @see CylinderOutlineGeometry.createGeometry
     *
     * @example
     * // create cylinder geometry
     * var cylinder = new Cesium.CylinderOutlineGeometry({
     *     length: 200000,
     *     topRadius: 80000,
     *     bottomRadius: 200000,
     * });
     * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);
     */
    function CylinderOutlineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var length = options.length;
        var topRadius = options.topRadius;
        var bottomRadius = options.bottomRadius;
        var slices = defaultValue(options.slices, 128);
        var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);

        

        this._length = length;
        this._topRadius = topRadius;
        this._bottomRadius = bottomRadius;
        this._slices = slices;
        this._numberOfVerticalLines = numberOfVerticalLines;
        this._offsetAttribute = options.offsetAttribute;
        this._workerName = 'createCylinderOutlineGeometry';
    }

    /**
     * The number of elements used to pack the object into an array.
     * @type {Number}
     */
    CylinderOutlineGeometry.packedLength = 6;

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {CylinderOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    CylinderOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        array[startingIndex++] = value._length;
        array[startingIndex++] = value._topRadius;
        array[startingIndex++] = value._bottomRadius;
        array[startingIndex++] = value._slices;
        array[startingIndex++] = value._numberOfVerticalLines;
        array[startingIndex] = defaultValue(value._offsetAttribute, -1);

        return array;
    };

    var scratchOptions = {
        length : undefined,
        topRadius : undefined,
        bottomRadius : undefined,
        slices : undefined,
        numberOfVerticalLines : undefined,
        offsetAttribute : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {CylinderOutlineGeometry} [result] The object into which to store the result.
     * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.
     */
    CylinderOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var length = array[startingIndex++];
        var topRadius = array[startingIndex++];
        var bottomRadius = array[startingIndex++];
        var slices = array[startingIndex++];
        var numberOfVerticalLines = array[startingIndex++];
        var offsetAttribute = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.length = length;
            scratchOptions.topRadius = topRadius;
            scratchOptions.bottomRadius = bottomRadius;
            scratchOptions.slices = slices;
            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;
            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;
            return new CylinderOutlineGeometry(scratchOptions);
        }

        result._length = length;
        result._topRadius = topRadius;
        result._bottomRadius = bottomRadius;
        result._slices = slices;
        result._numberOfVerticalLines = numberOfVerticalLines;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

        return result;
    };

    /**
     * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.
     *
     * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    CylinderOutlineGeometry.createGeometry = function(cylinderGeometry) {
        var length = cylinderGeometry._length;
        var topRadius = cylinderGeometry._topRadius;
        var bottomRadius = cylinderGeometry._bottomRadius;
        var slices = cylinderGeometry._slices;
        var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;

        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {
            return;
        }

        var numVertices = slices * 2;

        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);
        var numIndices = slices * 2;
        var numSide;
        if (numberOfVerticalLines > 0) {
            var numSideLines = Math.min(numberOfVerticalLines, slices);
            numSide = Math.round(slices / numSideLines);
            numIndices += numSideLines;
        }

        var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);
        var index = 0;
        var i;
        for (i = 0; i < slices - 1; i++) {
            indices[index++] = i;
            indices[index++] = i + 1;
            indices[index++] = i + slices;
            indices[index++] = i + 1 + slices;
        }

        indices[index++] = slices - 1;
        indices[index++] = 0;
        indices[index++] = slices + slices - 1;
        indices[index++] = slices;

        if (numberOfVerticalLines > 0) {
            for (i = 0; i < slices; i += numSide) {
                indices[index++] = i;
                indices[index++] = i + slices;
            }
        }

        var attributes = new GeometryAttributes();
        attributes.position = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : positions
        });

        radiusScratch.x = length * 0.5;
        radiusScratch.y = Math.max(bottomRadius, topRadius);

        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));

        if (defined(cylinderGeometry._offsetAttribute)) {
            length = positions.length;
            var applyOffset = new Uint8Array(length / 3);
            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
            arrayFill(applyOffset, offsetValue);
            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values: applyOffset
            });
        }

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.LINES,
            boundingSphere : boundingSphere,
            offsetAttribute : cylinderGeometry._offsetAttribute
        });
    };

    return CylinderOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ComponentDatatype,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError) {
    'use strict';

    /**
     * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.
     *
     * @alias DistanceDisplayConditionGeometryInstanceAttribute
     * @constructor
     *
     * @param {Number} [near=0.0] The near distance.
     * @param {Number} [far=Number.MAX_VALUE] The far distance.
     *
     * @exception {DeveloperError} far must be greater than near.
     *
     * @example
     * var instance = new Cesium.GeometryInstance({
     *   geometry : new Cesium.BoxGeometry({
     *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
     *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),
     *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)
     *   }),
     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
     *   id : 'box',
     *   attributes : {
     *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)
     *   }
     * });
     *
     * @see GeometryInstance
     * @see GeometryInstanceAttribute
     */
    function DistanceDisplayConditionGeometryInstanceAttribute(near, far) {
        near = defaultValue(near, 0.0);
        far = defaultValue(far, Number.MAX_VALUE);

        

        /**
         * The values for the attributes stored in a typed array.
         *
         * @type Float32Array
         *
         * @default [0.0, 0.0, Number.MAX_VALUE]
         */
        this.value = new Float32Array([near, far]);
    }

    defineProperties(DistanceDisplayConditionGeometryInstanceAttribute.prototype, {
        /**
         * The datatype of each component in the attribute, e.g., individual elements in
         * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
         *
         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype
         *
         * @type {ComponentDatatype}
         * @readonly
         *
         * @default {@link ComponentDatatype.FLOAT}
         */
        componentDatatype : {
            get : function() {
                return ComponentDatatype.FLOAT;
            }
        },

        /**
         * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
         *
         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype
         *
         * @type {Number}
         * @readonly
         *
         * @default 3
         */
        componentsPerAttribute : {
            get : function() {
                return 2;
            }
        },

        /**
         * When <code>true</code> and <code>componentDatatype</code> is an integer format,
         * indicate that the components should be mapped to the range [0, 1] (unsigned)
         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
         *
         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype
         *
         * @type {Boolean}
         * @readonly
         *
         * @default false
         */
        normalize : {
            get : function() {
                return false;
            }
        }
    });

    /**
     * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.
     *
     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.
     * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.
     *
     * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near
     *
     * @example
     * var distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);
     * var instance = new Cesium.GeometryInstance({
     *   geometry : geometry,
     *   attributes : {
     *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
     *   }
     * });
     */
    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition = function(distanceDisplayCondition) {
        

        return new DistanceDisplayConditionGeometryInstanceAttribute(distanceDisplayCondition.near, distanceDisplayCondition.far);
    };

    /**
     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.
     *
     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.
     * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.
     * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.
     *
     * @example
     * var attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
     */
    DistanceDisplayConditionGeometryInstanceAttribute.toValue = function(distanceDisplayCondition, result) {
        

        if (!defined(result)) {
            return new Float32Array([distanceDisplayCondition.near, distanceDisplayCondition.far]);
        }
        result[0] = distanceDisplayCondition.near;
        result[1] = distanceDisplayCondition.far;
        return result;
    };

    return DistanceDisplayConditionGeometryInstanceAttribute;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js":
/*!*********************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./EllipseGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./GeographicProjection */ "./node_modules/terriajs-cesium/Source/Core/GeographicProjection.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./GeometryPipeline */ "./node_modules/terriajs-cesium/Source/Core/GeometryPipeline.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js"),
        __webpack_require__(/*! ./Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayFill,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Cartographic,
        Check,
        ComponentDatatype,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        EllipseGeometryLibrary,
        Ellipsoid,
        GeographicProjection,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryInstance,
        GeometryOffsetAttribute,
        GeometryPipeline,
        IndexDatatype,
        CesiumMath,
        Matrix3,
        PrimitiveType,
        Quaternion,
        Rectangle,
        VertexFormat) {
    'use strict';

    var scratchCartesian1 = new Cartesian3();
    var scratchCartesian2 = new Cartesian3();
    var scratchCartesian3 = new Cartesian3();
    var scratchCartesian4 = new Cartesian3();
    var texCoordScratch = new Cartesian2();
    var textureMatrixScratch = new Matrix3();
    var tangentMatrixScratch = new Matrix3();
    var quaternionScratch = new Quaternion();

    var scratchNormal = new Cartesian3();
    var scratchTangent = new Cartesian3();
    var scratchBitangent = new Cartesian3();

    var scratchCartographic = new Cartographic();
    var projectedCenterScratch = new Cartesian3();

    var scratchMinTexCoord = new Cartesian2();
    var scratchMaxTexCoord = new Cartesian2();

    function computeTopBottomAttributes(positions, options, extrude) {
        var vertexFormat = options.vertexFormat;
        var center = options.center;
        var semiMajorAxis = options.semiMajorAxis;
        var semiMinorAxis = options.semiMinorAxis;
        var ellipsoid = options.ellipsoid;
        var stRotation = options.stRotation;
        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;
        var shadowVolume = options.shadowVolume;

        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;
        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;
        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;
        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;

        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;

        var textureCoordIndex = 0;

        // Raise positions to a height above the ellipsoid and compute the
        // texture coordinates, normals, tangents, and bitangents.
        var normal = scratchNormal;
        var tangent = scratchTangent;
        var bitangent = scratchBitangent;

        var projection = new GeographicProjection(ellipsoid);
        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);

        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);
        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);

        var textureMatrix = textureMatrixScratch;
        var tangentMatrix = tangentMatrixScratch;
        if (stRotation !== 0) {
            var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);
            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);

            rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);
            tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);
        } else {
            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);
            tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);
        }

        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);
        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);

        var length = positions.length;
        var bottomOffset = (extrude) ? length : 0;
        var stOffset = bottomOffset / 3 * 2;
        for (var i = 0; i < length; i += 3) {
            var i1 = i + 1;
            var i2 = i + 2;
            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);

            if (vertexFormat.st) {
                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);
                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);
                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);

                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);
                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);

                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);
                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);
                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);
                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);

                if (extrude) {
                    textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;
                    textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;
                }

                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;
                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;
            }

            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {
                normal = ellipsoid.geodeticSurfaceNormal(position, normal);

                if (shadowVolume) {
                    extrudeNormals[i + bottomOffset] = -normal.x;
                    extrudeNormals[i1 + bottomOffset] = -normal.y;
                    extrudeNormals[i2 + bottomOffset] = -normal.z;
                }

                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {
                    if (vertexFormat.tangent || vertexFormat.bitangent) {
                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);
                        Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);
                    }
                    if (vertexFormat.normal) {
                        normals[i] = normal.x;
                        normals[i1] = normal.y;
                        normals[i2] = normal.z;
                        if (extrude) {
                            normals[i + bottomOffset] = -normal.x;
                            normals[i1 + bottomOffset] = -normal.y;
                            normals[i2 + bottomOffset] = -normal.z;
                        }
                    }

                    if (vertexFormat.tangent) {
                        tangents[i] = tangent.x;
                        tangents[i1] = tangent.y;
                        tangents[i2] = tangent.z;
                        if (extrude) {
                            tangents[i + bottomOffset] = -tangent.x;
                            tangents[i1 + bottomOffset] = -tangent.y;
                            tangents[i2 + bottomOffset] = -tangent.z;
                        }
                    }

                    if (vertexFormat.bitangent) {
                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);
                        bitangents[i ] = bitangent.x;
                        bitangents[i1] = bitangent.y;
                        bitangents[i2] = bitangent.z;
                        if (extrude) {
                            bitangents[i + bottomOffset] = bitangent.x;
                            bitangents[i1 + bottomOffset] = bitangent.y;
                            bitangents[i2 + bottomOffset] = bitangent.z;
                        }
                    }
                }
            }
        }

        if (vertexFormat.st) {
            length = textureCoordinates.length;
            for (var k = 0; k < length; k += 2) {
                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);
                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);
            }
        }

        var attributes = new GeometryAttributes();

        if (vertexFormat.position) {
            var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);
            attributes.position = new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : finalPositions
            });
        }

        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : textureCoordinates
            });
        }

        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : normals
            });
        }

        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : tangents
            });
        }

        if (vertexFormat.bitangent) {
            attributes.bitangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : bitangents
            });
        }

        if (shadowVolume) {
            attributes.extrudeDirection = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : extrudeNormals
            });
        }

        if (extrude && defined(options.offsetAttribute)) {
            var offsetAttribute = new Uint8Array(size);
            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {
                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);
            } else {
                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                offsetAttribute = arrayFill(offsetAttribute, offsetValue);
            }

            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values : offsetAttribute
            });
        }

        return attributes;
    }

    function topIndices(numPts) {
        // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)
        //              = -1 + 4 * ((n * ( n + 1)) / 2)
        // total triangles = 2 * numTrangles in half
        // indices = total triangles * 3;
        // Substitute numPts for n above

        var indices = new Array(12 * (numPts * ( numPts + 1)) - 6);
        var indicesIndex = 0;
        var prevIndex;
        var numInterior;
        var positionIndex;
        var i;
        var j;
        // Indices triangles to the 'right' of the north vector

        prevIndex = 0;
        positionIndex = 1;
        for (i = 0; i < 3; i++) {
            indices[indicesIndex++] = positionIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;
        }

        for (i = 2; i < numPts + 1; ++i) {
            positionIndex = i * (i + 1) - 1;
            prevIndex = (i - 1) * i - 1;

            indices[indicesIndex++] = positionIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;

            numInterior = 2 * i;
            for (j = 0; j < numInterior - 1; ++j) {

                indices[indicesIndex++] = positionIndex;
                indices[indicesIndex++] = prevIndex++;
                indices[indicesIndex++] = prevIndex;

                indices[indicesIndex++] = positionIndex++;
                indices[indicesIndex++] = prevIndex;
                indices[indicesIndex++] = positionIndex;
            }

            indices[indicesIndex++] = positionIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;
        }

        // Indices for center column of triangles
        numInterior = numPts * 2;
        ++positionIndex;
        ++prevIndex;
        for (i = 0; i < numInterior - 1; ++i) {
            indices[indicesIndex++] = positionIndex;
            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = prevIndex;

            indices[indicesIndex++] = positionIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;
        }

        indices[indicesIndex++] = positionIndex;
        indices[indicesIndex++] = prevIndex++;
        indices[indicesIndex++] = prevIndex;

        indices[indicesIndex++] = positionIndex++;
        indices[indicesIndex++] = prevIndex++;
        indices[indicesIndex++] = prevIndex;

        // Reverse the process creating indices to the 'left' of the north vector
        ++prevIndex;
        for (i = numPts - 1; i > 1; --i) {
            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;

            numInterior = 2 * i;
            for (j = 0; j < numInterior - 1; ++j) {
                indices[indicesIndex++] = positionIndex;
                indices[indicesIndex++] = prevIndex++;
                indices[indicesIndex++] = prevIndex;

                indices[indicesIndex++] = positionIndex++;
                indices[indicesIndex++] = prevIndex;
                indices[indicesIndex++] = positionIndex;
            }

            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = positionIndex++;
        }

        for (i = 0; i < 3; i++) {
            indices[indicesIndex++] = prevIndex++;
            indices[indicesIndex++] = prevIndex;
            indices[indicesIndex++] = positionIndex;
        }
        return indices;
    }

    var boundingSphereCenter = new Cartesian3();

    function computeEllipse(options) {
        var center = options.center;
        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);
        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);
        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);
        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);
        var positions = cep.positions;
        var numPts = cep.numPts;
        var attributes = computeTopBottomAttributes(positions, options, false);
        var indices = topIndices(numPts);
        indices = IndexDatatype.createTypedArray(positions.length / 3, indices);
        return {
            boundingSphere : boundingSphere,
            attributes : attributes,
            indices : indices
        };
    }

    function computeWallAttributes(positions, options) {
        var vertexFormat = options.vertexFormat;
        var center = options.center;
        var semiMajorAxis = options.semiMajorAxis;
        var semiMinorAxis = options.semiMinorAxis;
        var ellipsoid = options.ellipsoid;
        var height = options.height;
        var extrudedHeight = options.extrudedHeight;
        var stRotation = options.stRotation;
        var size = positions.length / 3 * 2;

        var finalPositions = new Float64Array(size * 3);
        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;
        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;
        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;
        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;

        var shadowVolume = options.shadowVolume;
        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;

        var textureCoordIndex = 0;

        // Raise positions to a height above the ellipsoid and compute the
        // texture coordinates, normals, tangents, and bitangents.
        var normal = scratchNormal;
        var tangent = scratchTangent;
        var bitangent = scratchBitangent;

        var projection = new GeographicProjection(ellipsoid);
        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);

        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);
        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);
        var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);
        var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);

        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);
        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);

        var length = positions.length;
        var stOffset = length / 3 * 2;
        for (var i = 0; i < length; i += 3) {
            var i1 = i + 1;
            var i2 = i + 2;
            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);
            var extrudedPosition;

            if (vertexFormat.st) {
                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);
                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);
                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);

                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);
                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);

                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);
                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);
                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);
                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);

                textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;
                textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;

                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;
                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;
            }

            position = ellipsoid.scaleToGeodeticSurface(position, position);
            extrudedPosition = Cartesian3.clone(position, scratchCartesian2);
            normal = ellipsoid.geodeticSurfaceNormal(position, normal);

            if (shadowVolume) {
                extrudeNormals[i + length] = -normal.x;
                extrudeNormals[i1 + length] = -normal.y;
                extrudeNormals[i2 + length] = -normal.z;
            }

            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);
            position = Cartesian3.add(position, scaledNormal, position);
            scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);
            extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);

            if (vertexFormat.position) {
                finalPositions[i + length] = extrudedPosition.x;
                finalPositions[i1 + length] = extrudedPosition.y;
                finalPositions[i2 + length] = extrudedPosition.z;

                finalPositions[i] = position.x;
                finalPositions[i1] = position.y;
                finalPositions[i2] = position.z;
            }

            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {

                bitangent = Cartesian3.clone(normal, bitangent);
                var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);
                Cartesian3.subtract(next, position, next);
                var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);

                normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);

                if (vertexFormat.normal) {
                    normals[i] = normal.x;
                    normals[i1] = normal.y;
                    normals[i2] = normal.z;

                    normals[i + length] = normal.x;
                    normals[i1 + length] = normal.y;
                    normals[i2 + length] = normal.z;
                }

                if (vertexFormat.tangent) {
                    tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);
                    tangents[i] = tangent.x;
                    tangents[i1] = tangent.y;
                    tangents[i2] = tangent.z;

                    tangents[i + length] = tangent.x;
                    tangents[i + 1 + length] = tangent.y;
                    tangents[i + 2 + length] = tangent.z;
                }

                if (vertexFormat.bitangent) {
                    bitangents[i ] = bitangent.x;
                    bitangents[i1] = bitangent.y;
                    bitangents[i2] = bitangent.z;

                    bitangents[i + length] = bitangent.x;
                    bitangents[i1 + length] = bitangent.y;
                    bitangents[i2 + length] = bitangent.z;
                }
            }
        }

        if (vertexFormat.st) {
            length = textureCoordinates.length;
            for (var k = 0; k < length; k += 2) {
                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);
                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);
            }
        }

        var attributes = new GeometryAttributes();

        if (vertexFormat.position) {
            attributes.position = new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : finalPositions
            });
        }

        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : textureCoordinates
            });
        }

        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : normals
            });
        }

        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : tangents
            });
        }

        if (vertexFormat.bitangent) {
            attributes.bitangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : bitangents
            });
        }

        if (shadowVolume) {
            attributes.extrudeDirection = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : extrudeNormals
            });
        }

        if (defined(options.offsetAttribute)) {
            var offsetAttribute = new Uint8Array(size);
            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {
                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);
            } else {
                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                offsetAttribute = arrayFill(offsetAttribute, offsetValue);
            }
            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values : offsetAttribute
            });
        }

        return attributes;
    }

    function computeWallIndices(positions) {
        var length = positions.length / 3;
        var indices = IndexDatatype.createTypedArray(length, length * 6);
        var index = 0;
        for (var i = 0; i < length; i++) {
            var UL = i;
            var LL = i + length;
            var UR = (UL + 1) % length;
            var LR = UR + length;
            indices[index++] = UL;
            indices[index++] = LL;
            indices[index++] = UR;
            indices[index++] = UR;
            indices[index++] = LL;
            indices[index++] = LR;
        }

        return indices;
    }

    var topBoundingSphere = new BoundingSphere();
    var bottomBoundingSphere = new BoundingSphere();

    function computeExtrudedEllipse(options) {
        var center = options.center;
        var ellipsoid = options.ellipsoid;
        var semiMajorAxis = options.semiMajorAxis;
        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);
        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);
        topBoundingSphere.radius = semiMajorAxis;

        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);
        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);
        bottomBoundingSphere.radius = semiMajorAxis;

        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);
        var positions = cep.positions;
        var numPts = cep.numPts;
        var outerPositions = cep.outerPositions;
        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);
        var topBottomAttributes = computeTopBottomAttributes(positions, options, true);
        var indices = topIndices(numPts);
        var length = indices.length;
        indices.length = length * 2;
        var posLength = positions.length / 3;
        for (var i = 0; i < length; i += 3) {
            indices[i + length] = indices[i + 2] + posLength;
            indices[i + 1 + length] = indices[i + 1] + posLength;
            indices[i + 2 + length] = indices[i] + posLength;
        }

        var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);

        var topBottomGeo = new Geometry({
            attributes : topBottomAttributes,
            indices : topBottomIndices,
            primitiveType : PrimitiveType.TRIANGLES
        });

        var wallAttributes = computeWallAttributes(outerPositions, options);
        indices = computeWallIndices(outerPositions);
        var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);

        var wallGeo = new Geometry({
            attributes : wallAttributes,
            indices : wallIndices,
            primitiveType : PrimitiveType.TRIANGLES
        });

        var geo = GeometryPipeline.combineInstances([
            new GeometryInstance({
                geometry : topBottomGeo
            }),
            new GeometryInstance({
                geometry : wallGeo
            })
        ]);

        return {
            boundingSphere : boundingSphere,
            attributes : geo[0].attributes,
            indices : geo[0].indices
        };
    }

    function computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {
        var cep = EllipseGeometryLibrary.computeEllipsePositions({
            center : center,
            semiMajorAxis : semiMajorAxis,
            semiMinorAxis : semiMinorAxis,
            rotation : rotation,
            granularity : granularity
        }, false, true);
        var positionsFlat = cep.outerPositions;
        var positionsCount = positionsFlat.length / 3;
        var positions = new Array(positionsCount);
        for (var i = 0; i < positionsCount; ++i) {
            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);
        }
        var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);
        // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.
        // When this happens, make the rectangle into a "circle" around the pole
        if (rectangle.width > CesiumMath.PI) {
            rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;
            rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;
            rectangle.east = CesiumMath.PI;
            rectangle.west = -CesiumMath.PI;
        }
        return rectangle;
    }

    /**
     * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     *
     * @alias EllipseGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.
     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.
     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.
     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.
     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.
     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.
     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     *
     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.
     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.
     * @exception {DeveloperError} granularity must be greater than zero.
     *
     *
     * @example
     * // Create an ellipse.
     * var ellipse = new Cesium.EllipseGeometry({
     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
     *   semiMajorAxis : 500000.0,
     *   semiMinorAxis : 300000.0,
     *   rotation : Cesium.Math.toRadians(60.0)
     * });
     * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);
     *
     * @see EllipseGeometry.createGeometry
     */
    function EllipseGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var center = options.center;
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
        var semiMajorAxis = options.semiMajorAxis;
        var semiMinorAxis = options.semiMinorAxis;
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);

        

        var height = defaultValue(options.height, 0.0);
        var extrudedHeight = defaultValue(options.extrudedHeight, height);

        this._center = Cartesian3.clone(center);
        this._semiMajorAxis = semiMajorAxis;
        this._semiMinorAxis = semiMinorAxis;
        this._ellipsoid = Ellipsoid.clone(ellipsoid);
        this._rotation = defaultValue(options.rotation, 0.0);
        this._stRotation = defaultValue(options.stRotation, 0.0);
        this._height = Math.max(extrudedHeight, height);
        this._granularity = granularity;
        this._vertexFormat = VertexFormat.clone(vertexFormat);
        this._extrudedHeight = Math.min(extrudedHeight, height);
        this._shadowVolume = defaultValue(options.shadowVolume, false);
        this._workerName = 'createEllipseGeometry';
        this._offsetAttribute = options.offsetAttribute;

        this._rectangle = undefined;
        this._textureCoordinateRotationPoints = undefined;
    }

    /**
     * The number of elements used to pack the object into an array.
     * @type {Number}
     */
    EllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {EllipseGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    EllipseGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        Cartesian3.pack(value._center, array, startingIndex);
        startingIndex += Cartesian3.packedLength;

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._semiMajorAxis;
        array[startingIndex++] = value._semiMinorAxis;
        array[startingIndex++] = value._rotation;
        array[startingIndex++] = value._stRotation;
        array[startingIndex++] = value._height;
        array[startingIndex++] = value._granularity;
        array[startingIndex++] = value._extrudedHeight;
        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;
        array[startingIndex] = defaultValue(value._offsetAttribute, -1);

        return array;
    };

    var scratchCenter = new Cartesian3();
    var scratchEllipsoid = new Ellipsoid();
    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        center : scratchCenter,
        ellipsoid : scratchEllipsoid,
        vertexFormat : scratchVertexFormat,
        semiMajorAxis : undefined,
        semiMinorAxis : undefined,
        rotation : undefined,
        stRotation : undefined,
        height : undefined,
        granularity : undefined,
        extrudedHeight : undefined,
        shadowVolume: undefined,
        offsetAttribute: undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {EllipseGeometry} [result] The object into which to store the result.
     * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.
     */
    EllipseGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);
        startingIndex += Cartesian3.packedLength;

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var semiMajorAxis = array[startingIndex++];
        var semiMinorAxis = array[startingIndex++];
        var rotation = array[startingIndex++];
        var stRotation = array[startingIndex++];
        var height = array[startingIndex++];
        var granularity = array[startingIndex++];
        var extrudedHeight = array[startingIndex++];
        var shadowVolume = array[startingIndex++] === 1.0;
        var offsetAttribute = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.height = height;
            scratchOptions.extrudedHeight = extrudedHeight;
            scratchOptions.granularity = granularity;
            scratchOptions.stRotation = stRotation;
            scratchOptions.rotation = rotation;
            scratchOptions.semiMajorAxis = semiMajorAxis;
            scratchOptions.semiMinorAxis = semiMinorAxis;
            scratchOptions.shadowVolume = shadowVolume;
            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

            return new EllipseGeometry(scratchOptions);
        }

        result._center = Cartesian3.clone(center, result._center);
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._semiMajorAxis = semiMajorAxis;
        result._semiMinorAxis = semiMinorAxis;
        result._rotation = rotation;
        result._stRotation = stRotation;
        result._height = height;
        result._granularity = granularity;
        result._extrudedHeight = extrudedHeight;
        result._shadowVolume = shadowVolume;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

        return result;
    };

    /**
     * Computes the bounding rectangle based on the provided options
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.
     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.
     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.
     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.
     * @param {Rectangle} [result] An object in which to store the result
     *
     * @returns {Rectangle} The result rectangle
     */
    EllipseGeometry.computeRectangle = function(options, result) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var center = options.center;
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
        var semiMajorAxis = options.semiMajorAxis;
        var semiMinorAxis = options.semiMinorAxis;
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var rotation = defaultValue(options.rotation, 0.0);

        

        return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);
    };

    /**
     * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
     *
     * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    EllipseGeometry.createGeometry = function(ellipseGeometry) {
        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {
            return;
        }

        var height = ellipseGeometry._height;
        var extrudedHeight = ellipseGeometry._extrudedHeight;
        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);

        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);
        var options = {
            center : ellipseGeometry._center,
            semiMajorAxis : ellipseGeometry._semiMajorAxis,
            semiMinorAxis : ellipseGeometry._semiMinorAxis,
            ellipsoid : ellipseGeometry._ellipsoid,
            rotation : ellipseGeometry._rotation,
            height : height,
            granularity : ellipseGeometry._granularity,
            vertexFormat : ellipseGeometry._vertexFormat,
            stRotation : ellipseGeometry._stRotation
        };
        var geometry;
        if (extrude) {
            options.extrudedHeight = extrudedHeight;
            options.shadowVolume = ellipseGeometry._shadowVolume;
            options.offsetAttribute = ellipseGeometry._offsetAttribute;
            geometry = computeExtrudedEllipse(options);
        } else {
            geometry = computeEllipse(options);

            if (defined(ellipseGeometry._offsetAttribute)) {
                var length = geometry.attributes.position.values.length;
                var applyOffset = new Uint8Array(length / 3);
                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                arrayFill(applyOffset, offsetValue);
                geometry.attributes.applyOffset = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                    componentsPerAttribute : 1,
                    values: applyOffset
                });
            }
        }

        return new Geometry({
            attributes : geometry.attributes,
            indices : geometry.indices,
            primitiveType : PrimitiveType.TRIANGLES,
            boundingSphere : geometry.boundingSphere,
            offsetAttribute : ellipseGeometry._offsetAttribute
        });
    };

    /**
     * @private
     */
    EllipseGeometry.createShadowVolume = function(ellipseGeometry, minHeightFunc, maxHeightFunc) {
        var granularity = ellipseGeometry._granularity;
        var ellipsoid = ellipseGeometry._ellipsoid;

        var minHeight = minHeightFunc(granularity, ellipsoid);
        var maxHeight = maxHeightFunc(granularity, ellipsoid);

        return new EllipseGeometry({
            center : ellipseGeometry._center,
            semiMajorAxis : ellipseGeometry._semiMajorAxis,
            semiMinorAxis : ellipseGeometry._semiMinorAxis,
            ellipsoid : ellipsoid,
            rotation : ellipseGeometry._rotation,
            stRotation : ellipseGeometry._stRotation,
            granularity : granularity,
            extrudedHeight : minHeight,
            height : maxHeight,
            vertexFormat : VertexFormat.POSITION_ONLY,
            shadowVolume: true
        });
    };

    function textureCoordinateRotationPoints(ellipseGeometry) {
        var stRotation = -ellipseGeometry._stRotation;
        if (stRotation === 0.0) {
            return [0, 0, 0, 1, 1, 0];
        }

        var cep = EllipseGeometryLibrary.computeEllipsePositions({
            center : ellipseGeometry._center,
            semiMajorAxis : ellipseGeometry._semiMajorAxis,
            semiMinorAxis : ellipseGeometry._semiMinorAxis,
            rotation : ellipseGeometry._rotation,
            granularity : ellipseGeometry._granularity
        }, false, true);
        var positionsFlat = cep.outerPositions;
        var positionsCount = positionsFlat.length / 3;
        var positions = new Array(positionsCount);
        for (var i = 0; i < positionsCount; ++i) {
            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);
        }

        var ellipsoid = ellipseGeometry._ellipsoid;
        var boundingRectangle = ellipseGeometry.rectangle;
        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);
    }

    defineProperties(EllipseGeometry.prototype, {
        /**
         * @private
         */
        rectangle : {
            get : function() {
                if (!defined(this._rectangle)) {
                    this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);
                }
                return this._rectangle;
            }
        },
        /**
         * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.
         * @private
         */
        textureCoordinateRotationPoints : {
            get : function() {
                if (!defined(this._textureCoordinateRotationPoints)) {
                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);
                }
                return this._textureCoordinateRotationPoints;
            }
        }
    });

    return EllipseGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartesian3,
        CesiumMath,
        Matrix3,
        Quaternion) {
    'use strict';

    var EllipseGeometryLibrary = {};

    var rotAxis = new Cartesian3();
    var tempVec = new Cartesian3();
    var unitQuat = new Quaternion();
    var rotMtx = new Matrix3();

    function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {
        var azimuth = theta + rotation;

        Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);
        Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);
        Cartesian3.add(rotAxis, tempVec, rotAxis);

        var cosThetaSquared = Math.cos(theta);
        cosThetaSquared = cosThetaSquared * cosThetaSquared;

        var sinThetaSquared = Math.sin(theta);
        sinThetaSquared = sinThetaSquared * sinThetaSquared;

        var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);
        var angle = radius / mag;

        // Create the quaternion to rotate the position vector to the boundary of the ellipse.
        Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);
        Matrix3.fromQuaternion(unitQuat, rotMtx);

        Matrix3.multiplyByVector(rotMtx, unitPos, result);
        Cartesian3.normalize(result, result);
        Cartesian3.multiplyByScalar(result, mag, result);
        return result;
    }

    var scratchCartesian1 = new Cartesian3();
    var scratchCartesian2 = new Cartesian3();
    var scratchCartesian3 = new Cartesian3();
    var scratchNormal = new Cartesian3();
    /**
     * Returns the positions raised to the given heights
     * @private
     */
    EllipseGeometryLibrary.raisePositionsToHeight = function(positions, options, extrude) {
        var ellipsoid = options.ellipsoid;
        var height = options.height;
        var extrudedHeight = options.extrudedHeight;
        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;

        var finalPositions = new Float64Array(size * 3);

        var length = positions.length;
        var bottomOffset = (extrude) ? length : 0;
        for (var i = 0; i < length; i += 3) {
            var i1 = i + 1;
            var i2 = i + 2;

            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);
            ellipsoid.scaleToGeodeticSurface(position, position);

            var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);
            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);
            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);
            Cartesian3.add(position, scaledNormal, position);

            if (extrude) {
                Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);
                Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);

                finalPositions[i + bottomOffset] = extrudedPosition.x;
                finalPositions[i1 + bottomOffset] = extrudedPosition.y;
                finalPositions[i2 + bottomOffset] = extrudedPosition.z;
            }

            finalPositions[i] = position.x;
            finalPositions[i1] = position.y;
            finalPositions[i2] = position.z;
        }

        return finalPositions;
    };

    var unitPosScratch = new Cartesian3();
    var eastVecScratch = new Cartesian3();
    var northVecScratch = new Cartesian3();
    /**
     * Returns an array of positions that make up the ellipse.
     * @private
     */
    EllipseGeometryLibrary.computeEllipsePositions = function(options, addFillPositions, addEdgePositions) {
        var semiMinorAxis = options.semiMinorAxis;
        var semiMajorAxis = options.semiMajorAxis;
        var rotation = options.rotation;
        var center = options.center;

        // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the
        // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or
        // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make
        // the distance along the ellipse boundary more closely match the granularity.
        var granularity = options.granularity * 8.0;

        var aSqr = semiMinorAxis * semiMinorAxis;
        var bSqr = semiMajorAxis * semiMajorAxis;
        var ab = semiMajorAxis * semiMinorAxis;

        var mag = Cartesian3.magnitude(center);

        var unitPos = Cartesian3.normalize(center, unitPosScratch);
        var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);
        eastVec = Cartesian3.normalize(eastVec, eastVec);
        var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);

        // The number of points in the first quadrant
        var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);

        var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);
        var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;
        if (theta < 0.0) {
            numPts -= Math.ceil(Math.abs(theta) / deltaTheta);
        }

        // If the number of points were three, the ellipse
        // would be tessellated like below:
        //
        //         *---*
        //       / | \ | \
        //     *---*---*---*
        //   / | \ | \ | \ | \
        //  / .*---*---*---*. \
        // * ` | \ | \ | \ | `*
        //  \`.*---*---*---*.`/
        //   \ | \ | \ | \ | /
        //     *---*---*---*
        //       \ | \ | /
        //         *---*
        // The first and last column have one position and fan to connect to the adjacent column.
        // Each other vertical column contains an even number of positions.
        var size = 2 * (numPts * (numPts + 2));
        var positions = (addFillPositions) ? new Array(size * 3) : undefined;
        var positionIndex = 0;
        var position = scratchCartesian1;
        var reflectedPosition = scratchCartesian2;

        var outerPositionsLength = (numPts * 4) * 3;
        var outerRightIndex = outerPositionsLength - 1;
        var outerLeftIndex = 0;
        var outerPositions = (addEdgePositions) ? new Array(outerPositionsLength) : undefined;

        var i;
        var j;
        var numInterior;
        var t;
        var interiorPosition;

        // Compute points in the 'eastern' half of the ellipse
        theta = CesiumMath.PI_OVER_TWO;
        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);
        if (addFillPositions) {
            positions[positionIndex++] = position.x;
            positions[positionIndex++] = position.y;
            positions[positionIndex++] = position.z;
        }
        if (addEdgePositions) {
            outerPositions[outerRightIndex--] = position.z;
            outerPositions[outerRightIndex--] = position.y;
            outerPositions[outerRightIndex--] = position.x;
        }
        theta = CesiumMath.PI_OVER_TWO -  deltaTheta;
        for (i = 1; i < numPts + 1; ++i) {
            position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);
            reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);

            if (addFillPositions) {
                positions[positionIndex++] = position.x;
                positions[positionIndex++] = position.y;
                positions[positionIndex++] = position.z;

                numInterior = 2 * i + 2;
                for (j = 1; j < numInterior - 1; ++j) {
                    t = j / (numInterior - 1);
                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);
                    positions[positionIndex++] = interiorPosition.x;
                    positions[positionIndex++] = interiorPosition.y;
                    positions[positionIndex++] = interiorPosition.z;
                }

                positions[positionIndex++] = reflectedPosition.x;
                positions[positionIndex++] = reflectedPosition.y;
                positions[positionIndex++] = reflectedPosition.z;
            }

            if (addEdgePositions) {
                outerPositions[outerRightIndex--] = position.z;
                outerPositions[outerRightIndex--] = position.y;
                outerPositions[outerRightIndex--] = position.x;
                outerPositions[outerLeftIndex++] = reflectedPosition.x;
                outerPositions[outerLeftIndex++] = reflectedPosition.y;
                outerPositions[outerLeftIndex++] = reflectedPosition.z;
            }

            theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;
        }

        // Compute points in the 'western' half of the ellipse
        for (i = numPts; i > 1; --i) {
            theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;

            position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);
            reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);

            if (addFillPositions) {
                positions[positionIndex++] = position.x;
                positions[positionIndex++] = position.y;
                positions[positionIndex++] = position.z;

                numInterior = 2 * (i - 1) + 2;
                for (j = 1; j < numInterior - 1; ++j) {
                    t = j / (numInterior - 1);
                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);
                    positions[positionIndex++] = interiorPosition.x;
                    positions[positionIndex++] = interiorPosition.y;
                    positions[positionIndex++] = interiorPosition.z;
                }

                positions[positionIndex++] = reflectedPosition.x;
                positions[positionIndex++] = reflectedPosition.y;
                positions[positionIndex++] = reflectedPosition.z;
            }

            if (addEdgePositions) {
                outerPositions[outerRightIndex--] = position.z;
                outerPositions[outerRightIndex--] = position.y;
                outerPositions[outerRightIndex--] = position.x;
                outerPositions[outerLeftIndex++] = reflectedPosition.x;
                outerPositions[outerLeftIndex++] = reflectedPosition.y;
                outerPositions[outerLeftIndex++] = reflectedPosition.z;
            }
        }

        theta = CesiumMath.PI_OVER_TWO;
        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);

        var r = {};
        if (addFillPositions) {
            positions[positionIndex++] = position.x;
            positions[positionIndex++] = position.y;
            positions[positionIndex++] = position.z;
            r.positions = positions;
            r.numPts = numPts;
        }
        if (addEdgePositions) {
            outerPositions[outerRightIndex--] = position.z;
            outerPositions[outerRightIndex--] = position.y;
            outerPositions[outerRightIndex--] = position.x;
            r.outerPositions = outerPositions;
        }

        return r;
    };

    return EllipseGeometryLibrary;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./EllipseGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayFill,
        BoundingSphere,
        Cartesian3,
        ComponentDatatype,
        defaultValue,
        defined,
        DeveloperError,
        EllipseGeometryLibrary,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryOffsetAttribute,
        IndexDatatype,
        CesiumMath,
        PrimitiveType) {
    'use strict';

    var scratchCartesian1 = new Cartesian3();
    var boundingSphereCenter = new Cartesian3();

    function computeEllipse(options) {
        var center = options.center;
        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);
        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);
        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);
        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;

        var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)
            })
        });

        var length = positions.length / 3;
        var indices = IndexDatatype.createTypedArray(length, length * 2);
        var index = 0;
        for ( var i = 0; i < length; ++i) {
            indices[index++] = i;
            indices[index++] = (i + 1) % length;
        }

        return {
            boundingSphere : boundingSphere,
            attributes : attributes,
            indices : indices
        };
    }

    var topBoundingSphere = new BoundingSphere();
    var bottomBoundingSphere = new BoundingSphere();
    function computeExtrudedEllipse(options) {
        var center = options.center;
        var ellipsoid = options.ellipsoid;
        var semiMajorAxis = options.semiMajorAxis;
        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);
        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);
        topBoundingSphere.radius = semiMajorAxis;

        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);
        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);
        bottomBoundingSphere.radius = semiMajorAxis;

        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;
        var attributes = new GeometryAttributes({
            position: new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)
            })
        });

        positions = attributes.position.values;
        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);
        var length = positions.length/3;

        if (defined(options.offsetAttribute)) {
            var applyOffset = new Uint8Array(length);
            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {
                applyOffset = arrayFill(applyOffset, 1, 0, length / 2);
            } else {
                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                applyOffset = arrayFill(applyOffset, offsetValue);
            }

            attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values: applyOffset
            });
        }

        var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);
        numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length/2);

        var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);

        length /= 2;
        var index = 0;
        var i;
        for (i = 0; i < length; ++i) {
            indices[index++] = i;
            indices[index++] = (i + 1) % length;
            indices[index++] = i + length;
            indices[index++] = ((i + 1) % length) + length;
        }

        var numSide;
        if (numberOfVerticalLines > 0) {
            var numSideLines = Math.min(numberOfVerticalLines, length);
            numSide = Math.round(length / numSideLines);

            var maxI = Math.min(numSide * numberOfVerticalLines, length);
            for (i = 0; i < maxI; i += numSide) {
                indices[index++] = i;
                indices[index++] = i + length;
            }
        }

        return {
            boundingSphere : boundingSphere,
            attributes : attributes,
            indices : indices
        };
    }

    /**
     * A description of the outline of an ellipse on an ellipsoid.
     *
     * @alias EllipseOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.
     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.
     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.
     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.
     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.
     * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.
     * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.
     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.
     *
     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.
     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.
     * @exception {DeveloperError} granularity must be greater than zero.
     *
     * @see EllipseOutlineGeometry.createGeometry
     *
     * @example
     * var ellipse = new Cesium.EllipseOutlineGeometry({
     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
     *   semiMajorAxis : 500000.0,
     *   semiMinorAxis : 300000.0,
     *   rotation : Cesium.Math.toRadians(60.0)
     * });
     * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);
     */
    function EllipseOutlineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var center = options.center;
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
        var semiMajorAxis = options.semiMajorAxis;
        var semiMinorAxis = options.semiMinorAxis;
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);

        

        var height = defaultValue(options.height, 0.0);
        var extrudedHeight = defaultValue(options.extrudedHeight, height);

        this._center = Cartesian3.clone(center);
        this._semiMajorAxis = semiMajorAxis;
        this._semiMinorAxis = semiMinorAxis;
        this._ellipsoid = Ellipsoid.clone(ellipsoid);
        this._rotation = defaultValue(options.rotation, 0.0);
        this._height = Math.max(extrudedHeight, height);
        this._granularity = granularity;
        this._extrudedHeight = Math.min(extrudedHeight, height);
        this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);
        this._offsetAttribute = options.offsetAttribute;
        this._workerName = 'createEllipseOutlineGeometry';
    }

    /**
     * The number of elements used to pack the object into an array.
     * @type {Number}
     */
    EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {EllipseOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    EllipseOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        Cartesian3.pack(value._center, array, startingIndex);
        startingIndex += Cartesian3.packedLength;

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        array[startingIndex++] = value._semiMajorAxis;
        array[startingIndex++] = value._semiMinorAxis;
        array[startingIndex++] = value._rotation;
        array[startingIndex++] = value._height;
        array[startingIndex++] = value._granularity;
        array[startingIndex++] = value._extrudedHeight;
        array[startingIndex++]   = value._numberOfVerticalLines;
        array[startingIndex] = defaultValue(value._offsetAttribute, -1);

        return array;
    };

    var scratchCenter = new Cartesian3();
    var scratchEllipsoid = new Ellipsoid();
    var scratchOptions = {
        center : scratchCenter,
        ellipsoid : scratchEllipsoid,
        semiMajorAxis : undefined,
        semiMinorAxis : undefined,
        rotation : undefined,
        height : undefined,
        granularity : undefined,
        extrudedHeight : undefined,
        numberOfVerticalLines : undefined,
        offsetAttribute: undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {EllipseOutlineGeometry} [result] The object into which to store the result.
     * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.
     */
    EllipseOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);
        startingIndex += Cartesian3.packedLength;

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var semiMajorAxis = array[startingIndex++];
        var semiMinorAxis = array[startingIndex++];
        var rotation = array[startingIndex++];
        var height = array[startingIndex++];
        var granularity = array[startingIndex++];
        var extrudedHeight = array[startingIndex++];
        var numberOfVerticalLines = array[startingIndex++];
        var offsetAttribute = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.height = height;
            scratchOptions.extrudedHeight = extrudedHeight;
            scratchOptions.granularity = granularity;
            scratchOptions.rotation = rotation;
            scratchOptions.semiMajorAxis = semiMajorAxis;
            scratchOptions.semiMinorAxis = semiMinorAxis;
            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;
            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

            return new EllipseOutlineGeometry(scratchOptions);
        }

        result._center = Cartesian3.clone(center, result._center);
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._semiMajorAxis = semiMajorAxis;
        result._semiMinorAxis = semiMinorAxis;
        result._rotation = rotation;
        result._height = height;
        result._granularity = granularity;
        result._extrudedHeight = extrudedHeight;
        result._numberOfVerticalLines = numberOfVerticalLines;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;

        return result;
    };

    /**
     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
     *
     * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    EllipseOutlineGeometry.createGeometry = function(ellipseGeometry) {
        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {
            return;
        }

        var height = ellipseGeometry._height;
        var extrudedHeight = ellipseGeometry._extrudedHeight;
        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);

        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);
        var options = {
            center : ellipseGeometry._center,
            semiMajorAxis : ellipseGeometry._semiMajorAxis,
            semiMinorAxis : ellipseGeometry._semiMinorAxis,
            ellipsoid : ellipseGeometry._ellipsoid,
            rotation : ellipseGeometry._rotation,
            height : height,
            granularity : ellipseGeometry._granularity,
            numberOfVerticalLines : ellipseGeometry._numberOfVerticalLines
        };
        var geometry;
        if (extrude) {
            options.extrudedHeight = extrudedHeight;
            options.offsetAttribute = ellipseGeometry._offsetAttribute;
            geometry = computeExtrudedEllipse(options);
        } else {
            geometry = computeEllipse(options);

            if (defined(ellipseGeometry._offsetAttribute)) {
                var length = geometry.attributes.position.values.length;
                var applyOffset = new Uint8Array(length / 3);
                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                arrayFill(applyOffset, offsetValue);
                geometry.attributes.applyOffset = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                    componentsPerAttribute : 1,
                    values: applyOffset
                });
            }
        }

        return new Geometry({
            attributes : geometry.attributes,
            indices : geometry.indices,
            primitiveType : PrimitiveType.LINES,
            boundingSphere : geometry.boundingSphere,
            offsetAttribute : ellipseGeometry._offsetAttribute
        });
    };

    return EllipseOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js":
/*!*******************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        BoundingSphere,
        Cartesian3,
        Check,
        ComponentDatatype,
        defaultValue,
        defined,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        PrimitiveType,
        VertexFormat) {
    'use strict';

    /**
     * Describes geometry representing a plane centered at the origin, with a unit width and length.
     *
     * @alias PlaneGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     *
     * @example
     * var planeGeometry = new Cesium.PlaneGeometry({
     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY
     * });
     */
    function PlaneGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);

        this._vertexFormat = vertexFormat;
        this._workerName = 'createPlaneGeometry';
    }

    /**
     * The number of elements used to pack the object into an array.
     * @type {Number}
     */
    PlaneGeometry.packedLength = VertexFormat.packedLength;

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PlaneGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    PlaneGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        VertexFormat.pack(value._vertexFormat, array, startingIndex);

        return array;
    };

    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        vertexFormat: scratchVertexFormat
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PlaneGeometry} [result] The object into which to store the result.
     * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.
     */
    PlaneGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);

        if (!defined(result)) {
            return new PlaneGeometry(scratchOptions);
        }

        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);

        return result;
    };

    var min = new Cartesian3(-0.5, -0.5, 0.0);
    var max = new Cartesian3( 0.5,  0.5, 0.0);

    /**
     * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.
     *
     * @param {PlaneGeometry} planeGeometry A description of the plane.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PlaneGeometry.createGeometry = function(planeGeometry) {
        var vertexFormat = planeGeometry._vertexFormat;

        var attributes = new GeometryAttributes();
        var indices;
        var positions;

        if (vertexFormat.position) {
            // 4 corner points.  Duplicated 3 times each for each incident edge/face.
            positions = new Float64Array(4 * 3);

            // +z face
            positions[0]  = min.x;
            positions[1]  = min.y;
            positions[2]  = 0.0;
            positions[3]  = max.x;
            positions[4]  = min.y;
            positions[5]  = 0.0;
            positions[6]  = max.x;
            positions[7]  = max.y;
            positions[8]  = 0.0;
            positions[9]  = min.x;
            positions[10] = max.y;
            positions[11] = 0.0;

            attributes.position = new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : positions
            });

            if (vertexFormat.normal) {
                var normals = new Float32Array(4 * 3);

                // +z face
                normals[0]  = 0.0;
                normals[1]  = 0.0;
                normals[2]  = 1.0;
                normals[3]  = 0.0;
                normals[4]  = 0.0;
                normals[5]  = 1.0;
                normals[6]  = 0.0;
                normals[7]  = 0.0;
                normals[8]  = 1.0;
                normals[9]  = 0.0;
                normals[10] = 0.0;
                normals[11] = 1.0;

                attributes.normal = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : normals
                });
            }

            if (vertexFormat.st) {
                var texCoords = new Float32Array(4 * 2);

                // +z face
                texCoords[0]  = 0.0;
                texCoords[1]  = 0.0;
                texCoords[2]  = 1.0;
                texCoords[3]  = 0.0;
                texCoords[4]  = 1.0;
                texCoords[5]  = 1.0;
                texCoords[6]  = 0.0;
                texCoords[7]  = 1.0;

                attributes.st = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 2,
                    values : texCoords
                });
            }

            if (vertexFormat.tangent) {
                var tangents = new Float32Array(4 * 3);

                // +z face
                tangents[0]  = 1.0;
                tangents[1]  = 0.0;
                tangents[2]  = 0.0;
                tangents[3]  = 1.0;
                tangents[4]  = 0.0;
                tangents[5]  = 0.0;
                tangents[6]  = 1.0;
                tangents[7]  = 0.0;
                tangents[8]  = 0.0;
                tangents[9]  = 1.0;
                tangents[10] = 0.0;
                tangents[11] = 0.0;

                attributes.tangent = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : tangents
                });
            }

            if (vertexFormat.bitangent) {
                var bitangents = new Float32Array(4 * 3);

                // +z face
                bitangents[0] = 0.0;
                bitangents[1] = 1.0;
                bitangents[2] = 0.0;
                bitangents[3] = 0.0;
                bitangents[4] = 1.0;
                bitangents[5] = 0.0;
                bitangents[6] = 0.0;
                bitangents[7] = 1.0;
                bitangents[8] = 0.0;
                bitangents[9] = 0.0;
                bitangents[10] = 1.0;
                bitangents[11] = 0.0;

                attributes.bitangent = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : bitangents
                });
            }

            // 2 triangles
            indices = new Uint16Array(2 * 3);

            // +z face
            indices[0] = 0;
            indices[1] = 1;
            indices[2] = 2;
            indices[3] = 0;
            indices[4] = 2;
            indices[5] = 3;
        }

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.TRIANGLES,
            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))
        });
    };

    return PlaneGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js":
/*!**************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        BoundingSphere,
        Cartesian3,
        Check,
        ComponentDatatype,
        defined,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        PrimitiveType) {
    'use strict';

    /**
     * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.
     *
     * @alias PlaneOutlineGeometry
     * @constructor
     *
     */
    function PlaneOutlineGeometry() {
        this._workerName = 'createPlaneOutlineGeometry';
    }

    /**
     * The number of elements used to pack the object into an array.
     * @type {Number}
     */
    PlaneOutlineGeometry.packedLength = 0;

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PlaneOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     *
     * @returns {Number[]} The array that was packed into
     */
    PlaneOutlineGeometry.pack = function(value, array) {
        

        return array;
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PlaneOutlineGeometry} [result] The object into which to store the result.
     * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.
     */
    PlaneOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        if (!defined(result)) {
            return new PlaneOutlineGeometry();
        }

        return result;
    };

    var min = new Cartesian3(-0.5, -0.5, 0.0);
    var max = new Cartesian3( 0.5,  0.5, 0.0);

    /**
     * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.
     *
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PlaneOutlineGeometry.createGeometry = function() {
        var attributes = new GeometryAttributes();
        var indices = new Uint16Array(4 * 2);
        var positions = new Float64Array(4 * 3);

        positions[0] = min.x;
        positions[1] = min.y;
        positions[2] = min.z;
        positions[3] = max.x;
        positions[4] = min.y;
        positions[5] = min.z;
        positions[6] = max.x;
        positions[7] = max.y;
        positions[8] = min.z;
        positions[9] = min.x;
        positions[10] = max.y;
        positions[11] = min.z;

        attributes.position = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : positions
        });

        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 1;
        indices[3] = 2;
        indices[4] = 2;
        indices[5] = 3;
        indices[6] = 3;
        indices[7] = 0;

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.LINES,
            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))
        });
    };

    return PlaneOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js":
/*!*********************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./ArcType */ "./node_modules/terriajs-cesium/Source/Core/ArcType.js"),
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./BoundingRectangle */ "./node_modules/terriajs-cesium/Source/Core/BoundingRectangle.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./EllipsoidGeodesic */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidGeodesic.js"),
        __webpack_require__(/*! ./EllipsoidRhumbLine */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidRhumbLine.js"),
        __webpack_require__(/*! ./EllipsoidTangentPlane */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidTangentPlane.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./GeometryPipeline */ "./node_modules/terriajs-cesium/Source/Core/GeometryPipeline.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix2 */ "./node_modules/terriajs-cesium/Source/Core/Matrix2.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./PolygonGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolygonGeometryLibrary.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js"),
        __webpack_require__(/*! ./Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js"),
        __webpack_require__(/*! ./WindingOrder */ "./node_modules/terriajs-cesium/Source/Core/WindingOrder.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ArcType,
        arrayFill,
        BoundingRectangle,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        Cartographic,
        Check,
        ComponentDatatype,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Ellipsoid,
        EllipsoidGeodesic,
        EllipsoidRhumbLine,
        EllipsoidTangentPlane,
        Geometry,
        GeometryAttribute,
        GeometryInstance,
        GeometryOffsetAttribute,
        GeometryPipeline,
        IndexDatatype,
        CesiumMath,
        Matrix2,
        Matrix3,
        PolygonGeometryLibrary,
        PolygonPipeline,
        Quaternion,
        Rectangle,
        VertexFormat,
        WindingOrder) {
    'use strict';

    var scratchCarto1 = new Cartographic();
    var scratchCarto2 = new Cartographic();
    function adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {
        var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);
        var height = carto1.height;
        var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);
        p1Carto.height = height;
        ellipsoid.cartographicToCartesian(p1Carto, p1);

        var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);
        p2Carto.height = height - 100;
        ellipsoid.cartographicToCartesian(p2Carto, p2);
    }

    var scratchBoundingRectangle = new BoundingRectangle();
    var scratchPosition = new Cartesian3();
    var scratchNormal = new Cartesian3();
    var scratchTangent = new Cartesian3();
    var scratchBitangent = new Cartesian3();
    var p1Scratch = new Cartesian3();
    var p2Scratch = new Cartesian3();
    var scratchPerPosNormal = new Cartesian3();
    var scratchPerPosTangent = new Cartesian3();
    var scratchPerPosBitangent = new Cartesian3();

    var appendTextureCoordinatesOrigin = new Cartesian2();
    var appendTextureCoordinatesCartesian2 = new Cartesian2();
    var appendTextureCoordinatesCartesian3 = new Cartesian3();
    var appendTextureCoordinatesQuaternion = new Quaternion();
    var appendTextureCoordinatesMatrix3 = new Matrix3();
    var tangentMatrixScratch = new Matrix3();

    function computeAttributes(options) {
        var vertexFormat = options.vertexFormat;
        var geometry = options.geometry;
        var shadowVolume = options.shadowVolume;
        var flatPositions = geometry.attributes.position.values;
        var length = flatPositions.length;
        var wall = options.wall;
        var top = options.top || wall;
        var bottom = options.bottom || wall;
        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {
            // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.
            // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.
            var boundingRectangle = options.boundingRectangle;
            var tangentPlane = options.tangentPlane;
            var ellipsoid = options.ellipsoid;
            var stRotation = options.stRotation;
            var perPositionHeight = options.perPositionHeight;

            var origin = appendTextureCoordinatesOrigin;
            origin.x = boundingRectangle.x;
            origin.y = boundingRectangle.y;

            var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;
            var normals;
            if (vertexFormat.normal) {
                if (perPositionHeight && top && !wall) {
                    normals = geometry.attributes.normal.values;
                } else {
                    normals = new Float32Array(length);
                }
            }
            var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;
            var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;
            var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;

            var textureCoordIndex = 0;
            var attrIndex = 0;

            var normal = scratchNormal;
            var tangent = scratchTangent;
            var bitangent = scratchBitangent;
            var recomputeNormal = true;

            var textureMatrix = appendTextureCoordinatesMatrix3;
            var tangentRotationMatrix = tangentMatrixScratch;
            if (stRotation !== 0.0) {
                var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);
                textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);

                rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);
                tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);
            } else {
                textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);
                tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);
            }

            var bottomOffset = 0;
            var bottomOffset2 = 0;

            if (top && bottom) {
                bottomOffset = length / 2;
                bottomOffset2 = length / 3;

                length /= 2;
            }

            for ( var i = 0; i < length; i += 3) {
                var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);

                if (vertexFormat.st) {
                    var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);
                    p = ellipsoid.scaleToGeodeticSurface(p,p);
                    var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);
                    Cartesian2.subtract(st, origin, st);

                    var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);
                    var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);
                    if (bottom) {
                        textureCoordinates[textureCoordIndex + bottomOffset2] = stx;
                        textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;
                    }
                    if (top) {
                        textureCoordinates[textureCoordIndex] = stx;
                        textureCoordinates[textureCoordIndex + 1] = sty;
                    }

                    textureCoordIndex += 2;
                }

                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {
                    var attrIndex1 = attrIndex + 1;
                    var attrIndex2 = attrIndex + 2;

                    if (wall) {
                        if (i + 3 < length) {
                            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);

                            if (recomputeNormal) {
                                var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);
                                if (perPositionHeight) {
                                    adjustPosHeightsForNormal(position, p1, p2, ellipsoid);
                                }
                                Cartesian3.subtract(p1, position, p1);
                                Cartesian3.subtract(p2, position, p2);
                                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);
                                recomputeNormal = false;
                            }

                            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) { // if we've reached a corner
                                recomputeNormal = true;
                            }
                        }

                        if (vertexFormat.tangent || vertexFormat.bitangent) {
                            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);
                            if (vertexFormat.tangent) {
                                tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);
                            }
                        }
                    } else {
                        normal = ellipsoid.geodeticSurfaceNormal(position, normal);
                        if (vertexFormat.tangent || vertexFormat.bitangent) {
                            if (perPositionHeight) {
                                scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);
                                scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);
                                scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);
                                if (vertexFormat.bitangent) {
                                    scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);
                                }
                            }

                            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);
                            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);
                            if (vertexFormat.bitangent) {
                                bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);
                            }
                        }
                    }

                    if (vertexFormat.normal) {
                        if (options.wall) {
                            normals[attrIndex + bottomOffset] = normal.x;
                            normals[attrIndex1 + bottomOffset] = normal.y;
                            normals[attrIndex2 + bottomOffset] = normal.z;
                        } else if (bottom){
                            normals[attrIndex + bottomOffset] = -normal.x;
                            normals[attrIndex1 + bottomOffset] = -normal.y;
                            normals[attrIndex2 + bottomOffset] = -normal.z;
                        }

                        if ((top && !perPositionHeight) || wall) {
                            normals[attrIndex] = normal.x;
                            normals[attrIndex1] = normal.y;
                            normals[attrIndex2] = normal.z;
                        }
                    }

                    if (shadowVolume) {
                        if (wall) {
                            normal = ellipsoid.geodeticSurfaceNormal(position, normal);
                        }
                        extrudeNormals[attrIndex + bottomOffset] = -normal.x;
                        extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;
                        extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;
                    }

                    if (vertexFormat.tangent) {
                        if (options.wall) {
                            tangents[attrIndex + bottomOffset] = tangent.x;
                            tangents[attrIndex1 + bottomOffset] = tangent.y;
                            tangents[attrIndex2 + bottomOffset] = tangent.z;
                        } else if (bottom) {
                            tangents[attrIndex + bottomOffset] = -tangent.x;
                            tangents[attrIndex1 + bottomOffset] = -tangent.y;
                            tangents[attrIndex2 + bottomOffset] = -tangent.z;
                        }

                        if(top) {
                            if (perPositionHeight) {
                                tangents[attrIndex] = scratchPerPosTangent.x;
                                tangents[attrIndex1] = scratchPerPosTangent.y;
                                tangents[attrIndex2] = scratchPerPosTangent.z;
                            } else {
                                tangents[attrIndex] = tangent.x;
                                tangents[attrIndex1] = tangent.y;
                                tangents[attrIndex2] = tangent.z;
                            }
                        }
                    }

                    if (vertexFormat.bitangent) {
                        if (bottom) {
                            bitangents[attrIndex + bottomOffset] = bitangent.x;
                            bitangents[attrIndex1 + bottomOffset] = bitangent.y;
                            bitangents[attrIndex2 + bottomOffset] = bitangent.z;
                        }
                        if (top) {
                            if (perPositionHeight) {
                                bitangents[attrIndex] = scratchPerPosBitangent.x;
                                bitangents[attrIndex1] = scratchPerPosBitangent.y;
                                bitangents[attrIndex2] = scratchPerPosBitangent.z;
                            } else {
                                bitangents[attrIndex] = bitangent.x;
                                bitangents[attrIndex1] = bitangent.y;
                                bitangents[attrIndex2] = bitangent.z;
                            }
                        }
                    }
                    attrIndex += 3;
                }
            }

            if (vertexFormat.st) {
                geometry.attributes.st = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 2,
                    values : textureCoordinates
                });
            }

            if (vertexFormat.normal) {
                geometry.attributes.normal = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : normals
                });
            }

            if (vertexFormat.tangent) {
                geometry.attributes.tangent = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : tangents
                });
            }

            if (vertexFormat.bitangent) {
                geometry.attributes.bitangent = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : bitangents
                });
            }

            if (shadowVolume) {
                geometry.attributes.extrudeDirection = new GeometryAttribute({
                    componentDatatype : ComponentDatatype.FLOAT,
                    componentsPerAttribute : 3,
                    values : extrudeNormals
                });
            }
        }

        if (options.extrude && defined(options.offsetAttribute)) {
            var size = flatPositions.length / 3;
            var offsetAttribute = new Uint8Array(size);

            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {
                if ((top && bottom) || wall) {
                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);
                } else if (top) {
                    offsetAttribute = arrayFill(offsetAttribute, 1);
                }
            } else {
                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                offsetAttribute = arrayFill(offsetAttribute, offsetValue);
            }

            geometry.attributes.applyOffset = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 1,
                values : offsetAttribute
            });
        }

        return geometry;
    }

    var startCartographicScratch = new Cartographic();
    var endCartographicScratch = new Cartographic();
    var idlCross = {
        westOverIDL : 0.0,
        eastOverIDL : 0.0
    };
    var ellipsoidGeodesic = new EllipsoidGeodesic();
    function computeRectangle(positions, ellipsoid, arcType, granularity, result) {
        result = defaultValue(result, new Rectangle());
        if (!defined(positions) || positions.length < 3) {
            result.west = 0.0;
            result.north = 0.0;
            result.south = 0.0;
            result.east = 0.0;
            return result;
        }

        if (arcType === ArcType.RHUMB) {
            return Rectangle.fromCartesianArray(positions, ellipsoid, result);
        }

        if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {
            ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);
        }

        result.west = Number.POSITIVE_INFINITY;
        result.east = Number.NEGATIVE_INFINITY;
        result.south = Number.POSITIVE_INFINITY;
        result.north = Number.NEGATIVE_INFINITY;

        idlCross.westOverIDL = Number.POSITIVE_INFINITY;
        idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;

        var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
        var positionsLength = positions.length;
        var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);
        var startCartographic = startCartographicScratch;
        var swap;

        for (var i = 1; i < positionsLength; i++) {
            swap = startCartographic;
            startCartographic = endCartographic;
            endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);
            ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);
            interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);
        }

        swap = startCartographic;
        startCartographic = endCartographic;
        endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);
        ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);
        interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);

        if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {
            result.west = idlCross.westOverIDL;
            result.east = idlCross.eastOverIDL;

            if (result.east > CesiumMath.PI) {
                result.east = result.east - CesiumMath.TWO_PI;
            }
            if (result.west > CesiumMath.PI) {
                result.west = result.west - CesiumMath.TWO_PI;
            }
        }

        return result;
    }

    var interpolatedCartographicScratch = new Cartographic();
    function interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {
        var segmentLength = ellipsoidGeodesic.surfaceDistance;

        var numPoints = Math.ceil(segmentLength * inverseChordLength);
        var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;
        var interpolationDistance = 0.0;

        for (var i = 0; i < numPoints; i++) {
            var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);
            interpolationDistance += subsegmentDistance;
            var longitude = interpolatedCartographic.longitude;
            var latitude = interpolatedCartographic.latitude;

            result.west = Math.min(result.west, longitude);
            result.east = Math.max(result.east, longitude);
            result.south = Math.min(result.south, latitude);
            result.north = Math.max(result.north, latitude);

            var lonAdjusted = longitude >= 0 ?  longitude : longitude +  CesiumMath.TWO_PI;
            idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);
            idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);
        }
    }

    var createGeometryFromPositionsExtrudedPositions = [];

    function createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {
        var geos = {
            walls : []
        };
        var i;

        if (closeTop || closeBottom) {
            var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);

            var edgePoints = topGeo.attributes.position.values;
            var indices = topGeo.indices;
            var numPositions;
            var newIndices;

            if (closeTop && closeBottom) {
                var topBottomPositions = edgePoints.concat(edgePoints);

                numPositions = topBottomPositions.length / 3;

                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);
                newIndices.set(indices);
                var ilength = indices.length;

                var length = numPositions / 2;

                for (i = 0; i < ilength; i += 3) {
                    var i0 = newIndices[i] + length;
                    var i1 = newIndices[i + 1] + length;
                    var i2 = newIndices[i + 2] + length;

                    newIndices[i + ilength] = i2;
                    newIndices[i + 1 + ilength] = i1;
                    newIndices[i + 2 + ilength] = i0;
                }

                topGeo.attributes.position.values = topBottomPositions;
                if (perPositionHeight && vertexFormat.normal) {
                    var normals = topGeo.attributes.normal.values;
                    topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);
                    topGeo.attributes.normal.values.set(normals);
                }
                topGeo.indices = newIndices;
            } else if (closeBottom) {
                numPositions = edgePoints.length / 3;
                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);

                for (i = 0; i < indices.length; i += 3) {
                    newIndices[i] = indices[i + 2];
                    newIndices[i + 1] = indices[i + 1];
                    newIndices[i + 2] = indices[i];
                }

                topGeo.indices = newIndices;
            }

            geos.topAndBottom = new GeometryInstance({
                geometry : topGeo
            });
        }

        var outerRing = hierarchy.outerRing;
        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);
        var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);

        var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
        if (windingOrder === WindingOrder.CLOCKWISE) {
            outerRing = outerRing.slice().reverse();
        }

        var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);
        geos.walls.push(new GeometryInstance({
            geometry : wallGeo
        }));

        var holes = hierarchy.holes;
        for (i = 0; i < holes.length; i++) {
            var hole = holes[i];

            tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);
            positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);

            windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
            if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {
                hole = hole.slice().reverse();
            }

            wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);
            geos.walls.push(new GeometryInstance({
                geometry : wallGeo
            }));
        }

        return geos;
    }

    /**
     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     *
     * @alias PolygonGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.
     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.
     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.
     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     *
     * @see PolygonGeometry#createGeometry
     * @see PolygonGeometry#fromPositions
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}
     *
     * @example
     * // 1. create a polygon from points
     * var polygon = new Cesium.PolygonGeometry({
     *   polygonHierarchy : new Cesium.PolygonHierarchy(
     *     Cesium.Cartesian3.fromDegreesArray([
     *       -72.0, 40.0,
     *       -70.0, 35.0,
     *       -75.0, 30.0,
     *       -70.0, 30.0,
     *       -68.0, 40.0
     *     ])
     *   )
     * });
     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);
     *
     * // 2. create a nested polygon with holes
     * var polygonWithHole = new Cesium.PolygonGeometry({
     *   polygonHierarchy : new Cesium.PolygonHierarchy(
     *     Cesium.Cartesian3.fromDegreesArray([
     *       -109.0, 30.0,
     *       -95.0, 30.0,
     *       -95.0, 40.0,
     *       -109.0, 40.0
     *     ]),
     *     [new Cesium.PolygonHierarchy(
     *       Cesium.Cartesian3.fromDegreesArray([
     *         -107.0, 31.0,
     *         -107.0, 39.0,
     *         -97.0, 39.0,
     *         -97.0, 31.0
     *       ]),
     *       [new Cesium.PolygonHierarchy(
     *         Cesium.Cartesian3.fromDegreesArray([
     *           -105.0, 33.0,
     *           -99.0, 33.0,
     *           -99.0, 37.0,
     *           -105.0, 37.0
     *         ]),
     *         [new Cesium.PolygonHierarchy(
     *           Cesium.Cartesian3.fromDegreesArray([
     *             -103.0, 34.0,
     *             -101.0, 34.0,
     *             -101.0, 36.0,
     *             -103.0, 36.0
     *           ])
     *         )]
     *       )]
     *     )]
     *   )
     * });
     * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);
     *
     * // 3. create extruded polygon
     * var extrudedPolygon = new Cesium.PolygonGeometry({
     *   polygonHierarchy : new Cesium.PolygonHierarchy(
     *     Cesium.Cartesian3.fromDegreesArray([
     *       -72.0, 40.0,
     *       -70.0, 35.0,
     *       -75.0, 30.0,
     *       -70.0, 30.0,
     *       -68.0, 40.0
     *     ])
     *   ),
     *   extrudedHeight: 300000
     * });
     * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);
     */
    function PolygonGeometry(options) {
        

        var polygonHierarchy = options.polygonHierarchy;
        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var stRotation = defaultValue(options.stRotation, 0.0);
        var perPositionHeight = defaultValue(options.perPositionHeight, false);
        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);
        var height = defaultValue(options.height, 0.0);
        var extrudedHeight = defaultValue(options.extrudedHeight, height);

        if (!perPositionHeightExtrude) {
            var h = Math.max(height, extrudedHeight);
            extrudedHeight = Math.min(height, extrudedHeight);
            height = h;
        }

        this._vertexFormat = VertexFormat.clone(vertexFormat);
        this._ellipsoid = Ellipsoid.clone(ellipsoid);
        this._granularity = granularity;
        this._stRotation = stRotation;
        this._height = height;
        this._extrudedHeight = extrudedHeight;
        this._closeTop = defaultValue(options.closeTop, true);
        this._closeBottom = defaultValue(options.closeBottom, true);
        this._polygonHierarchy = polygonHierarchy;
        this._perPositionHeight = perPositionHeight;
        this._perPositionHeightExtrude = perPositionHeightExtrude;
        this._shadowVolume = defaultValue(options.shadowVolume, false);
        this._workerName = 'createPolygonGeometry';
        this._offsetAttribute = options.offsetAttribute;
        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);

        this._rectangle = undefined;
        this._textureCoordinateRotationPoints = undefined;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;
    }

    /**
     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
     * @param {Number} [options.height=0.0] The height of the polygon.
     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.
     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.
     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     * @returns {PolygonGeometry}
     *
     *
     * @example
     * // create a polygon from points
     * var polygon = Cesium.PolygonGeometry.fromPositions({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0,
     *     -75.0, 30.0,
     *     -70.0, 30.0,
     *     -68.0, 40.0
     *   ])
     * });
     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);
     *
     * @see PolygonGeometry#createGeometry
     */
    PolygonGeometry.fromPositions = function(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        

        var newOptions = {
            polygonHierarchy : {
                positions : options.positions
            },
            height : options.height,
            extrudedHeight : options.extrudedHeight,
            vertexFormat : options.vertexFormat,
            stRotation : options.stRotation,
            ellipsoid : options.ellipsoid,
            granularity : options.granularity,
            perPositionHeight : options.perPositionHeight,
            closeTop : options.closeTop,
            closeBottom : options.closeBottom,
            offsetAttribute : options.offsetAttribute,
            arcType : options.arcType
        };
        return new PolygonGeometry(newOptions);
    };

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PolygonGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    PolygonGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._height;
        array[startingIndex++] = value._extrudedHeight;
        array[startingIndex++] = value._granularity;
        array[startingIndex++] = value._stRotation;
        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;
        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;
        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;
        array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;
        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;
        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);
        array[startingIndex++] = value._arcType;
        array[startingIndex] = value.packedLength;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchVertexFormat = new VertexFormat();

    //Only used to avoid inability to default construct.
    var dummyOptions = {
        polygonHierarchy : {}
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PolygonGeometry} [result] The object into which to store the result.
     */
    PolygonGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
        startingIndex = polygonHierarchy.startingIndex;
        delete polygonHierarchy.startingIndex;

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var height = array[startingIndex++];
        var extrudedHeight = array[startingIndex++];
        var granularity = array[startingIndex++];
        var stRotation = array[startingIndex++];
        var perPositionHeightExtrude = array[startingIndex++] === 1.0;
        var perPositionHeight = array[startingIndex++] === 1.0;
        var closeTop = array[startingIndex++] === 1.0;
        var closeBottom = array[startingIndex++] === 1.0;
        var shadowVolume = array[startingIndex++] === 1.0;
        var offsetAttribute = array[startingIndex++];
        var arcType = array[startingIndex++];
        var packedLength = array[startingIndex];

        if (!defined(result)) {
            result = new PolygonGeometry(dummyOptions);
        }

        result._polygonHierarchy = polygonHierarchy;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._height = height;
        result._extrudedHeight = extrudedHeight;
        result._granularity = granularity;
        result._stRotation = stRotation;
        result._perPositionHeightExtrude = perPositionHeightExtrude;
        result._perPositionHeight = perPositionHeight;
        result._closeTop = closeTop;
        result._closeBottom = closeBottom;
        result._shadowVolume = shadowVolume;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;
        result._arcType = arcType;
        result.packedLength = packedLength;
        return result;
    };

    /**
     * Returns the bounding rectangle given the provided options
     *
     * @param {Object} options Object with the following properties:
     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.
     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Rectangle} [result] An object in which to store the result.
     *
     * @returns {Rectangle} The result rectangle
     */
    PolygonGeometry.computeRectangle = function(options, result) {
        

        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);
        

        var polygonHierarchy = options.polygonHierarchy;
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);

        return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);
    };

    /**
     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.
     *
     * @param {PolygonGeometry} polygonGeometry A description of the polygon.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PolygonGeometry.createGeometry = function(polygonGeometry) {
        var vertexFormat = polygonGeometry._vertexFormat;
        var ellipsoid = polygonGeometry._ellipsoid;
        var granularity = polygonGeometry._granularity;
        var stRotation = polygonGeometry._stRotation;
        var polygonHierarchy = polygonGeometry._polygonHierarchy;
        var perPositionHeight = polygonGeometry._perPositionHeight;
        var closeTop = polygonGeometry._closeTop;
        var closeBottom = polygonGeometry._closeBottom;
        var arcType = polygonGeometry._arcType;

        var outerPositions = polygonHierarchy.positions;
        if (outerPositions.length < 3) {
            return;
        }

        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);

        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);
        var hierarchy = results.hierarchy;
        var polygons = results.polygons;

        if (hierarchy.length === 0) {
            return;
        }

        outerPositions = hierarchy[0].outerRing;
        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);

        var geometries = [];

        var height = polygonGeometry._height;
        var extrudedHeight = polygonGeometry._extrudedHeight;
        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);

        var options = {
            perPositionHeight: perPositionHeight,
            vertexFormat: vertexFormat,
            geometry: undefined,
            tangentPlane: tangentPlane,
            boundingRectangle: boundingRectangle,
            ellipsoid: ellipsoid,
            stRotation: stRotation,
            bottom: false,
            top: true,
            wall: false,
            extrude: false,
            arcType: arcType
        };

        var i;

        if (extrude) {
            options.extrude = true;
            options.top = closeTop;
            options.bottom = closeBottom;
            options.shadowVolume = polygonGeometry._shadowVolume;
            options.offsetAttribute = polygonGeometry._offsetAttribute;
            for (i = 0; i < polygons.length; i++) {
                var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);

                var topAndBottom;
                if (closeTop && closeBottom) {
                    topAndBottom = splitGeometry.topAndBottom;
                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);
                } else if (closeTop) {
                    topAndBottom = splitGeometry.topAndBottom;
                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);
                    options.geometry = topAndBottom.geometry;
                } else if (closeBottom) {
                    topAndBottom = splitGeometry.topAndBottom;
                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);
                    options.geometry = topAndBottom.geometry;
                }
                if (closeTop || closeBottom) {
                    options.wall = false;
                    topAndBottom.geometry = computeAttributes(options);
                    geometries.push(topAndBottom);
                }

                var walls = splitGeometry.walls;
                options.wall = true;
                for ( var k = 0; k < walls.length; k++) {
                    var wall = walls[k];
                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);
                    wall.geometry = computeAttributes(options);
                    geometries.push(wall);
                }
            }
        } else {
            for (i = 0; i < polygons.length; i++) {
                var geometryInstance = new GeometryInstance({
                    geometry : PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)
                });
                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);
                options.geometry = geometryInstance.geometry;
                geometryInstance.geometry = computeAttributes(options);

                if (defined(polygonGeometry._offsetAttribute)) {
                    var length = geometryInstance.geometry.attributes.position.values.length;
                    var applyOffset = new Uint8Array(length / 3);
                    var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                    arrayFill(applyOffset, offsetValue);
                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        componentsPerAttribute : 1,
                        values: applyOffset
                    });
                }

                geometries.push(geometryInstance);
            }
        }

        var geometry = GeometryPipeline.combineInstances(geometries)[0];
        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);
        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);

        var attributes = geometry.attributes;
        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);

        if (!vertexFormat.position) {
            delete attributes.position;
        }

        return new Geometry({
            attributes : attributes,
            indices : geometry.indices,
            primitiveType : geometry.primitiveType,
            boundingSphere : boundingSphere,
            offsetAttribute : polygonGeometry._offsetAttribute
        });
    };

    /**
     * @private
     */
    PolygonGeometry.createShadowVolume = function(polygonGeometry, minHeightFunc, maxHeightFunc) {
        var granularity = polygonGeometry._granularity;
        var ellipsoid = polygonGeometry._ellipsoid;

        var minHeight = minHeightFunc(granularity, ellipsoid);
        var maxHeight = maxHeightFunc(granularity, ellipsoid);

        return new PolygonGeometry({
            polygonHierarchy : polygonGeometry._polygonHierarchy,
            ellipsoid : ellipsoid,
            stRotation : polygonGeometry._stRotation,
            granularity : granularity,
            perPositionHeight : false,
            extrudedHeight : minHeight,
            height : maxHeight,
            vertexFormat : VertexFormat.POSITION_ONLY,
            shadowVolume: true,
            arcType : polygonGeometry._arcType
        });
    };

    function textureCoordinateRotationPoints(polygonGeometry) {
        var stRotation = -polygonGeometry._stRotation;
        if (stRotation === 0.0) {
            return [0, 0, 0, 1, 1, 0];
        }
        var ellipsoid = polygonGeometry._ellipsoid;
        var positions = polygonGeometry._polygonHierarchy.positions;
        var boundingRectangle = polygonGeometry.rectangle;
        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);
    }

    defineProperties(PolygonGeometry.prototype, {
        /**
         * @private
         */
        rectangle : {
            get : function() {
                if (!defined(this._rectangle)) {
                    var positions = this._polygonHierarchy.positions;
                    this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);
                }

                return this._rectangle;
            }
        },
        /**
         * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.
         * @private
         */
        textureCoordinateRotationPoints : {
            get : function() {
                if (!defined(this._textureCoordinateRotationPoints)) {
                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);
                }
                return this._textureCoordinateRotationPoints;
            }
        }
    });

    return PolygonGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./ArcType */ "./node_modules/terriajs-cesium/Source/Core/ArcType.js"),
        __webpack_require__(/*! ./arrayFill */ "./node_modules/terriajs-cesium/Source/Core/arrayFill.js"),
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./EllipsoidTangentPlane */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidTangentPlane.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ./GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ./GeometryPipeline */ "./node_modules/terriajs-cesium/Source/Core/GeometryPipeline.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PolygonGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolygonGeometryLibrary.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./Queue */ "./node_modules/terriajs-cesium/Source/Core/Queue.js"),
        __webpack_require__(/*! ./WindingOrder */ "./node_modules/terriajs-cesium/Source/Core/WindingOrder.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ArcType,
        arrayFill,
        arrayRemoveDuplicates,
        BoundingSphere,
        Cartesian3,
        Check,
        ComponentDatatype,
        defaultValue,
        defined,
        DeveloperError,
        Ellipsoid,
        EllipsoidTangentPlane,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryInstance,
        GeometryOffsetAttribute,
        GeometryPipeline,
        IndexDatatype,
        CesiumMath,
        PolygonGeometryLibrary,
        PolygonPipeline,
        PrimitiveType,
        Queue,
        WindingOrder) {
    'use strict';
    var createGeometryFromPositionsPositions = [];
    var createGeometryFromPositionsSubdivided = [];

    function createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {
        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);
        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);

        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
        if (originalWindingOrder === WindingOrder.CLOCKWISE) {
            positions2D.reverse();
            positions = positions.slice().reverse();
        }

        var subdividedPositions;
        var i;

        var length = positions.length;
        var index = 0;

        if (!perPositionHeight) {
            var numVertices = 0;
            if (arcType === ArcType.GEODESIC) {
                for (i = 0; i < length; i++) {
                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);
                }
            } else if (arcType === ArcType.RHUMB) {
                for (i = 0; i < length; i++) {
                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);
                }
            }
            subdividedPositions = new Float64Array(numVertices * 3);
            for (i = 0; i < length; i++) {
                var tempPositions;
                if (arcType === ArcType.GEODESIC) {
                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);
                } else if (arcType === ArcType.RHUMB) {
                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);
                }
                var tempPositionsLength = tempPositions.length;
                for (var j = 0; j < tempPositionsLength; ++j) {
                    subdividedPositions[index++] = tempPositions[j];
                }
            }
        } else {
            subdividedPositions = new Float64Array(length * 2 * 3);
            for (i = 0; i < length; i++) {
                var p0 = positions[i];
                var p1 = positions[(i + 1) % length];
                subdividedPositions[index++] = p0.x;
                subdividedPositions[index++] = p0.y;
                subdividedPositions[index++] = p0.z;
                subdividedPositions[index++] = p1.x;
                subdividedPositions[index++] = p1.y;
                subdividedPositions[index++] = p1.z;
            }
        }

        length = subdividedPositions.length / 3;
        var indicesSize = length * 2;
        var indices = IndexDatatype.createTypedArray(length, indicesSize);
        index = 0;
        for (i = 0; i < length - 1; i++) {
            indices[index++] = i;
            indices[index++] = i + 1;
        }
        indices[index++] = length - 1;
        indices[index++] = 0;

        return new GeometryInstance({
            geometry : new Geometry({
                attributes : new GeometryAttributes({
                    position : new GeometryAttribute({
                        componentDatatype : ComponentDatatype.DOUBLE,
                        componentsPerAttribute : 3,
                        values : subdividedPositions
                    })
                }),
                indices : indices,
                primitiveType : PrimitiveType.LINES
            })
        });
    }

    function createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {
        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);
        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);

        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);
        if (originalWindingOrder === WindingOrder.CLOCKWISE) {
            positions2D.reverse();
            positions = positions.slice().reverse();
        }

        var subdividedPositions;
        var i;

        var length = positions.length;
        var corners = new Array(length);
        var index = 0;

        if (!perPositionHeight) {
            var numVertices = 0;
            if (arcType === ArcType.GEODESIC) {
                for (i = 0; i < length; i++) {
                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);
                }
            } else if (arcType === ArcType.RHUMB) {
                for (i = 0; i < length; i++) {
                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);
                }
            }

            subdividedPositions = new Float64Array(numVertices * 3 * 2);
            for (i = 0; i < length; ++i) {
                corners[i] = index / 3;
                var tempPositions;
                if (arcType === ArcType.GEODESIC) {
                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);
                } else if (arcType === ArcType.RHUMB) {
                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);
                }
                var tempPositionsLength = tempPositions.length;
                for (var j = 0; j < tempPositionsLength; ++j) {
                    subdividedPositions[index++] = tempPositions[j];
                }
            }
        } else {
            subdividedPositions = new Float64Array(length * 2 * 3 * 2);
            for (i = 0; i < length; ++i) {
                corners[i] = index / 3;
                var p0 = positions[i];
                var p1 = positions[(i + 1) % length];

                subdividedPositions[index++] = p0.x;
                subdividedPositions[index++] = p0.y;
                subdividedPositions[index++] = p0.z;
                subdividedPositions[index++] = p1.x;
                subdividedPositions[index++] = p1.y;
                subdividedPositions[index++] = p1.z;
            }
        }

        length = subdividedPositions.length / (3 * 2);
        var cornersLength = corners.length;

        var indicesSize = ((length * 2) + cornersLength) * 2;
        var indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);

        index = 0;
        for (i = 0; i < length; ++i) {
            indices[index++] = i;
            indices[index++] = (i + 1) % length;
            indices[index++] = i + length;
            indices[index++] = ((i + 1) % length) + length;
        }

        for (i = 0; i < cornersLength; i++) {
            var corner = corners[i];
            indices[index++] = corner;
            indices[index++] = corner + length;
        }

        return new GeometryInstance({
            geometry : new Geometry({
                attributes : new GeometryAttributes({
                    position : new GeometryAttribute({
                        componentDatatype : ComponentDatatype.DOUBLE,
                        componentsPerAttribute : 3,
                        values : subdividedPositions
                    })
                }),
                indices : indices,
                primitiveType : PrimitiveType.LINES
            })
        });
    }

    /**
     * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.
     *
     * @alias PolygonOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.
     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     *
     * @see PolygonOutlineGeometry#createGeometry
     * @see PolygonOutlineGeometry#fromPositions
     *
     * @example
     * // 1. create a polygon outline from points
     * var polygon = new Cesium.PolygonOutlineGeometry({
     *   polygonHierarchy : new Cesium.PolygonHierarchy(
     *     Cesium.Cartesian3.fromDegreesArray([
     *       -72.0, 40.0,
     *       -70.0, 35.0,
     *       -75.0, 30.0,
     *       -70.0, 30.0,
     *       -68.0, 40.0
     *     ])
     *   )
     * });
     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);
     *
     * // 2. create a nested polygon with holes outline
     * var polygonWithHole = new Cesium.PolygonOutlineGeometry({
     *   polygonHierarchy : new Cesium.PolygonHierarchy(
     *     Cesium.Cartesian3.fromDegreesArray([
     *       -109.0, 30.0,
     *       -95.0, 30.0,
     *       -95.0, 40.0,
     *       -109.0, 40.0
     *     ]),
     *     [new Cesium.PolygonHierarchy(
     *       Cesium.Cartesian3.fromDegreesArray([
     *         -107.0, 31.0,
     *         -107.0, 39.0,
     *         -97.0, 39.0,
     *         -97.0, 31.0
     *       ]),
     *       [new Cesium.PolygonHierarchy(
     *         Cesium.Cartesian3.fromDegreesArray([
     *           -105.0, 33.0,
     *           -99.0, 33.0,
     *           -99.0, 37.0,
     *           -105.0, 37.0
     *         ]),
     *         [new Cesium.PolygonHierarchy(
     *           Cesium.Cartesian3.fromDegreesArray([
     *             -103.0, 34.0,
     *             -101.0, 34.0,
     *             -101.0, 36.0,
     *             -103.0, 36.0
     *           ])
     *         )]
     *       )]
     *     )]
     *   )
     * });
     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);
     *
     * // 3. create extruded polygon outline
     * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({
     *   polygonHierarchy : new Cesium.PolygonHierarchy(
     *     Cesium.Cartesian3.fromDegreesArray([
     *       -72.0, 40.0,
     *       -70.0, 35.0,
     *       -75.0, 30.0,
     *       -70.0, 30.0,
     *       -68.0, 40.0
     *     ])
     *   ),
     *   extrudedHeight: 300000
     * });
     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);
     */
    function PolygonOutlineGeometry(options) {
        

        var polygonHierarchy = options.polygonHierarchy;
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var perPositionHeight = defaultValue(options.perPositionHeight, false);
        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);
        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);

        var height = defaultValue(options.height, 0.0);
        var extrudedHeight = defaultValue(options.extrudedHeight, height);

        if (!perPositionHeightExtrude) {
            var h = Math.max(height, extrudedHeight);
            extrudedHeight = Math.min(height, extrudedHeight);
            height = h;
        }

        this._ellipsoid = Ellipsoid.clone(ellipsoid);
        this._granularity = granularity;
        this._height = height;
        this._extrudedHeight = extrudedHeight;
        this._arcType = arcType;
        this._polygonHierarchy = polygonHierarchy;
        this._perPositionHeight = perPositionHeight;
        this._perPositionHeightExtrude = perPositionHeightExtrude;
        this._offsetAttribute = options.offsetAttribute;
        this._workerName = 'createPolygonOutlineGeometry';

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 8;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PolygonOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    PolygonOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        array[startingIndex++] = value._height;
        array[startingIndex++] = value._extrudedHeight;
        array[startingIndex++] = value._granularity;
        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;
        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;
        array[startingIndex++] = value._arcType;
        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);
        array[startingIndex] = value.packedLength;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var dummyOptions = {
        polygonHierarchy : {}
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PolygonOutlineGeometry} [result] The object into which to store the result.
     * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.
     */
    PolygonOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);
        startingIndex = polygonHierarchy.startingIndex;
        delete polygonHierarchy.startingIndex;

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var height = array[startingIndex++];
        var extrudedHeight = array[startingIndex++];
        var granularity = array[startingIndex++];
        var perPositionHeightExtrude = array[startingIndex++] === 1.0;
        var perPositionHeight = array[startingIndex++] === 1.0;
        var arcType = array[startingIndex++];
        var offsetAttribute = array[startingIndex++];
        var packedLength = array[startingIndex];

        if (!defined(result)) {
            result = new PolygonOutlineGeometry(dummyOptions);
        }

        result._polygonHierarchy = polygonHierarchy;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._height = height;
        result._extrudedHeight = extrudedHeight;
        result._granularity = granularity;
        result._perPositionHeight = perPositionHeight;
        result._perPositionHeightExtrude = perPositionHeightExtrude;
        result._arcType = arcType;
        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;
        result.packedLength = packedLength;

        return result;
    };

    /**
     * A description of a polygon outline from an array of positions.
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
     * @param {Number} [options.height=0.0] The height of the polygon.
     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.
     * @returns {PolygonOutlineGeometry}
     *
     *
     * @example
     * // create a polygon from points
     * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0,
     *     -75.0, 30.0,
     *     -70.0, 30.0,
     *     -68.0, 40.0
     *   ])
     * });
     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);
     *
     * @see PolygonOutlineGeometry#createGeometry
     */
    PolygonOutlineGeometry.fromPositions = function(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        

        var newOptions = {
            polygonHierarchy : {
                positions : options.positions
            },
            height : options.height,
            extrudedHeight : options.extrudedHeight,
            ellipsoid : options.ellipsoid,
            granularity : options.granularity,
            perPositionHeight : options.perPositionHeight,
            arcType: options.arcType,
            offsetAttribute : options.offsetAttribute
        };
        return new PolygonOutlineGeometry(newOptions);
    };

    /**
     * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.
     *
     * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PolygonOutlineGeometry.createGeometry = function(polygonGeometry) {
        var ellipsoid = polygonGeometry._ellipsoid;
        var granularity = polygonGeometry._granularity;
        var polygonHierarchy = polygonGeometry._polygonHierarchy;
        var perPositionHeight = polygonGeometry._perPositionHeight;
        var arcType = polygonGeometry._arcType;

        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);

        if (polygons.length === 0) {
            return undefined;
        }

        var geometryInstance;
        var geometries = [];
        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);

        var height = polygonGeometry._height;
        var extrudedHeight = polygonGeometry._extrudedHeight;
        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);
        var offsetValue;
        var i;
        if (extrude) {
            for (i = 0; i < polygons.length; i++) {
                geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);
                geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);
                if (defined(polygonGeometry._offsetAttribute)) {
                    var size = geometryInstance.geometry.attributes.position.values.length / 3;
                    var offsetAttribute = new Uint8Array(size);
                    if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {
                        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);
                    } else {
                        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                        offsetAttribute = arrayFill(offsetAttribute, offsetValue);
                    }

                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        componentsPerAttribute : 1,
                        values : offsetAttribute
                    });
                }
                geometries.push(geometryInstance);
            }
        } else {
            for (i = 0; i < polygons.length; i++) {
                geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);
                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);

                if (defined(polygonGeometry._offsetAttribute)) {
                    var length = geometryInstance.geometry.attributes.position.values.length;
                    var applyOffset = new Uint8Array(length / 3);
                    offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;
                    arrayFill(applyOffset, offsetValue);
                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({
                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                        componentsPerAttribute : 1,
                        values: applyOffset
                    });
                }

                geometries.push(geometryInstance);
            }
        }

        var geometry = GeometryPipeline.combineInstances(geometries)[0];
        var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);

        return new Geometry({
            attributes : geometry.attributes,
            indices : geometry.indices,
            primitiveType : geometry.primitiveType,
            boundingSphere : boundingSphere,
            offsetAttribute : polygonGeometry._offsetAttribute
        });
    };

    return PolygonOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js":
/*!**********************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./ArcType */ "./node_modules/terriajs-cesium/Source/Core/ArcType.js"),
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryType */ "./node_modules/terriajs-cesium/Source/Core/GeometryType.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PolylinePipeline */ "./node_modules/terriajs-cesium/Source/Core/PolylinePipeline.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ArcType,
        arrayRemoveDuplicates,
        BoundingSphere,
        Cartesian3,
        Color,
        ComponentDatatype,
        defaultValue,
        defined,
        DeveloperError,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryType,
        IndexDatatype,
        CesiumMath,
        PolylinePipeline,
        PrimitiveType,
        VertexFormat) {
    'use strict';

    var scratchInterpolateColorsArray = [];

    function interpolateColors(p0, p1, color0, color1, numPoints) {
        var colors = scratchInterpolateColorsArray;
        colors.length = numPoints;
        var i;

        var r0 = color0.red;
        var g0 = color0.green;
        var b0 = color0.blue;
        var a0 = color0.alpha;

        var r1 = color1.red;
        var g1 = color1.green;
        var b1 = color1.blue;
        var a1 = color1.alpha;

        if (Color.equals(color0, color1)) {
            for (i = 0; i < numPoints; i++) {
                colors[i] = Color.clone(color0);
            }
            return colors;
        }

        var redPerVertex = (r1 - r0) / numPoints;
        var greenPerVertex = (g1 - g0) / numPoints;
        var bluePerVertex = (b1 - b0) / numPoints;
        var alphaPerVertex = (a1 - a0) / numPoints;

        for (i = 0; i < numPoints; i++) {
            colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);
        }

        return colors;
    }

    /**
     * A description of a polyline modeled as a line strip; the first two positions define a line segment,
     * and each additional position defines a line segment from the previous position. The polyline is capable of
     * displaying with a material.
     *
     * @alias PolylineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
     * @param {Number} [options.width=1.0] The width in pixels.
     * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.
     * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     *
     * @exception {DeveloperError} At least two positions are required.
     * @exception {DeveloperError} width must be greater than or equal to one.
     * @exception {DeveloperError} colors has an invalid length.
     *
     * @see PolylineGeometry#createGeometry
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}
     *
     * @example
     * // A polyline with two connected line segments
     * var polyline = new Cesium.PolylineGeometry({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     0.0, 0.0,
     *     5.0, 0.0,
     *     5.0, 5.0
     *   ]),
     *   width : 10.0
     * });
     * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);
     */
    function PolylineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.positions;
        var colors = options.colors;
        var width = defaultValue(options.width, 1.0);
        var colorsPerVertex = defaultValue(options.colorsPerVertex, false);

        

        this._positions = positions;
        this._colors = colors;
        this._width = width;
        this._colorsPerVertex = colorsPerVertex;
        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));

        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);
        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
        this._workerName = 'createPolylineGeometry';

        var numComponents = 1 + positions.length * Cartesian3.packedLength;
        numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PolylineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    PolylineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        var colors = value._colors;
        length = defined(colors) ? colors.length : 0.0;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {
            Color.pack(colors[i], array, startingIndex);
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._width;
        array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;
        array[startingIndex++] = value._arcType;
        array[startingIndex]   = value._granularity;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        positions : undefined,
        colors : undefined,
        ellipsoid : scratchEllipsoid,
        vertexFormat : scratchVertexFormat,
        width : undefined,
        colorsPerVertex : undefined,
        arcType : undefined,
        granularity : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PolylineGeometry} [result] The object into which to store the result.
     * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.
     */
    PolylineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        length = array[startingIndex++];
        var colors = length > 0 ? new Array(length) : undefined;

        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {
            colors[i] = Color.unpack(array, startingIndex);
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var width = array[startingIndex++];
        var colorsPerVertex = array[startingIndex++] === 1.0;
        var arcType = array[startingIndex++];
        var granularity = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.positions = positions;
            scratchOptions.colors = colors;
            scratchOptions.width = width;
            scratchOptions.colorsPerVertex = colorsPerVertex;
            scratchOptions.arcType = arcType;
            scratchOptions.granularity = granularity;
            return new PolylineGeometry(scratchOptions);
        }

        result._positions = positions;
        result._colors = colors;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._width = width;
        result._colorsPerVertex = colorsPerVertex;
        result._arcType = arcType;
        result._granularity = granularity;

        return result;
    };

    var scratchCartesian3 = new Cartesian3();
    var scratchPosition = new Cartesian3();
    var scratchPrevPosition = new Cartesian3();
    var scratchNextPosition = new Cartesian3();

    /**
     * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.
     *
     * @param {PolylineGeometry} polylineGeometry A description of the polyline.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PolylineGeometry.createGeometry = function(polylineGeometry) {
        var width = polylineGeometry._width;
        var vertexFormat = polylineGeometry._vertexFormat;
        var colors = polylineGeometry._colors;
        var colorsPerVertex = polylineGeometry._colorsPerVertex;
        var arcType = polylineGeometry._arcType;
        var granularity = polylineGeometry._granularity;
        var ellipsoid = polylineGeometry._ellipsoid;

        var i;
        var j;
        var k;

        var positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon);
        var positionsLength = positions.length;

        // A width of a pixel or less is not a valid geometry, but in order to support external data
        // that may have errors we treat this as an empty geometry.
        if (positionsLength < 2 || width <= 0.0) {
            return undefined;
        }

        if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {
            var subdivisionSize;
            var numberOfPointsFunction;
            if (arcType === ArcType.GEODESIC) {
                subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);
                numberOfPointsFunction = PolylinePipeline.numberOfPoints;
            } else {
                subdivisionSize = granularity;
                numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;
            }

            var heights = PolylinePipeline.extractHeights(positions, ellipsoid);

            if (defined(colors)) {
                var colorLength = 1;
                for (i = 0; i < positionsLength - 1; ++i) {
                    colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);
                }

                var newColors = new Array(colorLength);
                var newColorIndex = 0;

                for (i = 0; i < positionsLength - 1; ++i) {
                    var p0 = positions[i];
                    var p1 = positions[i + 1];
                    var c0 = colors[i];

                    var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);
                    if (colorsPerVertex && i < colorLength) {
                        var c1 = colors[i + 1];
                        var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);
                        var interpolatedColorsLength = interpolatedColors.length;
                        for (j = 0; j < interpolatedColorsLength; ++j) {
                            newColors[newColorIndex++] = interpolatedColors[j];
                        }
                    } else {
                        for (j = 0; j < numColors; ++j) {
                            newColors[newColorIndex++] = Color.clone(c0);
                        }
                    }
                }

                newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);
                colors = newColors;

                scratchInterpolateColorsArray.length = 0;
            }

            if (arcType === ArcType.GEODESIC) {
                positions = PolylinePipeline.generateCartesianArc({
                    positions: positions,
                    minDistance: subdivisionSize,
                    ellipsoid: ellipsoid,
                    height: heights
                });
            } else {
                positions = PolylinePipeline.generateCartesianRhumbArc({
                    positions: positions,
                    granularity: subdivisionSize,
                    ellipsoid: ellipsoid,
                    height: heights
                });
            }
        }

        positionsLength = positions.length;
        var size = positionsLength * 4.0 - 4.0;

        var finalPositions = new Float64Array(size * 3);
        var prevPositions = new Float64Array(size * 3);
        var nextPositions = new Float64Array(size * 3);
        var expandAndWidth = new Float32Array(size * 2);
        var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;
        var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;

        var positionIndex = 0;
        var expandAndWidthIndex = 0;
        var stIndex = 0;
        var colorIndex = 0;
        var position;

        for (j = 0; j < positionsLength; ++j) {
            if (j === 0) {
                position = scratchCartesian3;
                Cartesian3.subtract(positions[0], positions[1], position);
                Cartesian3.add(positions[0], position, position);
            } else {
                position = positions[j - 1];
            }

            Cartesian3.clone(position, scratchPrevPosition);
            Cartesian3.clone(positions[j], scratchPosition);

            if (j === positionsLength - 1) {
                position = scratchCartesian3;
                Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);
                Cartesian3.add(positions[positionsLength - 1], position, position);
            } else {
                position = positions[j + 1];
            }

            Cartesian3.clone(position, scratchNextPosition);

            var color0, color1;
            if (defined(finalColors)) {
                if (j !== 0 && !colorsPerVertex) {
                    color0 = colors[j - 1];
                } else {
                    color0 = colors[j];
                }

                if (j !== positionsLength - 1) {
                    color1 = colors[j];
                }
            }

            var startK = j === 0 ? 2 : 0;
            var endK = j === positionsLength - 1 ? 2 : 4;

            for (k = startK; k < endK; ++k) {
                Cartesian3.pack(scratchPosition, finalPositions, positionIndex);
                Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);
                Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);
                positionIndex += 3;

                var direction = (k - 2 < 0) ? -1.0 : 1.0;
                expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;       // expand direction
                expandAndWidth[expandAndWidthIndex++] = direction * width;

                if (vertexFormat.st) {
                    st[stIndex++] = j / (positionsLength - 1);
                    st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);
                }

                if (defined(finalColors)) {
                    var color = (k < 2) ? color0 : color1;

                    finalColors[colorIndex++] = Color.floatToByte(color.red);
                    finalColors[colorIndex++] = Color.floatToByte(color.green);
                    finalColors[colorIndex++] = Color.floatToByte(color.blue);
                    finalColors[colorIndex++] = Color.floatToByte(color.alpha);
                }
            }
        }

        var attributes = new GeometryAttributes();

        attributes.position = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : finalPositions
        });

        attributes.prevPosition = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : prevPositions
        });

        attributes.nextPosition = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : nextPositions
        });

        attributes.expandAndWidth = new GeometryAttribute({
            componentDatatype : ComponentDatatype.FLOAT,
            componentsPerAttribute : 2,
            values : expandAndWidth
        });

        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : st
            });
        }

        if (defined(finalColors)) {
            attributes.color = new GeometryAttribute({
                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,
                componentsPerAttribute : 4,
                values : finalColors,
                normalize : true
            });
        }

        var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);
        var index = 0;
        var indicesIndex = 0;
        var length = positionsLength - 1.0;
        for (j = 0; j < length; ++j) {
            indices[indicesIndex++] = index;
            indices[indicesIndex++] = index + 2;
            indices[indicesIndex++] = index + 1;

            indices[indicesIndex++] = index + 1;
            indices[indicesIndex++] = index + 2;
            indices[indicesIndex++] = index + 3;

            index += 4;
        }

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.TRIANGLES,
            boundingSphere : BoundingSphere.fromPoints(positions),
            geometryType : GeometryType.POLYLINES
        });
    };

    return PolylineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingRectangle */ "./node_modules/terriajs-cesium/Source/Core/BoundingRectangle.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CornerType */ "./node_modules/terriajs-cesium/Source/Core/CornerType.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./GeometryPipeline */ "./node_modules/terriajs-cesium/Source/Core/GeometryPipeline.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./oneTimeWarning */ "./node_modules/terriajs-cesium/Source/Core/oneTimeWarning.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PolylineVolumeGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js"),
        __webpack_require__(/*! ./WindingOrder */ "./node_modules/terriajs-cesium/Source/Core/WindingOrder.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayRemoveDuplicates,
        BoundingRectangle,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        ComponentDatatype,
        CornerType,
        defaultValue,
        defined,
        DeveloperError,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        GeometryPipeline,
        IndexDatatype,
        CesiumMath,
        oneTimeWarning,
        PolygonPipeline,
        PolylineVolumeGeometryLibrary,
        PrimitiveType,
        VertexFormat,
        WindingOrder) {
    'use strict';

    function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {
        var attributes = new GeometryAttributes();
        if (vertexFormat.position) {
            attributes.position = new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : combinedPositions
            });
        }
        var shapeLength = shape.length;
        var vertexCount = combinedPositions.length / 3;
        var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);
        var firstEndIndices = PolygonPipeline.triangulate(shape);

        var indicesCount = (length - 1) * (shapeLength) * 6 + firstEndIndices.length * 2;
        var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);
        var i, j;
        var ll, ul, ur, lr;
        var offset = shapeLength * 2;
        var index = 0;
        for (i = 0; i < length - 1; i++) {
            for (j = 0; j < shapeLength - 1; j++) {
                ll = j * 2 + i * shapeLength * 2;
                lr = ll + offset;
                ul = ll + 1;
                ur = ul + offset;

                indices[index++] = ul;
                indices[index++] = ll;
                indices[index++] = ur;
                indices[index++] = ur;
                indices[index++] = ll;
                indices[index++] = lr;
            }
            ll = shapeLength * 2 - 2 + i * shapeLength * 2;
            ul = ll + 1;
            ur = ul + offset;
            lr = ll + offset;

            indices[index++] = ul;
            indices[index++] = ll;
            indices[index++] = ur;
            indices[index++] = ur;
            indices[index++] = ll;
            indices[index++] = lr;
        }

        if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) { // st required for tangent/bitangent calculation
            var st = new Float32Array(vertexCount * 2);
            var lengthSt = 1 / (length - 1);
            var heightSt = 1 / (boundingRectangle.height);
            var heightOffset = boundingRectangle.height / 2;
            var s, t;
            var stindex = 0;
            for (i = 0; i < length; i++) {
                s = i * lengthSt;
                t = heightSt * (shape[0].y + heightOffset);
                st[stindex++] = s;
                st[stindex++] = t;
                for (j = 1; j < shapeLength; j++) {
                    t = heightSt * (shape[j].y + heightOffset);
                    st[stindex++] = s;
                    st[stindex++] = t;
                    st[stindex++] = s;
                    st[stindex++] = t;
                }
                t = heightSt * (shape[0].y + heightOffset);
                st[stindex++] = s;
                st[stindex++] = t;
            }
            for (j = 0; j < shapeLength; j++) {
                s = 0;
                t = heightSt * (shape[j].y + heightOffset);
                st[stindex++] = s;
                st[stindex++] = t;
            }
            for (j = 0; j < shapeLength; j++) {
                s = (length - 1) * lengthSt;
                t = heightSt * (shape[j].y + heightOffset);
                st[stindex++] = s;
                st[stindex++] = t;
            }

            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : new Float32Array(st)
            });
        }

        var endOffset = vertexCount - shapeLength * 2;
        for (i = 0; i < firstEndIndices.length; i += 3) {
            var v0 = firstEndIndices[i] + endOffset;
            var v1 = firstEndIndices[i + 1] + endOffset;
            var v2 = firstEndIndices[i + 2] + endOffset;

            indices[index++] = v0;
            indices[index++] = v1;
            indices[index++] = v2;
            indices[index++] = v2 + shapeLength;
            indices[index++] = v1 + shapeLength;
            indices[index++] = v0 + shapeLength;
        }

        var geometry = new Geometry({
            attributes : attributes,
            indices : indices,
            boundingSphere : BoundingSphere.fromVertices(combinedPositions),
            primitiveType : PrimitiveType.TRIANGLES
        });

        if (vertexFormat.normal) {
            geometry = GeometryPipeline.computeNormal(geometry);
        }

        if (vertexFormat.tangent || vertexFormat.bitangent) {
            try {
                geometry = GeometryPipeline.computeTangentAndBitangent(geometry);
            } catch (e) {
                oneTimeWarning('polyline-volume-tangent-bitangent', 'Unable to compute tangents and bitangents for polyline volume geometry');
                //TODO https://github.com/AnalyticalGraphicsInc/cesium/issues/3609
            }

            if (!vertexFormat.tangent) {
                geometry.attributes.tangent = undefined;
            }
            if (!vertexFormat.bitangent) {
                geometry.attributes.bitangent = undefined;
            }
            if (!vertexFormat.st) {
                geometry.attributes.st = undefined;
            }
        }

        return geometry;
    }

    /**
     * A description of a polyline with a volume (a 2D shape extruded along a polyline).
     *
     * @alias PolylineVolumeGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.
     * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
     *
     * @see PolylineVolumeGeometry#createGeometry
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}
     *
     * @example
     * function computeCircle(radius) {
     *   var positions = [];
     *   for (var i = 0; i < 360; i++) {
     *     var radians = Cesium.Math.toRadians(i);
     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
     *   }
     *   return positions;
     * }
     *
     * var volume = new Cesium.PolylineVolumeGeometry({
     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0
     *   ]),
     *   shapePositions : computeCircle(100000.0)
     * });
     */
    function PolylineVolumeGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.polylinePositions;
        var shape = options.shapePositions;

        

        this._positions = positions;
        this._shape = shape;
        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));
        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        this._workerName = 'createPolylineVolumeGeometry';

        var numComponents = 1 + positions.length * Cartesian3.packedLength;
        numComponents += 1 + shape.length * Cartesian2.packedLength;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PolylineVolumeGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    PolylineVolumeGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        var shape = value._shape;
        length = shape.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
            Cartesian2.pack(shape[i], array, startingIndex);
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex++] = value._cornerType;
        array[startingIndex]   = value._granularity;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        polylinePositions : undefined,
        shapePositions : undefined,
        ellipsoid : scratchEllipsoid,
        vertexFormat : scratchVertexFormat,
        cornerType : undefined,
        granularity : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PolylineVolumeGeometry} [result] The object into which to store the result.
     * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.
     */
    PolylineVolumeGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        length = array[startingIndex++];
        var shape = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
            shape[i] = Cartesian2.unpack(array, startingIndex);
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var cornerType = array[startingIndex++];
        var granularity = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.polylinePositions = positions;
            scratchOptions.shapePositions = shape;
            scratchOptions.cornerType = cornerType;
            scratchOptions.granularity = granularity;
            return new PolylineVolumeGeometry(scratchOptions);
        }

        result._positions = positions;
        result._shape = shape;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._cornerType = cornerType;
        result._granularity = granularity;

        return result;
    };

    var brScratch = new BoundingRectangle();

    /**
     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.
     *
     * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PolylineVolumeGeometry.createGeometry = function(polylineVolumeGeometry) {
        var positions = polylineVolumeGeometry._positions;
        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);
        var shape2D = polylineVolumeGeometry._shape;
        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);

        if (cleanPositions.length < 2 || shape2D.length < 3) {
            return undefined;
        }

        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {
            shape2D.reverse();
        }
        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);

        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);
        return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);
    };

    return PolylineVolumeGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./Cartesian4 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian4.js"),
        __webpack_require__(/*! ./Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
        __webpack_require__(/*! ./CornerType */ "./node_modules/terriajs-cesium/Source/Core/CornerType.js"),
        __webpack_require__(/*! ./EllipsoidTangentPlane */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidTangentPlane.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ./Matrix4 */ "./node_modules/terriajs-cesium/Source/Core/Matrix4.js"),
        __webpack_require__(/*! ./PolylinePipeline */ "./node_modules/terriajs-cesium/Source/Core/PolylinePipeline.js"),
        __webpack_require__(/*! ./Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js"),
        __webpack_require__(/*! ./Transforms */ "./node_modules/terriajs-cesium/Source/Core/Transforms.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartesian2,
        Cartesian3,
        Cartesian4,
        Cartographic,
        CornerType,
        EllipsoidTangentPlane,
        CesiumMath,
        Matrix3,
        Matrix4,
        PolylinePipeline,
        Quaternion,
        Transforms) {
    'use strict';

    var scratch2Array = [new Cartesian3(), new Cartesian3()];
    var scratchCartesian1 = new Cartesian3();
    var scratchCartesian2 = new Cartesian3();
    var scratchCartesian3 = new Cartesian3();
    var scratchCartesian4 = new Cartesian3();
    var scratchCartesian5 = new Cartesian3();
    var scratchCartesian6 = new Cartesian3();
    var scratchCartesian7 = new Cartesian3();
    var scratchCartesian8 = new Cartesian3();
    var scratchCartesian9 = new Cartesian3();

    var scratch1 = new Cartesian3();
    var scratch2 = new Cartesian3();

    /**
     * @private
     */
    var PolylineVolumeGeometryLibrary = {};

    var cartographic = new Cartographic();
    function scaleToSurface(positions, ellipsoid) {
        var heights = new Array(positions.length);
        for (var i = 0; i < positions.length; i++) {
            var pos = positions[i];
            cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);
            heights[i] = cartographic.height;
            positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);
        }
        return heights;
    }

    function subdivideHeights(points, h0, h1, granularity) {
        var p0 = points[0];
        var p1 = points[1];
        var angleBetween = Cartesian3.angleBetween(p0, p1);
        var numPoints = Math.ceil(angleBetween / granularity);
        var heights = new Array(numPoints);
        var i;
        if (h0 === h1) {
            for (i = 0; i < numPoints; i++) {
                heights[i] = h0;
            }
            heights.push(h1);
            return heights;
        }

        var dHeight = h1 - h0;
        var heightPerVertex = dHeight / (numPoints);

        for (i = 1; i < numPoints; i++) {
            var h = h0 + i * heightPerVertex;
            heights[i] = h;
        }

        heights[0] = h0;
        heights.push(h1);
        return heights;
    }

    var nextScratch = new Cartesian3();
    var prevScratch = new Cartesian3();

    function computeRotationAngle(start, end, position, ellipsoid) {
        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);
        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);
        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);
        var angle = Cartesian2.angleBetween(next, prev);

        return (prev.x * next.y - prev.y * next.x >= 0.0) ? -angle : angle;
    }

    var negativeX = new Cartesian3(-1, 0, 0);
    var transform = new Matrix4();
    var translation = new Matrix4();
    var rotationZ = new Matrix3();
    var scaleMatrix = Matrix3.IDENTITY.clone();
    var westScratch = new Cartesian3();
    var finalPosScratch = new Cartesian4();
    var heightCartesian = new Cartesian3();
    function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {
        var west = westScratch;
        var finalPosition = finalPosScratch;
        transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);

        west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);
        west = Cartesian3.normalize(west, west);
        var angle = computeRotationAngle(west, left, center, ellipsoid);
        rotationZ = Matrix3.fromRotationZ(angle, rotationZ);

        heightCartesian.z = height;
        transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);
        var scale = scaleMatrix;
        scale[0] = xScalar;

        for (var j = 0; j < repeat; j++) {
            for (var i = 0; i < shape.length; i += 3) {
                finalPosition = Cartesian3.fromArray(shape, i, finalPosition);
                finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);
                finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);
                finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);
            }
        }

        return finalPositions;
    }

    var centerScratch = new Cartesian3();
    function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {
        for (var i = 0; i < centers.length; i += 3) {
            var center = Cartesian3.fromArray(centers, i, centerScratch);
            finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);
        }
        return finalPositions;
    }

    function convertShapeTo3DDuplicate(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points
        var length = shape2D.length;
        var shape = new Array(length * 6);
        var index = 0;
        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;
        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;

        var point = shape2D[0];
        shape[index++] = point.x - xOffset;
        shape[index++] = 0.0;
        shape[index++] = point.y - yOffset;
        for (var i = 1; i < length; i++) {
            point = shape2D[i];
            var x = point.x - xOffset;
            var z = point.y - yOffset;
            shape[index++] = x;
            shape[index++] = 0.0;
            shape[index++] = z;

            shape[index++] = x;
            shape[index++] = 0.0;
            shape[index++] = z;
        }
        point = shape2D[0];
        shape[index++] = point.x - xOffset;
        shape[index++] = 0.0;
        shape[index++] = point.y - yOffset;

        return shape;
    }

    function convertShapeTo3D(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0)
        var length = shape2D.length;
        var shape = new Array(length * 3);
        var index = 0;
        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;
        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;

        for (var i = 0; i < length; i++) {
            shape[index++] = shape2D[i].x - xOffset;
            shape[index++] = 0;
            shape[index++] = shape2D[i].y - yOffset;
        }

        return shape;
    }

    var quaterion = new Quaternion();
    var startPointScratch = new Cartesian3();
    var rotMatrix = new Matrix3();
    function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {
        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));
        var granularity = (cornerType === CornerType.BEVELED) ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));

        var m;
        if (leftIsOutside) {
            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);
        } else {
            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);
        }

        var left;
        var surfacePoint;
        startPoint = Cartesian3.clone(startPoint, startPointScratch);
        if (granularity > 0) {
            var repeat = duplicatePoints ? 2 : 1;
            for (var i = 0; i < granularity; i++) {
                startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);
                left = Cartesian3.subtract(startPoint, pivot, scratch1);
                left = Cartesian3.normalize(left, left);
                if (!leftIsOutside) {
                    left = Cartesian3.negate(left, left);
                }
                surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);
                finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);
            }
        } else {
            left = Cartesian3.subtract(startPoint, pivot, scratch1);
            left = Cartesian3.normalize(left, left);
            if (!leftIsOutside) {
                left = Cartesian3.negate(left, left);
            }
            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);
            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);

            endPoint = Cartesian3.clone(endPoint, startPointScratch);
            left = Cartesian3.subtract(endPoint, pivot, scratch1);
            left = Cartesian3.normalize(left, left);
            if (!leftIsOutside) {
                left = Cartesian3.negate(left, left);
            }
            surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);
            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);
        }

        return finalPositions;
    }

    PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function(shapePositions) {
        var length = shapePositions.length;
        var cleanedPositions = [];
        for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {
            var v0 = shapePositions[i0];
            var v1 = shapePositions[i1];

            if (!Cartesian2.equals(v0, v1)) {
                cleanedPositions.push(v1); // Shallow copy!
            }
        }

        return cleanedPositions;
    };

    PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function(forward, backward, position, ellipsoid) {
        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);
        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);
        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);

        return ((prev.x * next.y) - (prev.y * next.x)) >= 0.0;
    };

    var scratchForwardProjection = new Cartesian3();
    var scratchBackwardProjection = new Cartesian3();

    PolylineVolumeGeometryLibrary.computePositions = function(positions, shape2D, boundingRectangle, geometry, duplicatePoints) {
        var ellipsoid = geometry._ellipsoid;
        var heights = scaleToSurface(positions, ellipsoid);
        var granularity = geometry._granularity;
        var cornerType = geometry._cornerType;
        var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);
        var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;
        var heightOffset = boundingRectangle.height / 2;
        var width = boundingRectangle.width / 2;
        var length = positions.length;
        var finalPositions = [];
        var ends = duplicatePoints ? [] : undefined;

        var forward = scratchCartesian1;
        var backward = scratchCartesian2;
        var cornerDirection = scratchCartesian3;
        var surfaceNormal = scratchCartesian4;
        var pivot = scratchCartesian5;
        var start = scratchCartesian6;
        var end = scratchCartesian7;
        var left = scratchCartesian8;
        var previousPosition = scratchCartesian9;

        var position = positions[0];
        var nextPosition = positions[1];
        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);
        forward = Cartesian3.subtract(nextPosition, position, forward);
        forward = Cartesian3.normalize(forward, forward);
        left = Cartesian3.cross(surfaceNormal, forward, left);
        left = Cartesian3.normalize(left, left);
        var h0 = heights[0];
        var h1 = heights[1];
        if (duplicatePoints) {
            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);
        }
        previousPosition = Cartesian3.clone(position, previousPosition);
        position = nextPosition;
        backward = Cartesian3.negate(forward, backward);
        var subdividedHeights;
        var subdividedPositions;
        for (var i = 1; i < length - 1; i++) {
            var repeat = duplicatePoints ? 2 : 1;
            nextPosition = positions[i + 1];
            forward = Cartesian3.subtract(nextPosition, position, forward);
            forward = Cartesian3.normalize(forward, forward);
            cornerDirection = Cartesian3.add(forward, backward, cornerDirection);
            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);
            surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);

            var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);
            Cartesian3.subtract(forward, forwardProjection, forwardProjection);
            Cartesian3.normalize(forwardProjection, forwardProjection);

            var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);
            Cartesian3.subtract(backward, backwardProjection, backwardProjection);
            Cartesian3.normalize(backwardProjection, backwardProjection);

            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);

            if (doCorner) {
                cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);
                cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);
                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);
                var scalar = 1 / Math.max(0.25, (Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1))));
                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);
                if (leftIsOutside) {
                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);
                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);
                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);
                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);
                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);
                    subdividedPositions = PolylinePipeline.generateArc({
                        positions: scratch2Array,
                        granularity: granularity,
                        ellipsoid: ellipsoid
                    });
                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);
                    left = Cartesian3.cross(surfaceNormal, forward, left);
                    left = Cartesian3.normalize(left, left);
                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);
                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);
                    } else {
                        cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);
                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);
                    }
                    previousPosition = Cartesian3.clone(end, previousPosition);
                } else {
                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);
                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);
                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);
                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);
                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);
                    subdividedPositions = PolylinePipeline.generateArc({
                        positions: scratch2Array,
                        granularity: granularity,
                        ellipsoid: ellipsoid
                    });
                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);
                    left = Cartesian3.cross(surfaceNormal, forward, left);
                    left = Cartesian3.normalize(left, left);
                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);
                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {
                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);
                    } else {
                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);
                    }
                    previousPosition = Cartesian3.clone(end, previousPosition);
                }
                backward = Cartesian3.negate(forward, backward);
            } else {
                finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);
                previousPosition = position;
            }
            h0 = h1;
            h1 = heights[i + 1];
            position = nextPosition;
        }

        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);
        scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);
        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);
        subdividedPositions = PolylinePipeline.generateArc({
            positions: scratch2Array,
            granularity: granularity,
            ellipsoid: ellipsoid
        });
        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);
        if (duplicatePoints) {
            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);
        }

        length = finalPositions.length;
        var posLength = duplicatePoints ? length + ends.length : length;
        var combinedPositions = new Float64Array(posLength);
        combinedPositions.set(finalPositions);
        if (duplicatePoints) {
            combinedPositions.set(ends, length);
        }

        return combinedPositions;
    };

    return PolylineVolumeGeometryLibrary;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./arrayRemoveDuplicates */ "./node_modules/terriajs-cesium/Source/Core/arrayRemoveDuplicates.js"),
        __webpack_require__(/*! ./BoundingRectangle */ "./node_modules/terriajs-cesium/Source/Core/BoundingRectangle.js"),
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./CornerType */ "./node_modules/terriajs-cesium/Source/Core/CornerType.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PolylineVolumeGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./WindingOrder */ "./node_modules/terriajs-cesium/Source/Core/WindingOrder.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        arrayRemoveDuplicates,
        BoundingRectangle,
        BoundingSphere,
        Cartesian2,
        Cartesian3,
        ComponentDatatype,
        CornerType,
        defaultValue,
        defined,
        DeveloperError,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        IndexDatatype,
        CesiumMath,
        PolygonPipeline,
        PolylineVolumeGeometryLibrary,
        PrimitiveType,
        WindingOrder) {
    'use strict';

    function computeAttributes(positions, shape) {
        var attributes = new GeometryAttributes();
        attributes.position = new GeometryAttribute({
            componentDatatype : ComponentDatatype.DOUBLE,
            componentsPerAttribute : 3,
            values : positions
        });

        var shapeLength = shape.length;
        var vertexCount = attributes.position.values.length / 3;
        var positionLength = positions.length / 3;
        var shapeCount = positionLength / shapeLength;
        var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));
        var i, j;
        var index = 0;
        i = 0;
        var offset = i * shapeLength;
        for (j = 0; j < shapeLength - 1; j++) {
            indices[index++] = j + offset;
            indices[index++] = j + offset + 1;
        }
        indices[index++] = shapeLength - 1 + offset;
        indices[index++] = offset;

        i = shapeCount - 1;
        offset = i * shapeLength;
        for (j = 0; j < shapeLength - 1; j++) {
            indices[index++] = j + offset;
            indices[index++] = j + offset + 1;
        }
        indices[index++] = shapeLength - 1 + offset;
        indices[index++] = offset;

        for (i = 0; i < shapeCount - 1; i++) {
            var firstOffset = shapeLength * i;
            var secondOffset = firstOffset + shapeLength;
            for (j = 0; j < shapeLength; j++) {
                indices[index++] = j + firstOffset;
                indices[index++] = j + secondOffset;
            }
        }

        var geometry = new Geometry({
            attributes : attributes,
            indices : IndexDatatype.createTypedArray(vertexCount, indices),
            boundingSphere : BoundingSphere.fromVertices(positions),
            primitiveType : PrimitiveType.LINES
        });

        return geometry;
    }

    /**
     * A description of a polyline with a volume (a 2D shape extruded along a polyline).
     *
     * @alias PolylineVolumeOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.
     * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
     *
     * @see PolylineVolumeOutlineGeometry#createGeometry
     *
     * @example
     * function computeCircle(radius) {
     *   var positions = [];
     *   for (var i = 0; i < 360; i++) {
     *     var radians = Cesium.Math.toRadians(i);
     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
     *   }
     *   return positions;
     * }
     *
     * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({
     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0
     *   ]),
     *   shapePositions : computeCircle(100000.0)
     * });
     */
    function PolylineVolumeOutlineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.polylinePositions;
        var shape = options.shapePositions;

        

        this._positions = positions;
        this._shape = shape;
        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));
        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);
        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        this._workerName = 'createPolylineVolumeOutlineGeometry';

        var numComponents = 1 + positions.length * Cartesian3.packedLength;
        numComponents += 1 + shape.length * Cartesian2.packedLength;

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = numComponents + Ellipsoid.packedLength + 2;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {PolylineVolumeOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    PolylineVolumeOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        var shape = value._shape;
        length = shape.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
            Cartesian2.pack(shape[i], array, startingIndex);
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        array[startingIndex++] = value._cornerType;
        array[startingIndex]   = value._granularity;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchOptions = {
        polylinePositions : undefined,
        shapePositions : undefined,
        ellipsoid : scratchEllipsoid,
        height : undefined,
        cornerType : undefined,
        granularity : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.
     * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.
     */
    PolylineVolumeOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        length = array[startingIndex++];
        var shape = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {
            shape[i] = Cartesian2.unpack(array, startingIndex);
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var cornerType = array[startingIndex++];
        var granularity = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.polylinePositions = positions;
            scratchOptions.shapePositions = shape;
            scratchOptions.cornerType = cornerType;
            scratchOptions.granularity = granularity;
            return new PolylineVolumeOutlineGeometry(scratchOptions);
        }

        result._positions = positions;
        result._shape = shape;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._cornerType = cornerType;
        result._granularity = granularity;

        return result;
    };

    var brScratch = new BoundingRectangle();

    /**
     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.
     *
     * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    PolylineVolumeOutlineGeometry.createGeometry = function(polylineVolumeOutlineGeometry) {
        var positions = polylineVolumeOutlineGeometry._positions;
        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);
        var shape2D = polylineVolumeOutlineGeometry._shape;
        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);

        if (cleanPositions.length < 2 || shape2D.length < 3) {
            return undefined;
        }

        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {
            shape2D.reverse();
        }
        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);

        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);
        return computeAttributes(computedPositions, shape2D);
    };

    return PolylineVolumeOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../ThirdParty/rbush */ "./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js"),
        __webpack_require__(/*! ./Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        rbush,
        Check) {
    'use strict';

    /**
     * Wrapper around rbush for use with Rectangle types.
     * @private
     */
    function RectangleCollisionChecker() {
        this._tree = rbush();
    }

    function RectangleWithId() {
        this.minX = 0.0;
        this.minY = 0.0;
        this.maxX = 0.0;
        this.maxY = 0.0;
        this.id = '';
    }

    RectangleWithId.fromRectangleAndId = function(id, rectangle, result) {
        result.minX = rectangle.west;
        result.minY = rectangle.south;
        result.maxX = rectangle.east;
        result.maxY = rectangle.north;
        result.id = id;
        return result;
    };

    /**
     * Insert a rectangle into the collision checker.
     *
     * @param {String} id Unique string ID for the rectangle being inserted.
     * @param {Rectangle} rectangle A Rectangle
     * @private
     */
    RectangleCollisionChecker.prototype.insert = function(id, rectangle) {
        

        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, new RectangleWithId());
        this._tree.insert(withId);
    };

    function idCompare(a, b) {
        return a.id === b.id;
    }

    var removalScratch = new RectangleWithId();
    /**
     * Remove a rectangle from the collision checker.
     *
     * @param {String} id Unique string ID for the rectangle being removed.
     * @param {Rectangle} rectangle A Rectangle
     * @private
     */
    RectangleCollisionChecker.prototype.remove = function(id, rectangle) {
        

        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, removalScratch);
        this._tree.remove(withId, idCompare);
    };

    var collisionScratch = new RectangleWithId();
    /**
     * Checks if a given rectangle collides with any of the rectangles in the collection.
     *
     * @param {Rectangle} rectangle A Rectangle that should be checked against the rectangles in the collision checker.
     * @returns {Boolean} Whether the rectangle collides with any of the rectangles in the collision checker.
     */
    RectangleCollisionChecker.prototype.collides = function(rectangle) {
        

        var withId = RectangleWithId.fromRectangleAndId('', rectangle, collisionScratch);
        return this._tree.collides(withId);
    };

    return RectangleCollisionChecker;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/WallGeometry.js":
/*!******************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/WallGeometry.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js"),
        __webpack_require__(/*! ./WallGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        BoundingSphere,
        Cartesian3,
        ComponentDatatype,
        defaultValue,
        defined,
        DeveloperError,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        IndexDatatype,
        CesiumMath,
        PrimitiveType,
        VertexFormat,
        WallGeometryLibrary) {
    'use strict';

    var scratchCartesian3Position1 = new Cartesian3();
    var scratchCartesian3Position2 = new Cartesian3();
    var scratchCartesian3Position3 = new Cartesian3();
    var scratchCartesian3Position4 = new Cartesian3();
    var scratchCartesian3Position5 = new Cartesian3();
    var scratchBitangent = new Cartesian3();
    var scratchTangent = new Cartesian3();
    var scratchNormal = new Cartesian3();

    /**
     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     *
     * @alias WallGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the
     *        wall at <code>positions</code>. If undefined, the height of each position in used.
     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the
     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     *
     * @exception {DeveloperError} positions length must be greater than or equal to 2.
     * @exception {DeveloperError} positions and maximumHeights must have the same length.
     * @exception {DeveloperError} positions and minimumHeights must have the same length.
     *
     * @see WallGeometry#createGeometry
     * @see WallGeometry#fromConstantHeight
     *
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}
     *
     * @example
     * // create a wall that spans from ground level to 10000 meters
     * var wall = new Cesium.WallGeometry({
     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
     *     19.0, 47.0, 10000.0,
     *     19.0, 48.0, 10000.0,
     *     20.0, 48.0, 10000.0,
     *     20.0, 47.0, 10000.0,
     *     19.0, 47.0, 10000.0
     *   ])
     * });
     * var geometry = Cesium.WallGeometry.createGeometry(wall);
     */
    function WallGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var wallPositions = options.positions;
        var maximumHeights = options.maximumHeights;
        var minimumHeights = options.minimumHeights;

        

        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);
        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);

        this._positions = wallPositions;
        this._minimumHeights = minimumHeights;
        this._maximumHeights = maximumHeights;
        this._vertexFormat = VertexFormat.clone(vertexFormat);
        this._granularity = granularity;
        this._ellipsoid = Ellipsoid.clone(ellipsoid);
        this._workerName = 'createWallGeometry';

        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;
        if (defined(minimumHeights)) {
            numComponents += minimumHeights.length;
        }
        if (defined(maximumHeights)) {
            numComponents += maximumHeights.length;
        }

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {WallGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    WallGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        var minimumHeights = value._minimumHeights;
        length = defined(minimumHeights) ? minimumHeights.length : 0;
        array[startingIndex++] = length;

        if (defined(minimumHeights)) {
            for (i = 0; i < length; ++i) {
                array[startingIndex++] = minimumHeights[i];
            }
        }

        var maximumHeights = value._maximumHeights;
        length = defined(maximumHeights) ? maximumHeights.length : 0;
        array[startingIndex++] = length;

        if (defined(maximumHeights)) {
            for (i = 0; i < length; ++i) {
                array[startingIndex++] = maximumHeights[i];
            }
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        VertexFormat.pack(value._vertexFormat, array, startingIndex);
        startingIndex += VertexFormat.packedLength;

        array[startingIndex] = value._granularity;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchVertexFormat = new VertexFormat();
    var scratchOptions = {
        positions : undefined,
        minimumHeights : undefined,
        maximumHeights : undefined,
        ellipsoid : scratchEllipsoid,
        vertexFormat : scratchVertexFormat,
        granularity : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {WallGeometry} [result] The object into which to store the result.
     * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.
     */
    WallGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        length = array[startingIndex++];
        var minimumHeights;

        if (length > 0) {
            minimumHeights = new Array(length);
            for (i = 0; i < length; ++i) {
                minimumHeights[i] = array[startingIndex++];
            }
        }

        length = array[startingIndex++];
        var maximumHeights;

        if (length > 0) {
            maximumHeights = new Array(length);
            for (i = 0; i < length; ++i) {
                maximumHeights[i] = array[startingIndex++];
            }
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);
        startingIndex += VertexFormat.packedLength;

        var granularity = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.positions = positions;
            scratchOptions.minimumHeights = minimumHeights;
            scratchOptions.maximumHeights = maximumHeights;
            scratchOptions.granularity = granularity;
            return new WallGeometry(scratchOptions);
        }

        result._positions = positions;
        result._minimumHeights = minimumHeights;
        result._maximumHeights = maximumHeights;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);
        result._granularity = granularity;

        return result;
    };

    /**
     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the
     *        wall at <code>positions</code>. If undefined, the height of each position in used.
     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the
     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
     * @returns {WallGeometry}
     *
     *
     * @example
     * // create a wall that spans from 10000 meters to 20000 meters
     * var wall = Cesium.WallGeometry.fromConstantHeights({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     19.0, 47.0,
     *     19.0, 48.0,
     *     20.0, 48.0,
     *     20.0, 47.0,
     *     19.0, 47.0,
     *   ]),
     *   minimumHeight : 20000.0,
     *   maximumHeight : 10000.0
     * });
     * var geometry = Cesium.WallGeometry.createGeometry(wall);
     *
     * @see WallGeometry#createGeometry
     */
    WallGeometry.fromConstantHeights = function(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.positions;

        

        var minHeights;
        var maxHeights;

        var min = options.minimumHeight;
        var max = options.maximumHeight;

        var doMin = defined(min);
        var doMax = defined(max);
        if (doMin || doMax) {
            var length = positions.length;
            minHeights = (doMin) ? new Array(length) : undefined;
            maxHeights = (doMax) ? new Array(length) : undefined;

            for (var i = 0; i < length; ++i) {
                if (doMin) {
                    minHeights[i] = min;
                }

                if (doMax) {
                    maxHeights[i] = max;
                }
            }
        }

        var newOptions = {
            positions : positions,
            maximumHeights : maxHeights,
            minimumHeights : minHeights,
            ellipsoid : options.ellipsoid,
            vertexFormat : options.vertexFormat
        };
        return new WallGeometry(newOptions);
    };

    /**
     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.
     *
     * @param {WallGeometry} wallGeometry A description of the wall.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    WallGeometry.createGeometry = function(wallGeometry) {
        var wallPositions = wallGeometry._positions;
        var minimumHeights = wallGeometry._minimumHeights;
        var maximumHeights = wallGeometry._maximumHeights;
        var vertexFormat = wallGeometry._vertexFormat;
        var granularity = wallGeometry._granularity;
        var ellipsoid = wallGeometry._ellipsoid;

        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);
        if (!defined(pos)) {
            return;
        }

        var bottomPositions = pos.bottomPositions;
        var topPositions = pos.topPositions;
        var numCorners = pos.numCorners;

        var length = topPositions.length;
        var size = length * 2;

        var positions = vertexFormat.position ? new Float64Array(size) : undefined;
        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;
        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;
        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;
        var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;

        var positionIndex = 0;
        var normalIndex = 0;
        var bitangentIndex = 0;
        var tangentIndex = 0;
        var stIndex = 0;

        // add lower and upper points one after the other, lower
        // points being even and upper points being odd
        var normal = scratchNormal;
        var tangent = scratchTangent;
        var bitangent = scratchBitangent;
        var recomputeNormal = true;
        length /= 3;
        var i;
        var s = 0;
        var ds = 1/(length - wallPositions.length + 1);
        for (i = 0; i < length; ++i) {
            var i3 = i * 3;
            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);
            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);
            if (vertexFormat.position) {
                // insert the lower point
                positions[positionIndex++] = bottomPosition.x;
                positions[positionIndex++] = bottomPosition.y;
                positions[positionIndex++] = bottomPosition.z;

                // insert the upper point
                positions[positionIndex++] = topPosition.x;
                positions[positionIndex++] = topPosition.y;
                positions[positionIndex++] = topPosition.z;
            }

            if (vertexFormat.st) {
                textureCoordinates[stIndex++] = s;
                textureCoordinates[stIndex++] = 0.0;

                textureCoordinates[stIndex++] = s;
                textureCoordinates[stIndex++] = 1.0;
            }

            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {
                var nextPosition;
                var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);
                var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);
                if (i + 1 < length) {
                    nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);
                    nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);
                }

                if (recomputeNormal) {
                    var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);
                    var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);
                    normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);
                    recomputeNormal = false;
                }

                if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON10)) {
                    recomputeNormal = true;
                } else {
                    s += ds;
                    if (vertexFormat.tangent) {
                        tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);
                    }
                    if (vertexFormat.bitangent) {
                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);
                    }
                }

                if (vertexFormat.normal) {
                    normals[normalIndex++] = normal.x;
                    normals[normalIndex++] = normal.y;
                    normals[normalIndex++] = normal.z;

                    normals[normalIndex++] = normal.x;
                    normals[normalIndex++] = normal.y;
                    normals[normalIndex++] = normal.z;
                }

                if (vertexFormat.tangent) {
                    tangents[tangentIndex++] = tangent.x;
                    tangents[tangentIndex++] = tangent.y;
                    tangents[tangentIndex++] = tangent.z;

                    tangents[tangentIndex++] = tangent.x;
                    tangents[tangentIndex++] = tangent.y;
                    tangents[tangentIndex++] = tangent.z;
                }

                if (vertexFormat.bitangent) {
                    bitangents[bitangentIndex++] = bitangent.x;
                    bitangents[bitangentIndex++] = bitangent.y;
                    bitangents[bitangentIndex++] = bitangent.z;

                    bitangents[bitangentIndex++] = bitangent.x;
                    bitangents[bitangentIndex++] = bitangent.y;
                    bitangents[bitangentIndex++] = bitangent.z;
                }
            }
        }

        var attributes = new GeometryAttributes();

        if (vertexFormat.position) {
            attributes.position = new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : positions
            });
        }

        if (vertexFormat.normal) {
            attributes.normal = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : normals
            });
        }

        if (vertexFormat.tangent) {
            attributes.tangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : tangents
            });
        }

        if (vertexFormat.bitangent) {
            attributes.bitangent = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 3,
                values : bitangents
            });
        }

        if (vertexFormat.st) {
            attributes.st = new GeometryAttribute({
                componentDatatype : ComponentDatatype.FLOAT,
                componentsPerAttribute : 2,
                values : textureCoordinates
            });
        }

        // prepare the side walls, two triangles for each wall
        //
        //    A (i+1)  B (i+3) E
        //    +--------+-------+
        //    |      / |      /|    triangles:  A C B
        //    |     /  |     / |                B C D
        //    |    /   |    /  |
        //    |   /    |   /   |
        //    |  /     |  /    |
        //    | /      | /     |
        //    +--------+-------+
        //    C (i)    D (i+2) F
        //

        var numVertices = size / 3;
        size -= 6 * (numCorners + 1);
        var indices = IndexDatatype.createTypedArray(numVertices, size);

        var edgeIndex = 0;
        for (i = 0; i < numVertices - 2; i += 2) {
            var LL = i;
            var LR = i + 2;
            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);
            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);
            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {
                continue;
            }
            var UL = i + 1;
            var UR = i + 3;

            indices[edgeIndex++] = UL;
            indices[edgeIndex++] = LL;
            indices[edgeIndex++] = UR;
            indices[edgeIndex++] = UR;
            indices[edgeIndex++] = LL;
            indices[edgeIndex++] = LR;
        }

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.TRIANGLES,
            boundingSphere : new BoundingSphere.fromVertices(positions)
        });
    };

    return WallGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js":
/*!*************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./EllipsoidTangentPlane */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidTangentPlane.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PolygonPipeline */ "./node_modules/terriajs-cesium/Source/Core/PolygonPipeline.js"),
        __webpack_require__(/*! ./PolylinePipeline */ "./node_modules/terriajs-cesium/Source/Core/PolylinePipeline.js"),
        __webpack_require__(/*! ./WindingOrder */ "./node_modules/terriajs-cesium/Source/Core/WindingOrder.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartographic,
        defined,
        EllipsoidTangentPlane,
        CesiumMath,
        PolygonPipeline,
        PolylinePipeline,
        WindingOrder) {
    'use strict';

    /**
     * private
     */
    var WallGeometryLibrary = {};

    function latLonEquals(c0, c1) {
        return ((CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14)) && (CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14)));
    }

    var scratchCartographic1 = new Cartographic();
    var scratchCartographic2 = new Cartographic();
    function removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {
        var length = positions.length;
        if (length < 2) {
            return;
        }

        var hasBottomHeights = defined(bottomHeights);
        var hasTopHeights = defined(topHeights);
        var hasAllZeroHeights = true;

        var cleanedPositions = new Array(length);
        var cleanedTopHeights = new Array(length);
        var cleanedBottomHeights = new Array(length);

        var v0 = positions[0];
        cleanedPositions[0] = v0;

        var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);
        if (hasTopHeights) {
            c0.height = topHeights[0];
        }

        hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;

        cleanedTopHeights[0] = c0.height;

        if (hasBottomHeights) {
            cleanedBottomHeights[0] = bottomHeights[0];
        } else {
            cleanedBottomHeights[0] = 0.0;
        }

        var index = 1;
        for (var i = 1; i < length; ++i) {
            var v1 = positions[i];
            var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);
            if (hasTopHeights) {
                c1.height = topHeights[i];
            }
            hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;

            if (!latLonEquals(c0, c1)) {
                cleanedPositions[index] = v1; // Shallow copy!
                cleanedTopHeights[index] = c1.height;

                if (hasBottomHeights) {
                    cleanedBottomHeights[index] = bottomHeights[i];
                } else {
                    cleanedBottomHeights[index] = 0.0;
                }

                Cartographic.clone(c1, c0);
                ++index;
            } else if (c0.height < c1.height) {
                cleanedTopHeights[index - 1] = c1.height;
            }
        }

        if (hasAllZeroHeights || index < 2) {
            return;
        }

        cleanedPositions.length = index;
        cleanedTopHeights.length = index;
        cleanedBottomHeights.length = index;

        return {
            positions: cleanedPositions,
            topHeights: cleanedTopHeights,
            bottomHeights: cleanedBottomHeights
        };
    }

    var positionsArrayScratch = new Array(2);
    var heightsArrayScratch = new Array(2);
    var generateArcOptionsScratch = {
        positions : undefined,
        height : undefined,
        granularity : undefined,
        ellipsoid : undefined
    };

    /**
     * @private
     */
    WallGeometryLibrary.computePositions = function(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {
        var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);

        if (!defined(o)) {
            return;
        }

        wallPositions = o.positions;
        maximumHeights = o.topHeights;
        minimumHeights = o.bottomHeights;

        if (wallPositions.length >= 3) {
            // Order positions counter-clockwise
            var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);
            var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);

            if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {
                wallPositions.reverse();
                maximumHeights.reverse();
                minimumHeights.reverse();
            }
        }

        var length = wallPositions.length;
        var numCorners = length - 2;
        var topPositions;
        var bottomPositions;

        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);

        var generateArcOptions = generateArcOptionsScratch;
        generateArcOptions.minDistance = minDistance;
        generateArcOptions.ellipsoid = ellipsoid;

        if (duplicateCorners) {
            var count = 0;
            var i;

            for (i = 0; i < length - 1; i++) {
                count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i+1], minDistance) + 1;
            }

            topPositions = new Float64Array(count * 3);
            bottomPositions = new Float64Array(count * 3);

            var generateArcPositions = positionsArrayScratch;
            var generateArcHeights = heightsArrayScratch;
            generateArcOptions.positions = generateArcPositions;
            generateArcOptions.height = generateArcHeights;

            var offset = 0;
            for (i = 0; i < length - 1; i++) {
                generateArcPositions[0] = wallPositions[i];
                generateArcPositions[1] = wallPositions[i + 1];

                generateArcHeights[0] = maximumHeights[i];
                generateArcHeights[1] = maximumHeights[i + 1];

                var pos = PolylinePipeline.generateArc(generateArcOptions);
                topPositions.set(pos, offset);

                generateArcHeights[0] = minimumHeights[i];
                generateArcHeights[1] = minimumHeights[i + 1];

                bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);

                offset += pos.length;
            }
        } else {
            generateArcOptions.positions = wallPositions;
            generateArcOptions.height = maximumHeights;
            topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));

            generateArcOptions.height = minimumHeights;
            bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));
        }

        return {
            bottomPositions: bottomPositions,
            topPositions: topPositions,
            numCorners: numCorners
        };
    };

    return WallGeometryLibrary;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js":
/*!*************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ./BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ./Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ./ComponentDatatype */ "./node_modules/terriajs-cesium/Source/Core/ComponentDatatype.js"),
        __webpack_require__(/*! ./defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ./defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ./Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ./Geometry */ "./node_modules/terriajs-cesium/Source/Core/Geometry.js"),
        __webpack_require__(/*! ./GeometryAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttribute.js"),
        __webpack_require__(/*! ./GeometryAttributes */ "./node_modules/terriajs-cesium/Source/Core/GeometryAttributes.js"),
        __webpack_require__(/*! ./IndexDatatype */ "./node_modules/terriajs-cesium/Source/Core/IndexDatatype.js"),
        __webpack_require__(/*! ./Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ./PrimitiveType */ "./node_modules/terriajs-cesium/Source/Core/PrimitiveType.js"),
        __webpack_require__(/*! ./WallGeometryLibrary */ "./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        BoundingSphere,
        Cartesian3,
        ComponentDatatype,
        defaultValue,
        defined,
        DeveloperError,
        Ellipsoid,
        Geometry,
        GeometryAttribute,
        GeometryAttributes,
        IndexDatatype,
        CesiumMath,
        PrimitiveType,
        WallGeometryLibrary) {
    'use strict';

    var scratchCartesian3Position1 = new Cartesian3();
    var scratchCartesian3Position2 = new Cartesian3();

    /**
     * A description of a wall outline. A wall is defined by a series of points,
     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     *
     * @alias WallOutlineGeometry
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the
     *        wall at <code>positions</code>. If undefined, the height of each position in used.
     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the
     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
     *
     * @exception {DeveloperError} positions length must be greater than or equal to 2.
     * @exception {DeveloperError} positions and maximumHeights must have the same length.
     * @exception {DeveloperError} positions and minimumHeights must have the same length.
     *
     * @see WallGeometry#createGeometry
     * @see WallGeometry#fromConstantHeight
     *
     * @example
     * // create a wall outline that spans from ground level to 10000 meters
     * var wall = new Cesium.WallOutlineGeometry({
     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
     *     19.0, 47.0, 10000.0,
     *     19.0, 48.0, 10000.0,
     *     20.0, 48.0, 10000.0,
     *     20.0, 47.0, 10000.0,
     *     19.0, 47.0, 10000.0
     *   ])
     * });
     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);
     */
    function WallOutlineGeometry(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var wallPositions = options.positions;
        var maximumHeights = options.maximumHeights;
        var minimumHeights = options.minimumHeights;

        

        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);
        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);

        this._positions = wallPositions;
        this._minimumHeights = minimumHeights;
        this._maximumHeights = maximumHeights;
        this._granularity = granularity;
        this._ellipsoid = Ellipsoid.clone(ellipsoid);
        this._workerName = 'createWallOutlineGeometry';

        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;
        if (defined(minimumHeights)) {
            numComponents += minimumHeights.length;
        }
        if (defined(maximumHeights)) {
            numComponents += maximumHeights.length;
        }

        /**
         * The number of elements used to pack the object into an array.
         * @type {Number}
         */
        this.packedLength = numComponents + Ellipsoid.packedLength + 1;
    }

    /**
     * Stores the provided instance into the provided array.
     *
     * @param {WallOutlineGeometry} value The value to pack.
     * @param {Number[]} array The array to pack into.
     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
     *
     * @returns {Number[]} The array that was packed into
     */
    WallOutlineGeometry.pack = function(value, array, startingIndex) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var positions = value._positions;
        var length = positions.length;
        array[startingIndex++] = length;

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            Cartesian3.pack(positions[i], array, startingIndex);
        }

        var minimumHeights = value._minimumHeights;
        length = defined(minimumHeights) ? minimumHeights.length : 0;
        array[startingIndex++] = length;

        if (defined(minimumHeights)) {
            for (i = 0; i < length; ++i) {
                array[startingIndex++] = minimumHeights[i];
            }
        }

        var maximumHeights = value._maximumHeights;
        length = defined(maximumHeights) ? maximumHeights.length : 0;
        array[startingIndex++] = length;

        if (defined(maximumHeights)) {
            for (i = 0; i < length; ++i) {
                array[startingIndex++] = maximumHeights[i];
            }
        }

        Ellipsoid.pack(value._ellipsoid, array, startingIndex);
        startingIndex += Ellipsoid.packedLength;

        array[startingIndex]   = value._granularity;

        return array;
    };

    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);
    var scratchOptions = {
        positions : undefined,
        minimumHeights : undefined,
        maximumHeights : undefined,
        ellipsoid : scratchEllipsoid,
        granularity : undefined
    };

    /**
     * Retrieves an instance from a packed array.
     *
     * @param {Number[]} array The packed array.
     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
     * @param {WallOutlineGeometry} [result] The object into which to store the result.
     * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.
     */
    WallOutlineGeometry.unpack = function(array, startingIndex, result) {
        

        startingIndex = defaultValue(startingIndex, 0);

        var i;

        var length = array[startingIndex++];
        var positions = new Array(length);

        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {
            positions[i] = Cartesian3.unpack(array, startingIndex);
        }

        length = array[startingIndex++];
        var minimumHeights;

        if (length > 0) {
            minimumHeights = new Array(length);
            for (i = 0; i < length; ++i) {
                minimumHeights[i] = array[startingIndex++];
            }
        }

        length = array[startingIndex++];
        var maximumHeights;

        if (length > 0) {
            maximumHeights = new Array(length);
            for (i = 0; i < length; ++i) {
                maximumHeights[i] = array[startingIndex++];
            }
        }

        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);
        startingIndex += Ellipsoid.packedLength;

        var granularity = array[startingIndex];

        if (!defined(result)) {
            scratchOptions.positions = positions;
            scratchOptions.minimumHeights = minimumHeights;
            scratchOptions.maximumHeights = maximumHeights;
            scratchOptions.granularity = granularity;
            return new WallOutlineGeometry(scratchOptions);
        }

        result._positions = positions;
        result._minimumHeights = minimumHeights;
        result._maximumHeights = maximumHeights;
        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);
        result._granularity = granularity;

        return result;
    };

    /**
     * A description of a walloutline. A wall is defined by a series of points,
     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     *
     * @param {Object} options Object with the following properties:
     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the
     *        wall at <code>positions</code>. If undefined, the height of each position in used.
     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the
     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
     * @returns {WallOutlineGeometry}
     *
     *
     * @example
     * // create a wall that spans from 10000 meters to 20000 meters
     * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     19.0, 47.0,
     *     19.0, 48.0,
     *     20.0, 48.0,
     *     20.0, 47.0,
     *     19.0, 47.0,
     *   ]),
     *   minimumHeight : 20000.0,
     *   maximumHeight : 10000.0
     * });
     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);
     *
     * @see WallOutlineGeometry#createGeometry
     */
    WallOutlineGeometry.fromConstantHeights = function(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);
        var positions = options.positions;

        

        var minHeights;
        var maxHeights;

        var min = options.minimumHeight;
        var max = options.maximumHeight;

        var doMin = defined(min);
        var doMax = defined(max);
        if (doMin || doMax) {
            var length = positions.length;
            minHeights = (doMin) ? new Array(length) : undefined;
            maxHeights = (doMax) ? new Array(length) : undefined;

            for (var i = 0; i < length; ++i) {
                if (doMin) {
                    minHeights[i] = min;
                }

                if (doMax) {
                    maxHeights[i] = max;
                }
            }
        }

        var newOptions = {
            positions : positions,
            maximumHeights : maxHeights,
            minimumHeights : minHeights,
            ellipsoid : options.ellipsoid
        };
        return new WallOutlineGeometry(newOptions);
    };

    /**
     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.
     *
     * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.
     * @returns {Geometry|undefined} The computed vertices and indices.
     */
    WallOutlineGeometry.createGeometry = function(wallGeometry) {
        var wallPositions = wallGeometry._positions;
        var minimumHeights = wallGeometry._minimumHeights;
        var maximumHeights = wallGeometry._maximumHeights;
        var granularity = wallGeometry._granularity;
        var ellipsoid = wallGeometry._ellipsoid;

        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);
        if (!defined(pos)) {
            return;
        }

        var bottomPositions = pos.bottomPositions;
        var topPositions = pos.topPositions;

        var length = topPositions.length;
        var size = length * 2;

        var positions = new Float64Array(size);
        var positionIndex = 0;

        // add lower and upper points one after the other, lower
        // points being even and upper points being odd
        length /= 3;
        var i;
        for (i = 0; i < length; ++i) {
            var i3 = i * 3;
            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);
            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);

            // insert the lower point
            positions[positionIndex++] = bottomPosition.x;
            positions[positionIndex++] = bottomPosition.y;
            positions[positionIndex++] = bottomPosition.z;

            // insert the upper point
            positions[positionIndex++] = topPosition.x;
            positions[positionIndex++] = topPosition.y;
            positions[positionIndex++] = topPosition.z;
        }

        var attributes = new GeometryAttributes({
            position : new GeometryAttribute({
                componentDatatype : ComponentDatatype.DOUBLE,
                componentsPerAttribute : 3,
                values : positions
            })
        });

        var numVertices = size / 3;
        size = 2 * numVertices - 4 + numVertices;
        var indices = IndexDatatype.createTypedArray(numVertices, size);

        var edgeIndex = 0;
        for (i = 0; i < numVertices - 2; i += 2) {
            var LL = i;
            var LR = i + 2;
            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);
            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);
            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {
                continue;
            }
            var UL = i + 1;
            var UR = i + 3;

            indices[edgeIndex++] = UL;
            indices[edgeIndex++] = LL;
            indices[edgeIndex++] = UL;
            indices[edgeIndex++] = UR;
            indices[edgeIndex++] = LL;
            indices[edgeIndex++] = LR;
        }

        indices[edgeIndex++] = numVertices - 2;
        indices[edgeIndex++] = numVertices - 1;

        return new Geometry({
            attributes : attributes,
            indices : indices,
            primitiveType : PrimitiveType.LINES,
            boundingSphere : new BoundingSphere.fromVertices(positions)
        });
    };

    return WallOutlineGeometry;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/BoundingRectangle */ "./node_modules/terriajs-cesium/Source/Core/BoundingRectangle.js"),
        __webpack_require__(/*! ../Core/Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/NearFarScalar */ "./node_modules/terriajs-cesium/Source/Core/NearFarScalar.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/HorizontalOrigin */ "./node_modules/terriajs-cesium/Source/Scene/HorizontalOrigin.js"),
        __webpack_require__(/*! ../Scene/VerticalOrigin */ "./node_modules/terriajs-cesium/Source/Scene/VerticalOrigin.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        BoundingRectangle,
        Cartesian2,
        Cartesian3,
        Color,
        defined,
        destroyObject,
        DeveloperError,
        DistanceDisplayCondition,
        NearFarScalar,
        HeightReference,
        HorizontalOrigin,
        VerticalOrigin,
        BoundingSphereState,
        Property) {
    'use strict';

    var defaultColor = Color.WHITE;
    var defaultEyeOffset = Cartesian3.ZERO;
    var defaultHeightReference = HeightReference.NONE;
    var defaultPixelOffset = Cartesian2.ZERO;
    var defaultScale = 1.0;
    var defaultRotation = 0.0;
    var defaultAlignedAxis = Cartesian3.ZERO;
    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;
    var defaultVerticalOrigin = VerticalOrigin.CENTER;
    var defaultSizeInMeters = false;

    var positionScratch = new Cartesian3();
    var colorScratch = new Color();
    var eyeOffsetScratch = new Cartesian3();
    var pixelOffsetScratch = new Cartesian2();
    var scaleByDistanceScratch = new NearFarScalar();
    var translucencyByDistanceScratch = new NearFarScalar();
    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();
    var boundingRectangleScratch = new BoundingRectangle();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();

    function EntityData(entity) {
        this.entity = entity;
        this.billboard = undefined;
        this.textureValue = undefined;
    }

    /**
     * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.
     * @alias BillboardVisualizer
     * @constructor
     *
     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     */
    function BillboardVisualizer(entityCluster, entityCollection) {
        

        entityCollection.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);

        this._cluster = entityCluster;
        this._entityCollection = entityCollection;
        this._items = new AssociativeArray();
        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
    }

    /**
     * Updates the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} This function always returns true.
     */
    BillboardVisualizer.prototype.update = function(time) {
        

        var items = this._items.values;
        var cluster = this._cluster;

        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var entity = item.entity;
            var billboardGraphics = entity._billboard;
            var textureValue;
            var billboard = item.billboard;
            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(billboardGraphics._show, time, true);
            var position;
            if (show) {
                position = Property.getValueOrUndefined(entity._position, time, positionScratch);
                textureValue = Property.getValueOrUndefined(billboardGraphics._image, time);
                show = defined(position) && defined(textureValue);
            }

            if (!show) {
                //don't bother creating or updating anything else
                returnPrimitive(item, entity, cluster);
                continue;
            }

            if (!Property.isConstant(entity._position)) {
                cluster._clusterDirty = true;
            }

            if (!defined(billboard)) {
                billboard = cluster.getBillboard(entity);
                billboard.id = entity;
                billboard.image = undefined;
                item.billboard = billboard;
            }

            billboard.show = show;
            if (!defined(billboard.image) || item.textureValue !== textureValue) {
                billboard.image = textureValue;
                item.textureValue = textureValue;
            }
            billboard.position = position;
            billboard.color = Property.getValueOrDefault(billboardGraphics._color, time, defaultColor, colorScratch);
            billboard.eyeOffset = Property.getValueOrDefault(billboardGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);
            billboard.heightReference = Property.getValueOrDefault(billboardGraphics._heightReference, time, defaultHeightReference);
            billboard.pixelOffset = Property.getValueOrDefault(billboardGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);
            billboard.scale = Property.getValueOrDefault(billboardGraphics._scale, time, defaultScale);
            billboard.rotation = Property.getValueOrDefault(billboardGraphics._rotation, time, defaultRotation);
            billboard.alignedAxis = Property.getValueOrDefault(billboardGraphics._alignedAxis, time, defaultAlignedAxis);
            billboard.horizontalOrigin = Property.getValueOrDefault(billboardGraphics._horizontalOrigin, time, defaultHorizontalOrigin);
            billboard.verticalOrigin = Property.getValueOrDefault(billboardGraphics._verticalOrigin, time, defaultVerticalOrigin);
            billboard.width = Property.getValueOrUndefined(billboardGraphics._width, time);
            billboard.height = Property.getValueOrUndefined(billboardGraphics._height, time);
            billboard.scaleByDistance = Property.getValueOrUndefined(billboardGraphics._scaleByDistance, time, scaleByDistanceScratch);
            billboard.translucencyByDistance = Property.getValueOrUndefined(billboardGraphics._translucencyByDistance, time, translucencyByDistanceScratch);
            billboard.pixelOffsetScaleByDistance = Property.getValueOrUndefined(billboardGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);
            billboard.sizeInMeters = Property.getValueOrDefault(billboardGraphics._sizeInMeters, time, defaultSizeInMeters);
            billboard.distanceDisplayCondition = Property.getValueOrUndefined(billboardGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);
            billboard.disableDepthTestDistance = Property.getValueOrUndefined(billboardGraphics._disableDepthTestDistance, time);

            var subRegion = Property.getValueOrUndefined(billboardGraphics._imageSubRegion, time, boundingRectangleScratch);
            if (defined(subRegion)) {
                billboard.setImageSubRegion(billboard._imageId, subRegion);
            }
        }
        return true;
    };

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    BillboardVisualizer.prototype.getBoundingSphere = function(entity, result) {
        

        var item = this._items.get(entity.id);
        if (!defined(item) || !defined(item.billboard)) {
            return BoundingSphereState.FAILED;
        }

        var billboard = item.billboard;
        if (billboard.heightReference === HeightReference.NONE) {
            result.center = Cartesian3.clone(billboard.position, result.center);
        } else {
            if (!defined(billboard._clampedPosition)) {
                return BoundingSphereState.PENDING;
            }
            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);
        }
        result.radius = 0;
        return BoundingSphereState.DONE;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    BillboardVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    BillboardVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);
        var entities = this._entityCollection.values;
        for (var i = 0; i < entities.length; i++) {
            this._cluster.removeBillboard(entities[i]);
        }
        return destroyObject(this);
    };

    BillboardVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {
        var i;
        var entity;
        var items = this._items;
        var cluster = this._cluster;

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            if (defined(entity._billboard) && defined(entity._position)) {
                items.set(entity.id, new EntityData(entity));
            }
        }

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            if (defined(entity._billboard) && defined(entity._position)) {
                if (!items.contains(entity.id)) {
                    items.set(entity.id, new EntityData(entity));
                }
            } else {
                returnPrimitive(items.get(entity.id), entity, cluster);
                items.remove(entity.id);
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            returnPrimitive(items.get(entity.id), entity, cluster);
            items.remove(entity.id);
        }
    };

    function returnPrimitive(item, entity, cluster) {
        if (defined(item)) {
            item.billboard = undefined;
            cluster.removeBillboard(entity);
        }
    }

    return BillboardVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/BoxGeometry */ "./node_modules/terriajs-cesium/Source/Core/BoxGeometry.js"),
        __webpack_require__(/*! ../Core/BoxOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/BoxOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./heightReferenceOnEntityPropertyChanged */ "./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        BoxGeometry,
        BoxOutlineGeometry,
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        defineProperties,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        GeometryInstance,
        GeometryOffsetAttribute,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        heightReferenceOnEntityPropertyChanged,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        Property) {
    'use strict';

    var defaultOffset = Cartesian3.ZERO;

    var offsetScratch = new Cartesian3();
    var positionScratch = new Cartesian3();
    var scratchColor = new Color();

    function BoxGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.dimensions = undefined;
        this.offsetAttribute = undefined;
    }

    /**
     * A {@link GeometryUpdater} for boxes.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias BoxGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function BoxGeometryUpdater(entity, scene) {
        GeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new BoxGeometryOptions(entity),
            geometryPropertyName : 'box',
            observedPropertyNames : ['availability', 'position', 'orientation', 'box']
        });

        this._onEntityPropertyChanged(entity, 'box', entity.box, undefined);
    }

    if (defined(Object.create)) {
        BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;
    }

    defineProperties(BoxGeometryUpdater.prototype, {
        /**
         * Gets the terrain offset property
         * @type {TerrainOffsetProperty}
         * @memberof BoxGeometryUpdater.prototype
         * @readonly
         */
        terrainOffsetProperty: {
            get: function() {
                return this._terrainOffsetProperty;
            }
        }
    });

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    BoxGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);

        var attributes = {
            show : show,
            distanceDisplayCondition : distanceDisplayConditionAttribute,
            color : undefined,
            offset: undefined
        };
        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }
        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : BoxGeometry.fromDimensions(this._options),
            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    BoxGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),
            offset : undefined
        };
        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : BoxOutlineGeometry.fromDimensions(this._options),
            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),
            attributes : attributes
        });
    };

    BoxGeometryUpdater.prototype._computeCenter = function(time, result) {
        return Property.getValueOrUndefined(this._entity.position, time, result);
    };

    BoxGeometryUpdater.prototype._isHidden = function(entity, box) {
        return !defined(box.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, box);
    };

    BoxGeometryUpdater.prototype._isDynamic = function(entity, box) {
        return !entity.position.isConstant ||  !Property.isConstant(entity.orientation) ||  !box.dimensions.isConstant ||  !Property.isConstant(box.outlineWidth);
    };

    BoxGeometryUpdater.prototype._setStaticOptions = function(entity, box) {
        var heightReference = Property.getValueOrDefault(box.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);

        var options = this._options;
        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.dimensions = box.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);
        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;
    };

    BoxGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;

    BoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;

    /**
     * @private
     */
    function DynamicBoxGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicBoxGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;
    }

    DynamicBoxGeometryUpdater.prototype._isHidden = function(entity, box, time) {
        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);
        var dimensions = this._options.dimensions;
        return !defined(position) || !defined(dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time);
    };

    DynamicBoxGeometryUpdater.prototype._setOptions = function(entity, box, time) {
        var heightReference = Property.getValueOrDefault(box.heightReference, time, HeightReference.NONE);
        var options = this._options;
        options.dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);
        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;
    };

    return BoxGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js":
/*!************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ApproximateTerrainHeights */ "./node_modules/terriajs-cesium/Source/Core/ApproximateTerrainHeights.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/CorridorGeometry */ "./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js"),
        __webpack_require__(/*! ../Core/CorridorOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./GroundGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ApproximateTerrainHeights,
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        CorridorGeometry,
        CorridorOutlineGeometry,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        GeometryInstance,
        GeometryOffsetAttribute,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        Rectangle,
        ShowGeometryInstanceAttribute,
        GroundPrimitive,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        GroundGeometryUpdater,
        Property) {
    'use strict';

    var scratchColor = new Color();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();
    var scratchRectangle = new Rectangle();

    function CorridorGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.positions = undefined;
        this.width = undefined;
        this.cornerType = undefined;
        this.height = undefined;
        this.extrudedHeight = undefined;
        this.granularity = undefined;
        this.offsetAttribute = undefined;
    }

    /**
     * A {@link GeometryUpdater} for corridors.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias CorridorGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function CorridorGeometryUpdater(entity, scene) {
        GroundGeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new CorridorGeometryOptions(entity),
            geometryPropertyName : 'corridor',
            observedPropertyNames : ['availability', 'corridor']
        });

        this._onEntityPropertyChanged(entity, 'corridor', entity.corridor, undefined);
    }

    if (defined(Object.create)) {
        CorridorGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);
        CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    CorridorGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),
            offset : undefined,
            color : undefined
        };

        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }

        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new CorridorGeometry(this._options),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    CorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),
            offset : undefined
        };

        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new CorridorOutlineGeometry(this._options),
            attributes : attributes
        });
    };

    CorridorGeometryUpdater.prototype._computeCenter = function(time, result) {
        var positions = Property.getValueOrUndefined(this._entity.corridor.positions, time);
        if (!defined(positions) || positions.length === 0) {
            return;
        }
        return Cartesian3.clone(positions[Math.floor(positions.length / 2.0)], result);
    };

    CorridorGeometryUpdater.prototype._isHidden = function(entity, corridor) {
        return !defined(corridor.positions) || !defined(corridor.width) || GeometryUpdater.prototype._isHidden.call(this, entity, corridor);
    };

    CorridorGeometryUpdater.prototype._isDynamic = function(entity, corridor) {
        return !corridor.positions.isConstant || //
               !Property.isConstant(corridor.height) || //
               !Property.isConstant(corridor.extrudedHeight) || //
               !Property.isConstant(corridor.granularity) || //
               !Property.isConstant(corridor.width) || //
               !Property.isConstant(corridor.outlineWidth) || //
               !Property.isConstant(corridor.cornerType) || //
               !Property.isConstant(corridor.zIndex) || //
               (this._onTerrain && !Property.isConstant(this._materialProperty));
    };

    CorridorGeometryUpdater.prototype._setStaticOptions = function(entity, corridor) {
        var heightValue = Property.getValueOrUndefined(corridor.height, Iso8601.MINIMUM_VALUE);
        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, Iso8601.MINIMUM_VALUE);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        if (defined(extrudedHeightValue) && !defined(heightValue)) {
            heightValue = 0;
        }

        var options = this._options;
        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.positions = corridor.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);
        options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);
        options.granularity = Property.getValueOrUndefined(corridor.granularity, Iso8601.MINIMUM_VALUE);
        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, Iso8601.MINIMUM_VALUE);
        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    CorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;

    /**
     * @private
     */
    function DynamicCorridorGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicCorridorGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;
    }

    DynamicCorridorGeometryUpdater.prototype._isHidden = function(entity, corridor, time) {
        var options = this._options;
        return !defined(options.positions) || !defined(options.width) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, corridor, time);
    };

    DynamicCorridorGeometryUpdater.prototype._setOptions = function(entity, corridor, time) {
        var options = this._options;
        var heightValue = Property.getValueOrUndefined(corridor.height, time);
        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, time, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, time);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, time, HeightReference.NONE);
        if (defined(extrudedHeightValue) && !defined(heightValue)) {
            heightValue = 0;
        }

        options.positions = Property.getValueOrUndefined(corridor.positions, time);
        options.width = Property.getValueOrUndefined(corridor.width, time);
        options.granularity = Property.getValueOrUndefined(corridor.granularity, time);
        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);
        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    return CorridorGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js":
/*!************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/CylinderGeometry */ "./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js"),
        __webpack_require__(/*! ../Core/CylinderOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./heightReferenceOnEntityPropertyChanged */ "./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        CylinderGeometry,
        CylinderOutlineGeometry,
        defined,
        defineProperties,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        GeometryInstance,
        GeometryOffsetAttribute,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        heightReferenceOnEntityPropertyChanged,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        Property) {
    'use strict';

    var defaultOffset = Cartesian3.ZERO;

    var offsetScratch = new Cartesian3();
    var positionScratch = new Cartesian3();
    var scratchColor = new Color();

    function CylinderGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.length = undefined;
        this.topRadius = undefined;
        this.bottomRadius = undefined;
        this.slices = undefined;
        this.numberOfVerticalLines = undefined;
        this.offsetAttribute = undefined;
    }

    /**
     * A {@link GeometryUpdater} for cylinders.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias CylinderGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function CylinderGeometryUpdater(entity, scene) {
        GeometryUpdater.call(this, {
            entity: entity,
            scene: scene,
            geometryOptions: new CylinderGeometryOptions(entity),
            geometryPropertyName: 'cylinder',
            observedPropertyNames: ['availability', 'position', 'orientation', 'cylinder']
        });

        this._onEntityPropertyChanged(entity, 'cylinder', entity.cylinder, undefined);
    }

    if (defined(Object.create)) {
        CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;
    }

    defineProperties(CylinderGeometryUpdater.prototype, {
        /**
         * Gets the terrain offset property
         * @type {TerrainOffsetProperty}
         * @memberof CylinderGeometryUpdater.prototype
         * @readonly
         */
        terrainOffsetProperty: {
            get: function() {
                return this._terrainOffsetProperty;
            }
        }
    });

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    CylinderGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);

        var attributes = {
            show : show,
            distanceDisplayCondition : distanceDisplayConditionAttribute,
            color : undefined,
            offset: undefined
        };
        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }

        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new CylinderGeometry(this._options),
            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    CylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),
            offset : undefined
        };
        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new CylinderOutlineGeometry(this._options),
            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),
            attributes : attributes
        });
    };

    CylinderGeometryUpdater.prototype._computeCenter = function(time, result) {
        return Property.getValueOrUndefined(this._entity.position, time, result);
    };

    CylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder) {
        return !defined(entity.position) || !defined(cylinder.length) || !defined(cylinder.topRadius) || !defined(cylinder.bottomRadius) || GeometryUpdater.prototype._isHidden.call(this, entity, cylinder);
    };

    CylinderGeometryUpdater.prototype._isDynamic = function(entity, cylinder) {
        return !entity.position.isConstant || //
                !Property.isConstant(entity.orientation) || //
                !cylinder.length.isConstant || //
                !cylinder.topRadius.isConstant || //
                !cylinder.bottomRadius.isConstant || //
                !Property.isConstant(cylinder.slices) || //
                !Property.isConstant(cylinder.outlineWidth) || //
                !Property.isConstant(cylinder.numberOfVerticalLines);
    };

    CylinderGeometryUpdater.prototype._setStaticOptions = function(entity, cylinder) {
        var heightReference = Property.getValueOrDefault(cylinder.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var options = this._options;
        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);
        options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);
        options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);
        options.slices = Property.getValueOrUndefined(cylinder.slices, Iso8601.MINIMUM_VALUE);
        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);
        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;
    };

    CylinderGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;

    CylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;

    /**
     * @private
     */
    function DynamicCylinderGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicCylinderGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicCylinderGeometryUpdater.prototype.constructor = DynamicCylinderGeometryUpdater;
    }

    DynamicCylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder, time) {
        var options = this._options;
        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);
        return !defined(position) || !defined(options.length) || !defined(options.topRadius) || //
               !defined(options.bottomRadius) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, cylinder, time);
    };

    DynamicCylinderGeometryUpdater.prototype._setOptions = function(entity, cylinder, time) {
        var heightReference = Property.getValueOrDefault(cylinder.heightReference, time, HeightReference.NONE);
        var options = this._options;
        options.length = Property.getValueOrUndefined(cylinder.length, time);
        options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);
        options.bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);
        options.slices = Property.getValueOrUndefined(cylinder.slices, time);
        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);
        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;
    };

    return CylinderGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/DataSourceDisplay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/DataSourceDisplay.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ApproximateTerrainHeights */ "./node_modules/terriajs-cesium/Source/Core/ApproximateTerrainHeights.js"),
        __webpack_require__(/*! ../Core/BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/createGuid */ "./node_modules/terriajs-cesium/Source/Core/createGuid.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/EventHelper */ "./node_modules/terriajs-cesium/Source/Core/EventHelper.js"),
        __webpack_require__(/*! ../Scene/GroundPolylinePrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPolylinePrimitive.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/OrderedGroundPrimitiveCollection */ "./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js"),
        __webpack_require__(/*! ../Scene/PrimitiveCollection */ "./node_modules/terriajs-cesium/Source/Scene/PrimitiveCollection.js"),
        __webpack_require__(/*! ./BillboardVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./CustomDataSource */ "./node_modules/terriajs-cesium/Source/DataSources/CustomDataSource.js"),
        __webpack_require__(/*! ./GeometryVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js"),
        __webpack_require__(/*! ./LabelVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js"),
        __webpack_require__(/*! ./ModelVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js"),
        __webpack_require__(/*! ./PathVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js"),
        __webpack_require__(/*! ./PointVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js"),
        __webpack_require__(/*! ./PolylineVisualizer */ "./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ApproximateTerrainHeights,
        BoundingSphere,
        Check,
        createGuid,
        defaultValue,
        defined,
        defineProperties,
        destroyObject,
        EventHelper,
        GroundPolylinePrimitive,
        GroundPrimitive,
        OrderedGroundPrimitiveCollection,
        PrimitiveCollection,
        BillboardVisualizer,
        BoundingSphereState,
        CustomDataSource,
        GeometryVisualizer,
        LabelVisualizer,
        ModelVisualizer,
        PathVisualizer,
        PointVisualizer,
        PolylineVisualizer) {
    'use strict';

    /**
     * Visualizes a collection of {@link DataSource} instances.
     * @alias DataSourceDisplay
     * @constructor
     *
     * @param {Object} options Object with the following properties:
     * @param {Scene} options.scene The scene in which to display the data.
     * @param {DataSourceCollection} options.dataSourceCollection The data sources to display.
     * @param {DataSourceDisplay~VisualizersCallback} [options.visualizersCallback=DataSourceDisplay.defaultVisualizersCallback]
     *        A function which creates an array of visualizers used for visualization.
     *        If undefined, all standard visualizers are used.
     */
    function DataSourceDisplay(options) {
        

        this._displayID = createGuid();

        GroundPrimitive.initializeTerrainHeights();
        GroundPolylinePrimitive.initializeTerrainHeights();

        var scene = options.scene;
        var dataSourceCollection = options.dataSourceCollection;

        this._eventHelper = new EventHelper();
        this._eventHelper.add(dataSourceCollection.dataSourceAdded, this._onDataSourceAdded, this);
        this._eventHelper.add(dataSourceCollection.dataSourceRemoved, this._onDataSourceRemoved, this);
        this._eventHelper.add(dataSourceCollection.dataSourceMoved, this._onDataSourceMoved, this);

        this._dataSourceCollection = dataSourceCollection;
        this._scene = scene;
        this._visualizersCallback = defaultValue(options.visualizersCallback, DataSourceDisplay.defaultVisualizersCallback);

        var primitivesAdded = false;
        var primitives = new PrimitiveCollection();
        var groundPrimitives = new PrimitiveCollection();

        if (dataSourceCollection.length > 0) {
            scene.primitives.add(primitives);
            scene.groundPrimitives.add(groundPrimitives);
            primitivesAdded = true;
        }

        this._primitives = primitives;
        this._groundPrimitives = groundPrimitives;

        for (var i = 0, len = dataSourceCollection.length; i < len; i++) {
            this._onDataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));
        }

        var defaultDataSource = new CustomDataSource();
        this._onDataSourceAdded(undefined, defaultDataSource);
        this._defaultDataSource = defaultDataSource;

        var removeDefaultDataSoureListener;
        var removeDataSourceCollectionListener;
        if (!primitivesAdded) {
            var that = this;
            var addPrimitives = function() {
                scene.primitives.add(primitives);
                scene.groundPrimitives.add(groundPrimitives);
                removeDefaultDataSoureListener();
                removeDataSourceCollectionListener();
                that._removeDefaultDataSoureListener = undefined;
                that._removeDataSourceCollectionListener = undefined;
            };
            removeDefaultDataSoureListener = defaultDataSource.entities.collectionChanged.addEventListener(addPrimitives);
            removeDataSourceCollectionListener = dataSourceCollection.dataSourceAdded.addEventListener(addPrimitives);
        }

        this._removeDefaultDataSoureListener = removeDefaultDataSoureListener;
        this._removeDataSourceCollectionListener = removeDataSourceCollectionListener;

        this._ready = false;
    }

    /**
     * Gets or sets the default function which creates an array of visualizers used for visualization.
     * By default, this function uses all standard visualizers.
     *
     * @type {DataSourceDisplay~VisualizersCallback}
     */
    DataSourceDisplay.defaultVisualizersCallback = function(scene, entityCluster, dataSource) {
        var entities = dataSource.entities;
        return [new BillboardVisualizer(entityCluster, entities),
                new GeometryVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives),
                new LabelVisualizer(entityCluster, entities),
                new ModelVisualizer(scene, entities),
                new PointVisualizer(entityCluster, entities),
                new PathVisualizer(scene, entities),
                new PolylineVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives)];
    };

    defineProperties(DataSourceDisplay.prototype, {
        /**
         * Gets the scene associated with this display.
         * @memberof DataSourceDisplay.prototype
         * @type {Scene}
         */
        scene : {
            get : function() {
                return this._scene;
            }
        },
        /**
         * Gets the collection of data sources to display.
         * @memberof DataSourceDisplay.prototype
         * @type {DataSourceCollection}
         */
        dataSources : {
            get : function() {
                return this._dataSourceCollection;
            }
        },
        /**
         * Gets the default data source instance which can be used to
         * manually create and visualize entities not tied to
         * a specific data source. This instance is always available
         * and does not appear in the list dataSources collection.
         * @memberof DataSourceDisplay.prototype
         * @type {CustomDataSource}
         */
        defaultDataSource : {
            get : function() {
                return this._defaultDataSource;
            }
        },

        /**
         * Gets a value indicating whether or not all entities in the data source are ready
         * @memberof DataSourceDisplay.prototype
         * @type {Boolean}
         * @readonly
         */
        ready : {
            get : function() {
                return this._ready;
            }
        }
    });

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see DataSourceDisplay#destroy
     */
    DataSourceDisplay.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     *
     * @example
     * dataSourceDisplay = dataSourceDisplay.destroy();
     *
     * @see DataSourceDisplay#isDestroyed
     */
    DataSourceDisplay.prototype.destroy = function() {
        this._eventHelper.removeAll();

        var dataSourceCollection = this._dataSourceCollection;
        for (var i = 0, length = dataSourceCollection.length; i < length; ++i) {
            this._onDataSourceRemoved(this._dataSourceCollection, dataSourceCollection.get(i));
        }
        this._onDataSourceRemoved(undefined, this._defaultDataSource);

        if (defined(this._removeDefaultDataSoureListener)) {
            this._removeDefaultDataSoureListener();
            this._removeDataSourceCollectionListener();
        } else {
            this._scene.primitives.remove(this._primitives);
            this._scene.groundPrimitives.remove(this._groundPrimitives);
        }

        return destroyObject(this);
    };

    /**
     * Updates the display to the provided time.
     *
     * @param {JulianDate} time The simulation time.
     * @returns {Boolean} True if all data sources are ready to be displayed, false otherwise.
     */
    DataSourceDisplay.prototype.update = function(time) {
        

        if (!ApproximateTerrainHeights.initialized) {
            this._ready = false;
            return false;
        }

        var result = true;

        var i;
        var x;
        var visualizers;
        var vLength;
        var dataSources = this._dataSourceCollection;
        var length = dataSources.length;
        for (i = 0; i < length; i++) {
            var dataSource = dataSources.get(i);
            if (defined(dataSource.update)) {
                result = dataSource.update(time) && result;
            }

            visualizers = dataSource._visualizersByDisplayID[this._displayID];
            vLength = visualizers.length;
            for (x = 0; x < vLength; x++) {
                result = visualizers[x].update(time) && result;
            }
        }

        visualizers = this._defaultDataSource._visualizersByDisplayID[this._displayID];
        vLength = visualizers.length;
        for (x = 0; x < vLength; x++) {
            result = visualizers[x].update(time) && result;
        }

        this._ready = result;

        return result;
    };

    var getBoundingSphereArrayScratch = [];
    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {Boolean} allowPartial If true, pending bounding spheres are ignored and an answer will be returned from the currently available data.
     *                               If false, the the function will halt and return pending if any of the bounding spheres are pending.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    DataSourceDisplay.prototype.getBoundingSphere = function(entity, allowPartial, result) {
        

        if (!this._ready) {
            return BoundingSphereState.PENDING;
        }

        var i;
        var length;
        var dataSource = this._defaultDataSource;
        if (!dataSource.entities.contains(entity)) {
            dataSource = undefined;

            var dataSources = this._dataSourceCollection;
            length = dataSources.length;
            for (i = 0; i < length; i++) {
                var d = dataSources.get(i);
                if (d.entities.contains(entity)) {
                    dataSource = d;
                    break;
                }
            }
        }

        if (!defined(dataSource)) {
            return BoundingSphereState.FAILED;
        }

        var boundingSpheres = getBoundingSphereArrayScratch;
        var tmp = getBoundingSphereBoundingSphereScratch;

        var count = 0;
        var state = BoundingSphereState.DONE;
        var visualizers = dataSource._visualizers;
        var visualizersLength = visualizers.length;

        for (i = 0; i < visualizersLength; i++) {
            var visualizer = visualizers[i];
            if (defined(visualizer.getBoundingSphere)) {
                state = visualizers[i].getBoundingSphere(entity, tmp);
                if (!allowPartial && state === BoundingSphereState.PENDING) {
                    return BoundingSphereState.PENDING;
                } else if (state === BoundingSphereState.DONE) {
                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);
                    count++;
                }
            }
        }

        if (count === 0) {
            return BoundingSphereState.FAILED;
        }

        boundingSpheres.length = count;
        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);
        return BoundingSphereState.DONE;
    };

    DataSourceDisplay.prototype._onDataSourceAdded = function(dataSourceCollection, dataSource) {
        var scene = this._scene;

        var displayPrimitives = this._primitives;
        var displayGroundPrimitives = this._groundPrimitives;

        var primitives = displayPrimitives.add(new PrimitiveCollection());
        var groundPrimitives = displayGroundPrimitives.add(new OrderedGroundPrimitiveCollection());

        dataSource._primitives = primitives;
        dataSource._groundPrimitives = groundPrimitives;

        var entityCluster = dataSource.clustering;
        entityCluster._initialize(scene);

        primitives.add(entityCluster);

        var visualizers = this._visualizersCallback(scene, entityCluster, dataSource);

        dataSource._visualizersByDisplayID = dataSource._visualizersByDisplayID || {};
        dataSource._visualizersByDisplayID[this._displayID] = visualizers;

        dataSource._visualizers = dataSource._visualizers || [];
        dataSource._visualizers = dataSource._visualizers.concat(visualizers);
    };

    DataSourceDisplay.prototype._onDataSourceRemoved = function(dataSourceCollection, dataSource) {
        var displayPrimitives = this._primitives;
        var displayGroundPrimitives = this._groundPrimitives;

        var primitives = dataSource._primitives;
        var groundPrimitives = dataSource._groundPrimitives;

        var entityCluster = dataSource.clustering;
        primitives.remove(entityCluster);

        var visualizers = dataSource._visualizersByDisplayID[this._displayID];
        if (!defined(visualizers)) {
            return;
        }

        var length = visualizers.length;
        for (var i = 0; i < length; i++) {
            var visualizer = visualizers[i];
            visualizer.destroy();

            var index = dataSource._visualizers.indexOf(visualizer);
            dataSource._visualizers.splice(index, 1);
        }

        delete dataSource._visualizersByDisplayID[this._displayID];

        displayPrimitives.remove(primitives);
        displayGroundPrimitives.remove(groundPrimitives);
    };

    DataSourceDisplay.prototype._onDataSourceMoved = function(dataSource, newIndex, oldIndex) {
        var displayPrimitives = this._primitives;
        var displayGroundPrimitives = this._groundPrimitives;

        var primitives = dataSource._primitives;
        var groundPrimitives = dataSource._groundPrimitives;

        if (newIndex === oldIndex + 1) {
            displayPrimitives.raise(primitives);
            displayGroundPrimitives.raise(groundPrimitives);
        } else if (newIndex === oldIndex - 1) {
            displayPrimitives.lower(primitives);
            displayGroundPrimitives.lower(groundPrimitives);
        } else if (newIndex === 0) {
            displayPrimitives.lowerToBottom(primitives);
            displayGroundPrimitives.lowerToBottom(groundPrimitives);
            displayPrimitives.raise(primitives); // keep defaultDataSource primitives at index 0 since it's not in the collection
            displayGroundPrimitives.raise(groundPrimitives);
        } else {
            displayPrimitives.raiseToTop(primitives);
            displayGroundPrimitives.raiseToTop(groundPrimitives);
        }
    };

    /**
     * A function which creates an array of visualizers used for visualization.
     * @callback DataSourceDisplay~VisualizersCallback
     *
     * @param {Scene} scene The scene to create visualizers for.
     * @param {DataSource} dataSource The data source to create visualizers for.
     * @returns {Visualizer[]} An array of visualizers used for visualization.
     *
     * @example
     * function createVisualizers(scene, dataSource) {
     *     return [new Cesium.BillboardVisualizer(scene, dataSource.entities)];
     * }
     */

    return DataSourceDisplay;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        defined,
        BoundingSphereState) {
    'use strict';

    /**
     * @private
     */
    function DynamicGeometryBatch(primitives, orderedGroundPrimitives) {
        this._primitives = primitives;
        this._orderedGroundPrimitives = orderedGroundPrimitives;
        this._dynamicUpdaters = new AssociativeArray();
    }

    DynamicGeometryBatch.prototype.add = function(time, updater) {
        this._dynamicUpdaters.set(updater.id, updater.createDynamicUpdater(this._primitives, this._orderedGroundPrimitives));
    };

    DynamicGeometryBatch.prototype.remove = function(updater) {
        var id = updater.id;
        var dynamicUpdater = this._dynamicUpdaters.get(id);
        if (defined(dynamicUpdater)) {
            this._dynamicUpdaters.remove(id);
            dynamicUpdater.destroy();
        }
    };

    DynamicGeometryBatch.prototype.update = function(time) {
        var geometries = this._dynamicUpdaters.values;
        for (var i = 0, len = geometries.length; i < len; i++) {
            geometries[i].update(time);
        }
        return true;
    };

    DynamicGeometryBatch.prototype.removeAllPrimitives = function() {
        var geometries = this._dynamicUpdaters.values;
        for (var i = 0, len = geometries.length; i < len; i++) {
            geometries[i].destroy();
        }
        this._dynamicUpdaters.removeAll();
    };

    DynamicGeometryBatch.prototype.getBoundingSphere = function(updater, result) {
        updater = this._dynamicUpdaters.get(updater.id);
        if (defined(updater) && defined(updater.getBoundingSphere)) {
            return updater.getBoundingSphere(result);
        }
        return BoundingSphereState.FAILED;
    };

    return DynamicGeometryBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ../Scene/Primitive */ "./node_modules/terriajs-cesium/Source/Scene/Primitive.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        BoundingSphere,
        Check,
        defined,
        destroyObject,
        DeveloperError,
        GroundPrimitive,
        MaterialAppearance,
        PerInstanceColorAppearance,
        Primitive,
        BoundingSphereState,
        ColorMaterialProperty,
        MaterialProperty,
        Property) {
    'use strict';

    /**
     * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater
     * is responsible for handling visualization of a specific type of geometry
     * that needs to be recomputed based on simulation time.
     * This object is never used directly by client code, but is instead created by
     * {@link GeometryUpdater} implementations which contain dynamic geometry.
     *
     * This type defines an interface and cannot be instantiated directly.
     *
     * @alias DynamicGeometryUpdater
     * @constructor
     * @private
     */
    function DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {
        

        this._primitives = primitives;
        this._orderedGroundPrimitives = orderedGroundPrimitives;
        this._primitive = undefined;
        this._outlinePrimitive = undefined;
        this._geometryUpdater = geometryUpdater;
        this._options = geometryUpdater._options;
        this._entity = geometryUpdater._entity;
        this._material = undefined;
    }

    DynamicGeometryUpdater.prototype._isHidden = function(entity, geometry, time) {
        return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);
    };

    DynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;

    /**
     * Updates the geometry to the specified time.
     * @memberof DynamicGeometryUpdater
     * @function
     *
     * @param {JulianDate} time The current time.
     */
    DynamicGeometryUpdater.prototype.update = function(time) {
        

        var geometryUpdater = this._geometryUpdater;
        var onTerrain = geometryUpdater._onTerrain;

        var primitives = this._primitives;
        var orderedGroundPrimitives = this._orderedGroundPrimitives;
        if (onTerrain) {
            orderedGroundPrimitives.remove(this._primitive);
        } else {
            primitives.removeAndDestroy(this._primitive);
            primitives.removeAndDestroy(this._outlinePrimitive);
            this._outlinePrimitive = undefined;
        }
        this._primitive = undefined;

        var entity = this._entity;
        var geometry = entity[this._geometryUpdater._geometryPropertyName];
        this._setOptions(entity, geometry, time);
        if (this._isHidden(entity, geometry, time)) {
            return;
        }

        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);
        var options = this._options;
        if (!defined(geometry.fill) || geometry.fill.getValue(time)) {
            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;
            var isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;
            var appearance;
            var closed = geometryUpdater._getIsClosed(options);
            if (isColorAppearance) {
                appearance = new PerInstanceColorAppearance({
                    closed: closed,
                    flat : onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain
                });
            } else {
                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);
                this._material = material;
                appearance = new MaterialAppearance({
                    material : material,
                    translucent : material.isTranslucent(),
                    closed : closed
                });
            }

            if (onTerrain) {
                options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;
                this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({
                    geometryInstances : this._geometryUpdater.createFillGeometryInstance(time),
                    appearance : appearance,
                    asynchronous : false,
                    shadows : shadows,
                    classificationType : this._geometryUpdater.classificationTypeProperty.getValue(time)
                }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));
            } else {
                options.vertexFormat = appearance.vertexFormat;

                var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);

                if (isColorAppearance) {
                    appearance.translucent = fillInstance.attributes.color.value[3] !== 255;
                }

                this._primitive = primitives.add(new Primitive({
                    geometryInstances : fillInstance,
                    appearance : appearance,
                    asynchronous : false,
                    shadows : shadows
                }));
            }
        }

        if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {
            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);
            var outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);

            this._outlinePrimitive = primitives.add(new Primitive({
                geometryInstances : outlineInstance,
                appearance : new PerInstanceColorAppearance({
                    flat : true,
                    translucent : outlineInstance.attributes.color.value[3] !== 255,
                    renderState : {
                        lineWidth : geometryUpdater._scene.clampLineWidth(outlineWidth)
                    }
                }),
                asynchronous : false,
                shadows : shadows
            }));
        }
    };

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     * @function
     *
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {
        
        var entity = this._entity;
        var primitive = this._primitive;
        var outlinePrimitive = this._outlinePrimitive;

        var attributes;

        //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready
        if (defined(primitive) && primitive.show && primitive.ready) {
            attributes = primitive.getGeometryInstanceAttributes(entity);
            if (defined(attributes) && defined(attributes.boundingSphere)) {
                BoundingSphere.clone(attributes.boundingSphere, result);
                return BoundingSphereState.DONE;
            }
        }

        if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {
            attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);
            if (defined(attributes) && defined(attributes.boundingSphere)) {
                BoundingSphere.clone(attributes.boundingSphere, result);
                return BoundingSphereState.DONE;
            }
        }

        if ((defined(primitive) && !primitive.ready) || (defined(outlinePrimitive) && !outlinePrimitive.ready)) {
            return BoundingSphereState.PENDING;
        }

        return BoundingSphereState.FAILED;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @memberof DynamicGeometryUpdater
     * @function
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    DynamicGeometryUpdater.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     * @memberof DynamicGeometryUpdater
     * @function
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    DynamicGeometryUpdater.prototype.destroy = function() {
        var primitives = this._primitives;
        var orderedGroundPrimitives = this._orderedGroundPrimitives;
        if (this._geometryUpdater._onTerrain) {
            orderedGroundPrimitives.remove(this._primitive);
        } else {
            primitives.removeAndDestroy(this._primitive);
        }
        primitives.removeAndDestroy(this._outlinePrimitive);
        destroyObject(this);
    };

    return DynamicGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ApproximateTerrainHeights */ "./node_modules/terriajs-cesium/Source/Core/ApproximateTerrainHeights.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/EllipseGeometry */ "./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js"),
        __webpack_require__(/*! ../Core/EllipseOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./GroundGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ApproximateTerrainHeights,
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        EllipseGeometry,
        EllipseOutlineGeometry,
        GeometryInstance,
        GeometryOffsetAttribute,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        Rectangle,
        ShowGeometryInstanceAttribute,
        GroundPrimitive,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        GroundGeometryUpdater,
        Property) {
    'use strict';

    var scratchColor = new Color();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();
    var scratchRectangle = new Rectangle();

    function EllipseGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.center = undefined;
        this.semiMajorAxis = undefined;
        this.semiMinorAxis = undefined;
        this.rotation = undefined;
        this.height = undefined;
        this.extrudedHeight = undefined;
        this.granularity = undefined;
        this.stRotation = undefined;
        this.numberOfVerticalLines = undefined;
        this.offsetAttribute = undefined;
    }

    /**
     * A {@link GeometryUpdater} for ellipses.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias EllipseGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function EllipseGeometryUpdater(entity, scene) {
        GroundGeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new EllipseGeometryOptions(entity),
            geometryPropertyName : 'ellipse',
            observedPropertyNames : ['availability', 'position', 'ellipse']
        });

        this._onEntityPropertyChanged(entity, 'ellipse', entity.ellipse, undefined);
    }

    if (defined(Object.create)) {
        EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);
        EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    EllipseGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),
            offset : undefined,
            color : undefined
        };

        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }

        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new EllipseGeometry(this._options),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    EllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),
            offset : undefined
        };

        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new EllipseOutlineGeometry(this._options),
            attributes : attributes
        });
    };

    EllipseGeometryUpdater.prototype._computeCenter = function(time, result) {
        return Property.getValueOrUndefined(this._entity.position, time, result);
    };

    EllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse) {
        var position = entity.position;

        return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);
    };

    EllipseGeometryUpdater.prototype._isDynamic = function(entity, ellipse) {
        return !entity.position.isConstant || //
               !ellipse.semiMajorAxis.isConstant || //
               !ellipse.semiMinorAxis.isConstant || //
               !Property.isConstant(ellipse.rotation) || //
               !Property.isConstant(ellipse.height) || //
               !Property.isConstant(ellipse.extrudedHeight) || //
               !Property.isConstant(ellipse.granularity) || //
               !Property.isConstant(ellipse.stRotation) || //
               !Property.isConstant(ellipse.outlineWidth) || //
               !Property.isConstant(ellipse.numberOfVerticalLines) || //
               !Property.isConstant(ellipse.zIndex) || //
               (this._onTerrain && !Property.isConstant(this._materialProperty));
    };

    EllipseGeometryUpdater.prototype._setStaticOptions = function(entity, ellipse) {
        var heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);
        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        if (defined(extrudedHeightValue) && !defined(heightValue)) {
            heightValue = 0;
        }

        var options = this._options;
        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);
        options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);
        options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);
        options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);
        options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);
        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);
        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);
        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    EllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;

    /**
     * @private
     */
    function DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;
    }

    DynamicEllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse, time) {
        var options = this._options;
        return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);
    };

    DynamicEllipseGeometryUpdater.prototype._setOptions = function(entity, ellipse, time) {
        var options = this._options;
        var heightValue = Property.getValueOrUndefined(ellipse.height, time);
        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);
        if (defined(extrudedHeightValue) && !defined(heightValue)) {
            heightValue = 0;
        }

        options.center = Property.getValueOrUndefined(entity.position, time, options.center);
        options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);
        options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);
        options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);
        options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);
        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);
        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);
        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    return EllipseGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/EllipsoidGeometry */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidGeometry.js"),
        __webpack_require__(/*! ../Core/EllipsoidOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/Matrix4 */ "./node_modules/terriajs-cesium/Source/Core/Matrix4.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ../Scene/Primitive */ "./node_modules/terriajs-cesium/Source/Scene/Primitive.js"),
        __webpack_require__(/*! ../Scene/SceneMode */ "./node_modules/terriajs-cesium/Source/Scene/SceneMode.js"),
        __webpack_require__(/*! ./heightReferenceOnEntityPropertyChanged */ "./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defaultValue,
        defined,
        defineProperties,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        EllipsoidGeometry,
        EllipsoidOutlineGeometry,
        GeometryInstance,
        GeometryOffsetAttribute,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        Matrix4,
        ShowGeometryInstanceAttribute,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        Primitive,
        SceneMode,
        heightReferenceOnEntityPropertyChanged,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        MaterialProperty,
        Property) {
    'use strict';

    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);
    var defaultOffset = Cartesian3.ZERO;

    var offsetScratch = new Cartesian3();
    var radiiScratch = new Cartesian3();
    var scratchColor = new Color();
    var unitSphere = new Cartesian3(1, 1, 1);

    function EllipsoidGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.radii = undefined;
        this.stackPartitions = undefined;
        this.slicePartitions = undefined;
        this.subdivisions = undefined;
        this.offsetAttribute = undefined;
    }

    /**
     * A {@link GeometryUpdater} for ellipsoids.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias EllipsoidGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function EllipsoidGeometryUpdater(entity, scene) {
        GeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new EllipsoidGeometryOptions(entity),
            geometryPropertyName : 'ellipsoid',
            observedPropertyNames : ['availability', 'position', 'orientation', 'ellipsoid']
        });

        this._onEntityPropertyChanged(entity, 'ellipsoid', entity.ellipsoid, undefined);
    }

    if (defined(Object.create)) {
        EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;
    }

    defineProperties(EllipsoidGeometryUpdater.prototype, {
        /**
         * Gets the terrain offset property
         * @type {TerrainOffsetProperty}
         * @memberof EllipsoidGeometryUpdater.prototype
         * @readonly
         */
        terrainOffsetProperty: {
            get: function() {
                return this._terrainOffsetProperty;
            }
        }
    });

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance
     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    EllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var color;
        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);

        var attributes = {
            show : show,
            distanceDisplayCondition : distanceDisplayConditionAttribute,
            color : undefined,
            offset: undefined
        };

        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            color = ColorGeometryInstanceAttribute.fromColor(currentColor);
            attributes.color = color;
        }
        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new EllipsoidGeometry(this._options),
            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance
     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),
            offset : undefined
        };
        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new EllipsoidOutlineGeometry(this._options),
            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),
            attributes : attributes
        });
    };

    EllipsoidGeometryUpdater.prototype._computeCenter = function(time, result) {
        return Property.getValueOrUndefined(this._entity.position, time, result);
    };

    EllipsoidGeometryUpdater.prototype._isHidden = function(entity, ellipsoid) {
        return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);
    };

    EllipsoidGeometryUpdater.prototype._isDynamic = function(entity, ellipsoid) {
        return !entity.position.isConstant || //
               !Property.isConstant(entity.orientation) || //
               !ellipsoid.radii.isConstant || //
               !Property.isConstant(ellipsoid.stackPartitions) || //
               !Property.isConstant(ellipsoid.slicePartitions) || //
               !Property.isConstant(ellipsoid.outlineWidth) || //
               !Property.isConstant(ellipsoid.subdivisions);
    };

    EllipsoidGeometryUpdater.prototype._setStaticOptions = function(entity, ellipsoid) {
        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var options = this._options;
        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);
        options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);
        options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);
        options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);
        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;
    };

    EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;

    EllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;

    /**
     * @private
     */
    function DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);

        this._scene = geometryUpdater._scene;
        this._modelMatrix = new Matrix4();
        this._attributes = undefined;
        this._outlineAttributes = undefined;
        this._lastSceneMode = undefined;
        this._lastShow = undefined;
        this._lastOutlineShow = undefined;
        this._lastOutlineWidth = undefined;
        this._lastOutlineColor = undefined;
        this._lastOffset = new Cartesian3();
        this._material = {};
    }

    if (defined(Object.create)) {
        DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;
    }

    DynamicEllipsoidGeometryUpdater.prototype.update = function(time) {
        

        var entity = this._entity;
        var ellipsoid = entity.ellipsoid;
        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {
            if (defined(this._primitive)) {
                this._primitive.show = false;
            }

            if (defined(this._outlinePrimitive)) {
                this._outlinePrimitive.show = false;
            }
            return;
        }

        var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);
        var modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : undefined;
        if (!defined(modelMatrix) || !defined(radii)) {
            if (defined(this._primitive)) {
                this._primitive.show = false;
            }

            if (defined(this._outlinePrimitive)) {
                this._outlinePrimitive.show = false;
            }
            return;
        }

        //Compute attributes and material.
        var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);
        var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);
        var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);
        var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);

        // Check properties that could trigger a primitive rebuild.
        var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);
        var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);
        var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);
        var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);
        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);
        var offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;

        //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.
        //Also check for height reference because this method doesn't work when the height is relative to terrain.
        var sceneMode = this._scene.mode;
        var in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;

        var options = this._options;

        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);

        var distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;
        var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);

        var offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch);

        //We only rebuild the primitive if something other than the radii has changed
        //For the radii, we use unit sphere and then deform it with a scale matrix.
        var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || //
                                options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || //
                                options.subdivisions !== subdivisions || this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;

        if (rebuildPrimitives) {
            var primitives = this._primitives;
            primitives.removeAndDestroy(this._primitive);
            primitives.removeAndDestroy(this._outlinePrimitive);
            this._primitive = undefined;
            this._outlinePrimitive = undefined;
            this._lastSceneMode = sceneMode;
            this._lastOutlineWidth = outlineWidth;

            options.stackPartitions = stackPartitions;
            options.slicePartitions = slicePartitions;
            options.subdivisions = subdivisions;
            options.offsetAttribute = offsetAttribute;
            options.radii = in3D ? unitSphere : radii;

            var appearance = new MaterialAppearance({
                material : material,
                translucent : material.isTranslucent(),
                closed : true
            });
            options.vertexFormat = appearance.vertexFormat;

            var fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);

            this._primitive = primitives.add(new Primitive({
                geometryInstances : fillInstance,
                appearance : appearance,
                asynchronous : false,
                shadows : shadows
            }));

            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);
            this._outlinePrimitive = primitives.add(new Primitive({
                geometryInstances : outlineInstance,
                appearance : new PerInstanceColorAppearance({
                    flat : true,
                    translucent : outlineInstance.attributes.color.value[3] !== 255,
                    renderState : {
                        lineWidth : this._geometryUpdater._scene.clampLineWidth(outlineWidth)
                    }
                }),
                asynchronous : false,
                shadows : shadows
            }));

            this._lastShow = showFill;
            this._lastOutlineShow = showOutline;
            this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);
            this._lastDistanceDisplayCondition = distanceDisplayCondition;
            this._lastOffset = Cartesian3.clone(offset, this._lastOffset);
        } else if (this._primitive.ready) {
            //Update attributes only.
            var primitive = this._primitive;
            var outlinePrimitive = this._outlinePrimitive;

            primitive.show = true;
            outlinePrimitive.show = true;
            primitive.appearance.material = material;

            var attributes = this._attributes;
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(entity);
                this._attributes = attributes;
            }
            if (showFill !== this._lastShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);
                this._lastShow = showFill;
            }

            var outlineAttributes = this._outlineAttributes;

            if (!defined(outlineAttributes)) {
                outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);
                this._outlineAttributes = outlineAttributes;
            }

            if (showOutline !== this._lastOutlineShow) {
                outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);
                this._lastOutlineShow = showOutline;
            }

            if (!Color.equals(outlineColor, this._lastOutlineColor)) {
                outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);
                Color.clone(outlineColor, this._lastOutlineColor);
            }

            if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {
                attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);
                DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);
            }

            if (!Cartesian3.equals(offset, this._lastOffset)) {
                attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);
                outlineAttributes.offset  = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);
                Cartesian3.clone(offset, this._lastOffset);
            }
        }

        if (in3D) {
            //Since we are scaling a unit sphere, we can't let any of the values go to zero.
            //Instead we clamp them to a small value.  To the naked eye, this produces the same results
            //that you get passing EllipsoidGeometry a radii with a zero component.
            radii.x = Math.max(radii.x, 0.001);
            radii.y = Math.max(radii.y, 0.001);
            radii.z = Math.max(radii.z, 0.001);

            modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);
            this._primitive.modelMatrix = modelMatrix;
            this._outlinePrimitive.modelMatrix = modelMatrix;
        }
    };

    return EllipsoidGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/Event */ "./node_modules/terriajs-cesium/Source/Core/Event.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/oneTimeWarning */ "./node_modules/terriajs-cesium/Source/Core/oneTimeWarning.js"),
        __webpack_require__(/*! ../Scene/ClassificationType */ "./node_modules/terriajs-cesium/Source/Scene/ClassificationType.js"),
        __webpack_require__(/*! ../Scene/ShadowMode */ "./node_modules/terriajs-cesium/Source/Scene/ShadowMode.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./ConstantProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ConstantProperty.js"),
        __webpack_require__(/*! ./Entity */ "./node_modules/terriajs-cesium/Source/DataSources/Entity.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Check,
        Color,
        defaultValue,
        defined,
        defineProperties,
        destroyObject,
        DeveloperError,
        DistanceDisplayCondition,
        Event,
        Iso8601,
        oneTimeWarning,
        ClassificationType,
        ShadowMode,
        ColorMaterialProperty,
        ConstantProperty,
        Entity,
        Property) {
    'use strict';

    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);
    var defaultShow = new ConstantProperty(true);
    var defaultFill = new ConstantProperty(true);
    var defaultOutline = new ConstantProperty(false);
    var defaultOutlineColor = new ConstantProperty(Color.BLACK);
    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);
    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());
    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);

    /**
     * An abstract class for updating geometry entites.
     * @alias GeometryUpdater
     * @constructor
     *
     * @param {Object} options An object with the following properties:
     * @param {Entity} options.entity The entity containing the geometry to be visualized.
     * @param {Scene} options.scene The scene where visualization is taking place.
     * @param {Object} options.geometryOptions Options for the geometry
     * @param {String} options.geometryPropertyName The geometry property name
     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about
     */
    function GeometryUpdater(options) {
        

        var entity = options.entity;
        var geometryPropertyName = options.geometryPropertyName;

        this._entity = entity;
        this._scene = options.scene;
        this._fillEnabled = false;
        this._isClosed = false;
        this._onTerrain = false;
        this._dynamic = false;
        this._outlineEnabled = false;
        this._geometryChanged = new Event();
        this._showProperty = undefined;
        this._materialProperty = undefined;
        this._showOutlineProperty = undefined;
        this._outlineColorProperty = undefined;
        this._outlineWidth = 1.0;
        this._shadowsProperty = undefined;
        this._distanceDisplayConditionProperty = undefined;
        this._classificationTypeProperty = undefined;
        this._options = options.geometryOptions;
        this._geometryPropertyName = geometryPropertyName;
        this._id = geometryPropertyName + '-' + entity.id;
        this._observedPropertyNames = options.observedPropertyNames;
        this._supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(options.scene);
    }

    defineProperties(GeometryUpdater.prototype, {
        /**
         * Gets the unique ID associated with this updater
         * @memberof GeometryUpdater.prototype
         * @type {String}
         * @readonly
         */
        id : {
            get : function() {
                return this._id;
            }
        },
        /**
         * Gets the entity associated with this geometry.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Entity}
         * @readonly
         */
        entity : {
            get : function() {
                return this._entity;
            }
        },
        /**
         * Gets a value indicating if the geometry has a fill component.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        fillEnabled : {
            get : function() {
                return this._fillEnabled;
            }
        },
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        hasConstantFill : {
            get : function() {
                return !this._fillEnabled ||
                       (!defined(this._entity.availability) &&
                        Property.isConstant(this._showProperty) &&
                        Property.isConstant(this._fillProperty));
            }
        },
        /**
         * Gets the material property used to fill the geometry.
         * @memberof GeometryUpdater.prototype
         *
         * @type {MaterialProperty}
         * @readonly
         */
        fillMaterialProperty : {
            get : function() {
                return this._materialProperty;
            }
        },
        /**
         * Gets a value indicating if the geometry has an outline component.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        outlineEnabled : {
            get : function() {
                return this._outlineEnabled;
            }
        },
        /**
         * Gets a value indicating if the geometry has an outline component.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        hasConstantOutline : {
            get : function() {
                return !this._outlineEnabled ||
                       (!defined(this._entity.availability) &&
                        Property.isConstant(this._showProperty) &&
                        Property.isConstant(this._showOutlineProperty));
            }
        },
        /**
         * Gets the {@link Color} property for the geometry outline.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        outlineColorProperty : {
            get : function() {
                return this._outlineColorProperty;
            }
        },
        /**
         * Gets the constant with of the geometry outline, in pixels.
         * This value is only valid if isDynamic is false.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Number}
         * @readonly
         */
        outlineWidth : {
            get : function() {
                return this._outlineWidth;
            }
        },
        /**
         * Gets the property specifying whether the geometry
         * casts or receives shadows from each light source.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        shadowsProperty : {
            get : function() {
                return this._shadowsProperty;
            }
        },
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        distanceDisplayConditionProperty : {
            get : function() {
                return this._distanceDisplayConditionProperty;
            }
        },
        /**
         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        classificationTypeProperty : {
            get : function() {
                return this._classificationTypeProperty;
            }
        },
        /**
         * Gets a value indicating if the geometry is time-varying.
         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
         * returned by GeometryUpdater#createDynamicUpdater.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isDynamic : {
            get : function() {
                return this._dynamic;
            }
        },
        /**
         * Gets a value indicating if the geometry is closed.
         * This property is only valid for static geometry.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isClosed : {
            get : function() {
                return this._isClosed;
            }
        },
        /**
         * Gets a value indicating if the geometry should be drawn on terrain.
         * @memberof EllipseGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        onTerrain : {
            get : function() {
                return this._onTerrain;
            }
        },
        /**
         * Gets an event that is raised whenever the public properties
         * of this updater change.
         * @memberof GeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        geometryChanged : {
            get : function() {
                return this._geometryChanged;
            }
        }
    });

    /**
     * Checks if the geometry is outlined at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve visibility.
     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.
     */
    GeometryUpdater.prototype.isOutlineVisible = function(time) {
        var entity = this._entity;
        var visible = this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);
        return defaultValue(visible, false);
    };

    /**
     * Checks if the geometry is filled at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve visibility.
     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.
     */
    GeometryUpdater.prototype.isFilled = function(time) {
        var entity = this._entity;
        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);
        return defaultValue(visible, false);
    };

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @function
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    GeometryUpdater.prototype.createFillGeometryInstance = DeveloperError.throwInstantiationError;

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @function
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    GeometryUpdater.prototype.createOutlineGeometryInstance = DeveloperError.throwInstantiationError;

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    GeometryUpdater.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    GeometryUpdater.prototype.destroy = function() {
        destroyObject(this);
    };
    /**
     * @param {Entity} entity
     * @param {Object} geometry
     * @private
     */
    GeometryUpdater.prototype._isHidden = function(entity, geometry) {
        var show = geometry.show;
        return defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE);
    };

    /**
     * @param {Entity} entity
     * @param {Object} geometry
     * @private
     */
    GeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {
        return false;
    };

    /**
     * @param {GeometryOptions} options
     * @private
     */
    GeometryUpdater.prototype._getIsClosed = function(options) {
        return true;
    };

    /**
     * @param {Entity} entity
     * @param {Object} geometry
     * @private
     */
    GeometryUpdater.prototype._isDynamic = DeveloperError.throwInstantiationError;

    /**
     * @param {Entity} entity
     * @param {Object} geometry
     * @private
     */
    GeometryUpdater.prototype._setStaticOptions = DeveloperError.throwInstantiationError;

    /**
     * @param {Entity} entity
     * @param {String} propertyName
     * @param {*} newValue
     * @param {*} oldValue
     * @private
     */
    GeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {
        if (this._observedPropertyNames.indexOf(propertyName) === -1) {
            return;
        }

        var geometry = this._entity[this._geometryPropertyName];

        if (!defined(geometry)) {
            if (this._fillEnabled || this._outlineEnabled) {
                this._fillEnabled = false;
                this._outlineEnabled = false;
                this._geometryChanged.raiseEvent(this);
            }
            return;
        }

        var fillProperty = geometry.fill;
        var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;

        var outlineProperty = geometry.outline;
        var outlineEnabled = defined(outlineProperty);
        if (outlineEnabled && outlineProperty.isConstant) {
            outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);
        }

        if (!fillEnabled && !outlineEnabled) {
            if (this._fillEnabled || this._outlineEnabled) {
                this._fillEnabled = false;
                this._outlineEnabled = false;
                this._geometryChanged.raiseEvent(this);
            }
            return;
        }

        var show = geometry.show;
        if (this._isHidden(entity, geometry)) {
            if (this._fillEnabled || this._outlineEnabled) {
                this._fillEnabled = false;
                this._outlineEnabled = false;
                this._geometryChanged.raiseEvent(this);
            }
            return;
        }

        this._materialProperty = defaultValue(geometry.material, defaultMaterial);
        this._fillProperty = defaultValue(fillProperty, defaultFill);
        this._showProperty = defaultValue(show, defaultShow);
        this._showOutlineProperty = defaultValue(geometry.outline, defaultOutline);
        this._outlineColorProperty = outlineEnabled ? defaultValue(geometry.outlineColor, defaultOutlineColor) : undefined;
        this._shadowsProperty = defaultValue(geometry.shadows, defaultShadows);
        this._distanceDisplayConditionProperty = defaultValue(geometry.distanceDisplayCondition, defaultDistanceDisplayCondition);
        this._classificationTypeProperty = defaultValue(geometry.classificationType, defaultClassificationType);

        this._fillEnabled = fillEnabled;

        var onTerrain = this._isOnTerrain(entity, geometry) &&
            (this._supportsMaterialsforEntitiesOnTerrain || this._materialProperty instanceof ColorMaterialProperty);

        if (outlineEnabled && onTerrain) {
            oneTimeWarning(oneTimeWarning.geometryOutlines);
            outlineEnabled = false;
        }

        this._onTerrain = onTerrain;
        this._outlineEnabled = outlineEnabled;

        if (this._isDynamic(entity, geometry)) {
            if (!this._dynamic) {
                this._dynamic = true;
                this._geometryChanged.raiseEvent(this);
            }
        } else {
            this._setStaticOptions(entity, geometry);
            this._isClosed = this._getIsClosed(this._options);
            var outlineWidth = geometry.outlineWidth;
            this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1.0;
            this._dynamic = false;
            this._geometryChanged.raiseEvent(this);
        }
    };

    /**
     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
     *
     * @param {PrimitiveCollection} primitives The primitive collection to use.
     * @param {PrimitiveCollection} [groundPrimitives] The primitive collection to use for ground primitives.
     *
     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.
     *
     * @exception {DeveloperError} This instance does not represent dynamic geometry.
     */
    GeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {
        

        return new this.constructor.DynamicGeometryUpdater(this, primitives, groundPrimitives);
    };

    return GeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/Event */ "./node_modules/terriajs-cesium/Source/Core/Event.js"),
        __webpack_require__(/*! ../Core/EventHelper */ "./node_modules/terriajs-cesium/Source/Core/EventHelper.js"),
        __webpack_require__(/*! ../Scene/ClassificationType */ "./node_modules/terriajs-cesium/Source/Scene/ClassificationType.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ../Scene/ShadowMode */ "./node_modules/terriajs-cesium/Source/Scene/ShadowMode.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./BoxGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./CorridorGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js"),
        __webpack_require__(/*! ./CylinderGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js"),
        __webpack_require__(/*! ./DynamicGeometryBatch */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js"),
        __webpack_require__(/*! ./EllipseGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js"),
        __webpack_require__(/*! ./EllipsoidGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js"),
        __webpack_require__(/*! ./Entity */ "./node_modules/terriajs-cesium/Source/DataSources/Entity.js"),
        __webpack_require__(/*! ./PlaneGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js"),
        __webpack_require__(/*! ./PolygonGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js"),
        __webpack_require__(/*! ./PolylineVolumeGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js"),
        __webpack_require__(/*! ./RectangleGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js"),
        __webpack_require__(/*! ./StaticGeometryColorBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js"),
        __webpack_require__(/*! ./StaticGeometryPerMaterialBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js"),
        __webpack_require__(/*! ./StaticGroundGeometryColorBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js"),
        __webpack_require__(/*! ./StaticGroundGeometryPerMaterialBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js"),
        __webpack_require__(/*! ./StaticOutlineGeometryBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js"),
        __webpack_require__(/*! ./WallGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        BoundingSphere,
        Check,
        defaultValue,
        defined,
        destroyObject,
        Event,
        EventHelper,
        ClassificationType,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ShadowMode,
        BoundingSphereState,
        BoxGeometryUpdater,
        ColorMaterialProperty,
        CorridorGeometryUpdater,
        CylinderGeometryUpdater,
        DynamicGeometryBatch,
        EllipseGeometryUpdater,
        EllipsoidGeometryUpdater,
        Entity,
        PlaneGeometryUpdater,
        PolygonGeometryUpdater,
        PolylineVolumeGeometryUpdater,
        RectangleGeometryUpdater,
        StaticGeometryColorBatch,
        StaticGeometryPerMaterialBatch,
        StaticGroundGeometryColorBatch,
        StaticGroundGeometryPerMaterialBatch,
        StaticOutlineGeometryBatch,
        WallGeometryUpdater) {
    'use strict';

    var emptyArray = [];

    var geometryUpdaters = [BoxGeometryUpdater, CylinderGeometryUpdater, CorridorGeometryUpdater, EllipseGeometryUpdater, EllipsoidGeometryUpdater, PlaneGeometryUpdater,
                            PolygonGeometryUpdater, PolylineVolumeGeometryUpdater, RectangleGeometryUpdater, WallGeometryUpdater];

    function GeometryUpdaterSet(entity, scene) {
        this.entity = entity;
        this.scene = scene;
        var updaters = new Array(geometryUpdaters.length);
        var geometryChanged = new Event();
        function raiseEvent(geometry) {
            geometryChanged.raiseEvent(geometry);
        }
        var eventHelper = new EventHelper();
        for (var i = 0; i < updaters.length; i++) {
            var updater = new geometryUpdaters[i](entity, scene);
            eventHelper.add(updater.geometryChanged, raiseEvent);
            updaters[i] = updater;
        }
        this.updaters = updaters;
        this.geometryChanged = geometryChanged;
        this.eventHelper = eventHelper;

        this._removeEntitySubscription = entity.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged, this);
    }

    GeometryUpdaterSet.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {
        var updaters = this.updaters;
        for (var i = 0; i < updaters.length; i++) {
            updaters[i]._onEntityPropertyChanged(entity, propertyName, newValue, oldValue);
        }
    };

    GeometryUpdaterSet.prototype.forEach = function (callback) {
        var updaters = this.updaters;
        for (var i = 0; i < updaters.length; i++) {
            callback(updaters[i]);
        }
    };

    GeometryUpdaterSet.prototype.destroy = function() {
        this.eventHelper.removeAll();
        var updaters = this.updaters;
        for (var i = 0; i < updaters.length; i++) {
            updaters[i].destroy();
        }
        this._removeEntitySubscription();
        destroyObject(this);
    };

    /**
     * A general purpose visualizer for geometry represented by {@link Primitive} instances.
     * @alias GeometryVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities
     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities
     */
    function GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {
        

        primitives = defaultValue(primitives, scene.primitives);
        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);

        this._scene = scene;
        this._primitives = primitives;
        this._groundPrimitives = groundPrimitives;
        this._entityCollection = undefined;
        this._addedObjects = new AssociativeArray();
        this._removedObjects = new AssociativeArray();
        this._changedObjects = new AssociativeArray();

        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;
        this._outlineBatches = new Array(numberOfShadowModes*2);
        this._closedColorBatches = new Array(numberOfShadowModes*2);
        this._closedMaterialBatches = new Array(numberOfShadowModes*2);
        this._openColorBatches = new Array(numberOfShadowModes*2);
        this._openMaterialBatches = new Array(numberOfShadowModes*2);

        var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);
        this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;

        var i;
        for (i = 0; i < numberOfShadowModes; ++i) {
            this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);
            this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);

            this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);
            this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);

            this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);
            this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);

            this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);
            this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);

            this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);
            this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);
        }

        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;
        var groundColorBatches = new Array(numberOfClassificationTypes);
        var groundMaterialBatches = [];
        if (supportsMaterialsforEntitiesOnTerrain) {
            for (i = 0; i < numberOfClassificationTypes; ++i) {
                groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));
                groundColorBatches[i] = new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, PerInstanceColorAppearance);
            }
        } else {
            for (i = 0; i < numberOfClassificationTypes; ++i) {
                groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);
            }
        }

        this._groundColorBatches = groundColorBatches;
        this._groundMaterialBatches = groundMaterialBatches;

        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);

        this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);

        this._subscriptions = new AssociativeArray();
        this._updaterSets = new AssociativeArray();

        this._entityCollection = entityCollection;
        entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);
        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);
    }

    /**
     * Updates all of the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} True if the visualizer successfully updated to the provided time,
     * false if the visualizer is waiting for asynchronous primitives to be created.
     */
    GeometryVisualizer.prototype.update = function(time) {
        

        var addedObjects = this._addedObjects;
        var added = addedObjects.values;
        var removedObjects = this._removedObjects;
        var removed = removedObjects.values;
        var changedObjects = this._changedObjects;
        var changed = changedObjects.values;

        var i;
        var entity;
        var id;
        var updaterSet;
        var that = this;

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            id = entity.id;
            updaterSet = this._updaterSets.get(id);

            //If in a single update, an entity gets removed and a new instance
            //re-added with the same id, the updater no longer tracks the
            //correct entity, we need to both remove the old one and
            //add the new one, which is done by pushing the entity
            //onto the removed/added lists.
            if (updaterSet.entity === entity) {
                updaterSet.forEach(function(updater) {
                    that._removeUpdater(updater);
                    that._insertUpdaterIntoBatch(time, updater);
                });
            } else {
                removed.push(entity);
                added.push(entity);
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            id = entity.id;
            updaterSet = this._updaterSets.get(id);
            updaterSet.forEach(this._removeUpdater.bind(this));
            updaterSet.destroy();
            this._updaterSets.remove(id);
            this._subscriptions.get(id)();
            this._subscriptions.remove(id);
        }

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            id = entity.id;
            updaterSet = new GeometryUpdaterSet(entity, this._scene);
            this._updaterSets.set(id, updaterSet);
            updaterSet.forEach(function(updater) {
                that._insertUpdaterIntoBatch(time, updater);
            });
            this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));
        }

        addedObjects.removeAll();
        removedObjects.removeAll();
        changedObjects.removeAll();

        var isUpdated = true;
        var batches = this._batches;
        var length = batches.length;
        for (i = 0; i < length; i++) {
            isUpdated = batches[i].update(time) && isUpdated;
        }

        return isUpdated;
    };

    var getBoundingSphereArrayScratch = [];
    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    GeometryVisualizer.prototype.getBoundingSphere = function(entity, result) {
        

        var boundingSpheres = getBoundingSphereArrayScratch;
        var tmp = getBoundingSphereBoundingSphereScratch;

        var count = 0;
        var state = BoundingSphereState.DONE;
        var batches = this._batches;
        var batchesLength = batches.length;

        var id = entity.id;
        var updaters = this._updaterSets.get(id).updaters;

        for (var j = 0; j < updaters.length; j++) {
            var updater = updaters[j];
            for (var i = 0; i < batchesLength; i++) {
                state = batches[i].getBoundingSphere(updater, tmp);
                if (state === BoundingSphereState.PENDING) {
                    return BoundingSphereState.PENDING;
                } else if (state === BoundingSphereState.DONE) {
                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);
                    count++;
                }
            }
        }

        if (count === 0) {
            return BoundingSphereState.FAILED;
        }

        boundingSpheres.length = count;
        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);
        return BoundingSphereState.DONE;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    GeometryVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    GeometryVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);
        this._addedObjects.removeAll();
        this._removedObjects.removeAll();

        var i;
        var batches = this._batches;
        var length = batches.length;
        for (i = 0; i < length; i++) {
            batches[i].removeAllPrimitives();
        }

        var subscriptions = this._subscriptions.values;
        length = subscriptions.length;
        for (i = 0; i < length; i++) {
            subscriptions[i]();
        }
        this._subscriptions.removeAll();

        var updaterSets = this._updaterSets.values;
        length = updaterSets.length;
        for (i = 0; i < length; i++) {
            updaterSets[i].destroy();
        }
        this._updaterSets.removeAll();
        return destroyObject(this);
    };

    /**
     * @private
     */
    GeometryVisualizer.prototype._removeUpdater = function(updater) {
        //We don't keep track of which batch an updater is in, so just remove it from all of them.
        var batches = this._batches;
        var length = batches.length;
        for (var i = 0; i < length; i++) {
            batches[i].remove(updater);
        }
    };

    /**
     * @private
     */
    GeometryVisualizer.prototype._insertUpdaterIntoBatch = function(time, updater) {
        if (updater.isDynamic) {
            this._dynamicBatch.add(time, updater);
            return;
        }

        var shadows;
        if (updater.outlineEnabled || updater.fillEnabled) {
            shadows = updater.shadowsProperty.getValue(time);
        }

        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;
        if (updater.outlineEnabled) {
            if (defined(updater.terrainOffsetProperty)) {
                this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);
            } else {
                this._outlineBatches[shadows].add(time, updater);
            }
        }

        if (updater.fillEnabled) {
            if (updater.onTerrain) {
                var classificationType = updater.classificationTypeProperty.getValue(time);
                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {
                    this._groundColorBatches[classificationType].add(time, updater);
                } else {
                    // If unsupported, updater will not be on terrain.
                    this._groundMaterialBatches[classificationType].add(time, updater);
                }
            } else if (updater.isClosed) {
                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {
                    if (defined(updater.terrainOffsetProperty)) {
                        this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);
                    } else {
                        this._closedColorBatches[shadows].add(time, updater);
                    }
                } else if (defined(updater.terrainOffsetProperty)) {
                    this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);
                } else {
                    this._closedMaterialBatches[shadows].add(time, updater);
                }
            } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {
                if (defined(updater.terrainOffsetProperty)) {
                    this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);
                } else {
                    this._openColorBatches[shadows].add(time, updater);
                }
            } else if (defined(updater.terrainOffsetProperty)) {
                this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);
            } else {
                this._openMaterialBatches[shadows].add(time, updater);
            }
        }
    };

    /**
     * @private
     */
    GeometryVisualizer._onGeometryChanged = function(updater) {
        var removedObjects = this._removedObjects;
        var changedObjects = this._changedObjects;

        var entity = updater.entity;
        var id = entity.id;

        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {
            changedObjects.set(id, entity);
        }
    };

    /**
     * @private
     */
    GeometryVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {
        var addedObjects = this._addedObjects;
        var removedObjects = this._removedObjects;
        var changedObjects = this._changedObjects;

        var i;
        var id;
        var entity;
        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            id = entity.id;
            if (!addedObjects.remove(id)) {
                removedObjects.set(id, entity);
                changedObjects.remove(id);
            }
        }

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            id = entity.id;
            if (removedObjects.remove(id)) {
                changedObjects.set(id, entity);
            } else {
                addedObjects.set(id, entity);
            }
        }
    };

    return GeometryVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ApproximateTerrainHeights */ "./node_modules/terriajs-cesium/Source/Core/ApproximateTerrainHeights.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/oneTimeWarning */ "./node_modules/terriajs-cesium/Source/Core/oneTimeWarning.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ./CallbackProperty */ "./node_modules/terriajs-cesium/Source/DataSources/CallbackProperty.js"),
        __webpack_require__(/*! ./ConstantProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ConstantProperty.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js"),
        __webpack_require__(/*! ./TerrainOffsetProperty */ "./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ApproximateTerrainHeights,
        Cartesian3,
        Check,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        GeometryOffsetAttribute,
        Iso8601,
        oneTimeWarning,
        GroundPrimitive,
        HeightReference,
        CallbackProperty,
        ConstantProperty,
        GeometryUpdater,
        Property,
        TerrainOffsetProperty) {
    'use strict';

    var defaultZIndex = new ConstantProperty(0);

    /**
     * An abstract class for updating ground geometry entities.
     * @constructor
     * @alias GroundGeometryUpdater
     * @param {Object} options An object with the following properties:
     * @param {Entity} options.entity The entity containing the geometry to be visualized.
     * @param {Scene} options.scene The scene where visualization is taking place.
     * @param {Object} options.geometryOptions Options for the geometry
     * @param {String} options.geometryPropertyName The geometry property name
     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about
     */
    function GroundGeometryUpdater(options) {
        GeometryUpdater.call(this, options);

        this._zIndex = 0;
        this._terrainOffsetProperty = undefined;
    }

    if (defined(Object.create)) {
        GroundGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        GroundGeometryUpdater.prototype.constructor = GroundGeometryUpdater;
    }

    defineProperties(GroundGeometryUpdater.prototype, {
        /**
         * Gets the zindex
         * @type {Number}
         * @memberof GroundGeometryUpdater.prototype
         * @readonly
         */
        zIndex: {
            get: function() {
                return this._zIndex;
            }
        },

        /**
         * Gets the terrain offset property
         * @type {TerrainOffsetProperty}
         * @memberof GroundGeometryUpdater.prototype
         * @readonly
         */
        terrainOffsetProperty: {
            get: function() {
                return this._terrainOffsetProperty;
            }
        }
    });

    GroundGeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {
        return this._fillEnabled && !defined(geometry.height) && !defined(geometry.extrudedHeight) && GroundPrimitive.isSupported(this._scene);
    };

    GroundGeometryUpdater.prototype._getIsClosed = function(options) {
        var height = options.height;
        var extrudedHeight = options.extrudedHeight;
        return height === 0 || (defined(extrudedHeight) && extrudedHeight !== height);
    };

    GroundGeometryUpdater.prototype._computeCenter = DeveloperError.throwInstantiationError;

    GroundGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {
        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);
        if (this._observedPropertyNames.indexOf(propertyName) === -1) {
            return;
        }

        var geometry = this._entity[this._geometryPropertyName];
        if (!defined(geometry)) {
            return;
        }
        if (defined(geometry.zIndex) && (defined(geometry.height) || defined(geometry.extrudedHeight))) {
            oneTimeWarning(oneTimeWarning.geometryZIndex);
        }

        this._zIndex = defaultValue(geometry.zIndex, defaultZIndex);

        if (defined(this._terrainOffsetProperty)) {
            this._terrainOffsetProperty.destroy();
            this._terrainOffsetProperty = undefined;
        }

        var heightReferenceProperty = geometry.heightReference;
        var extrudedHeightReferenceProperty = geometry.extrudedHeightReference;

        if (defined(heightReferenceProperty) || defined(extrudedHeightReferenceProperty)) {
            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);
            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty, extrudedHeightReferenceProperty);
        }
    };

    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    GroundGeometryUpdater.prototype.destroy = function() {
        if (defined(this._terrainOffsetProperty)) {
            this._terrainOffsetProperty.destroy();
            this._terrainOffsetProperty = undefined;
        }

        GeometryUpdater.prototype.destroy.call(this);
    };

    /**
     * @private
     */
    GroundGeometryUpdater.getGeometryHeight = function(height, heightReference) {
        
        if (!defined(height)) {
            if (heightReference !== HeightReference.NONE) {
                oneTimeWarning(oneTimeWarning.geometryHeightReference);
            }
            return;
        }

        if (heightReference !== HeightReference.CLAMP_TO_GROUND) {
            return height;
        }
        return 0.0;
    };

    /**
     * @private
     */
    GroundGeometryUpdater.getGeometryExtrudedHeight = function(extrudedHeight, extrudedHeightReference) {
        
        if (!defined(extrudedHeight)) {
            if (extrudedHeightReference !== HeightReference.NONE) {
                oneTimeWarning(oneTimeWarning.geometryExtrudedHeightReference);
            }
            return;
        }
        if (extrudedHeightReference !== HeightReference.CLAMP_TO_GROUND) {
            return extrudedHeight;
        }

        return GroundGeometryUpdater.CLAMP_TO_GROUND;
    };

    /**
     * @private
     */
    GroundGeometryUpdater.CLAMP_TO_GROUND = 'clamp';

    /**
     * @private
     */
    GroundGeometryUpdater.computeGeometryOffsetAttribute = function(height, heightReference, extrudedHeight, extrudedHeightReference) {
        if (!defined(height) || !defined(heightReference)) {
            heightReference = HeightReference.NONE;
        }
        if (!defined(extrudedHeight) || !defined(extrudedHeightReference)) {
            extrudedHeightReference = HeightReference.NONE;
        }
        var n = 0;
        if (heightReference !== HeightReference.NONE) {
            n++;
        }
        if (extrudedHeightReference === HeightReference.RELATIVE_TO_GROUND) {
            n++;
        }
        if (n === 2) {
            return GeometryOffsetAttribute.ALL;
        }
        if (n === 1) {
            return GeometryOffsetAttribute.TOP;
        }

        return undefined;
    };

    return GroundGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/NearFarScalar */ "./node_modules/terriajs-cesium/Source/Core/NearFarScalar.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/HorizontalOrigin */ "./node_modules/terriajs-cesium/Source/Scene/HorizontalOrigin.js"),
        __webpack_require__(/*! ../Scene/LabelStyle */ "./node_modules/terriajs-cesium/Source/Scene/LabelStyle.js"),
        __webpack_require__(/*! ../Scene/VerticalOrigin */ "./node_modules/terriajs-cesium/Source/Scene/VerticalOrigin.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Cartesian2,
        Cartesian3,
        Color,
        defaultValue,
        defined,
        destroyObject,
        DeveloperError,
        DistanceDisplayCondition,
        NearFarScalar,
        HeightReference,
        HorizontalOrigin,
        LabelStyle,
        VerticalOrigin,
        BoundingSphereState,
        Property) {
    'use strict';

    var defaultScale = 1.0;
    var defaultFont = '30px sans-serif';
    var defaultStyle = LabelStyle.FILL;
    var defaultFillColor = Color.WHITE;
    var defaultOutlineColor = Color.BLACK;
    var defaultOutlineWidth = 1.0;
    var defaultShowBackground = false;
    var defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);
    var defaultBackgroundPadding = new Cartesian2(7, 5);
    var defaultPixelOffset = Cartesian2.ZERO;
    var defaultEyeOffset = Cartesian3.ZERO;
    var defaultHeightReference = HeightReference.NONE;
    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;
    var defaultVerticalOrigin = VerticalOrigin.CENTER;

    var positionScratch = new Cartesian3();
    var fillColorScratch = new Color();
    var outlineColorScratch = new Color();
    var backgroundColorScratch = new Color();
    var backgroundPaddingScratch = new Cartesian2();
    var eyeOffsetScratch = new Cartesian3();
    var pixelOffsetScratch = new Cartesian2();
    var translucencyByDistanceScratch = new NearFarScalar();
    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();
    var scaleByDistanceScratch = new NearFarScalar();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();

    function EntityData(entity) {
        this.entity = entity;
        this.label = undefined;
        this.index = undefined;
    }

    /**
     * A {@link Visualizer} which maps the {@link LabelGraphics} instance
     * in {@link Entity#label} to a {@link Label}.
     * @alias LabelVisualizer
     * @constructor
     *
     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     */
    function LabelVisualizer(entityCluster, entityCollection) {
        

        entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);

        this._cluster = entityCluster;
        this._entityCollection = entityCollection;
        this._items = new AssociativeArray();

        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
    }

    /**
     * Updates the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} This function always returns true.
     */
    LabelVisualizer.prototype.update = function(time) {
        

        var items = this._items.values;
        var cluster = this._cluster;

        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var entity = item.entity;
            var labelGraphics = entity._label;
            var text;
            var label = item.label;
            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);
            var position;
            if (show) {
                position = Property.getValueOrUndefined(entity._position, time, positionScratch);
                text = Property.getValueOrUndefined(labelGraphics._text, time);
                show = defined(position) && defined(text);
            }

            if (!show) {
                //don't bother creating or updating anything else
                returnPrimitive(item, entity, cluster);
                continue;
            }

            if (!Property.isConstant(entity._position)) {
                cluster._clusterDirty = true;
            }

            var updateClamping = false;
            var heightReference = Property.getValueOrDefault(labelGraphics._heightReference, time, defaultHeightReference);

            if (!defined(label)) {
                label = cluster.getLabel(entity);
                label.id = entity;
                item.label = label;

                // If this new label happens to have a position and height reference that match our new values,
                // label._updateClamping will not be called automatically. That's a problem because the clamped
                // height may be based on different terrain than is now loaded. So we'll manually call
                // _updateClamping below.
                updateClamping = Cartesian3.equals(label.position, position) && label.heightReference === heightReference;
            }

            label.show = true;
            label.position = position;
            label.text = text;
            label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);
            label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);
            label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);
            label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColorScratch);
            label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);
            label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);
            label.showBackground = Property.getValueOrDefault(labelGraphics._showBackground, time, defaultShowBackground);
            label.backgroundColor = Property.getValueOrDefault(labelGraphics._backgroundColor, time, defaultBackgroundColor, backgroundColorScratch);
            label.backgroundPadding = Property.getValueOrDefault(labelGraphics._backgroundPadding, time, defaultBackgroundPadding, backgroundPaddingScratch);
            label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);
            label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);
            label.heightReference = heightReference;
            label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);
            label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);
            label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistanceScratch);
            label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);
            label.scaleByDistance = Property.getValueOrUndefined(labelGraphics._scaleByDistance, time, scaleByDistanceScratch);
            label.distanceDisplayCondition = Property.getValueOrUndefined(labelGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);
            label.disableDepthTestDistance = Property.getValueOrUndefined(labelGraphics._disableDepthTestDistance, time);

            if (updateClamping) {
                label._updateClamping();
            }
        }
        return true;
    };

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    LabelVisualizer.prototype.getBoundingSphere = function(entity, result) {
        

        var item = this._items.get(entity.id);
        if (!defined(item) || !defined(item.label)) {
            return BoundingSphereState.FAILED;
        }

        var label = item.label;
        result.center = Cartesian3.clone(defaultValue(label._clampedPosition, label.position), result.center);
        result.radius = 0;
        return BoundingSphereState.DONE;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    LabelVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    LabelVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);
        var entities = this._entityCollection.values;
        for (var i = 0; i < entities.length; i++) {
            this._cluster.removeLabel(entities[i]);
        }
        return destroyObject(this);
    };

    LabelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {
        var i;
        var entity;
        var items = this._items;
        var cluster = this._cluster;

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            if (defined(entity._label) && defined(entity._position)) {
                items.set(entity.id, new EntityData(entity));
            }
        }

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            if (defined(entity._label) && defined(entity._position)) {
                if (!items.contains(entity.id)) {
                    items.set(entity.id, new EntityData(entity));
                }
            } else {
                returnPrimitive(items.get(entity.id), entity, cluster);
                items.remove(entity.id);
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            returnPrimitive(items.get(entity.id), entity, cluster);
            items.remove(entity.id);
        }
    };

    function returnPrimitive(item, entity, cluster) {
        if (defined(item)) {
            item.label = undefined;
            cluster.removeLabel(entity);
        }
    }

    return LabelVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Scene/Material */ "./node_modules/terriajs-cesium/Source/Scene/Material.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Color,
        defined,
        defineProperties,
        DeveloperError,
        Material) {
    'use strict';

    /**
     * The interface for all {@link Property} objects that represent {@link Material} uniforms.
     * This type defines an interface and cannot be instantiated directly.
     *
     * @alias MaterialProperty
     * @constructor
     *
     * @see ColorMaterialProperty
     * @see CompositeMaterialProperty
     * @see GridMaterialProperty
     * @see ImageMaterialProperty
     * @see PolylineGlowMaterialProperty
     * @see PolylineOutlineMaterialProperty
     * @see StripeMaterialProperty
     */
    function MaterialProperty() {
        DeveloperError.throwInstantiationError();
    }

    defineProperties(MaterialProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.  A property is considered
         * constant if getValue always returns the same result for the current definition.
         * @memberof MaterialProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : DeveloperError.throwInstantiationError
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * The definition is considered to have changed if a call to getValue would return
         * a different result for the same time.
         * @memberof MaterialProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : DeveloperError.throwInstantiationError
        }
    });

    /**
     * Gets the {@link Material} type at the provided time.
     * @function
     *
     * @param {JulianDate} time The time for which to retrieve the type.
     * @returns {String} The type of material.
     */
    MaterialProperty.prototype.getType = DeveloperError.throwInstantiationError;

    /**
     * Gets the value of the property at the provided time.
     * @function
     *
     * @param {JulianDate} time The time for which to retrieve the value.
     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
     */
    MaterialProperty.prototype.getValue = DeveloperError.throwInstantiationError;

    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @function
     *
     * @param {Property} [other] The other property.
     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    MaterialProperty.prototype.equals = DeveloperError.throwInstantiationError;

    /**
     * @private
     */
    MaterialProperty.getValue = function(time, materialProperty, material) {
        var type;

        if (defined(materialProperty)) {
            type = materialProperty.getType(time);
            if (defined(type)) {
                if (!defined(material) || (material.type !== type)) {
                    material = Material.fromType(type);
                }
                materialProperty.getValue(time, material.uniforms);
                return material;
            }
        }

        if (!defined(material) || (material.type !== Material.ColorType)) {
            material = Material.fromType(Material.ColorType);
        }
        Color.clone(Color.WHITE, material.uniforms.color);

        return material;
    };

    return MaterialProperty;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ../Core/Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/Matrix4 */ "./node_modules/terriajs-cesium/Source/Core/Matrix4.js"),
        __webpack_require__(/*! ../Core/Resource */ "./node_modules/terriajs-cesium/Source/Core/Resource.js"),
        __webpack_require__(/*! ../Scene/Axis */ "./node_modules/terriajs-cesium/Source/Scene/Axis.js"),
        __webpack_require__(/*! ../Scene/ColorBlendMode */ "./node_modules/terriajs-cesium/Source/Scene/ColorBlendMode.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/Model */ "./node_modules/terriajs-cesium/Source/Scene/Model.js"),
        __webpack_require__(/*! ../Scene/ModelAnimationLoop */ "./node_modules/terriajs-cesium/Source/Scene/ModelAnimationLoop.js"),
        __webpack_require__(/*! ../Scene/ShadowMode */ "./node_modules/terriajs-cesium/Source/Scene/ShadowMode.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        BoundingSphere,
        Cartesian2,
        Color,
        defined,
        destroyObject,
        DeveloperError,
        Matrix4,
        Resource,
        Axis,
        ColorBlendMode,
        HeightReference,
        Model,
        ModelAnimationLoop,
        ShadowMode,
        BoundingSphereState,
        Property) {
    'use strict';

    var defaultScale = 1.0;
    var defaultMinimumPixelSize = 0.0;
    var defaultIncrementallyLoadTextures = true;
    var defaultClampAnimations = true;
    var defaultShadows = ShadowMode.ENABLED;
    var defaultHeightReference = HeightReference.NONE;
    var defaultSilhouetteColor = Color.RED;
    var defaultSilhouetteSize = 0.0;
    var defaultColor = Color.WHITE;
    var defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;
    var defaultColorBlendAmount = 0.5;
    var defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);
    var defaultUpAxis = Axis.Y;

    var modelMatrixScratch = new Matrix4();
    var nodeMatrixScratch = new Matrix4();

    /**
     * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.
     * @alias ModelVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     */
    function ModelVisualizer(scene, entityCollection) {
        

        entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);

        this._scene = scene;
        this._primitives = scene.primitives;
        this._entityCollection = entityCollection;
        this._modelHash = {};
        this._entitiesToVisualize = new AssociativeArray();
        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
    }

    /**
     * Updates models created this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} This function always returns true.
     */
    ModelVisualizer.prototype.update = function(time) {
        

        var entities = this._entitiesToVisualize.values;
        var modelHash = this._modelHash;
        var primitives = this._primitives;

        for (var i = 0, len = entities.length; i < len; i++) {
            var entity = entities[i];
            var modelGraphics = entity._model;

            var resource;
            var modelData = modelHash[entity.id];
            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);

            var modelMatrix;
            if (show) {
                modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);
                resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));
                show = defined(modelMatrix) && defined(resource);
            }

            if (!show) {
                if (defined(modelData)) {
                    modelData.modelPrimitive.show = false;
                }
                continue;
            }

            var model = defined(modelData) ? modelData.modelPrimitive : undefined;
            if (!defined(model) || resource.url !== modelData.url) {
                if (defined(model)) {
                    primitives.removeAndDestroy(model);
                    delete modelHash[entity.id];
                }
                model = Model.fromGltf({
                    url : resource,
                    incrementallyLoadTextures : Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures),
                    scene : this._scene
                });
                model.id = entity;
                primitives.add(model);

                modelData = {
                    modelPrimitive : model,
                    url : resource.url,
                    animationsRunning : false,
                    nodeTransformationsScratch : {},
                    articulationsScratch : {},
                    loadFail : false
                };
                modelHash[entity.id] = modelData;

                checkModelLoad(model, entity, modelHash);
            }

            model.show = true;
            model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);
            model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);
            model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);
            model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);
            model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);
            model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);
            model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);
            model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, model._silhouetteColor);
            model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);
            model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, model._color);
            model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);
            model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);
            model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);
            model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);
            model.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);
            model.lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);
            model._upAxis = Property.getValueOrDefault(modelGraphics._upAxis, time, defaultUpAxis);
            model._forwardAxis = Property.getValueOrUndefined(modelGraphics._forwardAxis, time);

            if (model.ready) {
                var runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);
                if (modelData.animationsRunning !== runAnimations) {
                    if (runAnimations) {
                        model.activeAnimations.addAll({
                            loop : ModelAnimationLoop.REPEAT
                        });
                    } else {
                        model.activeAnimations.removeAll();
                    }
                    modelData.animationsRunning = runAnimations;
                }

                // Apply node transformations
                var nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);
                if (defined(nodeTransformations)) {
                    var nodeNames = Object.keys(nodeTransformations);
                    for (var nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {
                        var nodeName = nodeNames[nodeIndex];

                        var nodeTransformation = nodeTransformations[nodeName];
                        if (!defined(nodeTransformation)) {
                            continue;
                        }

                        var modelNode = model.getNode(nodeName);
                        if (!defined(modelNode)) {
                            continue;
                        }

                        var transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);
                        modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);
                    }
                }

                // Apply articulations
                var anyArticulationUpdated = false;
                var articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);
                if (defined(articulations)) {
                    var articulationStageKeys = Object.keys(articulations);
                    for (var s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {
                        var key = articulationStageKeys[s];

                        var articulationStageValue = articulations[key];
                        if (!defined(articulationStageValue)) {
                            continue;
                        }

                        anyArticulationUpdated = true;
                        model.setArticulationStage(key, articulationStageValue);
                    }
                }

                if (anyArticulationUpdated) {
                    model.applyArticulations();
                }
            }
        }

        return true;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    ModelVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    ModelVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);
        var entities = this._entitiesToVisualize.values;
        var modelHash = this._modelHash;
        var primitives = this._primitives;
        for (var i = entities.length - 1; i > -1; i--) {
            removeModel(this, entities[i], modelHash, primitives);
        }
        return destroyObject(this);
    };

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    ModelVisualizer.prototype.getBoundingSphere = function(entity, result) {
        

        var modelData = this._modelHash[entity.id];
        if (!defined(modelData) || modelData.loadFail) {
            return BoundingSphereState.FAILED;
        }

        var model = modelData.modelPrimitive;
        if (!defined(model) || !model.show) {
            return BoundingSphereState.FAILED;
        }

        if (!model.ready) {
            return BoundingSphereState.PENDING;
        }

        if (model.heightReference === HeightReference.NONE) {
            BoundingSphere.transform(model.boundingSphere, model.modelMatrix, result);
        } else {
            if (!defined(model._clampedModelMatrix) || model._heightChanged) {
                return BoundingSphereState.PENDING;
            }
            BoundingSphere.transform(model.boundingSphere, model._clampedModelMatrix, result);
        }
        return BoundingSphereState.DONE;
    };

    /**
     * @private
     */
    ModelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {
        var i;
        var entity;
        var entities = this._entitiesToVisualize;
        var modelHash = this._modelHash;
        var primitives = this._primitives;

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            if (defined(entity._model) && defined(entity._position)) {
                entities.set(entity.id, entity);
            }
        }

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            if (defined(entity._model) && defined(entity._position)) {
                clearNodeTransformationsArticulationsScratch(entity, modelHash);
                entities.set(entity.id, entity);
            } else {
                removeModel(this, entity, modelHash, primitives);
                entities.remove(entity.id);
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            removeModel(this, entity, modelHash, primitives);
            entities.remove(entity.id);
        }
    };

    function removeModel(visualizer, entity, modelHash, primitives) {
        var modelData = modelHash[entity.id];
        if (defined(modelData)) {
            primitives.removeAndDestroy(modelData.modelPrimitive);
            delete modelHash[entity.id];
        }
    }

    function clearNodeTransformationsArticulationsScratch(entity, modelHash) {
        var modelData = modelHash[entity.id];
        if (defined(modelData)) {
            modelData.nodeTransformationsScratch = {};
            modelData.articulationsScratch = {};
        }
    }

    function checkModelLoad(model, entity, modelHash){
        model.readyPromise.otherwise(function(error){
            console.error(error);
            modelHash[entity.id].loadFail = true;
        });
    }

    return ModelVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/JulianDate */ "./node_modules/terriajs-cesium/Source/Core/JulianDate.js"),
        __webpack_require__(/*! ../Core/Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ../Core/Matrix4 */ "./node_modules/terriajs-cesium/Source/Core/Matrix4.js"),
        __webpack_require__(/*! ../Core/ReferenceFrame */ "./node_modules/terriajs-cesium/Source/Core/ReferenceFrame.js"),
        __webpack_require__(/*! ../Core/TimeInterval */ "./node_modules/terriajs-cesium/Source/Core/TimeInterval.js"),
        __webpack_require__(/*! ../Core/Transforms */ "./node_modules/terriajs-cesium/Source/Core/Transforms.js"),
        __webpack_require__(/*! ../Scene/PolylineCollection */ "./node_modules/terriajs-cesium/Source/Scene/PolylineCollection.js"),
        __webpack_require__(/*! ../Scene/SceneMode */ "./node_modules/terriajs-cesium/Source/Scene/SceneMode.js"),
        __webpack_require__(/*! ./CompositePositionProperty */ "./node_modules/terriajs-cesium/Source/DataSources/CompositePositionProperty.js"),
        __webpack_require__(/*! ./ConstantPositionProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ConstantPositionProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js"),
        __webpack_require__(/*! ./ReferenceProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ReferenceProperty.js"),
        __webpack_require__(/*! ./SampledPositionProperty */ "./node_modules/terriajs-cesium/Source/DataSources/SampledPositionProperty.js"),
        __webpack_require__(/*! ./ScaledPositionProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ScaledPositionProperty.js"),
        __webpack_require__(/*! ./TimeIntervalCollectionPositionProperty */ "./node_modules/terriajs-cesium/Source/DataSources/TimeIntervalCollectionPositionProperty.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Cartesian3,
        defined,
        destroyObject,
        DeveloperError,
        JulianDate,
        Matrix3,
        Matrix4,
        ReferenceFrame,
        TimeInterval,
        Transforms,
        PolylineCollection,
        SceneMode,
        CompositePositionProperty,
        ConstantPositionProperty,
        MaterialProperty,
        Property,
        ReferenceProperty,
        SampledPositionProperty,
        ScaledPositionProperty,
        TimeIntervalCollectionPositionProperty) {
    'use strict';

    var defaultResolution = 60.0;
    var defaultWidth = 1.0;

    var scratchTimeInterval = new TimeInterval();
    var subSampleCompositePropertyScratch = new TimeInterval();
    var subSampleIntervalPropertyScratch = new TimeInterval();

    function EntityData(entity) {
        this.entity = entity;
        this.polyline = undefined;
        this.index = undefined;
        this.updater = undefined;
    }

    function subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {
        var r = startingIndex;
        //Always step exactly on start (but only use it if it exists.)
        var tmp;
        tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);
        if (defined(tmp)) {
            result[r++] = tmp;
        }

        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);

        //Iterate over all interval times and add the ones that fall in our
        //time range.  Note that times can contain data outside of
        //the intervals range.  This is by design for use with interpolation.
        var t = 0;
        var len = times.length;
        var current = times[t];
        var loopStop = stop;
        var sampling = false;
        var sampleStepsToTake;
        var sampleStepsTaken;
        var sampleStepSize;

        while (t < len) {
            if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {
                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);
                if (defined(tmp)) {
                    result[r++] = tmp;
                }
                steppedOnNow = true;
            }
            if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {
                tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);
                if (defined(tmp)) {
                    result[r++] = tmp;
                }
            }

            if (t < (len - 1)) {
                if (maximumStep > 0 && !sampling) {
                    var next = times[t + 1];
                    var secondsUntilNext = JulianDate.secondsDifference(next, current);
                    sampling = secondsUntilNext > maximumStep;

                    if (sampling) {
                        sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);
                        sampleStepsTaken = 0;
                        sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);
                        sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);
                    }
                }

                if (sampling && sampleStepsTaken < sampleStepsToTake) {
                    current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());
                    sampleStepsTaken++;
                    continue;
                }
            }
            sampling = false;
            t++;
            current = times[t];
        }

        //Always step exactly on stop (but only use it if it exists.)
        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);
        if (defined(tmp)) {
            result[r++] = tmp;
        }

        return r;
    }

    function subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
        var tmp;
        var i = 0;
        var index = startingIndex;
        var time = start;
        var stepSize = Math.max(maximumStep, 60);
        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);
        while (JulianDate.lessThan(time, stop)) {
            if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {
                steppedOnNow = true;
                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);
                if (defined(tmp)) {
                    result[index] = tmp;
                    index++;
                }
            }
            tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);
            if (defined(tmp)) {
                result[index] = tmp;
                index++;
            }
            i++;
            time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());
        }
        //Always sample stop.
        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);
        if (defined(tmp)) {
            result[index] = tmp;
            index++;
        }
        return index;
    }

    function subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
        subSampleIntervalPropertyScratch.start = start;
        subSampleIntervalPropertyScratch.stop = stop;

        var index = startingIndex;
        var intervals = property.intervals;
        for (var i = 0; i < intervals.length; i++) {
            var interval = intervals.get(i);
            if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {
                var time = interval.start;
                if (!interval.isStartIncluded) {
                    if (interval.isStopIncluded) {
                        time = interval.stop;
                    } else {
                        time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());
                    }
                }
                var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);
                if (defined(tmp)) {
                    result[index] = tmp;
                    index++;
                }
            }
        }
        return index;
    }

    function subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
        var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);
        if (defined(tmp)) {
            result[startingIndex++] = tmp;
        }
        return startingIndex;
    }

    function subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {
        subSampleCompositePropertyScratch.start = start;
        subSampleCompositePropertyScratch.stop = stop;

        var index = startingIndex;
        var intervals = property.intervals;
        for (var i = 0; i < intervals.length; i++) {
            var interval = intervals.get(i);
            if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {
                var intervalStart = interval.start;
                var intervalStop = interval.stop;

                var sampleStart = start;
                if (JulianDate.greaterThan(intervalStart, sampleStart)) {
                    sampleStart = intervalStart;
                }

                var sampleStop = stop;
                if (JulianDate.lessThan(intervalStop, sampleStop)) {
                    sampleStop = intervalStop;
                }

                index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);
            }
        }
        return index;
    }

    function reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {
        //Unwrap any references until we have the actual property.
        while (property instanceof ReferenceProperty) {
            property = property.resolvedProperty;
        }

        if (property instanceof SampledPositionProperty) {
            var times = property._property._times;
            index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);
        } else if (property instanceof CompositePositionProperty) {
            index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);
        } else if (property instanceof TimeIntervalCollectionPositionProperty) {
            index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);
        } else if (property instanceof ConstantPositionProperty ||
                   (property instanceof ScaledPositionProperty && Property.isConstant(property))) {
            index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);
        } else {
            //Fallback to generic sampling.
            index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);
        }
        return index;
    }

    function subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {
        if (!defined(result)) {
            result = [];
        }

        var length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);
        result.length = length;
        return result;
    }

    var toFixedScratch = new Matrix3();
    function PolylineUpdater(scene, referenceFrame) {
        this._unusedIndexes = [];
        this._polylineCollection = new PolylineCollection();
        this._scene = scene;
        this._referenceFrame = referenceFrame;
        scene.primitives.add(this._polylineCollection);
    }

    PolylineUpdater.prototype.update = function(time) {
        if (this._referenceFrame === ReferenceFrame.INERTIAL) {
            var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);
            if (!defined(toFixed)) {
                toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);
            }
            Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);
        }
    };

    PolylineUpdater.prototype.updateObject = function(time, item) {
        var entity = item.entity;
        var pathGraphics = entity._path;
        var positionProperty = entity._position;

        var sampleStart;
        var sampleStop;
        var showProperty = pathGraphics._show;
        var polyline = item.polyline;
        var show = entity.isShowing && (!defined(showProperty) || showProperty.getValue(time));

        //While we want to show the path, there may not actually be anything to show
        //depending on lead/trail settings.  Compute the interval of the path to
        //show and check against actual availability.
        if (show) {
            var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);
            var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);
            var availability = entity._availability;
            var hasAvailability = defined(availability);
            var hasLeadTime = defined(leadTime);
            var hasTrailTime = defined(trailTime);

            //Objects need to have either defined availability or both a lead and trail time in order to
            //draw a path (since we can't draw "infinite" paths.
            show = hasAvailability || (hasLeadTime && hasTrailTime);

            //The final step is to compute the actual start/stop times of the path to show.
            //If current time is outside of the availability interval, there's a chance that
            //we won't have to draw anything anyway.
            if (show) {
                if (hasTrailTime) {
                    sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());
                }
                if (hasLeadTime) {
                    sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());
                }

                if (hasAvailability) {
                    var start = availability.start;
                    var stop = availability.stop;

                    if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {
                        sampleStart = start;
                    }

                    if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {
                        sampleStop = stop;
                    }
                }
                show = JulianDate.lessThan(sampleStart, sampleStop);
            }
        }

        if (!show) {
            //don't bother creating or updating anything else
            if (defined(polyline)) {
                this._unusedIndexes.push(item.index);
                item.polyline = undefined;
                polyline.show = false;
                item.index = undefined;
            }
            return;
        }

        if (!defined(polyline)) {
            var unusedIndexes = this._unusedIndexes;
            var length = unusedIndexes.length;
            if (length > 0) {
                var index = unusedIndexes.pop();
                polyline = this._polylineCollection.get(index);
                item.index = index;
            } else {
                item.index = this._polylineCollection.length;
                polyline = this._polylineCollection.add();
            }
            polyline.id = entity;
            item.polyline = polyline;
        }

        var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);

        polyline.show = true;
        polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());
        polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);
        polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);
        polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);
    };

    PolylineUpdater.prototype.removeObject = function(item) {
        var polyline = item.polyline;
        if (defined(polyline)) {
            this._unusedIndexes.push(item.index);
            item.polyline = undefined;
            polyline.show = false;
            polyline.id = undefined;
            item.index = undefined;
        }
    };

    PolylineUpdater.prototype.destroy = function() {
        this._scene.primitives.remove(this._polylineCollection);
        return destroyObject(this);
    };

    /**
     * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.
     * @alias PathVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     */
    function PathVisualizer(scene, entityCollection) {
        

        entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);

        this._scene = scene;
        this._updaters = {};
        this._entityCollection = entityCollection;
        this._items = new AssociativeArray();

        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
    }

    /**
     * Updates all of the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} This function always returns true.
     */
    PathVisualizer.prototype.update = function(time) {
        

        var updaters = this._updaters;
        for ( var key in updaters) {
            if (updaters.hasOwnProperty(key)) {
                updaters[key].update(time);
            }
        }

        var items = this._items.values;
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var entity = item.entity;
            var positionProperty = entity._position;

            var lastUpdater = item.updater;

            var frameToVisualize = ReferenceFrame.FIXED;
            if (this._scene.mode === SceneMode.SCENE3D) {
                frameToVisualize = positionProperty.referenceFrame;
            }

            var currentUpdater = this._updaters[frameToVisualize];

            if ((lastUpdater === currentUpdater) && (defined(currentUpdater))) {
                currentUpdater.updateObject(time, item);
                continue;
            }

            if (defined(lastUpdater)) {
                lastUpdater.removeObject(item);
            }

            if (!defined(currentUpdater)) {
                currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);
                currentUpdater.update(time);
                this._updaters[frameToVisualize] = currentUpdater;
            }

            item.updater = currentUpdater;
            if (defined(currentUpdater)) {
                currentUpdater.updateObject(time, item);
            }
        }
        return true;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    PathVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    PathVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);

        var updaters = this._updaters;
        for ( var key in updaters) {
            if (updaters.hasOwnProperty(key)) {
                updaters[key].destroy();
            }
        }

        return destroyObject(this);
    };

    PathVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {
        var i;
        var entity;
        var item;
        var items = this._items;

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            if (defined(entity._path) && defined(entity._position)) {
                items.set(entity.id, new EntityData(entity));
            }
        }

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            if (defined(entity._path) && defined(entity._position)) {
                if (!items.contains(entity.id)) {
                    items.set(entity.id, new EntityData(entity));
                }
            } else {
                item = items.get(entity.id);
                if (defined(item)) {
                    if (defined(item.updater)) {
                        item.updater.removeObject(item);
                    }
                    items.remove(entity.id);
                }
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            item = items.get(entity.id);
            if (defined(item)) {
                if (defined(item.updater)) {
                    item.updater.removeObject(item);
                }
                items.remove(entity.id);
            }
        }
    };

    //for testing
    PathVisualizer._subSample = subSample;

    return PathVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
        __webpack_require__(/*! ../Core/Matrix3 */ "./node_modules/terriajs-cesium/Source/Core/Matrix3.js"),
        __webpack_require__(/*! ../Core/Matrix4 */ "./node_modules/terriajs-cesium/Source/Core/Matrix4.js"),
        __webpack_require__(/*! ../Core/PlaneGeometry */ "./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js"),
        __webpack_require__(/*! ../Core/PlaneOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/Quaternion */ "./node_modules/terriajs-cesium/Source/Core/Quaternion.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Cartesian2,
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        GeometryInstance,
        Iso8601,
        CesiumMath,
        Matrix3,
        Matrix4,
        PlaneGeometry,
        PlaneOutlineGeometry,
        Quaternion,
        ShowGeometryInstanceAttribute,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        Property) {
    'use strict';

    var positionScratch = new Cartesian3();
    var scratchColor = new Color();

    function PlaneGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.plane = undefined;
        this.dimensions = undefined;
    }

    /**
     * A {@link GeometryUpdater} for planes.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias PlaneGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function PlaneGeometryUpdater(entity, scene) {
        GeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new PlaneGeometryOptions(entity),
            geometryPropertyName : 'plane',
            observedPropertyNames : ['availability', 'position', 'orientation', 'plane']
        });

        this._onEntityPropertyChanged(entity, 'plane', entity.plane, undefined);
    }

    if (defined(Object.create)) {
        PlaneGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        PlaneGeometryUpdater.prototype.constructor = PlaneGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    PlaneGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var attributes;

        var color;
        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);
        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            color = ColorGeometryInstanceAttribute.fromColor(currentColor);
            attributes = {
                show : show,
                distanceDisplayCondition : distanceDisplayConditionAttribute,
                color : color
            };
        } else {
            attributes = {
                show : show,
                distanceDisplayCondition : distanceDisplayConditionAttribute
            };
        }

        var planeGraphics = entity.plane;
        var options = this._options;
        var modelMatrix = entity.computeModelMatrix(time);
        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);
        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);

        options.plane = plane;
        options.dimensions = dimensions;

        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);

        return new GeometryInstance({
            id : entity,
            geometry : new PlaneGeometry(this._options),
            modelMatrix : modelMatrix,
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    PlaneGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var planeGraphics = entity.plane;
        var options = this._options;
        var modelMatrix = entity.computeModelMatrix(time);
        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);
        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);

        options.plane = plane;
        options.dimensions = dimensions;

        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);

        return new GeometryInstance({
            id : entity,
            geometry : new PlaneOutlineGeometry(),
            modelMatrix : modelMatrix,
            attributes : {
                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
            }
        });
    };

    PlaneGeometryUpdater.prototype._isHidden = function(entity, plane) {
        return !defined(plane.plane) || !defined(plane.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, plane);
    };

    PlaneGeometryUpdater.prototype._getIsClosed = function(options) {
        return false;
    };

    PlaneGeometryUpdater.prototype._isDynamic = function(entity, plane) {
        return !entity.position.isConstant || //
               !Property.isConstant(entity.orientation) || //
               !plane.plane.isConstant || //
               !plane.dimensions.isConstant || //
               !Property.isConstant(plane.outlineWidth);
    };

    PlaneGeometryUpdater.prototype._setStaticOptions = function(entity, plane) {
        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;

        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.plane = plane.plane.getValue(Iso8601.MINIMUM_VALUE, options.plane);
        options.dimensions = plane.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);
    };

    PlaneGeometryUpdater.DynamicGeometryUpdater = DynamicPlaneGeometryUpdater;

    /**
     * @private
     */
    function DynamicPlaneGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicPlaneGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicPlaneGeometryUpdater.prototype.constructor = DynamicPlaneGeometryUpdater;
    }

    DynamicPlaneGeometryUpdater.prototype._isHidden = function(entity, plane, time) {
        var options = this._options;
        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);
        return !defined(position) || !defined(options.plane) || !defined(options.dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, plane, time);
    };

    DynamicPlaneGeometryUpdater.prototype._setOptions = function(entity, plane, time) {
        var options = this._options;
        options.plane = Property.getValueOrDefault(plane.plane, time, options.plane);
        options.dimensions = Property.getValueOrUndefined(plane.dimensions, time, options.dimensions);
    };

    var scratchAxis = new Cartesian3();
    var scratchAxis2 = new Cartesian3();
    var scratchTranslation = new Cartesian3();
    var scratchNormal = new Cartesian3();
    var scratchScale = new Cartesian3();
    var scratchQuaternion = new Quaternion();
    var scratchMatrix3 = new Matrix3();
    function createPrimitiveMatrix(plane, dimensions, transform, ellipsoid, result) {
        var normal = plane.normal;
        var distance = plane.distance;

        var translation = Cartesian3.multiplyByScalar(normal, -distance, scratchTranslation);
        translation = Matrix4.multiplyByPoint(transform, translation, translation);

        var transformedNormal = Matrix4.multiplyByPointAsVector(transform, normal, scratchNormal);
        Cartesian3.normalize(transformedNormal, transformedNormal);

        var up = ellipsoid.geodeticSurfaceNormal(translation, scratchAxis2);
        if (CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(up, transformedNormal)), 1.0, CesiumMath.EPSILON8)) {
            up = Cartesian3.clone(Cartesian3.UNIT_Z, up);
        }

        var left = Cartesian3.cross(up, transformedNormal, scratchAxis);
        up = Cartesian3.cross(transformedNormal, left, up);
        Cartesian3.normalize(left, left);
        Cartesian3.normalize(up, up);

        var rotationMatrix = scratchMatrix3;
        Matrix3.setColumn(rotationMatrix, 0, left, rotationMatrix);
        Matrix3.setColumn(rotationMatrix, 1, up, rotationMatrix);
        Matrix3.setColumn(rotationMatrix, 2, transformedNormal, rotationMatrix);
        var rotation = Quaternion.fromRotationMatrix(rotationMatrix, scratchQuaternion);

        var scale = Cartesian2.clone(dimensions, scratchScale);
        scale.z = 1.0;

        return Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, result);
    }

    /**
     * @private
     */
    PlaneGeometryUpdater.createPrimitiveMatrix = createPrimitiveMatrix;

    return PlaneGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/NearFarScalar */ "./node_modules/terriajs-cesium/Source/Core/NearFarScalar.js"),
        __webpack_require__(/*! ../Scene/createBillboardPointCallback */ "./node_modules/terriajs-cesium/Source/Scene/createBillboardPointCallback.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Cartesian3,
        Color,
        defined,
        destroyObject,
        DeveloperError,
        DistanceDisplayCondition,
        NearFarScalar,
        createBillboardPointCallback,
        HeightReference,
        BoundingSphereState,
        Property) {
    'use strict';

    var defaultColor = Color.WHITE;
    var defaultOutlineColor = Color.BLACK;
    var defaultOutlineWidth = 0.0;
    var defaultPixelSize = 1.0;
    var defaultDisableDepthTestDistance = 0.0;

    var colorScratch = new Color();
    var positionScratch = new Cartesian3();
    var outlineColorScratch = new Color();
    var scaleByDistanceScratch = new NearFarScalar();
    var translucencyByDistanceScratch = new NearFarScalar();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();

    function EntityData(entity) {
        this.entity = entity;
        this.pointPrimitive = undefined;
        this.billboard = undefined;
        this.color = undefined;
        this.outlineColor = undefined;
        this.pixelSize = undefined;
        this.outlineWidth = undefined;
    }

    /**
     * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.
     * @alias PointVisualizer
     * @constructor
     *
     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     */
    function PointVisualizer(entityCluster, entityCollection) {
        

        entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);

        this._cluster = entityCluster;
        this._entityCollection = entityCollection;
        this._items = new AssociativeArray();
        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
    }

    /**
     * Updates the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} This function always returns true.
     */
    PointVisualizer.prototype.update = function(time) {
        

        var items = this._items.values;
        var cluster = this._cluster;
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var entity = item.entity;
            var pointGraphics = entity._point;
            var pointPrimitive = item.pointPrimitive;
            var billboard = item.billboard;
            var heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);
            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);
            var position;
            if (show) {
                position = Property.getValueOrUndefined(entity._position, time, positionScratch);
                show = defined(position);
            }
            if (!show) {
                returnPrimitive(item, entity, cluster);
                continue;
            }

            if (!Property.isConstant(entity._position)) {
                cluster._clusterDirty = true;
            }

            var needsRedraw = false;
            var updateClamping = false;
            if ((heightReference !== HeightReference.NONE) && !defined(billboard)) {
                if (defined(pointPrimitive)) {
                    returnPrimitive(item, entity, cluster);
                    pointPrimitive = undefined;
                }

                billboard = cluster.getBillboard(entity);
                billboard.id = entity;
                billboard.image = undefined;
                item.billboard = billboard;
                needsRedraw = true;

                // If this new billboard happens to have a position and height reference that match our new values,
                // billboard._updateClamping will not be called automatically. That's a problem because the clamped
                // height may be based on different terrain than is now loaded. So we'll manually call
                // _updateClamping below.
                updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;
            } else if ((heightReference === HeightReference.NONE) && !defined(pointPrimitive)) {
                if (defined(billboard)) {
                    returnPrimitive(item, entity, cluster);
                    billboard = undefined;
                }

                pointPrimitive = cluster.getPoint(entity);
                pointPrimitive.id = entity;
                item.pointPrimitive = pointPrimitive;
            }

            if (defined(pointPrimitive)) {
                pointPrimitive.show = true;
                pointPrimitive.position = position;
                pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);
                pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);
                pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);
                pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);
                pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);
                pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);
                pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);
                pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);
            } else if (defined(billboard)) {
                billboard.show = true;
                billboard.position = position;
                billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);
                billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);
                billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);
                billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);
                billboard.heightReference = heightReference;

                var newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);
                var newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);
                var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));
                var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));

                if (newOutlineWidth > 0) {
                    billboard.scale = 1.0;
                    needsRedraw = needsRedraw || //
                                 newOutlineWidth !== item.outlineWidth || //
                                 newPixelSize !== item.pixelSize || //
                                 !Color.equals(newColor, item.color) || //
                                 !Color.equals(newOutlineColor, item.outlineColor);
                } else {
                    billboard.scale = newPixelSize / 50.0;
                    newPixelSize = 50.0;
                    needsRedraw = needsRedraw || //
                                 newOutlineWidth !== item.outlineWidth || //
                                 !Color.equals(newColor, item.color) || //
                                 !Color.equals(newOutlineColor, item.outlineColor);
                }

                if (needsRedraw) {
                    item.color = Color.clone(newColor, item.color);
                    item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);
                    item.pixelSize = newPixelSize;
                    item.outlineWidth = newOutlineWidth;

                    var centerAlpha = newColor.alpha;
                    var cssColor = newColor.toCssColorString();
                    var cssOutlineColor = newOutlineColor.toCssColorString();
                    var textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);

                    billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));
                }

                if (updateClamping) {
                    billboard._updateClamping();
                }
            }
        }
        return true;
    };

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    PointVisualizer.prototype.getBoundingSphere = function(entity, result) {
        

        var item = this._items.get(entity.id);
        if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {
            return BoundingSphereState.FAILED;
        }

        if (defined(item.pointPrimitive)) {
            result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);
        } else {
            var billboard = item.billboard;
            if (!defined(billboard._clampedPosition)) {
                return BoundingSphereState.PENDING;
            }
            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);
        }

        result.radius = 0;
        return BoundingSphereState.DONE;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    PointVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    PointVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);
        var entities = this._entityCollection.values;
        for (var i = 0; i < entities.length; i++) {
            this._cluster.removePoint(entities[i]);
        }
        return destroyObject(this);
    };

    PointVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {
        var i;
        var entity;
        var items = this._items;
        var cluster = this._cluster;

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            if (defined(entity._point) && defined(entity._position)) {
                items.set(entity.id, new EntityData(entity));
            }
        }

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            if (defined(entity._point) && defined(entity._position)) {
                if (!items.contains(entity.id)) {
                    items.set(entity.id, new EntityData(entity));
                }
            } else {
                returnPrimitive(items.get(entity.id), entity, cluster);
                items.remove(entity.id);
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            returnPrimitive(items.get(entity.id), entity, cluster);
            items.remove(entity.id);
        }
    };

    function returnPrimitive(item, entity, cluster) {
        if (defined(item)) {
            var pointPrimitive = item.pointPrimitive;
            if (defined(pointPrimitive)) {
                item.pointPrimitive = undefined;
                cluster.removePoint(entity);
                return;
            }
            var billboard = item.billboard;
            if (defined(billboard)) {
                item.billboard = undefined;
                cluster.removeBillboard(entity);
            }
        }
    }

    return PointVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ApproximateTerrainHeights */ "./node_modules/terriajs-cesium/Source/Core/ApproximateTerrainHeights.js"),
        __webpack_require__(/*! ../Core/ArcType */ "./node_modules/terriajs-cesium/Source/Core/ArcType.js"),
        __webpack_require__(/*! ../Core/Cartesian2 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian2.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/CoplanarPolygonGeometry */ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js"),
        __webpack_require__(/*! ../Core/CoplanarPolygonOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/EllipsoidTangentPlane */ "./node_modules/terriajs-cesium/Source/Core/EllipsoidTangentPlane.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/oneTimeWarning */ "./node_modules/terriajs-cesium/Source/Core/oneTimeWarning.js"),
        __webpack_require__(/*! ../Core/PolygonGeometry */ "./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js"),
        __webpack_require__(/*! ../Core/PolygonOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./GroundGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ApproximateTerrainHeights,
        ArcType,
        Cartesian2,
        Cartesian3,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        CoplanarPolygonGeometry,
        CoplanarPolygonOutlineGeometry,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        EllipsoidTangentPlane,
        GeometryInstance,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        oneTimeWarning,
        PolygonGeometry,
        PolygonOutlineGeometry,
        Rectangle,
        ShowGeometryInstanceAttribute,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        GroundGeometryUpdater,
        Property) {
    'use strict';

    var heightAndPerPositionHeightWarning = 'Entity polygons cannot have both height and perPositionHeight.  height will be ignored';
    var heightReferenceAndPerPositionHeightWarning = 'heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored';

    var scratchColor = new Color();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();
    var scratchRectangle = new Rectangle();
    var scratch2DPositions = [];
    var cart2Scratch = new Cartesian2();

    function PolygonGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.polygonHierarchy = undefined;
        this.perPositionHeight = undefined;
        this.closeTop = undefined;
        this.closeBottom = undefined;
        this.height = undefined;
        this.extrudedHeight = undefined;
        this.granularity = undefined;
        this.stRotation = undefined;
        this.offsetAttribute = undefined;
        this.arcType = undefined;
    }

    /**
     * A {@link GeometryUpdater} for polygons.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias PolygonGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function PolygonGeometryUpdater(entity, scene) {
        GroundGeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new PolygonGeometryOptions(entity),
            geometryPropertyName : 'polygon',
            observedPropertyNames : ['availability', 'polygon']
        });

        this._onEntityPropertyChanged(entity, 'polygon', entity.polygon, undefined);
    }

    if (defined(Object.create)) {
        PolygonGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);
        PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    PolygonGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var options = this._options;

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),
            offset : undefined,
            color : undefined
        };

        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }
        if (defined(options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        var geometry;
        if (options.perPositionHeight && !defined(options.extrudedHeight)) {
            geometry = new CoplanarPolygonGeometry(options);
        } else {
            geometry = new PolygonGeometry(options);
        }

        return new GeometryInstance({
            id : entity,
            geometry : geometry,
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    PolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var options = this._options;
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),
            offset : undefined
        };

        if (defined(options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        var geometry;
        if (options.perPositionHeight && !defined(options.extrudedHeight)) {
            geometry = new CoplanarPolygonOutlineGeometry(options);
        } else {
            geometry = new PolygonOutlineGeometry(options);
        }
        return new GeometryInstance({
            id : entity,
            geometry : geometry,
            attributes : attributes
        });
    };

    PolygonGeometryUpdater.prototype._computeCenter = function(time, result) {
        var hierarchy = Property.getValueOrUndefined(this._entity.polygon.hierarchy, time);
        if (!defined(hierarchy)) {
            return;
        }
        var positions = hierarchy.positions;
        if (positions.length === 0) {
            return;
        }
        var ellipsoid = this._scene.mapProjection.ellipsoid;

        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);
        var positions2D = tangentPlane.projectPointsOntoPlane(positions, scratch2DPositions);

        var length = positions2D.length;
        var area = 0;
        var j = length - 1;
        var centroid2D = new Cartesian2();
        for (var i = 0; i < length; j = i++) {
            var p1 = positions2D[i];
            var p2 = positions2D[j];
            var f = p1.x * p2.y - p2.x * p1.y;

            var sum = Cartesian2.add(p1, p2, cart2Scratch);
            sum = Cartesian2.multiplyByScalar(sum, f, sum);
            centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);

            area += f;
        }

        var a = 1.0 / (area * 3.0);
        centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);
        return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);
    };

    PolygonGeometryUpdater.prototype._isHidden = function(entity, polygon) {
        return !defined(polygon.hierarchy) || GeometryUpdater.prototype._isHidden.call(this, entity, polygon);
    };

    PolygonGeometryUpdater.prototype._isOnTerrain = function(entity, polygon) {
        var onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(this, entity, polygon);
        var perPositionHeightProperty = polygon.perPositionHeight;
        var perPositionHeightEnabled = defined(perPositionHeightProperty) && (perPositionHeightProperty.isConstant ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE) : true);
        return onTerrain && !perPositionHeightEnabled;
    };

    PolygonGeometryUpdater.prototype._isDynamic = function(entity, polygon) {
        return !polygon.hierarchy.isConstant || //
               !Property.isConstant(polygon.height) || //
               !Property.isConstant(polygon.extrudedHeight) || //
               !Property.isConstant(polygon.granularity) || //
               !Property.isConstant(polygon.stRotation) || //
               !Property.isConstant(polygon.outlineWidth) || //
               !Property.isConstant(polygon.perPositionHeight) || //
               !Property.isConstant(polygon.closeTop) || //
               !Property.isConstant(polygon.closeBottom) || //
               !Property.isConstant(polygon.zIndex) || //
               !Property.isConstant(polygon.arcType) || //
               (this._onTerrain && !Property.isConstant(this._materialProperty));
    };

    PolygonGeometryUpdater.prototype._setStaticOptions = function(entity, polygon) {
        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;

        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;

        var hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);
        var heightValue = Property.getValueOrUndefined(polygon.height, Iso8601.MINIMUM_VALUE);
        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, Iso8601.MINIMUM_VALUE);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var perPositionHeightValue = Property.getValueOrDefault(polygon.perPositionHeight, Iso8601.MINIMUM_VALUE, false);

        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        var offsetAttribute;
        if (perPositionHeightValue) {
            if (defined(heightValue)) {
                heightValue = undefined;
                oneTimeWarning(heightAndPerPositionHeightWarning);
            }
            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {
                heightValue = undefined;
                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);
            }
        } else {
            if (defined(extrudedHeightValue) && !defined(heightValue)) {
                heightValue = 0;
            }
            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        }

        options.polygonHierarchy = hierarchyValue;
        options.granularity = Property.getValueOrUndefined(polygon.granularity, Iso8601.MINIMUM_VALUE);
        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, Iso8601.MINIMUM_VALUE);
        options.perPositionHeight = perPositionHeightValue;
        options.closeTop = Property.getValueOrDefault(polygon.closeTop, Iso8601.MINIMUM_VALUE, true);
        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, Iso8601.MINIMUM_VALUE, true);
        options.offsetAttribute = offsetAttribute;
        options.height = heightValue;
        options.arcType = Property.getValueOrDefault(polygon.arcType, Iso8601.MINIMUM_VALUE, ArcType.GEODESIC);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    PolygonGeometryUpdater.prototype._getIsClosed = function(options) {
        var height = options.height;
        var extrudedHeight = options.extrudedHeight;
        var isExtruded = defined(extrudedHeight) && extrudedHeight !== height;
        return !options.perPositionHeight && (!isExtruded && height === 0 || (isExtruded && options.closeTop && options.closeBottom));
    };

    PolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;

    /**
     * @private
     */
    function DyanmicPolygonGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DyanmicPolygonGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DyanmicPolygonGeometryUpdater.prototype.constructor = DyanmicPolygonGeometryUpdater;
    }

    DyanmicPolygonGeometryUpdater.prototype._isHidden = function(entity, polygon, time) {
        return !defined(this._options.polygonHierarchy) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time);
    };

    DyanmicPolygonGeometryUpdater.prototype._setOptions = function(entity, polygon, time) {
        var options = this._options;

        options.polygonHierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);

        var heightValue = Property.getValueOrUndefined(polygon.height, time);
        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, time, HeightReference.NONE);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, time, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, time);
        var perPositionHeightValue = Property.getValueOrUndefined(polygon.perPositionHeight, time);

        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, extrudedHeightReferenceValue);

        var offsetAttribute;
        if (perPositionHeightValue) {
            if (defined(heightValue)) {
                heightValue = undefined;
                oneTimeWarning(heightAndPerPositionHeightWarning);
            }
            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {
                heightValue = undefined;
                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);
            }
        } else {
            if (defined(extrudedHeightValue) && !defined(heightValue)) {
                heightValue = 0;
            }

            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        }

        options.granularity = Property.getValueOrUndefined(polygon.granularity, time);
        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);
        options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);
        options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);
        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, time, true);
        options.offsetAttribute = offsetAttribute;
        options.height = heightValue;
        options.arcType = Property.getValueOrDefault(polygon.arcType, time, ArcType.GEODESIC);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    return PolygonGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js":
/*!************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ArcType */ "./node_modules/terriajs-cesium/Source/Core/ArcType.js"),
        __webpack_require__(/*! ../Core/BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/Event */ "./node_modules/terriajs-cesium/Source/Core/Event.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GroundPolylineGeometry */ "./node_modules/terriajs-cesium/Source/Core/GroundPolylineGeometry.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/oneTimeWarning */ "./node_modules/terriajs-cesium/Source/Core/oneTimeWarning.js"),
        __webpack_require__(/*! ../Core/PolylineGeometry */ "./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js"),
        __webpack_require__(/*! ../Core/PolylinePipeline */ "./node_modules/terriajs-cesium/Source/Core/PolylinePipeline.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../DataSources/Entity */ "./node_modules/terriajs-cesium/Source/DataSources/Entity.js"),
        __webpack_require__(/*! ../Scene/ClassificationType */ "./node_modules/terriajs-cesium/Source/Scene/ClassificationType.js"),
        __webpack_require__(/*! ../Scene/GroundPolylinePrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPolylinePrimitive.js"),
        __webpack_require__(/*! ../Scene/PolylineCollection */ "./node_modules/terriajs-cesium/Source/Scene/PolylineCollection.js"),
        __webpack_require__(/*! ../Scene/PolylineColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PolylineColorAppearance.js"),
        __webpack_require__(/*! ../Scene/PolylineMaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PolylineMaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/ShadowMode */ "./node_modules/terriajs-cesium/Source/Scene/ShadowMode.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./ConstantProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ConstantProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ArcType,
        BoundingSphere,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defaultValue,
        defined,
        defineProperties,
        destroyObject,
        DeveloperError,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        Event,
        GeometryInstance,
        GroundPolylineGeometry,
        Iso8601,
        oneTimeWarning,
        PolylineGeometry,
        PolylinePipeline,
        ShowGeometryInstanceAttribute,
        Entity,
        ClassificationType,
        GroundPolylinePrimitive,
        PolylineCollection,
        PolylineColorAppearance,
        PolylineMaterialAppearance,
        ShadowMode,
        BoundingSphereState,
        ColorMaterialProperty,
        ConstantProperty,
        MaterialProperty,
        Property) {
    'use strict';

    var defaultZIndex = new ConstantProperty(0);

    //We use this object to create one polyline collection per-scene.
    var polylineCollections = {};

    var scratchColor = new Color();
    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);
    var defaultShow = new ConstantProperty(true);
    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);
    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());
    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);

    function GeometryOptions() {
        this.vertexFormat = undefined;
        this.positions = undefined;
        this.width = undefined;
        this.arcType = undefined;
        this.granularity = undefined;
    }

    function GroundGeometryOptions() {
        this.positions = undefined;
        this.width = undefined;
        this.arcType = undefined;
        this.granularity = undefined;
    }

    /**
     * A {@link GeometryUpdater} for polylines.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias PolylineGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function PolylineGeometryUpdater(entity, scene) {
        

        this._entity = entity;
        this._scene = scene;
        this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);
        this._fillEnabled = false;
        this._dynamic = false;
        this._geometryChanged = new Event();
        this._showProperty = undefined;
        this._materialProperty = undefined;
        this._shadowsProperty = undefined;
        this._distanceDisplayConditionProperty = undefined;
        this._classificationTypeProperty = undefined;
        this._depthFailMaterialProperty = undefined;
        this._geometryOptions = new GeometryOptions();
        this._groundGeometryOptions = new GroundGeometryOptions();
        this._id = 'polyline-' + entity.id;
        this._clampToGround = false;
        this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);

        this._zIndex = 0;

        this._onEntityPropertyChanged(entity, 'polyline', entity.polyline, undefined);
    }

    defineProperties(PolylineGeometryUpdater.prototype, {
        /**
         * Gets the unique ID associated with this updater
         * @memberof PolylineGeometryUpdater.prototype
         * @type {String}
         * @readonly
         */
        id: {
            get: function() {
                return this._id;
            }
        },
        /**
         * Gets the entity associated with this geometry.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Entity}
         * @readonly
         */
        entity : {
            get : function() {
                return this._entity;
            }
        },
        /**
         * Gets a value indicating if the geometry has a fill component.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        fillEnabled : {
            get : function() {
                return this._fillEnabled;
            }
        },
        /**
         * Gets a value indicating if fill visibility varies with simulation time.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        hasConstantFill : {
            get : function() {
                return !this._fillEnabled || (!defined(this._entity.availability) && Property.isConstant(this._showProperty));
            }
        },
        /**
         * Gets the material property used to fill the geometry.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {MaterialProperty}
         * @readonly
         */
        fillMaterialProperty : {
            get : function() {
                return this._materialProperty;
            }
        },
        /**
         * Gets the material property used to fill the geometry when it fails the depth test.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {MaterialProperty}
         * @readonly
         */
        depthFailMaterialProperty : {
            get : function() {
                return this._depthFailMaterialProperty;
            }
        },
        /**
         * Gets a value indicating if the geometry has an outline component.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        outlineEnabled : {
            value : false
        },
        /**
         * Gets a value indicating if outline visibility varies with simulation time.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        hasConstantOutline : {
            value : true
        },
        /**
         * Gets the {@link Color} property for the geometry outline.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        outlineColorProperty : {
            value : undefined
        },
        /**
         * Gets the property specifying whether the geometry
         * casts or receives shadows from each light source.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        shadowsProperty : {
            get : function() {
                return this._shadowsProperty;
            }
        },
        /**
         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        distanceDisplayConditionProperty : {
            get : function() {
                return this._distanceDisplayConditionProperty;
            }
        },
        /**
         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Property}
         * @readonly
         */
        classificationTypeProperty : {
            get : function() {
                return this._classificationTypeProperty;
            }
        },
        /**
         * Gets a value indicating if the geometry is time-varying.
         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
         * returned by GeometryUpdater#createDynamicUpdater.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isDynamic : {
            get : function() {
                return this._dynamic;
            }
        },
        /**
         * Gets a value indicating if the geometry is closed.
         * This property is only valid for static geometry.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isClosed : {
            value : false
        },
        /**
         * Gets an event that is raised whenever the public properties
         * of this updater change.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        geometryChanged : {
            get : function() {
                return this._geometryChanged;
            }
        },

        /**
         * Gets a value indicating if the path of the line.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {ArcType}
         * @readonly
         */
        arcType : {
            get : function() {
                return this._arcType;
            }
        },

        /**
         * Gets a value indicating if the geometry is clamped to the ground.
         * Returns false if polylines on terrain is not supported.
         * @memberof PolylineGeometryUpdater.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        clampToGround : {
            get : function() {
                return this._clampToGround && this._supportsPolylinesOnTerrain;
            }
        },

        /**
         * Gets the zindex
         * @type {Number}
         * @memberof PolylineGeometryUpdater.prototype
         * @readonly
         */
        zIndex: {
            get: function() {
                return this._zIndex;
            }
        }
    });

    /**
     * Checks if the geometry is outlined at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve visibility.
     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.
     */
    PolylineGeometryUpdater.prototype.isOutlineVisible = function(time) {
        return false;
    };

    /**
     * Checks if the geometry is filled at the provided time.
     *
     * @param {JulianDate} time The time for which to retrieve visibility.
     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.
     */
    PolylineGeometryUpdater.prototype.isFilled = function(time) {
        var entity = this._entity;
        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);
        return defaultValue(visible, false);
    };

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    PolylineGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);

        var attributes = {
            show : show,
            distanceDisplayCondition : distanceDisplayConditionAttribute
        };

        var currentColor;
        if (this._materialProperty instanceof ColorMaterialProperty) {
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }

        if (this.clampToGround) {
            return new GeometryInstance({
                id : entity,
                geometry : new GroundPolylineGeometry(this._groundGeometryOptions),
                attributes : attributes
            });
        }

        if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {
            if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {
                currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }

        return new GeometryInstance({
            id : entity,
            geometry : new PolylineGeometry(this._geometryOptions),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    PolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    PolylineGeometryUpdater.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     */
    PolylineGeometryUpdater.prototype.destroy = function() {
        this._entitySubscription();
        destroyObject(this);
    };

    PolylineGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {
        if (!(propertyName === 'availability' || propertyName === 'polyline')) {
            return;
        }

        var polyline = this._entity.polyline;

        if (!defined(polyline)) {
            if (this._fillEnabled) {
                this._fillEnabled = false;
                this._geometryChanged.raiseEvent(this);
            }
            return;
        }

        var positionsProperty = polyline.positions;

        var show = polyline.show;
        if ((defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) || //
            (!defined(positionsProperty))) {
            if (this._fillEnabled) {
                this._fillEnabled = false;
                this._geometryChanged.raiseEvent(this);
            }
            return;
        }

        var zIndex = polyline.zIndex;
        var material = defaultValue(polyline.material, defaultMaterial);
        var isColorMaterial = material instanceof ColorMaterialProperty;
        this._materialProperty = material;
        this._depthFailMaterialProperty = polyline.depthFailMaterial;
        this._showProperty = defaultValue(show, defaultShow);
        this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);
        this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);
        this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);
        this._fillEnabled = true;
        this._zIndex = defaultValue(zIndex, defaultZIndex);

        var width = polyline.width;
        var arcType = polyline.arcType;
        var clampToGround = polyline.clampToGround;
        var granularity = polyline.granularity;

        if (!positionsProperty.isConstant || !Property.isConstant(width) ||
            !Property.isConstant(arcType) || !Property.isConstant(granularity) ||
            !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {
            if (!this._dynamic) {
                this._dynamic = true;
                this._geometryChanged.raiseEvent(this);
            }
        } else {
            var geometryOptions = this._geometryOptions;
            var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions);

            //Because of the way we currently handle reference properties,
            //we can't automatically assume the positions are always valid.
            if (!defined(positions) || positions.length < 2) {
                if (this._fillEnabled) {
                    this._fillEnabled = false;
                    this._geometryChanged.raiseEvent(this);
                }
                return;
            }

            var vertexFormat;
            if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {
                vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;
            } else {
                vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;
            }

            geometryOptions.vertexFormat = vertexFormat;
            geometryOptions.positions = positions;
            geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;
            geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;
            geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;

            var groundGeometryOptions = this._groundGeometryOptions;
            groundGeometryOptions.positions = positions;
            groundGeometryOptions.width = geometryOptions.width;
            groundGeometryOptions.arcType = geometryOptions.arcType;
            groundGeometryOptions.granularity = geometryOptions.granularity;

            this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;

            if (!this._clampToGround && defined(zIndex)) {
                oneTimeWarning('Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.');
            }

            this._dynamic = false;
            this._geometryChanged.raiseEvent(this);
        }
    };

    /**
     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
     *
     * @param {PrimitiveCollection} primitives The primitive collection to use.
     * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.
     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.
     *
     * @exception {DeveloperError} This instance does not represent dynamic geometry.
     */
    PolylineGeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {
        

        return new DynamicGeometryUpdater(primitives, groundPrimitives, this);
    };

    /**
     * @private
     */
    var generateCartesianArcOptions = {
        positions : undefined,
        granularity : undefined,
        height : undefined,
        ellipsoid : undefined
    };

    function DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {
        this._line = undefined;
        this._primitives = primitives;
        this._groundPrimitives = groundPrimitives;
        this._groundPolylinePrimitive = undefined;
        this._material = undefined;
        this._geometryUpdater = geometryUpdater;
        this._positions = [];
    }

    function getLine(dynamicGeometryUpdater) {
        if (defined(dynamicGeometryUpdater._line)) {
            return dynamicGeometryUpdater._line;
        }

        var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;
        var polylineCollection = polylineCollections[sceneId];
        var primitives = dynamicGeometryUpdater._primitives;
        if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {
            polylineCollection = new PolylineCollection();
            polylineCollections[sceneId] = polylineCollection;
            primitives.add(polylineCollection);
        } else if (!primitives.contains(polylineCollection)) {
            primitives.add(polylineCollection);
        }

        var line = polylineCollection.add();
        line.id = dynamicGeometryUpdater._geometryUpdater._entity;
        dynamicGeometryUpdater._line = line;
        return line;
    }

    DynamicGeometryUpdater.prototype.update = function(time) {
        var geometryUpdater = this._geometryUpdater;
        var entity = geometryUpdater._entity;
        var polyline = entity.polyline;

        var positionsProperty = polyline.positions;
        var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);

        // Synchronize with geometryUpdater for GroundPolylinePrimitive
        geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);
        geometryUpdater._groundGeometryOptions.positions = positions;
        geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);
        geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);
        geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);

        var groundPrimitives = this._groundPrimitives;

        if (defined(this._groundPolylinePrimitive)) {
            groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default
            this._groundPolylinePrimitive = undefined;
        }

        if (geometryUpdater.clampToGround) {
            if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {
                return;
            }

            if (!defined(positions) || positions.length < 2) {
                return;
            }

            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;
            var appearance;
            if (fillMaterialProperty instanceof ColorMaterialProperty) {
                appearance = new PolylineColorAppearance();
            } else {
                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);
                appearance = new PolylineMaterialAppearance({
                    material : material,
                    translucent : material.isTranslucent()
                });
                this._material = material;
            }

            this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({
                geometryInstances : geometryUpdater.createFillGeometryInstance(time),
                appearance : appearance,
                classificationType : geometryUpdater.classificationTypeProperty.getValue(time),
                asynchronous : false
            }), Property.getValueOrUndefined(geometryUpdater.zIndex, time));

            // Hide the polyline in the collection, if any
            if (defined(this._line)) {
                this._line.show = false;
            }
            return;
        }

        var line = getLine(this);

        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {
            line.show = false;
            return;
        }

        if (!defined(positions) || positions.length < 2) {
            line.show = false;
            return;
        }

        var arcType = ArcType.GEODESIC;
        arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);

        var globe = geometryUpdater._scene.globe;
        if (arcType !== ArcType.NONE && defined(globe)) {
            generateCartesianArcOptions.ellipsoid = globe.ellipsoid;
            generateCartesianArcOptions.positions = positions;
            generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);
            generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, globe.ellipsoid);
            positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);
        }

        line.show = true;
        line.positions = positions.slice();
        line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);
        line.width = Property.getValueOrDefault(polyline._width, time, 1);
        line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);
    };

    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {
        

        if (!this._geometryUpdater.clampToGround) {
            var line = getLine(this);
            if (line.show && line.positions.length > 0) {
                BoundingSphere.fromPoints(line.positions, result);
                return BoundingSphereState.DONE;
            }
        } else {
            var groundPolylinePrimitive = this._groundPolylinePrimitive;
            if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {
                var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);
                if (defined(attributes) && defined(attributes.boundingSphere)) {
                    BoundingSphere.clone(attributes.boundingSphere, result);
                    return BoundingSphereState.DONE;
                }
            }

            if ((defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready)) {
                return BoundingSphereState.PENDING;
            }

            return BoundingSphereState.DONE;
        }

        return BoundingSphereState.FAILED;
    };

    DynamicGeometryUpdater.prototype.isDestroyed = function() {
        return false;
    };

    DynamicGeometryUpdater.prototype.destroy = function() {
        var geometryUpdater = this._geometryUpdater;
        var sceneId = geometryUpdater._scene.id;
        var polylineCollection = polylineCollections[sceneId];
        if (defined(polylineCollection)) {
            polylineCollection.remove(this._line);
            if (polylineCollection.length === 0) {
                this._primitives.removeAndDestroy(polylineCollection);
                delete polylineCollections[sceneId];
            }
        }
        if (defined(this._groundPolylinePrimitive)) {
            this._groundPrimitives.remove(this._groundPolylinePrimitive);
        }
        destroyObject(this);
    };

    return PolylineGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/BoundingSphere */ "./node_modules/terriajs-cesium/Source/Core/BoundingSphere.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
        __webpack_require__(/*! ../Scene/ClassificationType */ "./node_modules/terriajs-cesium/Source/Scene/ClassificationType.js"),
        __webpack_require__(/*! ../Scene/PolylineColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PolylineColorAppearance.js"),
        __webpack_require__(/*! ../Scene/PolylineMaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PolylineMaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/ShadowMode */ "./node_modules/terriajs-cesium/Source/Scene/ShadowMode.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryBatch */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js"),
        __webpack_require__(/*! ./PolylineGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js"),
        __webpack_require__(/*! ./StaticGeometryColorBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js"),
        __webpack_require__(/*! ./StaticGeometryPerMaterialBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js"),
        __webpack_require__(/*! ./StaticGroundPolylinePerMaterialBatch */ "./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        BoundingSphere,
        Check,
        defaultValue,
        defined,
        destroyObject,
        ClassificationType,
        PolylineColorAppearance,
        PolylineMaterialAppearance,
        ShadowMode,
        BoundingSphereState,
        ColorMaterialProperty,
        DynamicGeometryBatch,
        PolylineGeometryUpdater,
        StaticGeometryColorBatch,
        StaticGeometryPerMaterialBatch,
        StaticGroundPolylinePerMaterialBatch) {
    'use strict';

    var emptyArray = [];

    function removeUpdater(that, updater) {
        //We don't keep track of which batch an updater is in, so just remove it from all of them.
        var batches = that._batches;
        var length = batches.length;
        for (var i = 0; i < length; i++) {
            batches[i].remove(updater);
        }
    }

    function insertUpdaterIntoBatch(that, time, updater) {
        if (updater.isDynamic) {
            that._dynamicBatch.add(time, updater);
            return;
        }

        if (updater.clampToGround && updater.fillEnabled) { // Also checks for support
            var classificationType = updater.classificationTypeProperty.getValue(time);
            that._groundBatches[classificationType].add(time, updater);
            return;
        }

        var shadows;
        if (updater.fillEnabled) {
            shadows = updater.shadowsProperty.getValue(time);
        }

        var multiplier = 0;
        if (defined(updater.depthFailMaterialProperty)) {
            multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;
        }

        var index;
        if (defined(shadows)) {
            index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;
        }

        if (updater.fillEnabled) {
            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {
                that._colorBatches[index].add(time, updater);
            } else {
                that._materialBatches[index].add(time, updater);
            }
        }
    }

    /**
     * A visualizer for polylines represented by {@link Primitive} instances.
     * @alias PolylineVisualizer
     * @constructor
     *
     * @param {Scene} scene The scene the primitives will be rendered in.
     * @param {EntityCollection} entityCollection The entityCollection to visualize.
     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities
     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities
     */
    function PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {
        

        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);
        primitives = defaultValue(primitives, scene.primitives);

        this._scene = scene;
        this._primitives = primitives;
        this._entityCollection = undefined;
        this._addedObjects = new AssociativeArray();
        this._removedObjects = new AssociativeArray();
        this._changedObjects = new AssociativeArray();

        var i;
        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;
        this._colorBatches = new Array(numberOfShadowModes * 3);
        this._materialBatches = new Array(numberOfShadowModes * 3);

        for (i = 0; i < numberOfShadowModes; ++i) {
            this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance
            this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);

            this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations
            this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);

            this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);
            this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);
        }

        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);

        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;
        this._groundBatches = new Array(numberOfClassificationTypes);

        for (i = 0; i < numberOfClassificationTypes; ++i) {
            this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);
        }

        this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);

        this._subscriptions = new AssociativeArray();
        this._updaters = new AssociativeArray();

        this._entityCollection = entityCollection;
        entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);
        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);
    }

    /**
     * Updates all of the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     *
     * @param {JulianDate} time The time to update to.
     * @returns {Boolean} True if the visualizer successfully updated to the provided time,
     * false if the visualizer is waiting for asynchronous primitives to be created.
     */
    PolylineVisualizer.prototype.update = function(time) {
        

        var addedObjects = this._addedObjects;
        var added = addedObjects.values;
        var removedObjects = this._removedObjects;
        var removed = removedObjects.values;
        var changedObjects = this._changedObjects;
        var changed = changedObjects.values;

        var i;
        var entity;
        var id;
        var updater;

        for (i = changed.length - 1; i > -1; i--) {
            entity = changed[i];
            id = entity.id;
            updater = this._updaters.get(id);

            //If in a single update, an entity gets removed and a new instance
            //re-added with the same id, the updater no longer tracks the
            //correct entity, we need to both remove the old one and
            //add the new one, which is done by pushing the entity
            //onto the removed/added lists.
            if (updater.entity === entity) {
                removeUpdater(this, updater);
                insertUpdaterIntoBatch(this, time, updater);
            } else {
                removed.push(entity);
                added.push(entity);
            }
        }

        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            id = entity.id;
            updater = this._updaters.get(id);
            removeUpdater(this, updater);
            updater.destroy();
            this._updaters.remove(id);
            this._subscriptions.get(id)();
            this._subscriptions.remove(id);
        }

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            id = entity.id;
            updater = new PolylineGeometryUpdater(entity, this._scene);
            this._updaters.set(id, updater);
            insertUpdaterIntoBatch(this, time, updater);
            this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));
        }

        addedObjects.removeAll();
        removedObjects.removeAll();
        changedObjects.removeAll();

        var isUpdated = true;
        var batches = this._batches;
        var length = batches.length;
        for (i = 0; i < length; i++) {
            isUpdated = batches[i].update(time) && isUpdated;
        }

        return isUpdated;
    };

    var getBoundingSphereArrayScratch = [];
    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();

    /**
     * Computes a bounding sphere which encloses the visualization produced for the specified entity.
     * The bounding sphere is in the fixed frame of the scene's globe.
     *
     * @param {Entity} entity The entity whose bounding sphere to compute.
     * @param {BoundingSphere} result The bounding sphere onto which to store the result.
     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
     *                       BoundingSphereState.PENDING if the result is still being computed, or
     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
     * @private
     */
    PolylineVisualizer.prototype.getBoundingSphere = function(entity, result) {
        

        var boundingSpheres = getBoundingSphereArrayScratch;
        var tmp = getBoundingSphereBoundingSphereScratch;

        var count = 0;
        var state = BoundingSphereState.DONE;
        var batches = this._batches;
        var batchesLength = batches.length;
        var updater = this._updaters.get(entity.id);
        for (var i = 0; i < batchesLength; i++) {
            state = batches[i].getBoundingSphere(updater, tmp);
            if (state === BoundingSphereState.PENDING) {
                return BoundingSphereState.PENDING;
            } else if (state === BoundingSphereState.DONE) {
                boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);
                count++;
            }
        }

        if (count === 0) {
            return BoundingSphereState.FAILED;
        }

        boundingSpheres.length = count;
        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);
        return BoundingSphereState.DONE;
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     */
    PolylineVisualizer.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Removes and destroys all primitives created by this instance.
     */
    PolylineVisualizer.prototype.destroy = function() {
        this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);
        this._addedObjects.removeAll();
        this._removedObjects.removeAll();

        var i;
        var batches = this._batches;
        var length = batches.length;
        for (i = 0; i < length; i++) {
            batches[i].removeAllPrimitives();
        }

        var subscriptions = this._subscriptions.values;
        length = subscriptions.length;
        for (i = 0; i < length; i++) {
            subscriptions[i]();
        }
        this._subscriptions.removeAll();
        return destroyObject(this);
    };

    /**
     * @private
     */
    PolylineVisualizer._onGeometryChanged = function(updater) {
        var removedObjects = this._removedObjects;
        var changedObjects = this._changedObjects;

        var entity = updater.entity;
        var id = entity.id;

        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {
            changedObjects.set(id, entity);
        }
    };

    /**
     * @private
     */
    PolylineVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {
        var addedObjects = this._addedObjects;
        var removedObjects = this._removedObjects;
        var changedObjects = this._changedObjects;

        var i;
        var id;
        var entity;
        for (i = removed.length - 1; i > -1; i--) {
            entity = removed[i];
            id = entity.id;
            if (!addedObjects.remove(id)) {
                removedObjects.set(id, entity);
                changedObjects.remove(id);
            }
        }

        for (i = added.length - 1; i > -1; i--) {
            entity = added[i];
            id = entity.id;
            if (removedObjects.remove(id)) {
                changedObjects.set(id, entity);
            } else {
                addedObjects.set(id, entity);
            }
        }
    };

    return PolylineVisualizer;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/PolylineVolumeGeometry */ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js"),
        __webpack_require__(/*! ../Core/PolylineVolumeOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        GeometryInstance,
        Iso8601,
        PolylineVolumeGeometry,
        PolylineVolumeOutlineGeometry,
        ShowGeometryInstanceAttribute,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        Property) {
    'use strict';

    var scratchColor = new Color();

    function PolylineVolumeGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.polylinePositions = undefined;
        this.shapePositions = undefined;
        this.cornerType = undefined;
        this.granularity = undefined;
    }

    /**
     * A {@link GeometryUpdater} for polyline volumes.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias PolylineVolumeGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function PolylineVolumeGeometryUpdater(entity, scene) {
        GeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new PolylineVolumeGeometryOptions(entity),
            geometryPropertyName : 'polylineVolume',
            observedPropertyNames : ['availability', 'polylineVolume']
        });

        this._onEntityPropertyChanged(entity, 'polylineVolume', entity.polylineVolume, undefined);
    }

    if (defined(Object.create)) {
        PolylineVolumeGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        PolylineVolumeGeometryUpdater.prototype.constructor = PolylineVolumeGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var attributes;

        var color;
        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);
        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            color = ColorGeometryInstanceAttribute.fromColor(currentColor);
            attributes = {
                show : show,
                distanceDisplayCondition : distanceDisplayConditionAttribute,
                color : color
            };
        } else {
            attributes = {
                show : show,
                distanceDisplayCondition : distanceDisplayConditionAttribute
            };
        }

        return new GeometryInstance({
            id : entity,
            geometry : new PolylineVolumeGeometry(this._options),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        return new GeometryInstance({
            id : entity,
            geometry : new PolylineVolumeOutlineGeometry(this._options),
            attributes : {
                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
            }
        });
    };

    PolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume) {
        return !defined(polylineVolume.positions) || !defined(polylineVolume.shape) || GeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume);
    };

    PolylineVolumeGeometryUpdater.prototype._isDynamic = function(entity, polylineVolume) {
        return !polylineVolume.positions.isConstant || //
               !polylineVolume.shape.isConstant || //
               !Property.isConstant(polylineVolume.granularity) || //
               !Property.isConstant(polylineVolume.outlineWidth) || //
               !Property.isConstant(polylineVolume.cornerType);
    };

    PolylineVolumeGeometryUpdater.prototype._setStaticOptions = function(entity, polylineVolume) {
        var granularity = polylineVolume.granularity;
        var cornerType = polylineVolume.cornerType;

        var options = this._options;
        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.polylinePositions = polylineVolume.positions.getValue(Iso8601.MINIMUM_VALUE, options.polylinePositions);
        options.shapePositions = polylineVolume.shape.getValue(Iso8601.MINIMUM_VALUE, options.shape);
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;
    };

    PolylineVolumeGeometryUpdater.DynamicGeometryUpdater = DynamicPolylineVolumeGeometryUpdater;

    /**
     * @private
     */
    function DynamicPolylineVolumeGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicPolylineVolumeGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicPolylineVolumeGeometryUpdater.prototype.constructor = DynamicPolylineVolumeGeometryUpdater;
    }

    DynamicPolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume, time) {
        var options = this._options;
        return !defined(options.polylinePositions) || !defined(options.shapePositions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume, time);
    };

    DynamicPolylineVolumeGeometryUpdater.prototype._setOptions = function(entity, polylineVolume, time) {
        var options = this._options;
        options.polylinePositions = Property.getValueOrUndefined(polylineVolume.positions, time, options.polylinePositions);
        options.shapePositions = Property.getValueOrUndefined(polylineVolume.shape, time);
        options.granularity = Property.getValueOrUndefined(polylineVolume.granularity, time);
        options.cornerType = Property.getValueOrUndefined(polylineVolume.cornerType, time);
    };

    return PolylineVolumeGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/ApproximateTerrainHeights */ "./node_modules/terriajs-cesium/Source/Core/ApproximateTerrainHeights.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/Ellipsoid */ "./node_modules/terriajs-cesium/Source/Core/Ellipsoid.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/GeometryOffsetAttribute */ "./node_modules/terriajs-cesium/Source/Core/GeometryOffsetAttribute.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/Rectangle */ "./node_modules/terriajs-cesium/Source/Core/Rectangle.js"),
        __webpack_require__(/*! ../Core/RectangleGeometry */ "./node_modules/terriajs-cesium/Source/Core/RectangleGeometry.js"),
        __webpack_require__(/*! ../Core/RectangleOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/RectangleOutlineGeometry.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./GroundGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        ApproximateTerrainHeights,
        Cartesian3,
        Cartographic,
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        Ellipsoid,
        GeometryInstance,
        GeometryOffsetAttribute,
        Iso8601,
        OffsetGeometryInstanceAttribute,
        Rectangle,
        RectangleGeometry,
        RectangleOutlineGeometry,
        ShowGeometryInstanceAttribute,
        GroundPrimitive,
        HeightReference,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        GroundGeometryUpdater,
        Property) {
    'use strict';

    var scratchColor = new Color();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();
    var scratchRectangle = new Rectangle();
    var scratchCenterRect = new Rectangle();
    var scratchCarto = new Cartographic();

    function RectangleGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.rectangle = undefined;
        this.height = undefined;
        this.extrudedHeight = undefined;
        this.granularity = undefined;
        this.stRotation = undefined;
        this.rotation = undefined;
        this.offsetAttribute = undefined;
    }

    /**
     * A {@link GeometryUpdater} for rectangles.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias RectangleGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function RectangleGeometryUpdater(entity, scene) {
        GroundGeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new RectangleGeometryOptions(entity),
            geometryPropertyName : 'rectangle',
            observedPropertyNames : ['availability', 'rectangle']
        });

        this._onEntityPropertyChanged(entity, 'rectangle', entity.rectangle, undefined);
    }

    if (defined(Object.create)) {
        RectangleGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);
        RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    RectangleGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),
            offset : undefined,
            color : undefined
        };

        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);
        }
        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new RectangleGeometry(this._options),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    RectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        var attributes = {
            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),
            offset : undefined
        };

        if (defined(this._options.offsetAttribute)) {
            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));
        }

        return new GeometryInstance({
            id : entity,
            geometry : new RectangleOutlineGeometry(this._options),
            attributes : attributes
        });
    };

    RectangleGeometryUpdater.prototype._computeCenter = function(time, result) {
        var rect = Property.getValueOrUndefined(this._entity.rectangle.coordinates, time, scratchCenterRect);
        if (!defined(rect)) {
            return;
        }
        var center = Rectangle.center(rect, scratchCarto);
        return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);
    };

    RectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle) {
        return !defined(rectangle.coordinates) || GeometryUpdater.prototype._isHidden.call(this, entity, rectangle);
    };

    RectangleGeometryUpdater.prototype._isDynamic = function(entity, rectangle) {
        return !rectangle.coordinates.isConstant || //
               !Property.isConstant(rectangle.height) || //
               !Property.isConstant(rectangle.extrudedHeight) || //
               !Property.isConstant(rectangle.granularity) || //
               !Property.isConstant(rectangle.stRotation) || //
               !Property.isConstant(rectangle.rotation) || //
               !Property.isConstant(rectangle.outlineWidth) || //
               !Property.isConstant(rectangle.zIndex) || //
               (this._onTerrain && !Property.isConstant(this._materialProperty));
    };

    RectangleGeometryUpdater.prototype._setStaticOptions = function(entity, rectangle) {
        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;

        var heightValue = Property.getValueOrUndefined(rectangle.height, Iso8601.MINIMUM_VALUE);
        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, Iso8601.MINIMUM_VALUE);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);
        if (defined(extrudedHeightValue) && !defined(heightValue)) {
            heightValue = 0;
        }

        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.rectangle = rectangle.coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);
        options.granularity = Property.getValueOrUndefined(rectangle.granularity, Iso8601.MINIMUM_VALUE);
        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, Iso8601.MINIMUM_VALUE);
        options.rotation = Property.getValueOrUndefined(rectangle.rotation, Iso8601.MINIMUM_VALUE);
        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    RectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;

    /**
     * @private
     */
    function DynamicRectangleGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicRectangleGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;
    }

    DynamicRectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle, time) {
        return  !defined(this._options.rectangle) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, rectangle, time);
    };

    DynamicRectangleGeometryUpdater.prototype._setOptions = function(entity, rectangle, time) {
        var options = this._options;
        var heightValue = Property.getValueOrUndefined(rectangle.height, time);
        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, time, HeightReference.NONE);
        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, time);
        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, time, HeightReference.NONE);
        if (defined(extrudedHeightValue) && !defined(heightValue)) {
            heightValue = 0;
        }

        options.rectangle = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);
        options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);
        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);
        options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);
        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);
        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);

        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);
        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {
            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;
        }

        options.extrudedHeight = extrudedHeightValue;
    };

    return RectangleGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/Primitive */ "./node_modules/terriajs-cesium/Source/Scene/Primitive.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Cartesian3,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        OffsetGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        Primitive,
        BoundingSphereState,
        ColorMaterialProperty,
        MaterialProperty,
        Property) {
    'use strict';

    var colorScratch = new Color();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();
    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();

    function Batch(primitives, translucent, appearanceType, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {
        this.translucent = translucent;
        this.appearanceType = appearanceType;
        this.depthFailAppearanceType = depthFailAppearanceType;
        this.depthFailMaterialProperty = depthFailMaterialProperty;
        this.depthFailMaterial = undefined;
        this.closed = closed;
        this.shadows = shadows;
        this.primitives = primitives;
        this.createPrimitive = false;
        this.waitingOnCreate = false;
        this.primitive = undefined;
        this.oldPrimitive = undefined;
        this.geometry = new AssociativeArray();
        this.updaters = new AssociativeArray();
        this.updatersWithAttributes = new AssociativeArray();
        this.attributes = new AssociativeArray();
        this.subscriptions = new AssociativeArray();
        this.showsUpdated = new AssociativeArray();
        this.itemsToRemove = [];
        this.invalidated = false;

        var removeMaterialSubscription;
        if (defined(depthFailMaterialProperty)) {
            removeMaterialSubscription = depthFailMaterialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);
        }
        this.removeMaterialSubscription = removeMaterialSubscription;
    }

    Batch.prototype.onMaterialChanged = function() {
        this.invalidated = true;
    };

    Batch.prototype.isMaterial = function(updater) {
        var material = this.depthFailMaterialProperty;
        var updaterMaterial = updater.depthFailMaterialProperty;
        if (updaterMaterial === material) {
            return true;
        }
        if (defined(material)) {
            return material.equals(updaterMaterial);
        }
        return false;
    };

    Batch.prototype.add = function(updater, instance) {
        var id = updater.id;
        this.createPrimitive = true;
        this.geometry.set(id, instance);
        this.updaters.set(id, updater);
        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {
            this.updatersWithAttributes.set(id, updater);
        } else {
            var that = this;
            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {
                if (propertyName === 'isShowing') {
                    that.showsUpdated.set(updater.id, updater);
                }
            }));
        }
    };

    Batch.prototype.remove = function(updater) {
        var id = updater.id;
        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
        if (this.updaters.remove(id)) {
            this.updatersWithAttributes.remove(id);
            var unsubscribe = this.subscriptions.get(id);
            if (defined(unsubscribe)) {
                unsubscribe();
                this.subscriptions.remove(id);
                this.showsUpdated.remove(id);
            }
            return true;
        }
        return false;
    };

    Batch.prototype.update = function(time) {
        var isUpdated = true;
        var removedCount = 0;
        var primitive = this.primitive;
        var primitives = this.primitives;
        var i;

        if (this.createPrimitive) {
            var geometries = this.geometry.values;
            var geometriesLength = geometries.length;
            if (geometriesLength > 0) {
                if (defined(primitive)) {
                    if (!defined(this.oldPrimitive)) {
                        this.oldPrimitive = primitive;
                    } else {
                        primitives.remove(primitive);
                    }
                }

                var depthFailAppearance;
                if (defined(this.depthFailAppearanceType)) {
                    if (defined(this.depthFailMaterialProperty)) {
                        this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);
                    }
                    depthFailAppearance = new this.depthFailAppearanceType({
                        material : this.depthFailMaterial,
                        translucent : this.translucent,
                        closed : this.closed
                    });
                }

                primitive = new Primitive({
                    show : false,
                    asynchronous : true,
                    geometryInstances : geometries,
                    appearance : new this.appearanceType({
                        translucent : this.translucent,
                        closed : this.closed
                    }),
                    depthFailAppearance : depthFailAppearance,
                    shadows : this.shadows
                });
                primitives.add(primitive);
                isUpdated = false;
            } else {
                if (defined(primitive)) {
                    primitives.remove(primitive);
                    primitive = undefined;
                }
                var oldPrimitive = this.oldPrimitive;
                if (defined(oldPrimitive)) {
                    primitives.remove(oldPrimitive);
                    this.oldPrimitive = undefined;
                }
            }

            this.attributes.removeAll();
            this.primitive = primitive;
            this.createPrimitive = false;
            this.waitingOnCreate = true;
        } else if (defined(primitive) && primitive.ready) {
            primitive.show = true;
            if (defined(this.oldPrimitive)) {
                primitives.remove(this.oldPrimitive);
                this.oldPrimitive = undefined;
            }

            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {
                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);
                this.primitive.depthFailAppearance.material = this.depthFailMaterial;
            }

            var updatersWithAttributes = this.updatersWithAttributes.values;
            var length = updatersWithAttributes.length;
            var waitingOnCreate = this.waitingOnCreate;
            for (i = 0; i < length; i++) {
                var updater = updatersWithAttributes[i];
                var instance = this.geometry.get(updater.id);

                var attributes = this.attributes.get(instance.id.id);
                if (!defined(attributes)) {
                    attributes = primitive.getGeometryInstanceAttributes(instance.id);
                    this.attributes.set(instance.id.id, attributes);
                }

                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {
                    var colorProperty = updater.fillMaterialProperty.color;
                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);
                    if (!Color.equals(attributes._lastColor, resultColor)) {
                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);
                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);
                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {
                            this.itemsToRemove[removedCount++] = updater;
                        }
                    }
                }

                if (defined(this.depthFailAppearanceType) && updater.depthFailMaterialProperty instanceof ColorMaterialProperty && (!updater.depthFailMaterialProperty.isConstant || waitingOnCreate)) {
                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;
                    var depthColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);
                    if (!Color.equals(attributes._lastDepthFailColor, depthColor)) {
                        attributes._lastDepthFailColor = Color.clone(depthColor, attributes._lastDepthFailColor);
                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthColor, attributes.depthFailColor);
                    }
                }

                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));
                var currentShow = attributes.show[0] === 1;
                if (show !== currentShow) {
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }

                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;
                if (!Property.isConstant(distanceDisplayConditionProperty)) {
                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);
                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {
                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);
                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                    }
                }

                var offsetProperty = updater.terrainOffsetProperty;
                if (!Property.isConstant(offsetProperty)) {
                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);
                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {
                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);
                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);
                    }
                }
            }

            this.updateShows(primitive);
            this.waitingOnCreate = false;
        } else if (defined(primitive) && !primitive.ready) {
            isUpdated = false;
        }
        this.itemsToRemove.length = removedCount;
        return isUpdated;
    };

    Batch.prototype.updateShows = function(primitive) {
        var showsUpdated = this.showsUpdated.values;
        var length = showsUpdated.length;
        for (var i = 0; i < length; i++) {
            var updater = showsUpdated[i];
            var instance = this.geometry.get(updater.id);

            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }

            var show = updater.entity.isShowing;
            var currentShow = attributes.show[0] === 1;
            if (show !== currentShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                instance.attributes.show.value[0] = attributes.show[0];
            }
        }
        this.showsUpdated.removeAll();
    };

    Batch.prototype.contains = function(updater) {
        return this.updaters.contains(updater.id);
    };

    Batch.prototype.getBoundingSphere = function(updater, result) {
        var primitive = this.primitive;
        if (!primitive.ready) {
            return BoundingSphereState.PENDING;
        }
        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);
        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//
            (defined(attributes.show) && attributes.show[0] === 0)) {
            return BoundingSphereState.FAILED;
        }
        attributes.boundingSphere.clone(result);
        return BoundingSphereState.DONE;
    };

    Batch.prototype.destroy = function() {
        var primitive = this.primitive;
        var primitives = this.primitives;
        if (defined(primitive)) {
            primitives.remove(primitive);
        }
        var oldPrimitive = this.oldPrimitive;
        if (defined(oldPrimitive)) {
            primitives.remove(oldPrimitive);
        }
        if (defined(this.removeMaterialSubscription)) {
            this.removeMaterialSubscription();
        }
    };

    /**
     * @private
     */
    function StaticGeometryColorBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {
        this._solidItems = [];
        this._translucentItems = [];
        this._primitives = primitives;
        this._appearanceType = appearanceType;
        this._depthFailAppearanceType = depthFailAppearanceType;
        this._closed = closed;
        this._shadows = shadows;
    }

    StaticGeometryColorBatch.prototype.add = function(time, updater) {
        var items;
        var translucent;
        var instance = updater.createFillGeometryInstance(time);
        if (instance.attributes.color.value[3] === 255) {
            items = this._solidItems;
            translucent = false;
        } else {
            items = this._translucentItems;
            translucent = true;
        }

        var length = items.length;
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (item.isMaterial(updater)) {
                item.add(updater, instance);
                return;
            }
        }
        var batch = new Batch(this._primitives, translucent, this._appearanceType, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);
        batch.add(updater, instance);
        items.push(batch);
    };

    function removeItem(items, updater) {
        var length = items.length;
        for (var i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.remove(updater)) {
                if (item.updaters.length === 0) {
                    items.splice(i, 1);
                    item.destroy();
                }
                return true;
            }
        }
        return false;
    }

    StaticGeometryColorBatch.prototype.remove = function(updater) {
        if (!removeItem(this._solidItems, updater)) {
            removeItem(this._translucentItems, updater);
        }
    };

    function moveItems(batch, items, time) {
        var itemsMoved = false;
        var length = items.length;
        for (var i = 0; i < length; ++i) {
            var item = items[i];
            var itemsToRemove = item.itemsToRemove;
            var itemsToMoveLength = itemsToRemove.length;
            if (itemsToMoveLength > 0) {
                for (i = 0; i < itemsToMoveLength; i++) {
                    var updater = itemsToRemove[i];
                    item.remove(updater);
                    batch.add(time, updater);
                    itemsMoved = true;
                }
            }
        }
        return itemsMoved;
    }

    function updateItems(batch, items, time, isUpdated) {
        var length = items.length;
        var i;
        for (i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.invalidated) {
                items.splice(i, 1);
                var updaters = item.updaters.values;
                var updatersLength = updaters.length;
                for (var h = 0; h < updatersLength; h++) {
                    batch.add(time, updaters[h]);
                }
                item.destroy();
            }
        }

        length = items.length;
        for (i = 0; i < length; ++i) {
            isUpdated = items[i].update(time) && isUpdated;
        }
        return isUpdated;
    }

    StaticGeometryColorBatch.prototype.update = function(time) {
        //Perform initial update
        var isUpdated = updateItems(this, this._solidItems, time, true);
        isUpdated = updateItems(this, this._translucentItems, time, isUpdated) && isUpdated;

        //If any items swapped between solid/translucent, we need to
        //move them between batches
        var solidsMoved = moveItems(this, this._solidItems, time);
        var translucentsMoved = moveItems(this, this._translucentItems, time);

        //If we moved anything around, we need to re-build the primitive
        if (solidsMoved || translucentsMoved) {
            isUpdated = updateItems(this, this._solidItems, time, isUpdated) && isUpdated;
            isUpdated = updateItems(this, this._translucentItems, time, isUpdated)&& isUpdated;
        }

        return isUpdated;
    };

    function getBoundingSphere(items, updater, result) {
        var length = items.length;
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (item.contains(updater)){
                return item.getBoundingSphere(updater, result);
            }
        }
        return BoundingSphereState.FAILED;
    }

    StaticGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {
        var boundingSphere = getBoundingSphere(this._solidItems, updater, result);
        if (boundingSphere === BoundingSphereState.FAILED) {
            return getBoundingSphere(this._translucentItems, updater, result);
        }
        return boundingSphere;
    };

    function removeAllPrimitives(items) {
        var length = items.length;
        for (var i = 0; i < length; i++) {
            items[i].destroy();
        }
        items.length = 0;
    }

    StaticGeometryColorBatch.prototype.removeAllPrimitives = function() {
        removeAllPrimitives(this._solidItems);
        removeAllPrimitives(this._translucentItems);
    };

    return StaticGeometryColorBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/Primitive */ "./node_modules/terriajs-cesium/Source/Scene/Primitive.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Cartesian3,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        OffsetGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        Primitive,
        BoundingSphereState,
        ColorMaterialProperty,
        MaterialProperty,
        Property) {
    'use strict';

    var distanceDisplayConditionScratch = new DistanceDisplayCondition();
    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();

    function Batch(primitives, appearanceType, materialProperty, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {
        this.primitives = primitives;
        this.appearanceType = appearanceType;
        this.materialProperty = materialProperty;
        this.depthFailAppearanceType = depthFailAppearanceType;
        this.depthFailMaterialProperty = depthFailMaterialProperty;
        this.closed = closed;
        this.shadows = shadows;
        this.updaters = new AssociativeArray();
        this.createPrimitive = true;
        this.primitive = undefined;
        this.oldPrimitive = undefined;
        this.geometry = new AssociativeArray();
        this.material = undefined;
        this.depthFailMaterial = undefined;
        this.updatersWithAttributes = new AssociativeArray();
        this.attributes = new AssociativeArray();
        this.invalidated = false;
        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);
        this.subscriptions = new AssociativeArray();
        this.showsUpdated = new AssociativeArray();
    }

    Batch.prototype.onMaterialChanged = function() {
        this.invalidated = true;
    };

    Batch.prototype.isMaterial = function(updater) {
        var material = this.materialProperty;
        var updaterMaterial = updater.fillMaterialProperty;
        var depthFailMaterial = this.depthFailMaterialProperty;
        var updaterDepthFailMaterial = updater.depthFailMaterialProperty;

        if (updaterMaterial === material && updaterDepthFailMaterial === depthFailMaterial) {
            return true;
        }
        var equals = defined(material) && material.equals(updaterMaterial);
        equals = ((!defined(depthFailMaterial) && !defined(updaterDepthFailMaterial)) || (defined(depthFailMaterial) && depthFailMaterial.equals(updaterDepthFailMaterial))) && equals;
        return equals;
    };

    Batch.prototype.add = function(time, updater) {
        var id = updater.id;
        this.updaters.set(id, updater);
        this.geometry.set(id, updater.createFillGeometryInstance(time));
        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)  || !Property.isConstant(updater.terrainOffsetProperty)) {
            this.updatersWithAttributes.set(id, updater);
        } else {
            var that = this;
            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {
                if (propertyName === 'isShowing') {
                    that.showsUpdated.set(updater.id, updater);
                }
            }));
        }
        this.createPrimitive = true;
    };

    Batch.prototype.remove = function(updater) {
        var id = updater.id;
        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
        if (this.updaters.remove(id)) {
            this.updatersWithAttributes.remove(id);
            var unsubscribe = this.subscriptions.get(id);
            if (defined(unsubscribe)) {
                unsubscribe();
                this.subscriptions.remove(id);
                this.showsUpdated.remove(id);
            }
            return true;
        }
        return false;
    };

    var colorScratch = new Color();

    Batch.prototype.update = function(time) {
        var isUpdated = true;
        var primitive = this.primitive;
        var primitives = this.primitives;
        var geometries = this.geometry.values;
        var i;

        if (this.createPrimitive) {
            var geometriesLength = geometries.length;
            if (geometriesLength > 0) {
                if (defined(primitive)) {
                    if (!defined(this.oldPrimitive)) {
                        this.oldPrimitive = primitive;
                    } else {
                        primitives.remove(primitive);
                    }
                }

                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);

                var depthFailAppearance;
                if (defined(this.depthFailMaterialProperty)) {
                    this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);
                    depthFailAppearance = new this.depthFailAppearanceType({
                        material : this.depthFailMaterial,
                        translucent : this.depthFailMaterial.isTranslucent(),
                        closed : this.closed
                    });
                }

                primitive = new Primitive({
                    show : false,
                    asynchronous : true,
                    geometryInstances : geometries,
                    appearance : new this.appearanceType({
                        material : this.material,
                        translucent : this.material.isTranslucent(),
                        closed : this.closed
                    }),
                    depthFailAppearance : depthFailAppearance,
                    shadows : this.shadows
                });

                primitives.add(primitive);
                isUpdated = false;
            } else {
                if (defined(primitive)) {
                    primitives.remove(primitive);
                    primitive = undefined;
                }
                var oldPrimitive = this.oldPrimitive;
                if (defined(oldPrimitive)) {
                    primitives.remove(oldPrimitive);
                    this.oldPrimitive = undefined;
                }
            }

            this.attributes.removeAll();
            this.primitive = primitive;
            this.createPrimitive = false;
        } else if (defined(primitive) && primitive.ready) {
            primitive.show = true;
            if (defined(this.oldPrimitive)) {
                primitives.remove(this.oldPrimitive);
                this.oldPrimitive = undefined;
            }

            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);
            this.primitive.appearance.material = this.material;

            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {
                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);
                this.primitive.depthFailAppearance.material = this.depthFailMaterial;
            }

            var updatersWithAttributes = this.updatersWithAttributes.values;
            var length = updatersWithAttributes.length;
            for (i = 0; i < length; i++) {
                var updater = updatersWithAttributes[i];
                var entity = updater.entity;
                var instance = this.geometry.get(updater.id);

                var attributes = this.attributes.get(instance.id.id);
                if (!defined(attributes)) {
                    attributes = primitive.getGeometryInstanceAttributes(instance.id);
                    this.attributes.set(instance.id.id, attributes);
                }

                if (defined(this.depthFailAppearanceType) && this.depthFailMaterialProperty instanceof ColorMaterialProperty && !updater.depthFailMaterialProperty.isConstant) {
                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;
                    var depthFailColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);
                    if (!Color.equals(attributes._lastDepthFailColor, depthFailColor)) {
                        attributes._lastDepthFailColor = Color.clone(depthFailColor, attributes._lastDepthFailColor);
                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthFailColor, attributes.depthFailColor);
                    }
                }

                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));
                var currentShow = attributes.show[0] === 1;
                if (show !== currentShow) {
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }

                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;
                if (!Property.isConstant(distanceDisplayConditionProperty)) {
                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);
                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {
                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);
                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                    }
                }

                var offsetProperty = updater.terrainOffsetProperty;
                if (!Property.isConstant(offsetProperty)) {
                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);
                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {
                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);
                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);
                    }
                }
            }

            this.updateShows(primitive);
        } else if (defined(primitive) && !primitive.ready) {
            isUpdated = false;
        }
        return isUpdated;
    };

    Batch.prototype.updateShows = function(primitive) {
        var showsUpdated = this.showsUpdated.values;
        var length = showsUpdated.length;
        for (var i = 0; i < length; i++) {
            var updater = showsUpdated[i];
            var entity = updater.entity;
            var instance = this.geometry.get(updater.id);

            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }

            var show = entity.isShowing;
            var currentShow = attributes.show[0] === 1;
            if (show !== currentShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                instance.attributes.show.value[0] = attributes.show[0];
            }
        }
        this.showsUpdated.removeAll();
    };

    Batch.prototype.contains = function(updater) {
        return this.updaters.contains(updater.id);
    };

    Batch.prototype.getBoundingSphere = function(updater, result) {
        var primitive = this.primitive;
        if (!primitive.ready) {
            return BoundingSphereState.PENDING;
        }
        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);
        if (!defined(attributes) || !defined(attributes.boundingSphere) ||
            (defined(attributes.show) && attributes.show[0] === 0)) {
            return BoundingSphereState.FAILED;
        }
        attributes.boundingSphere.clone(result);
        return BoundingSphereState.DONE;
    };

    Batch.prototype.destroy = function() {
        var primitive = this.primitive;
        var primitives = this.primitives;
        if (defined(primitive)) {
            primitives.remove(primitive);
        }
        var oldPrimitive = this.oldPrimitive;
        if (defined(oldPrimitive)) {
            primitives.remove(oldPrimitive);
        }
        this.removeMaterialSubscription();
    };

    /**
     * @private
     */
    function StaticGeometryPerMaterialBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {
        this._items = [];
        this._primitives = primitives;
        this._appearanceType = appearanceType;
        this._depthFailAppearanceType = depthFailAppearanceType;
        this._closed = closed;
        this._shadows = shadows;
    }

    StaticGeometryPerMaterialBatch.prototype.add = function(time, updater) {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (item.isMaterial(updater)) {
                item.add(time, updater);
                return;
            }
        }
        var batch = new Batch(this._primitives, this._appearanceType, updater.fillMaterialProperty, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);
        batch.add(time, updater);
        items.push(batch);
    };

    StaticGeometryPerMaterialBatch.prototype.remove = function(updater) {
        var items = this._items;
        var length = items.length;
        for (var i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.remove(updater)) {
                if (item.updaters.length === 0) {
                    items.splice(i, 1);
                    item.destroy();
                }
                break;
            }
        }
    };

    StaticGeometryPerMaterialBatch.prototype.update = function(time) {
        var i;
        var items = this._items;
        var length = items.length;

        for (i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.invalidated) {
                items.splice(i, 1);
                var updaters = item.updaters.values;
                var updatersLength = updaters.length;
                for (var h = 0; h < updatersLength; h++) {
                    this.add(time, updaters[h]);
                }
                item.destroy();
            }
        }

        var isUpdated = true;
        for (i = 0; i < items.length; i++) {
            isUpdated = items[i].update(time) && isUpdated;
        }
        return isUpdated;
    };

    StaticGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (item.contains(updater)){
                return item.getBoundingSphere(updater, result);
            }
        }
        return BoundingSphereState.FAILED;
    };

    StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            items[i].destroy();
        }
        this._items.length = 0;
    };

    return StaticGeometryPerMaterialBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Color,
        defined,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        GroundPrimitive,
        BoundingSphereState,
        Property) {
    'use strict';

    var colorScratch = new Color();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();
    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();

    function Batch(primitives, classificationType, color, key, zIndex) {
        this.primitives = primitives;
        this.zIndex = zIndex;
        this.classificationType = classificationType;
        this.color = color;
        this.key = key;
        this.createPrimitive = false;
        this.waitingOnCreate = false;
        this.primitive = undefined;
        this.oldPrimitive = undefined;
        this.geometry = new AssociativeArray();
        this.updaters = new AssociativeArray();
        this.updatersWithAttributes = new AssociativeArray();
        this.attributes = new AssociativeArray();
        this.subscriptions = new AssociativeArray();
        this.showsUpdated = new AssociativeArray();
        this.itemsToRemove = [];
        this.isDirty = false;
    }

    Batch.prototype.add = function(updater, instance) {
        var id = updater.id;
        this.createPrimitive = true;
        this.geometry.set(id, instance);
        this.updaters.set(id, updater);
        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {
            this.updatersWithAttributes.set(id, updater);
        } else {
            var that = this;
            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {
                if (propertyName === 'isShowing') {
                    that.showsUpdated.set(updater.id, updater);
                }
            }));
        }
    };

    Batch.prototype.remove = function(updater) {
        var id = updater.id;
        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
        if (this.updaters.remove(id)) {
            this.updatersWithAttributes.remove(id);
            var unsubscribe = this.subscriptions.get(id);
            if (defined(unsubscribe)) {
                unsubscribe();
                this.subscriptions.remove(id);
                this.showsUpdated.remove(id);
            }
            return true;
        }
        return false;
    };

    var scratchArray = new Array(4);

    Batch.prototype.update = function(time) {
        var isUpdated = true;
        var removedCount = 0;
        var primitive = this.primitive;
        var primitives = this.primitives;
        var i;

        if (this.createPrimitive) {
            var geometries = this.geometry.values;
            var geometriesLength = geometries.length;
            if (geometriesLength > 0) {
                if (defined(primitive)) {
                    if (!defined(this.oldPrimitive)) {
                        this.oldPrimitive = primitive;
                    } else {
                        primitives.remove(primitive);
                    }
                }

                primitive = new GroundPrimitive({
                    show : false,
                    asynchronous : true,
                    geometryInstances : geometries,
                    classificationType : this.classificationType
                });
                primitives.add(primitive, this.zIndex);
                isUpdated = false;
            } else {
                if (defined(primitive)) {
                    primitives.remove(primitive);
                    primitive = undefined;
                }
                var oldPrimitive = this.oldPrimitive;
                if (defined(oldPrimitive)) {
                    primitives.remove(oldPrimitive);
                    this.oldPrimitive = undefined;
                }
            }

            this.attributes.removeAll();
            this.primitive = primitive;
            this.createPrimitive = false;
            this.waitingOnCreate = true;
        } else if (defined(primitive) && primitive.ready) {
            primitive.show = true;
            if (defined(this.oldPrimitive)) {
                primitives.remove(this.oldPrimitive);
                this.oldPrimitive = undefined;
            }
            var updatersWithAttributes = this.updatersWithAttributes.values;
            var length = updatersWithAttributes.length;
            var waitingOnCreate = this.waitingOnCreate;
            for (i = 0; i < length; i++) {
                var updater = updatersWithAttributes[i];
                var instance = this.geometry.get(updater.id);

                var attributes = this.attributes.get(instance.id.id);
                if (!defined(attributes)) {
                    attributes = primitive.getGeometryInstanceAttributes(instance.id);
                    this.attributes.set(instance.id.id, attributes);
                }

                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {
                    var colorProperty = updater.fillMaterialProperty.color;
                    var fillColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);

                    if (!Color.equals(attributes._lastColor, fillColor)) {
                        attributes._lastColor = Color.clone(fillColor, attributes._lastColor);
                        var color = this.color;
                        var newColor = fillColor.toBytes(scratchArray);
                        if (color[0] !== newColor[0] || color[1] !== newColor[1] ||
                            color[2] !== newColor[2] || color[3] !== newColor[3]) {
                           this.itemsToRemove[removedCount++] = updater;
                        }
                    }
                }

                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));
                var currentShow = attributes.show[0] === 1;
                if (show !== currentShow) {
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }

                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;
                if (!Property.isConstant(distanceDisplayConditionProperty)) {
                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);
                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {
                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);
                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                    }
                }
            }

            this.updateShows(primitive);
            this.waitingOnCreate = false;
        } else if (defined(primitive) && !primitive.ready) {
            isUpdated = false;
        }
        this.itemsToRemove.length = removedCount;
        return isUpdated;
    };

    Batch.prototype.updateShows = function(primitive) {
        var showsUpdated = this.showsUpdated.values;
        var length = showsUpdated.length;
        for (var i = 0; i < length; i++) {
            var updater = showsUpdated[i];
            var instance = this.geometry.get(updater.id);

            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }

            var show = updater.entity.isShowing;
            var currentShow = attributes.show[0] === 1;
            if (show !== currentShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                instance.attributes.show.value[0] = attributes.show[0];
            }
        }
        this.showsUpdated.removeAll();
    };

    Batch.prototype.contains = function(updater) {
        return this.updaters.contains(updater.id);
    };

    Batch.prototype.getBoundingSphere = function(updater, result) {
        var primitive = this.primitive;
        if (!primitive.ready) {
            return BoundingSphereState.PENDING;
        }

        var bs = primitive.getBoundingSphere(updater.entity);
        if (!defined(bs)) {
            return BoundingSphereState.FAILED;
        }

        bs.clone(result);
        return BoundingSphereState.DONE;
    };

    Batch.prototype.removeAllPrimitives = function() {
        var primitives = this.primitives;

        var primitive = this.primitive;
        if (defined(primitive)) {
            primitives.remove(primitive);
            this.primitive = undefined;
            this.geometry.removeAll();
            this.updaters.removeAll();
        }

        var oldPrimitive = this.oldPrimitive;
        if (defined(oldPrimitive)) {
            primitives.remove(oldPrimitive);
            this.oldPrimitive = undefined;
        }
    };

    /**
     * @private
     */
    function StaticGroundGeometryColorBatch(primitives, classificationType) {
        this._batches = new AssociativeArray();
        this._primitives = primitives;
        this._classificationType = classificationType;
    }

    StaticGroundGeometryColorBatch.prototype.add = function(time, updater) {
        var instance = updater.createFillGeometryInstance(time);
        var batches = this._batches;
        // color and zIndex are batch breakers, so we'll use that for the key
        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);
        var batchKey = new Uint32Array(instance.attributes.color.value.buffer)[0] + ':' + zIndex;
        var batch;
        if (batches.contains(batchKey)) {
            batch = batches.get(batchKey);
        } else {
            batch = new Batch(this._primitives, this._classificationType, instance.attributes.color.value, batchKey, zIndex);
            batches.set(batchKey, batch);
        }
        batch.add(updater, instance);
        return batch;
    };

    StaticGroundGeometryColorBatch.prototype.remove = function(updater) {
        var batchesArray = this._batches.values;
        var count = batchesArray.length;
        for (var i = 0; i < count; ++i) {
            if (batchesArray[i].remove(updater)) {
                return;
            }
        }
    };

    StaticGroundGeometryColorBatch.prototype.update = function(time) {
        var i;
        var updater;

        //Perform initial update
        var isUpdated = true;
        var batches = this._batches;
        var batchesArray = batches.values;
        var batchCount = batchesArray.length;
        for (i = 0; i < batchCount; ++i) {
            isUpdated = batchesArray[i].update(time) && isUpdated;
        }

        //If any items swapped between batches we need to move them
        for (i = 0; i < batchCount; ++i) {
            var oldBatch = batchesArray[i];
            var itemsToRemove = oldBatch.itemsToRemove;
            var itemsToMoveLength = itemsToRemove.length;
            for (var j = 0; j < itemsToMoveLength; j++) {
                updater = itemsToRemove[j];
                oldBatch.remove(updater);
                var newBatch = this.add(time, updater);
                oldBatch.isDirty = true;
                newBatch.isDirty = true;
            }
        }

        //If we moved anything around, we need to re-build the primitive and remove empty batches
        var batchesArrayCopy = batchesArray.slice();
        var batchesCopyCount = batchesArrayCopy.length;
        for (i = 0; i < batchesCopyCount; ++i) {
            var batch = batchesArrayCopy[i];
            if (batch.isDirty) {
                isUpdated = batchesArrayCopy[i].update(time) && isUpdated;
                batch.isDirty = false;
            }
            if (batch.geometry.length === 0) {
                batches.remove(batch.key);
            }
        }

        return isUpdated;
    };

    StaticGroundGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {
        var batchesArray = this._batches.values;
        var batchCount = batchesArray.length;
        for (var i = 0; i < batchCount; ++i) {
            var batch = batchesArray[i];
            if (batch.contains(updater)) {
                return batch.getBoundingSphere(updater, result);
            }
        }

        return BoundingSphereState.FAILED;
    };

    StaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function() {
        var batchesArray = this._batches.values;
        var batchCount = batchesArray.length;
        for (var i = 0; i < batchCount; ++i) {
            batchesArray[i].removeAllPrimitives();
        }
    };

    return StaticGroundGeometryColorBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/RectangleCollisionChecker */ "./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js"),
        __webpack_require__(/*! ../Scene/ClassificationType */ "./node_modules/terriajs-cesium/Source/Scene/ClassificationType.js"),
        __webpack_require__(/*! ../Scene/GroundPrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPrimitive.js"),
        __webpack_require__(/*! ../Scene/ShadowVolumeAppearance */ "./node_modules/terriajs-cesium/Source/Scene/ShadowVolumeAppearance.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        ColorGeometryInstanceAttribute,
        defined,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        RectangleCollisionChecker,
        ClassificationType,
        GroundPrimitive,
        ShadowVolumeAppearance,
        BoundingSphereState,
        ColorMaterialProperty,
        MaterialProperty,
        Property) {
    'use strict';

    var distanceDisplayConditionScratch = new DistanceDisplayCondition();
    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();

    // Encapsulates a Primitive and all the entities that it represents.
    function Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {
        this.primitives = primitives; // scene level primitive collection
        this.classificationType = classificationType;
        this.appearanceType = appearanceType;
        this.materialProperty = materialProperty;
        this.updaters = new AssociativeArray();
        this.createPrimitive = true;
        this.primitive = undefined; // a GroundPrimitive encapsulating all the entities
        this.oldPrimitive = undefined;
        this.geometry = new AssociativeArray();
        this.material = undefined;
        this.updatersWithAttributes = new AssociativeArray();
        this.attributes = new AssociativeArray();
        this.invalidated = false;
        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);
        this.subscriptions = new AssociativeArray();
        this.showsUpdated = new AssociativeArray();
        this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;
        this.zIndex = zIndex;
        this.rectangleCollisionCheck = new RectangleCollisionChecker();
    }

    Batch.prototype.onMaterialChanged = function() {
        this.invalidated = true;
    };

    Batch.prototype.overlapping = function(rectangle) {
        return this.rectangleCollisionCheck.collides(rectangle);
    };

    // Check if the given updater's material is compatible with this batch
    Batch.prototype.isMaterial = function(updater) {
        var material = this.materialProperty;
        var updaterMaterial = updater.fillMaterialProperty;

        if (updaterMaterial === material ||
            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {
            return true;
        }
        return defined(material) && material.equals(updaterMaterial);
    };

    Batch.prototype.add = function(time, updater, geometryInstance) {
        var id = updater.id;
        this.updaters.set(id, updater);
        this.geometry.set(id, geometryInstance);
        this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);
        // Updaters with dynamic attributes must be tracked separately, may exit the batch
        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {
            this.updatersWithAttributes.set(id, updater);
        } else {
            var that = this;
            // Listen for show changes. These will be synchronized in updateShows.
            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {
                if (propertyName === 'isShowing') {
                    that.showsUpdated.set(updater.id, updater);
                }
            }));
        }
        this.createPrimitive = true;
    };

    Batch.prototype.remove = function(updater) {
        var id = updater.id;
        var geometryInstance = this.geometry.get(id);
        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
        if (this.updaters.remove(id)) {
            this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);
            this.updatersWithAttributes.remove(id);
            var unsubscribe = this.subscriptions.get(id);
            if (defined(unsubscribe)) {
                unsubscribe();
                this.subscriptions.remove(id);
            }
            return true;
        }
        return false;
    };

    Batch.prototype.update = function(time) {
        var isUpdated = true;
        var primitive = this.primitive;
        var primitives = this.primitives;
        var geometries = this.geometry.values;
        var i;

        if (this.createPrimitive) {
            var geometriesLength = geometries.length;
            if (geometriesLength > 0) {
                if (defined(primitive)) {
                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.
                    if (!defined(this.oldPrimitive)) {
                        this.oldPrimitive = primitive;
                    } else {
                        // For if the new primitive changes again before it is ready.
                        primitives.remove(primitive);
                    }
                }

                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);

                primitive = new GroundPrimitive({
                    show : false,
                    asynchronous : true,
                    geometryInstances : geometries,
                    appearance : new this.appearanceType({
                        material : this.material
                        // translucent and closed properties overridden
                    }),
                    classificationType : this.classificationType
                });

                primitives.add(primitive, this.zIndex);
                isUpdated = false;
            } else {
                if (defined(primitive)) {
                    primitives.remove(primitive);
                    primitive = undefined;
                }
                var oldPrimitive = this.oldPrimitive;
                if (defined(oldPrimitive)) {
                    primitives.remove(oldPrimitive);
                    this.oldPrimitive = undefined;
                }
            }

            this.attributes.removeAll();
            this.primitive = primitive;
            this.createPrimitive = false;
        } else if (defined(primitive) && primitive.ready) {
            primitive.show = true;
            if (defined(this.oldPrimitive)) {
                primitives.remove(this.oldPrimitive);
                this.oldPrimitive = undefined;
            }

            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);
            this.primitive.appearance.material = this.material;

            var updatersWithAttributes = this.updatersWithAttributes.values;
            var length = updatersWithAttributes.length;
            for (i = 0; i < length; i++) {
                var updater = updatersWithAttributes[i];
                var entity = updater.entity;
                var instance = this.geometry.get(updater.id);

                var attributes = this.attributes.get(instance.id.id);
                if (!defined(attributes)) {
                    attributes = primitive.getGeometryInstanceAttributes(instance.id);
                    this.attributes.set(instance.id.id, attributes);
                }

                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));
                var currentShow = attributes.show[0] === 1;
                if (show !== currentShow) {
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }

                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;
                if (!Property.isConstant(distanceDisplayConditionProperty)) {
                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);
                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {
                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);
                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                    }
                }
            }

            this.updateShows(primitive);
        } else if (defined(primitive) && !primitive.ready) {
            isUpdated = false;
        }
        return isUpdated;
    };

    Batch.prototype.updateShows = function(primitive) {
        var showsUpdated = this.showsUpdated.values;
        var length = showsUpdated.length;
        for (var i = 0; i < length; i++) {
            var updater = showsUpdated[i];
            var entity = updater.entity;
            var instance = this.geometry.get(updater.id);

            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }

            var show = entity.isShowing;
            var currentShow = attributes.show[0] === 1;
            if (show !== currentShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                instance.attributes.show.value[0] = attributes.show[0];
            }
        }
        this.showsUpdated.removeAll();
    };

    Batch.prototype.contains = function(updater) {
        return this.updaters.contains(updater.id);
    };

    Batch.prototype.getBoundingSphere = function(updater, result) {
        var primitive = this.primitive;
        if (!primitive.ready) {
            return BoundingSphereState.PENDING;
        }
        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);
        if (!defined(attributes) || !defined(attributes.boundingSphere) ||
            (defined(attributes.show) && attributes.show[0] === 0)) {
            return BoundingSphereState.FAILED;
        }
        attributes.boundingSphere.clone(result);
        return BoundingSphereState.DONE;
    };

    Batch.prototype.destroy = function() {
        var primitive = this.primitive;
        var primitives = this.primitives;
        if (defined(primitive)) {
            primitives.remove(primitive);
        }
        var oldPrimitive = this.oldPrimitive;
        if (defined(oldPrimitive)) {
            primitives.remove(oldPrimitive);
        }
        this.removeMaterialSubscription();
    };

    /**
     * @private
     */
    function StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {
        this._items = [];
        this._primitives = primitives;
        this._classificationType = classificationType;
        this._appearanceType = appearanceType;
    }

    StaticGroundGeometryPerMaterialBatch.prototype.add = function(time, updater) {
        var items = this._items;
        var length = items.length;
        var geometryInstance = updater.createFillGeometryInstance(time);
        var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);
        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);
        // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:
        // * compatible material (same material or same color)
        // * same type of texture coordinates (spherical vs. planar)
        // * conservatively non-overlapping with any entities in the existing batch
        for (var i = 0; i < length; ++i) {
            var item = items[i];
            if (item.isMaterial(updater) &&
                item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates &&
                item.zIndex === zIndex &&
                !item.overlapping(geometryInstance.geometry.rectangle)) {
                item.add(time, updater, geometryInstance);
                return;
            }
        }
        // If a compatible batch wasn't found, create a new batch.
        var batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);
        batch.add(time, updater, geometryInstance);
        items.push(batch);
    };

    StaticGroundGeometryPerMaterialBatch.prototype.remove = function(updater) {
        var items = this._items;
        var length = items.length;
        for (var i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.remove(updater)) {
                if (item.updaters.length === 0) {
                    items.splice(i, 1);
                    item.destroy();
                }
                break;
            }
        }
    };

    StaticGroundGeometryPerMaterialBatch.prototype.update = function(time) {
        var i;
        var items = this._items;
        var length = items.length;

        for (i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.invalidated) {
                items.splice(i, 1);
                var updaters = item.updaters.values;
                var updatersLength = updaters.length;
                for (var h = 0; h < updatersLength; h++) {
                    this.add(time, updaters[h]);
                }
                item.destroy();
            }
        }

        var isUpdated = true;
        for (i = 0; i < items.length; i++) {
            isUpdated = items[i].update(time) && isUpdated;
        }
        return isUpdated;
    };

    StaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (item.contains(updater)){
                return item.getBoundingSphere(updater, result);
            }
        }
        return BoundingSphereState.FAILED;
    };

    StaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            items[i].destroy();
        }
        this._items.length = 0;
    };

    return StaticGroundGeometryPerMaterialBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/GroundPolylinePrimitive */ "./node_modules/terriajs-cesium/Source/Scene/GroundPolylinePrimitive.js"),
        __webpack_require__(/*! ../Scene/PolylineColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PolylineColorAppearance.js"),
        __webpack_require__(/*! ../Scene/PolylineMaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PolylineMaterialAppearance.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./MaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        defaultValue,
        AssociativeArray,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        GroundPolylinePrimitive,
        PolylineColorAppearance,
        PolylineMaterialAppearance,
        BoundingSphereState,
        ColorMaterialProperty,
        MaterialProperty,
        Property) {
    'use strict';

    var scratchColor = new Color();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();
    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();

    // Encapsulates a Primitive and all the entities that it represents.
    function Batch(orderedGroundPrimitives, classificationType, materialProperty, zIndex, asynchronous) {
        var appearanceType;
        if (materialProperty instanceof ColorMaterialProperty) {
            appearanceType = PolylineColorAppearance;
        } else {
            appearanceType = PolylineMaterialAppearance;
        }

        this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection
        this.classificationType = classificationType;
        this.appearanceType = appearanceType;
        this.materialProperty = materialProperty;
        this.updaters = new AssociativeArray();
        this.createPrimitive = true;
        this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities
        this.oldPrimitive = undefined;
        this.geometry = new AssociativeArray();
        this.material = undefined;
        this.updatersWithAttributes = new AssociativeArray();
        this.attributes = new AssociativeArray();
        this.invalidated = false;
        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);
        this.subscriptions = new AssociativeArray();
        this.showsUpdated = new AssociativeArray();
        this.zIndex = zIndex;

        this._asynchronous = asynchronous;
    }

    Batch.prototype.onMaterialChanged = function() {
        this.invalidated = true;
    };

    // Check if the given updater's material is compatible with this batch
    Batch.prototype.isMaterial = function(updater) {
        var material = this.materialProperty;
        var updaterMaterial = updater.fillMaterialProperty;

        if (updaterMaterial === material ||
            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {
            return true;
        }
        return defined(material) && material.equals(updaterMaterial);
    };

    Batch.prototype.add = function(time, updater, geometryInstance) {
        var id = updater.id;
        this.updaters.set(id, updater);
        this.geometry.set(id, geometryInstance);
        // Updaters with dynamic attributes must be tracked separately, may exit the batch
        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {
            this.updatersWithAttributes.set(id, updater);
        } else {
            var that = this;
            // Listen for show changes. These will be synchronized in updateShows.
            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {
                if (propertyName === 'isShowing') {
                    that.showsUpdated.set(updater.id, updater);
                }
            }));
        }
        this.createPrimitive = true;
    };

    Batch.prototype.remove = function(updater) {
        var id = updater.id;
        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
        if (this.updaters.remove(id)) {
            this.updatersWithAttributes.remove(id);
            var unsubscribe = this.subscriptions.get(id);
            if (defined(unsubscribe)) {
                unsubscribe();
                this.subscriptions.remove(id);
            }
            return true;
        }
        return false;
    };

    Batch.prototype.update = function(time) {
        var isUpdated = true;
        var primitive = this.primitive;
        var orderedGroundPrimitives = this.orderedGroundPrimitives;
        var geometries = this.geometry.values;
        var i;

        if (this.createPrimitive) {
            var geometriesLength = geometries.length;
            if (geometriesLength > 0) {
                if (defined(primitive)) {
                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.
                    if (!defined(this.oldPrimitive)) {
                        this.oldPrimitive = primitive;
                    } else {
                        // For if the new primitive changes again before it is ready.
                        orderedGroundPrimitives.remove(primitive);
                    }
                }

                primitive = new GroundPolylinePrimitive({
                    show : false,
                    asynchronous : this._asynchronous,
                    geometryInstances : geometries,
                    appearance : new this.appearanceType(),
                    classificationType : this.classificationType
                });

                if (this.appearanceType === PolylineMaterialAppearance) {
                    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);
                    primitive.appearance.material = this.material;
                }

                orderedGroundPrimitives.add(primitive, this.zIndex);
                isUpdated = false;
            } else {
                if (defined(primitive)) {
                    orderedGroundPrimitives.remove(primitive);
                    primitive = undefined;
                }
                var oldPrimitive = this.oldPrimitive;
                if (defined(oldPrimitive)) {
                    orderedGroundPrimitives.remove(oldPrimitive);
                    this.oldPrimitive = undefined;
                }
            }

            this.attributes.removeAll();
            this.primitive = primitive;
            this.createPrimitive = false;
        } else if (defined(primitive) && primitive.ready) {
            primitive.show = true;
            if (defined(this.oldPrimitive)) {
                orderedGroundPrimitives.remove(this.oldPrimitive);
                this.oldPrimitive = undefined;
            }

            if (this.appearanceType === PolylineMaterialAppearance) {
                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);
                this.primitive.appearance.material = this.material;
            }
            var updatersWithAttributes = this.updatersWithAttributes.values;
            var length = updatersWithAttributes.length;
            for (i = 0; i < length; i++) {
                var updater = updatersWithAttributes[i];
                var entity = updater.entity;
                var instance = this.geometry.get(updater.id);

                var attributes = this.attributes.get(instance.id.id);
                if (!defined(attributes)) {
                    attributes = primitive.getGeometryInstanceAttributes(instance.id);
                    this.attributes.set(instance.id.id, attributes);
                }

                if (!updater.fillMaterialProperty.isConstant) {
                    var colorProperty = updater.fillMaterialProperty.color;
                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, scratchColor);
                    if (!Color.equals(attributes._lastColor, resultColor)) {
                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);
                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);
                    }
                }

                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));
                var currentShow = attributes.show[0] === 1;
                if (show !== currentShow) {
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }

                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;
                if (!Property.isConstant(distanceDisplayConditionProperty)) {
                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);
                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {
                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);
                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                    }
                }
            }

            this.updateShows(primitive);
        } else if (defined(primitive) && !primitive.ready) {
            isUpdated = false;
        }
        return isUpdated;
    };

    Batch.prototype.updateShows = function(primitive) {
        var showsUpdated = this.showsUpdated.values;
        var length = showsUpdated.length;
        for (var i = 0; i < length; i++) {
            var updater = showsUpdated[i];
            var entity = updater.entity;
            var instance = this.geometry.get(updater.id);

            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }

            var show = entity.isShowing;
            var currentShow = attributes.show[0] === 1;
            if (show !== currentShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                instance.attributes.show.value[0] = attributes.show[0];
            }
        }
        this.showsUpdated.removeAll();
    };

    Batch.prototype.contains = function(updater) {
        return this.updaters.contains(updater.id);
    };

    Batch.prototype.getBoundingSphere = function(updater, result) {
        var primitive = this.primitive;
        if (!primitive.ready) {
            return BoundingSphereState.PENDING;
        }
        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);
        if (!defined(attributes) || !defined(attributes.boundingSphere) ||
            (defined(attributes.show) && attributes.show[0] === 0)) {
            return BoundingSphereState.FAILED;
        }
        attributes.boundingSphere.clone(result);
        return BoundingSphereState.DONE;
    };

    Batch.prototype.destroy = function() {
        var primitive = this.primitive;
        var orderedGroundPrimitives = this.orderedGroundPrimitives;
        if (defined(primitive)) {
            orderedGroundPrimitives.remove(primitive);
        }
        var oldPrimitive = this.oldPrimitive;
        if (defined(oldPrimitive)) {
            orderedGroundPrimitives.remove(oldPrimitive);
        }
        this.removeMaterialSubscription();
    };

    /**
     * @private
     */
    function StaticGroundPolylinePerMaterialBatch(orderedGroundPrimitives, classificationType, asynchronous) {
        this._items = [];
        this._orderedGroundPrimitives = orderedGroundPrimitives;
        this._classificationType = classificationType;
        this._asynchronous = defaultValue(asynchronous, true);
    }

    StaticGroundPolylinePerMaterialBatch.prototype.add = function(time, updater) {
        var items = this._items;
        var length = items.length;
        var geometryInstance = updater.createFillGeometryInstance(time);
        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);
        // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.
        for (var i = 0; i < length; ++i) {
            var item = items[i];
            if (item.isMaterial(updater) &&
                item.zIndex === zIndex) {
                item.add(time, updater, geometryInstance);
                return;
            }
        }
        // If a compatible batch wasn't found, create a new batch.
        var batch = new Batch(this._orderedGroundPrimitives, this._classificationType, updater.fillMaterialProperty, zIndex, this._asynchronous);
        batch.add(time, updater, geometryInstance);
        items.push(batch);
    };

    StaticGroundPolylinePerMaterialBatch.prototype.remove = function(updater) {
        var items = this._items;
        var length = items.length;
        for (var i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.remove(updater)) {
                if (item.updaters.length === 0) {
                    items.splice(i, 1);
                    item.destroy();
                }
                break;
            }
        }
    };

    StaticGroundPolylinePerMaterialBatch.prototype.update = function(time) {
        var i;
        var items = this._items;
        var length = items.length;

        for (i = length - 1; i >= 0; i--) {
            var item = items[i];
            if (item.invalidated) {
                items.splice(i, 1);
                var updaters = item.updaters.values;
                var updatersLength = updaters.length;
                for (var h = 0; h < updatersLength; h++) {
                    this.add(time, updaters[h]);
                }
                item.destroy();
            }
        }

        var isUpdated = true;
        for (i = 0; i < items.length; i++) {
            isUpdated = items[i].update(time) && isUpdated;
        }
        return isUpdated;
    };

    StaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (item.contains(updater)){
                return item.getBoundingSphere(updater, result);
            }
        }
        return BoundingSphereState.FAILED;
    };

    StaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives = function() {
        var items = this._items;
        var length = items.length;
        for (var i = 0; i < length; i++) {
            items[i].destroy();
        }
        this._items.length = 0;
    };

    return StaticGroundPolylinePerMaterialBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/AssociativeArray */ "./node_modules/terriajs-cesium/Source/Core/AssociativeArray.js"),
        __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayCondition */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayCondition.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/OffsetGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/OffsetGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ../Scene/Primitive */ "./node_modules/terriajs-cesium/Source/Scene/Primitive.js"),
        __webpack_require__(/*! ./BoundingSphereState */ "./node_modules/terriajs-cesium/Source/DataSources/BoundingSphereState.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        AssociativeArray,
        Cartesian3,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DistanceDisplayCondition,
        DistanceDisplayConditionGeometryInstanceAttribute,
        OffsetGeometryInstanceAttribute,
        ShowGeometryInstanceAttribute,
        PerInstanceColorAppearance,
        Primitive,
        BoundingSphereState,
        Property) {
    'use strict';

    var colorScratch = new Color();
    var distanceDisplayConditionScratch = new DistanceDisplayCondition();
    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();
    var defaultOffset = Cartesian3.ZERO;
    var offsetScratch = new Cartesian3();

    function Batch(primitives, translucent, width, shadows) {
        this.translucent = translucent;
        this.width = width;
        this.shadows = shadows;
        this.primitives = primitives;
        this.createPrimitive = false;
        this.waitingOnCreate = false;
        this.primitive = undefined;
        this.oldPrimitive = undefined;
        this.geometry = new AssociativeArray();
        this.updaters = new AssociativeArray();
        this.updatersWithAttributes = new AssociativeArray();
        this.attributes = new AssociativeArray();
        this.itemsToRemove = [];
        this.subscriptions = new AssociativeArray();
        this.showsUpdated = new AssociativeArray();
    }
    Batch.prototype.add = function(updater, instance) {
        var id = updater.id;
        this.createPrimitive = true;
        this.geometry.set(id, instance);
        this.updaters.set(id, updater);
        if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {
            this.updatersWithAttributes.set(id, updater);
        } else {
            var that = this;
            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {
                if (propertyName === 'isShowing') {
                    that.showsUpdated.set(updater.id, updater);
                }
            }));
        }
    };

    Batch.prototype.remove = function(updater) {
        var id = updater.id;
        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;
        if (this.updaters.remove(id)) {
            this.updatersWithAttributes.remove(id);
            var unsubscribe = this.subscriptions.get(id);
            if (defined(unsubscribe)) {
                unsubscribe();
                this.subscriptions.remove(id);
                this.showsUpdated.remove(id);
            }
            return true;
        }
        return false;
    };

    Batch.prototype.update = function(time) {
        var isUpdated = true;
        var removedCount = 0;
        var primitive = this.primitive;
        var primitives = this.primitives;
        var i;

        if (this.createPrimitive) {
            var geometries = this.geometry.values;
            var geometriesLength = geometries.length;
            if (geometriesLength > 0) {
                if (defined(primitive)) {
                    if (!defined(this.oldPrimitive)) {
                        this.oldPrimitive = primitive;
                    } else {
                        primitives.remove(primitive);
                    }
                }

                primitive = new Primitive({
                    show : false,
                    asynchronous : true,
                    geometryInstances : geometries,
                    appearance : new PerInstanceColorAppearance({
                        flat : true,
                        translucent : this.translucent,
                        renderState : {
                            lineWidth : this.width
                        }
                    }),
                    shadows : this.shadows
                });

                primitives.add(primitive);
                isUpdated = false;
            } else {
                if (defined(primitive)) {
                    primitives.remove(primitive);
                    primitive = undefined;
                }
                var oldPrimitive = this.oldPrimitive;
                if (defined(oldPrimitive)) {
                    primitives.remove(oldPrimitive);
                    this.oldPrimitive = undefined;
                }
            }

            this.attributes.removeAll();
            this.primitive = primitive;
            this.createPrimitive = false;
            this.waitingOnCreate = true;
        } else if (defined(primitive) && primitive.ready) {
            primitive.show = true;
            if (defined(this.oldPrimitive)) {
                primitives.remove(this.oldPrimitive);
                this.oldPrimitive = undefined;
            }

            var updatersWithAttributes = this.updatersWithAttributes.values;
            var length = updatersWithAttributes.length;
            var waitingOnCreate = this.waitingOnCreate;
            for (i = 0; i < length; i++) {
                var updater = updatersWithAttributes[i];
                var instance = this.geometry.get(updater.id);

                var attributes = this.attributes.get(instance.id.id);
                if (!defined(attributes)) {
                    attributes = primitive.getGeometryInstanceAttributes(instance.id);
                    this.attributes.set(instance.id.id, attributes);
                }

                if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {
                    var outlineColorProperty = updater.outlineColorProperty;
                    var outlineColor = Property.getValueOrDefault(outlineColorProperty, time, Color.WHITE, colorScratch);
                    if (!Color.equals(attributes._lastColor, outlineColor)) {
                        attributes._lastColor = Color.clone(outlineColor, attributes._lastColor);
                        attributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, attributes.color);
                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {
                            this.itemsToRemove[removedCount++] = updater;
                        }
                    }
                }

                var show = updater.entity.isShowing && (updater.hasConstantOutline || updater.isOutlineVisible(time));
                var currentShow = attributes.show[0] === 1;
                if (show !== currentShow) {
                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                }

                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;
                if (!Property.isConstant(distanceDisplayConditionProperty)) {
                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);
                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {
                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);
                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
                    }
                }

                var offsetProperty = updater.terrainOffsetProperty;
                if (!Property.isConstant(offsetProperty)) {
                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);
                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {
                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);
                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);
                    }
                }
            }

            this.updateShows(primitive);
            this.waitingOnCreate = false;
        } else if (defined(primitive) && !primitive.ready) {
            isUpdated = false;
        }

        this.itemsToRemove.length = removedCount;
        return isUpdated;
    };

    Batch.prototype.updateShows = function(primitive) {
        var showsUpdated = this.showsUpdated.values;
        var length = showsUpdated.length;
        for (var i = 0; i < length; i++) {
            var updater = showsUpdated[i];
            var instance = this.geometry.get(updater.id);

            var attributes = this.attributes.get(instance.id.id);
            if (!defined(attributes)) {
                attributes = primitive.getGeometryInstanceAttributes(instance.id);
                this.attributes.set(instance.id.id, attributes);
            }

            var show = updater.entity.isShowing;
            var currentShow = attributes.show[0] === 1;
            if (show !== currentShow) {
                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);
                instance.attributes.show.value[0] = attributes.show[0];
            }
        }
        this.showsUpdated.removeAll();
    };

    Batch.prototype.contains = function(updater) {
        return this.updaters.contains(updater.id);
    };

    Batch.prototype.getBoundingSphere = function(updater, result) {
        var primitive = this.primitive;
        if (!primitive.ready) {
            return BoundingSphereState.PENDING;
        }
        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);
        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//
            (defined(attributes.show) && attributes.show[0] === 0)) {
            return BoundingSphereState.FAILED;
        }
        attributes.boundingSphere.clone(result);
        return BoundingSphereState.DONE;
    };

    Batch.prototype.removeAllPrimitives = function() {
        var primitives = this.primitives;

        var primitive = this.primitive;
        if (defined(primitive)) {
            primitives.remove(primitive);
            this.primitive = undefined;
            this.geometry.removeAll();
            this.updaters.removeAll();
        }

        var oldPrimitive = this.oldPrimitive;
        if (defined(oldPrimitive)) {
            primitives.remove(oldPrimitive);
            this.oldPrimitive = undefined;
        }
    };

    /**
     * @private
     */
    function StaticOutlineGeometryBatch(primitives, scene, shadows) {
        this._primitives = primitives;
        this._scene = scene;
        this._shadows = shadows;
        this._solidBatches = new AssociativeArray();
        this._translucentBatches = new AssociativeArray();
    }
    StaticOutlineGeometryBatch.prototype.add = function(time, updater) {
        var instance = updater.createOutlineGeometryInstance(time);
        var width = this._scene.clampLineWidth(updater.outlineWidth);
        var batches;
        var batch;
        if (instance.attributes.color.value[3] === 255) {
            batches = this._solidBatches;
            batch = batches.get(width);
            if (!defined(batch)) {
                batch = new Batch(this._primitives, false, width, this._shadows);
                batches.set(width, batch);
            }
            batch.add(updater, instance);
        } else {
            batches = this._translucentBatches;
            batch = batches.get(width);
            if (!defined(batch)) {
                batch = new Batch(this._primitives, true, width, this._shadows);
                batches.set(width, batch);
            }
            batch.add(updater, instance);
        }
    };

    StaticOutlineGeometryBatch.prototype.remove = function(updater) {
        var i;

        var solidBatches = this._solidBatches.values;
        var solidBatchesLength = solidBatches.length;
        for (i = 0; i < solidBatchesLength; i++) {
            if (solidBatches[i].remove(updater)) {
                return;
            }
        }

        var translucentBatches = this._translucentBatches.values;
        var translucentBatchesLength = translucentBatches.length;
        for (i = 0; i < translucentBatchesLength; i++) {
            if (translucentBatches[i].remove(updater)) {
                return;
            }
        }
    };

    StaticOutlineGeometryBatch.prototype.update = function(time) {
        var i;
        var x;
        var updater;
        var batch;
        var solidBatches = this._solidBatches.values;
        var solidBatchesLength = solidBatches.length;
        var translucentBatches = this._translucentBatches.values;
        var translucentBatchesLength = translucentBatches.length;
        var itemsToRemove;
        var isUpdated = true;
        var needUpdate = false;

        do {
            needUpdate = false;
            for (x = 0; x < solidBatchesLength; x++) {
                batch = solidBatches[x];
                //Perform initial update
                isUpdated = batch.update(time);

                //If any items swapped between solid/translucent, we need to
                //move them between batches
                itemsToRemove = batch.itemsToRemove;
                var solidsToMoveLength = itemsToRemove.length;
                if (solidsToMoveLength > 0) {
                    needUpdate = true;
                    for (i = 0; i < solidsToMoveLength; i++) {
                        updater = itemsToRemove[i];
                        batch.remove(updater);
                        this.add(time, updater);
                    }
                }
            }
            for (x = 0; x < translucentBatchesLength; x++) {
                batch = translucentBatches[x];
                //Perform initial update
                isUpdated = batch.update(time);

                //If any items swapped between solid/translucent, we need to
                //move them between batches
                itemsToRemove = batch.itemsToRemove;
                var translucentToMoveLength = itemsToRemove.length;
                if (translucentToMoveLength > 0) {
                    needUpdate = true;
                    for (i = 0; i < translucentToMoveLength; i++) {
                        updater = itemsToRemove[i];
                        batch.remove(updater);
                        this.add(time, updater);
                    }
                }
            }
        } while (needUpdate);

        return isUpdated;
    };

    StaticOutlineGeometryBatch.prototype.getBoundingSphere = function(updater, result) {
        var i;

        var solidBatches = this._solidBatches.values;
        var solidBatchesLength = solidBatches.length;
        for (i = 0; i < solidBatchesLength; i++) {
            var solidBatch = solidBatches[i];
            if (solidBatch.contains(updater)){
                return solidBatch.getBoundingSphere(updater, result);
            }
        }

        var translucentBatches = this._translucentBatches.values;
        var translucentBatchesLength = translucentBatches.length;
        for (i = 0; i < translucentBatchesLength; i++) {
            var translucentBatch = translucentBatches[i];
            if (translucentBatch.contains(updater)){
                return translucentBatch.getBoundingSphere(updater, result);
            }
        }

        return BoundingSphereState.FAILED;
    };

    StaticOutlineGeometryBatch.prototype.removeAllPrimitives = function() {
        var i;

        var solidBatches = this._solidBatches.values;
        var solidBatchesLength = solidBatches.length;
        for (i = 0; i < solidBatchesLength; i++) {
            solidBatches[i].removeAllPrimitives();
        }

        var translucentBatches = this._translucentBatches.values;
        var translucentBatchesLength = translucentBatches.length;
        for (i = 0; i < translucentBatchesLength; i++) {
            translucentBatches[i].removeAllPrimitives();
        }
    };

    return StaticOutlineGeometryBatch;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(/*! ../Core/Cartesian3 */ "./node_modules/terriajs-cesium/Source/Core/Cartesian3.js"),
    __webpack_require__(/*! ../Core/Cartographic */ "./node_modules/terriajs-cesium/Source/Core/Cartographic.js"),
    __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
    __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
    __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
    __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
    __webpack_require__(/*! ../Core/Event */ "./node_modules/terriajs-cesium/Source/Core/Event.js"),
    __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
    __webpack_require__(/*! ../Core/Math */ "./node_modules/terriajs-cesium/Source/Core/Math.js"),
    __webpack_require__(/*! ../Scene/HeightReference */ "./node_modules/terriajs-cesium/Source/Scene/HeightReference.js"),
    __webpack_require__(/*! ../Scene/SceneMode */ "./node_modules/terriajs-cesium/Source/Scene/SceneMode.js"),
    __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
    Cartesian3,
    Cartographic,
    Check,
    defined,
    defineProperties,
    destroyObject,
    Event,
    Iso8601,
    CesiumMath,
    HeightReference,
    SceneMode,
    Property) {
    'use strict';

    var scratchPosition = new Cartesian3();
    var scratchCarto = new Cartographic();

    /**
     * @private
     */
    function TerrainOffsetProperty(scene, positionProperty, heightReferenceProperty, extrudedHeightReferenceProperty) {
        

        this._scene = scene;
        this._heightReference = heightReferenceProperty;
        this._extrudedHeightReference = extrudedHeightReferenceProperty;
        this._positionProperty = positionProperty;

        this._position = new Cartesian3();
        this._cartographicPosition = new Cartographic();
        this._normal = new Cartesian3();

        this._definitionChanged = new Event();
        this._terrainHeight = 0;
        this._removeCallbackFunc = undefined;
        this._removeEventListener = undefined;
        this._removeModeListener = undefined;

        var that = this;
        if (defined(scene.globe)) {
            this._removeEventListener = scene.terrainProviderChanged.addEventListener(function() {
                that._updateClamping();
            });
            this._removeModeListener = scene.morphComplete.addEventListener(function() {
                that._updateClamping();
            });
        }

        if (positionProperty.isConstant) {
            var position = positionProperty.getValue(Iso8601.MINIMUM_VALUE, scratchPosition);
            if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {
                return;
            }
            this._position = Cartesian3.clone(position, this._position);

            this._updateClamping();

            this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);
        }
    }

    defineProperties(TerrainOffsetProperty.prototype, {
        /**
         * Gets a value indicating if this property is constant.
         * @memberof TerrainOffsetProperty.prototype
         *
         * @type {Boolean}
         * @readonly
         */
        isConstant : {
            get : function() {
                return false;
            }
        },
        /**
         * Gets the event that is raised whenever the definition of this property changes.
         * @memberof TerrainOffsetProperty.prototype
         *
         * @type {Event}
         * @readonly
         */
        definitionChanged : {
            get : function() {
                return this._definitionChanged;
            }
        }
    });

    /**
     * @private
     */
    TerrainOffsetProperty.prototype._updateClamping = function() {
        if (defined(this._removeCallbackFunc)) {
            this._removeCallbackFunc();
        }

        var scene = this._scene;
        var globe = scene.globe;
        var position = this._position;

        if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {
            this._terrainHeight = 0;
            return;
        }
        var ellipsoid = globe.ellipsoid;
        var surface = globe._surface;

        var that = this;
        var cartographicPosition = ellipsoid.cartesianToCartographic(position, this._cartographicPosition);
        var height = globe.getHeight(cartographicPosition);
        if (defined(height)) {
            this._terrainHeight = height;
        } else {
            this._terrainHeight = 0;
        }

        function updateFunction(clampedPosition) {
            if (scene.mode === SceneMode.SCENE3D) {
                var carto = ellipsoid.cartesianToCartographic(clampedPosition, scratchCarto);
                that._terrainHeight = carto.height;
            } else {
                that._terrainHeight = clampedPosition.x;
            }
            that.definitionChanged.raiseEvent();
        }
        this._removeCallbackFunc = surface.updateHeight(cartographicPosition, updateFunction);
    };

    /**
     * Gets the height relative to the terrain based on the positions.
     *
     * @returns {Cartesian3} The offset
     */
    TerrainOffsetProperty.prototype.getValue = function(time, result) {
        var heightReference = Property.getValueOrDefault(this._heightReference, time, HeightReference.NONE);
        var extrudedHeightReference = Property.getValueOrDefault(this._extrudedHeightReference, time, HeightReference.NONE);

        if (heightReference === HeightReference.NONE && extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND) {
            this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);
            return Cartesian3.clone(Cartesian3.ZERO, result);
        }

        if (this._positionProperty.isConstant) {
            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);
        }

        var scene = this._scene;
        var position = this._positionProperty.getValue(time, scratchPosition);
        if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {
            return Cartesian3.clone(Cartesian3.ZERO, result);
        }

        if (Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)) {
            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);
        }

        this._position = Cartesian3.clone(position, this._position);

        this._updateClamping();

        var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);
        return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);
    };

    TerrainOffsetProperty.prototype.isDestroyed = function() {
        return false;
    };

    TerrainOffsetProperty.prototype.destroy = function() {
        if (defined(this._removeEventListener)) {
            this._removeEventListener();
        }
        if (defined(this._removeModeListener)) {
            this._removeModeListener();
        }
        if (defined(this._removeCallbackFunc)) {
            this._removeCallbackFunc();
        }
        return destroyObject(this);
    };

    /**
     * A function which creates one or more providers.
     * @callback TerrainOffsetProperty~PositionFunction
     * @param {JulianDate} time The clock time at which to retrieve the position
     * @param {Cartesian3} result The result position
     * @returns {Cartesian3} The position at which to do the terrain height check
     */

    return TerrainOffsetProperty;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js":
/*!********************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
        __webpack_require__(/*! ../Core/Color */ "./node_modules/terriajs-cesium/Source/Core/Color.js"),
        __webpack_require__(/*! ../Core/ColorGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ColorGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
        __webpack_require__(/*! ../Core/DistanceDisplayConditionGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/GeometryInstance */ "./node_modules/terriajs-cesium/Source/Core/GeometryInstance.js"),
        __webpack_require__(/*! ../Core/Iso8601 */ "./node_modules/terriajs-cesium/Source/Core/Iso8601.js"),
        __webpack_require__(/*! ../Core/ShowGeometryInstanceAttribute */ "./node_modules/terriajs-cesium/Source/Core/ShowGeometryInstanceAttribute.js"),
        __webpack_require__(/*! ../Core/WallGeometry */ "./node_modules/terriajs-cesium/Source/Core/WallGeometry.js"),
        __webpack_require__(/*! ../Core/WallOutlineGeometry */ "./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js"),
        __webpack_require__(/*! ../Scene/MaterialAppearance */ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js"),
        __webpack_require__(/*! ../Scene/PerInstanceColorAppearance */ "./node_modules/terriajs-cesium/Source/Scene/PerInstanceColorAppearance.js"),
        __webpack_require__(/*! ./ColorMaterialProperty */ "./node_modules/terriajs-cesium/Source/DataSources/ColorMaterialProperty.js"),
        __webpack_require__(/*! ./DynamicGeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./Property */ "./node_modules/terriajs-cesium/Source/DataSources/Property.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        Check,
        Color,
        ColorGeometryInstanceAttribute,
        defined,
        DeveloperError,
        DistanceDisplayConditionGeometryInstanceAttribute,
        GeometryInstance,
        Iso8601,
        ShowGeometryInstanceAttribute,
        WallGeometry,
        WallOutlineGeometry,
        MaterialAppearance,
        PerInstanceColorAppearance,
        ColorMaterialProperty,
        DynamicGeometryUpdater,
        GeometryUpdater,
        Property) {
    'use strict';

    var scratchColor = new Color();

    function WallGeometryOptions(entity) {
        this.id = entity;
        this.vertexFormat = undefined;
        this.positions = undefined;
        this.minimumHeights = undefined;
        this.maximumHeights = undefined;
        this.granularity = undefined;
    }

    /**
     * A {@link GeometryUpdater} for walls.
     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
     * @alias WallGeometryUpdater
     * @constructor
     *
     * @param {Entity} entity The entity containing the geometry to be visualized.
     * @param {Scene} scene The scene where visualization is taking place.
     */
    function WallGeometryUpdater(entity, scene) {
        GeometryUpdater.call(this, {
            entity : entity,
            scene : scene,
            geometryOptions : new WallGeometryOptions(entity),
            geometryPropertyName : 'wall',
            observedPropertyNames : ['availability', 'wall']
        });

        this._onEntityPropertyChanged(entity, 'wall', entity.wall, undefined);
    }

    if (defined(Object.create)) {
        WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);
        WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;
    }

    /**
     * Creates the geometry instance which represents the fill of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent a filled geometry.
     */
    WallGeometryUpdater.prototype.createFillGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);

        var attributes;

        var color;
        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);
        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);
        if (this._materialProperty instanceof ColorMaterialProperty) {
            var currentColor;
            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {
                currentColor = this._materialProperty.color.getValue(time, scratchColor);
            }
            if (!defined(currentColor)) {
                currentColor = Color.WHITE;
            }
            color = ColorGeometryInstanceAttribute.fromColor(currentColor);
            attributes = {
                show : show,
                distanceDisplayCondition : distanceDisplayConditionAttribute,
                color : color
            };
        } else {
            attributes = {
                show : show,
                distanceDisplayCondition : distanceDisplayConditionAttribute
            };
        }

        return new GeometryInstance({
            id : entity,
            geometry : new WallGeometry(this._options),
            attributes : attributes
        });
    };

    /**
     * Creates the geometry instance which represents the outline of the geometry.
     *
     * @param {JulianDate} time The time to use when retrieving initial attribute values.
     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
     *
     * @exception {DeveloperError} This instance does not represent an outlined geometry.
     */
    WallGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {
        

        var entity = this._entity;
        var isAvailable = entity.isAvailable(time);
        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);
        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);

        return new GeometryInstance({
            id : entity,
            geometry : new WallOutlineGeometry(this._options),
            attributes : {
                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),
                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),
                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
            }
        });
    };

    WallGeometryUpdater.prototype._isHidden = function(entity, wall) {
        return !defined(wall.positions) || GeometryUpdater.prototype._isHidden.call(this, entity, wall);
    };

    WallGeometryUpdater.prototype._getIsClosed = function(options) {
        return false;
    };

    WallGeometryUpdater.prototype._isDynamic = function(entity, wall) {
        return !wall.positions.isConstant || //
               !Property.isConstant(wall.minimumHeights) || //
               !Property.isConstant(wall.maximumHeights) || //
               !Property.isConstant(wall.outlineWidth) || //
               !Property.isConstant(wall.granularity);
    };

    WallGeometryUpdater.prototype._setStaticOptions = function(entity, wall) {
        var minimumHeights = wall.minimumHeights;
        var maximumHeights = wall.maximumHeights;
        var granularity = wall.granularity;
        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;

        var options = this._options;
        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;
        options.positions = wall.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);
        options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;
        options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;
        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;
    };

    WallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;

    /**
     * @private
     */
    function DynamicWallGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {
        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);
    }

    if (defined(Object.create)) {
        DynamicWallGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);
        DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;
    }

    DynamicWallGeometryUpdater.prototype._isHidden = function(entity, wall, time) {
        return  !defined(this._options.positions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time);
    };

    DynamicWallGeometryUpdater.prototype._setOptions = function(entity, wall, time) {
        var options = this._options;
        options.positions = Property.getValueOrUndefined(wall.positions, time, options.positions);
        options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);
        options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);
        options.granularity = Property.getValueOrUndefined(wall.granularity, time);
    };

    return WallGeometryUpdater;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ./CallbackProperty */ "./node_modules/terriajs-cesium/Source/DataSources/CallbackProperty.js"),
        __webpack_require__(/*! ./GeometryUpdater */ "./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js"),
        __webpack_require__(/*! ./TerrainOffsetProperty */ "./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        defaultValue,
        defined,
        CallbackProperty,
        GeometryUpdater,
        TerrainOffsetProperty) {
    'use strict';

    function heightReferenceOnEntityPropertyChanged(entity, propertyName, newValue, oldValue) {
        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);
        if (this._observedPropertyNames.indexOf(propertyName) === -1) {
            return;
        }

        var geometry = this._entity[this._geometryPropertyName];
        if (!defined(geometry)) {
            return;
        }

        if (defined(this._terrainOffsetProperty)) {
            this._terrainOffsetProperty.destroy();
            this._terrainOffsetProperty = undefined;
        }

        var heightReferenceProperty = geometry.heightReference;

        if (defined(heightReferenceProperty)) {
            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);
            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty);
        }
    }

    return heightReferenceOnEntityPropertyChanged;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js":
/*!*************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
        __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
        __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
        __webpack_require__(/*! ../Core/freezeObject */ "./node_modules/terriajs-cesium/Source/Core/freezeObject.js"),
        __webpack_require__(/*! ../Core/VertexFormat */ "./node_modules/terriajs-cesium/Source/Core/VertexFormat.js"),
        __webpack_require__(/*! ../Shaders/Appearances/AllMaterialAppearanceFS */ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js"),
        __webpack_require__(/*! ../Shaders/Appearances/AllMaterialAppearanceVS */ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js"),
        __webpack_require__(/*! ../Shaders/Appearances/BasicMaterialAppearanceFS */ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js"),
        __webpack_require__(/*! ../Shaders/Appearances/BasicMaterialAppearanceVS */ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js"),
        __webpack_require__(/*! ../Shaders/Appearances/TexturedMaterialAppearanceFS */ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js"),
        __webpack_require__(/*! ../Shaders/Appearances/TexturedMaterialAppearanceVS */ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js"),
        __webpack_require__(/*! ./Appearance */ "./node_modules/terriajs-cesium/Source/Scene/Appearance.js"),
        __webpack_require__(/*! ./Material */ "./node_modules/terriajs-cesium/Source/Scene/Material.js")
    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
        defaultValue,
        defined,
        defineProperties,
        freezeObject,
        VertexFormat,
        AllMaterialAppearanceFS,
        AllMaterialAppearanceVS,
        BasicMaterialAppearanceFS,
        BasicMaterialAppearanceVS,
        TexturedMaterialAppearanceFS,
        TexturedMaterialAppearanceVS,
        Appearance,
        Material) {
    'use strict';

    /**
     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)
     * that supports shading with materials.
     *
     * @alias MaterialAppearance
     * @constructor
     *
     * @param {Object} [options] Object with the following properties:
     * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
     * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
     * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.
     * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.
     * @param {MaterialAppearance.MaterialSupport} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.
     * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.
     * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
     * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
     * @param {RenderState} [options.renderState] Optional render state to override the default render state.
     *
     * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}
     *
     * @example
     * var primitive = new Cesium.Primitive({
     *   geometryInstances : new Cesium.GeometryInstance({
     *     geometry : new Cesium.WallGeometry({
            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,
     *       // ...
     *     })
     *   }),
     *   appearance : new Cesium.MaterialAppearance({
     *     material : Cesium.Material.fromType('Color'),
     *     faceForward : true
     *   })
     *
     * });
     */
    function MaterialAppearance(options) {
        options = defaultValue(options, defaultValue.EMPTY_OBJECT);

        var translucent = defaultValue(options.translucent, true);
        var closed = defaultValue(options.closed, false);
        var materialSupport = defaultValue(options.materialSupport, MaterialAppearance.MaterialSupport.TEXTURED);

        /**
         * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}
         * properties, this is not read-only, so an appearance's material can change on the fly.
         *
         * @type Material
         *
         * @default {@link Material.ColorType}
         *
         * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
         */
        this.material = (defined(options.material)) ? options.material : Material.fromType(Material.ColorType);

        /**
         * When <code>true</code>, the geometry is expected to appear translucent.
         *
         * @type {Boolean}
         *
         * @default true
         */
        this.translucent = translucent;

        this._vertexShaderSource = defaultValue(options.vertexShaderSource, materialSupport.vertexShaderSource);
        this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, materialSupport.fragmentShaderSource);
        this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);
        this._closed = closed;

        // Non-derived members

        this._materialSupport = materialSupport;
        this._vertexFormat = materialSupport.vertexFormat;
        this._flat = defaultValue(options.flat, false);
        this._faceForward = defaultValue(options.faceForward, !closed);
    }

    defineProperties(MaterialAppearance.prototype, {
        /**
         * The GLSL source code for the vertex shader.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {String}
         * @readonly
         */
        vertexShaderSource : {
            get : function() {
                return this._vertexShaderSource;
            }
        },

        /**
         * The GLSL source code for the fragment shader.  The full fragment shader
         * source is built procedurally taking into account {@link MaterialAppearance#material},
         * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
         * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {String}
         * @readonly
         */
        fragmentShaderSource : {
            get : function() {
                return this._fragmentShaderSource;
            }
        },

        /**
         * The WebGL fixed-function state to use when rendering the geometry.
         * <p>
         * The render state can be explicitly defined when constructing a {@link MaterialAppearance}
         * instance, or it is set implicitly via {@link MaterialAppearance#translucent}
         * and {@link MaterialAppearance#closed}.
         * </p>
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {Object}
         * @readonly
         */
        renderState : {
            get : function() {
                return this._renderState;
            }
        },

        /**
         * When <code>true</code>, the geometry is expected to be closed so
         * {@link MaterialAppearance#renderState} has backface culling enabled.
         * If the viewer enters the geometry, it will not be visible.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {Boolean}
         * @readonly
         *
         * @default false
         */
        closed : {
            get : function() {
                return this._closed;
            }
        },

        /**
         * The type of materials supported by this instance.  This impacts the required
         * {@link VertexFormat} and the complexity of the vertex and fragment shaders.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {MaterialAppearance.MaterialSupport}
         * @readonly
         *
         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}
         */
        materialSupport : {
            get : function() {
                return this._materialSupport;
            }
        },

        /**
         * The {@link VertexFormat} that this appearance instance is compatible with.
         * A geometry can have more vertex attributes and still be compatible - at a
         * potential performance cost - but it can't have less.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type VertexFormat
         * @readonly
         *
         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}
         */
        vertexFormat : {
            get : function() {
                return this._vertexFormat;
            }
        },

        /**
         * When <code>true</code>, flat shading is used in the fragment shader,
         * which means lighting is not taking into account.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {Boolean}
         * @readonly
         *
         * @default false
         */
        flat : {
            get : function() {
                return this._flat;
            }
        },

        /**
         * When <code>true</code>, the fragment shader flips the surface normal
         * as needed to ensure that the normal faces the viewer to avoid
         * dark spots.  This is useful when both sides of a geometry should be
         * shaded like {@link WallGeometry}.
         *
         * @memberof MaterialAppearance.prototype
         *
         * @type {Boolean}
         * @readonly
         *
         * @default true
         */
        faceForward : {
            get : function() {
                return this._faceForward;
            }
        }
    });

    /**
     * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},
     * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},
     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
     *
     * @function
     *
     * @returns {String} The full GLSL fragment shader source.
     */
    MaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;

    /**
     * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.
     *
     * @function
     *
     * @returns {Boolean} <code>true</code> if the appearance is translucent.
     */
    MaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;

    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     *
     * @function
     *
     * @returns {Object} The render state.
     */
    MaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;

    /**
     * Determines the type of {@link Material} that is supported by a
     * {@link MaterialAppearance} instance.  This is a trade-off between
     * flexibility (a wide array of materials) and memory/performance
     * (required vertex format and GLSL shader complexity.
     * @exports MaterialAppearance.MaterialSupport
     */
    MaterialAppearance.MaterialSupport = {
        /**
         * Only basic materials, which require just <code>position</code> and
         * <code>normal</code> vertex attributes, are supported.
         *
         * @constant
         */
        BASIC : freezeObject({
            vertexFormat : VertexFormat.POSITION_AND_NORMAL,
            vertexShaderSource : BasicMaterialAppearanceVS,
            fragmentShaderSource : BasicMaterialAppearanceFS
        }),
        /**
         * Materials with textures, which require <code>position</code>,
         * <code>normal</code>, and <code>st</code> vertex attributes,
         * are supported.  The vast majority of materials fall into this category.
         *
         * @constant
         */
        TEXTURED : freezeObject({
            vertexFormat : VertexFormat.POSITION_NORMAL_AND_ST,
            vertexShaderSource : TexturedMaterialAppearanceVS,
            fragmentShaderSource : TexturedMaterialAppearanceFS
        }),
        /**
         * All materials, including those that work in tangent space, are supported.
         * This requires <code>position</code>, <code>normal</code>, <code>st</code>,
         * <code>tangent</code>, and <code>bitangent</code> vertex attributes.
         *
         * @constant
         */
        ALL : freezeObject({
            vertexFormat : VertexFormat.ALL,
            vertexShaderSource : AllMaterialAppearanceVS,
            fragmentShaderSource : AllMaterialAppearanceFS
        })
    };

    return MaterialAppearance;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(/*! ../Core/defaultValue */ "./node_modules/terriajs-cesium/Source/Core/defaultValue.js"),
    __webpack_require__(/*! ../Core/defined */ "./node_modules/terriajs-cesium/Source/Core/defined.js"),
    __webpack_require__(/*! ../Core/defineProperties */ "./node_modules/terriajs-cesium/Source/Core/defineProperties.js"),
    __webpack_require__(/*! ../Core/destroyObject */ "./node_modules/terriajs-cesium/Source/Core/destroyObject.js"),
    __webpack_require__(/*! ../Core/Check */ "./node_modules/terriajs-cesium/Source/Core/Check.js"),
    __webpack_require__(/*! ../Core/DeveloperError */ "./node_modules/terriajs-cesium/Source/Core/DeveloperError.js"),
    __webpack_require__(/*! ./PrimitiveCollection */ "./node_modules/terriajs-cesium/Source/Scene/PrimitiveCollection.js")
], __WEBPACK_AMD_DEFINE_RESULT__ = (function(
    defaultValue,
    defined,
    defineProperties,
    destroyObject,
    Check,
    DeveloperError,
    PrimitiveCollection) {
    'use strict';

    /**
     * A primitive collection for helping maintain the order or ground primitives based on a z-index
     *
     * @private
     */
    function OrderedGroundPrimitiveCollection() {
        this._length = 0;
        this._collections = {};
        this._collectionsArray = [];

        this.show = true;
    }

    defineProperties(OrderedGroundPrimitiveCollection.prototype, {
        /**
         * Gets the number of primitives in the collection.
         *
         * @memberof OrderedGroundPrimitiveCollection.prototype
         *
         * @type {Number}
         * @readonly
         */
        length : {
            get : function() {
                return this._length;
            }
        }
    });

    /**
     * Adds a primitive to the collection.
     *
     * @param {GroundPrimitive} primitive The primitive to add.
     * @param {Number} [zIndex = 0] The index of the primitive
     * @returns {GroundPrimitive} The primitive added to the collection.
     */
    OrderedGroundPrimitiveCollection.prototype.add = function(primitive, zIndex) {
        

        zIndex = defaultValue(zIndex, 0);
        var collection = this._collections[zIndex];
        if (!defined(collection)) {
            collection = new PrimitiveCollection({ destroyPrimitives: false });
            collection._zIndex = zIndex;
            this._collections[zIndex] = collection;
            var array = this._collectionsArray;
            var i = 0;
            while (i < array.length && array[i]._zIndex < zIndex) {
                i++;
            }
            array.splice(i, 0, collection);
        }

        collection.add(primitive);
        this._length++;
        primitive._zIndex = zIndex;

        return primitive;
    };

    /**
     * Adjusts the z-index
     * @param {GroundPrimitive} primitive
     * @param {Number} zIndex
     */
    OrderedGroundPrimitiveCollection.prototype.set = function(primitive, zIndex) {
        

        if (zIndex === primitive._zIndex) {
            return primitive;
        }

        this.remove(primitive, true);
        this.add(primitive, zIndex);

        return primitive;
    };

    /**
     * Removes a primitive from the collection.
     *
     * @param {Object} primitive The primitive to remove.
     * @param {Boolean} [doNotDestroy = false]
     * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
     */
    OrderedGroundPrimitiveCollection.prototype.remove = function(primitive, doNotDestroy) {
        if (this.contains(primitive)) {
            var index = primitive._zIndex;
            var collection = this._collections[index];
            var result;
            if (doNotDestroy) {
                result = collection.remove(primitive);
            } else {
                result = collection.removeAndDestroy(primitive);
            }

            if (result) {
                this._length--;
            }

            if (collection.length === 0) {
                this._collectionsArray.splice(this._collectionsArray.indexOf(collection), 1);
                this._collections[index] = undefined;
                collection.destroy();
            }

            return result;
        }

        return false;
    };

    /**
     * Removes all primitives in the collection.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     * @see OrderedGroundPrimitiveCollection#destroyPrimitives
     */
    OrderedGroundPrimitiveCollection.prototype.removeAll = function() {
        var collections = this._collectionsArray;
        for (var i = 0; i < collections.length; i++) {
            var collection = collections[i];
            collection.destroyPrimitives = true;
            collection.destroy();
        }

        this._collections = {};
        this._collectionsArray = [];
        this._length = 0;
    };

    /**
     * Determines if this collection contains a primitive.
     *
     * @param {Object} primitive The primitive to check for.
     * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
     */
    OrderedGroundPrimitiveCollection.prototype.contains = function(primitive) {
        if (!defined(primitive)) {
            return false;
        }
        var collection = this._collections[primitive._zIndex];
        return defined(collection) && collection.contains(primitive);
    };

    /**
     * @private
     */
    OrderedGroundPrimitiveCollection.prototype.update = function(frameState) {
        if (!this.show) {
            return;
        }

        var collections = this._collectionsArray;
        for (var i = 0 ; i < collections.length; i++) {
            collections[i].update(frameState);
        }
    };

    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     *
     * @returns {Boolean} True if this object was destroyed; otherwise, false.
     *
     * @see OrderedGroundPrimitiveCollection#destroy
     */
    OrderedGroundPrimitiveCollection.prototype.isDestroyed = function() {
        return false;
    };

    /**
     * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this
     * collection allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector to destroy this collection.
     * <br /><br />
     * Since destroying a collection destroys all the contained primitives, only destroy a collection
     * when you are sure no other code is still using any of the contained primitives.
     * <br /><br />
     * Once this collection is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     *
     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
     *
     *
     * @example
     * primitives = primitives && primitives.destroy();
     *
     * @see OrderedGroundPrimitiveCollection#isDestroyed
     */
    OrderedGroundPrimitiveCollection.prototype.destroy = function() {
        this.removeAll();
        return destroyObject(this);
    };

    return OrderedGroundPrimitiveCollection;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;//This file is automatically rebuilt by the Cesium build process.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    'use strict';
    return "varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec3 v_tangentEC;\n\
varying vec3 v_bitangentEC;\n\
varying vec2 v_st;\n\
\n\
void main()\n\
{\n\
    vec3 positionToEyeEC = -v_positionEC;\n\
    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\n\
\n\
    vec3 normalEC = normalize(v_normalEC);\n\
#ifdef FACE_FORWARD\n\
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
#endif\n\
\n\
    czm_materialInput materialInput;\n\
    materialInput.normalEC = normalEC;\n\
    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n\
    materialInput.positionToEyeEC = positionToEyeEC;\n\
    materialInput.st = v_st;\n\
    czm_material material = czm_getMaterial(materialInput);\n\
\n\
#ifdef FLAT\n\
    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
#else\n\
    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n\
#endif\n\
}\n\
";
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;//This file is automatically rebuilt by the Cesium build process.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    'use strict';
    return "attribute vec3 position3DHigh;\n\
attribute vec3 position3DLow;\n\
attribute vec3 normal;\n\
attribute vec3 tangent;\n\
attribute vec3 bitangent;\n\
attribute vec2 st;\n\
attribute float batchId;\n\
\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec3 v_tangentEC;\n\
varying vec3 v_bitangentEC;\n\
varying vec2 v_st;\n\
\n\
void main()\n\
{\n\
    vec4 p = czm_computePosition();\n\
\n\
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n\
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n\
    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\n\
    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\n\
    v_st = st;\n\
\n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
}\n\
";
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;//This file is automatically rebuilt by the Cesium build process.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    'use strict';
    return "varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
\n\
void main()\n\
{\n\
    vec3 positionToEyeEC = -v_positionEC;\n\
\n\
    vec3 normalEC = normalize(v_normalEC);\n\
#ifdef FACE_FORWARD\n\
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
#endif\n\
\n\
    czm_materialInput materialInput;\n\
    materialInput.normalEC = normalEC;\n\
    materialInput.positionToEyeEC = positionToEyeEC;\n\
    czm_material material = czm_getMaterial(materialInput);\n\
\n\
#ifdef FLAT\n\
    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
#else\n\
    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n\
#endif\n\
}\n\
";
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;//This file is automatically rebuilt by the Cesium build process.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    'use strict';
    return "attribute vec3 position3DHigh;\n\
attribute vec3 position3DLow;\n\
attribute vec3 normal;\n\
attribute float batchId;\n\
\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
\n\
void main()\n\
{\n\
    vec4 p = czm_computePosition();\n\
\n\
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n\
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n\
\n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
}\n\
";
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;//This file is automatically rebuilt by the Cesium build process.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    'use strict';
    return "varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec2 v_st;\n\
\n\
void main()\n\
{\n\
    vec3 positionToEyeEC = -v_positionEC;\n\
\n\
    vec3 normalEC = normalize(v_normalEC);\n\
#ifdef FACE_FORWARD\n\
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
#endif\n\
\n\
    czm_materialInput materialInput;\n\
    materialInput.normalEC = normalEC;\n\
    materialInput.positionToEyeEC = positionToEyeEC;\n\
    materialInput.st = v_st;\n\
    czm_material material = czm_getMaterial(materialInput);\n\
\n\
#ifdef FLAT\n\
    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
#else\n\
    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\n\
#endif\n\
}\n\
";
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;//This file is automatically rebuilt by the Cesium build process.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    'use strict';
    return "attribute vec3 position3DHigh;\n\
attribute vec3 position3DLow;\n\
attribute vec3 normal;\n\
attribute vec2 st;\n\
attribute float batchId;\n\
\n\
varying vec3 v_positionEC;\n\
varying vec3 v_normalEC;\n\
varying vec2 v_st;\n\
\n\
void main()\n\
{\n\
    vec4 p = czm_computePosition();\n\
\n\
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n\
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n\
    v_st = st;\n\
\n\
    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
}\n\
";
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
};

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js":
/*!*****************************************************************!*\
  !*** ./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./quickselect */ "./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(quickselect) {
'use strict';

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

return rbush;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })

}]);
//# sourceMappingURL=vendors~3D.TerriaJS-specs.js.map