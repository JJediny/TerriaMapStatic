{"version":3,"sources":["webpack:///./node_modules/terriajs-cesium/Source/Core/DistanceDisplayConditionGeometryInstanceAttribute.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/MaterialAppearance.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CornerType.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/MaterialProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositeProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CompositePositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ReferenceProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GroundGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ScaledPositionProperty.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/heightReferenceOnEntityPropertyChanged.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/TerrainOffsetProperty.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DynamicGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometryLibrary.js","webpack:///./node_modules/terriajs-cesium/Source/Scene/OrderedGroundPrimitiveCollection.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BillboardVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/GeometryVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/AllMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/BasicMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceFS.js","webpack:///./node_modules/terriajs-cesium/Source/Shaders/Appearances/TexturedMaterialAppearanceVS.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/BoxGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CorridorGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CorridorOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/CylinderGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CylinderOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipseGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/EllipseOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/EllipsoidGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PlaneGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PlaneOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolygonGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/CoplanarPolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolygonOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVolumeGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineVolumeOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/RectangleGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryColorBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundGeometryPerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/Core/RectangleCollisionChecker.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/rbush.js","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/quickselect.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticOutlineGeometryBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/WallGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/Core/WallOutlineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/LabelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/ModelVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PathVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PointVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineVisualizer.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/PolylineGeometryUpdater.js","webpack:///./node_modules/terriajs-cesium/Source/Core/PolylineGeometry.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/StaticGroundPolylinePerMaterialBatch.js","webpack:///./node_modules/terriajs-cesium/Source/DataSources/DataSourceDisplay.js"],"names":["ComponentDatatype","defaultValue","defined","defineProperties","DeveloperError","DistanceDisplayConditionGeometryInstanceAttribute","near","far","Number","MAX_VALUE","this","value","Float32Array","prototype","componentDatatype","get","FLOAT","componentsPerAttribute","normalize","fromDistanceDisplayCondition","distanceDisplayCondition","toValue","result","freezeObject","VertexFormat","AllMaterialAppearanceFS","AllMaterialAppearanceVS","BasicMaterialAppearanceFS","BasicMaterialAppearanceVS","TexturedMaterialAppearanceFS","TexturedMaterialAppearanceVS","Appearance","Material","MaterialAppearance","options","EMPTY_OBJECT","translucent","closed","materialSupport","MaterialSupport","TEXTURED","material","fromType","ColorType","_vertexShaderSource","vertexShaderSource","_fragmentShaderSource","fragmentShaderSource","_renderState","getDefaultRenderState","renderState","_closed","_materialSupport","_vertexFormat","vertexFormat","_flat","flat","_faceForward","faceForward","getFragmentShaderSource","isTranslucent","getRenderState","BASIC","POSITION_AND_NORMAL","POSITION_NORMAL_AND_ST","ALL","Check","Color","destroyObject","DistanceDisplayCondition","Event","Iso8601","oneTimeWarning","ClassificationType","ShadowMode","ColorMaterialProperty","ConstantProperty","Entity","Property","defaultMaterial","WHITE","defaultShow","defaultFill","defaultOutline","defaultOutlineColor","BLACK","defaultShadows","DISABLED","defaultDistanceDisplayCondition","defaultClassificationType","BOTH","GeometryUpdater","entity","geometryPropertyName","_entity","_scene","scene","_fillEnabled","_isClosed","_onTerrain","_dynamic","_outlineEnabled","_geometryChanged","_showProperty","undefined","_materialProperty","_showOutlineProperty","_outlineColorProperty","_outlineWidth","_shadowsProperty","_distanceDisplayConditionProperty","_classificationTypeProperty","_options","geometryOptions","_geometryPropertyName","_id","id","_observedPropertyNames","observedPropertyNames","_supportsMaterialsforEntitiesOnTerrain","supportsMaterialsforEntitiesOnTerrain","fillEnabled","hasConstantFill","availability","isConstant","_fillProperty","fillMaterialProperty","outlineEnabled","hasConstantOutline","outlineColorProperty","outlineWidth","shadowsProperty","distanceDisplayConditionProperty","classificationTypeProperty","isDynamic","isClosed","onTerrain","geometryChanged","isOutlineVisible","time","visible","isAvailable","getValue","isFilled","createFillGeometryInstance","throwInstantiationError","createOutlineGeometryInstance","isDestroyed","destroy","_isHidden","geometry","show","MINIMUM_VALUE","_isOnTerrain","_getIsClosed","_isDynamic","_setStaticOptions","_onEntityPropertyChanged","propertyName","newValue","oldValue","indexOf","fillProperty","fill","outlineProperty","outline","raiseEvent","outlineColor","shadows","classificationType","geometryOutlines","createDynamicUpdater","primitives","groundPrimitives","constructor","DynamicGeometryUpdater","BoundingSphere","GroundPrimitive","PerInstanceColorAppearance","Primitive","BoundingSphereState","MaterialProperty","geometryUpdater","orderedGroundPrimitives","_primitives","_orderedGroundPrimitives","_primitive","_outlinePrimitive","_geometryUpdater","_material","isShowing","getValueOrDefault","_setOptions","update","remove","removeAndDestroy","appearance","isColorAppearance","VERTEX_FORMAT","add","geometryInstances","asynchronous","getValueOrUndefined","zIndex","fillInstance","attributes","color","outlineInstance","lineWidth","clampLineWidth","getBoundingSphere","primitive","outlinePrimitive","ready","getGeometryInstanceAttributes","boundingSphere","clone","DONE","PENDING","FAILED","ROUNDED","MITERED","BEVELED","definitionChanged","getType","equals","materialProperty","type","uniforms","EventHelper","TimeIntervalCollection","CompositeProperty","_eventHelper","_definitionChanged","_intervals","changedEvent","addEventListener","_intervalsChanged","isEmpty","intervals","innerProperty","findDataForIntervalContainingDate","other","property","eventHelper","callback","items","removeAll","length","i","interval","data","subscribeAll","ReferenceFrame","CompositePositionProperty","referenceFrame","_referenceFrame","FIXED","_composite","_raiseDefinitionChanged","set","getValueInReferenceFrame","RuntimeError","resolve","that","targetProperty","_targetProperty","_resolveProperty","entityIsResolved","_resolveEntity","targetEntity","_targetCollection","getById","_targetId","ReferenceProperty","_onTargetEntityDefinitionChanged","_targetEntity","resolveEntity","names","_targetPropertyNames","join","targetCollection","targetId","targetPropertyNames","collectionChanged","_onCollectionChanged","resolvedProperty","fromString","referenceString","identifier","values","inIdentifier","isEscaped","token","c","charAt","push","otherNames","name","collection","added","removed","removeEventListener","ApproximateTerrainHeights","Cartesian3","GeometryOffsetAttribute","HeightReference","CallbackProperty","TerrainOffsetProperty","defaultZIndex","GroundGeometryUpdater","call","_zIndex","_terrainOffsetProperty","Object","create","terrainOffsetProperty","height","extrudedHeight","isSupported","_computeCenter","geometryZIndex","heightReferenceProperty","heightReference","extrudedHeightReferenceProperty","extrudedHeightReference","centerPosition","bind","getGeometryHeight","CLAMP_TO_GROUND","NONE","geometryHeightReference","getGeometryExtrudedHeight","geometryExtrudedHeightReference","computeGeometryOffsetAttribute","n","RELATIVE_TO_GROUND","TOP","Ellipsoid","ScaledPositionProperty","_value","_removeSubscription","setValue","WGS84","scaleToGeodeticSurface","Cartesian2","Cartesian4","Cartographic","CornerType","EllipsoidTangentPlane","CesiumMath","Matrix3","Matrix4","PolylinePipeline","Quaternion","Transforms","scratch2Array","scratchCartesian1","scratchCartesian2","scratchCartesian3","scratchCartesian4","scratchCartesian5","scratchCartesian6","scratchCartesian7","scratchCartesian8","scratchCartesian9","scratch1","scratch2","PolylineVolumeGeometryLibrary","cartographic","subdivideHeights","points","h0","h1","granularity","p0","p1","angleBetween","numPoints","Math","ceil","heights","Array","heightPerVertex","h","nextScratch","prevScratch","negativeX","transform","translation","rotationZ","scaleMatrix","IDENTITY","westScratch","finalPosScratch","heightCartesian","addPosition","center","left","shape","finalPositions","ellipsoid","xScalar","repeat","west","finalPosition","eastNorthUpToFixedFrame","multiplyByPointAsVector","angle","start","end","position","tangentPlane","next","projectPointOntoPlane","prev","x","y","computeRotationAngle","fromRotationZ","z","multiplyTransformation","fromRotationTranslation","scale","j","fromArray","multiplyByVector","multiplyByPoint","centerScratch","addPositions","centers","convertShapeTo3D","shape2D","boundingRectangle","index","xOffset","width","yOffset","quaterion","startPointScratch","rotMatrix","computeRoundCorner","pivot","startPoint","endPoint","cornerType","leftIsOutside","duplicatePoints","m","subtract","toRadians","fromQuaternion","fromAxisAngle","negate","removeDuplicatesFromShape","shapePositions","cleanedPositions","i0","i1","v0","v1","angleIsGreaterThanPi","forward","backward","scratchForwardProjection","scratchBackwardProjection","computePositions","positions","_ellipsoid","pos","cartesianToCartographic","scaleToSurface","_granularity","_cornerType","shapeForSides","point","convertShapeTo3DDuplicate","shapeForEnds","heightOffset","ends","cornerDirection","surfaceNormal","previousPosition","nextPosition","geodeticSurfaceNormal","cross","subdividedHeights","forwardProjection","multiplyByScalar","dot","backwardProjection","equalsEpsilon","abs","EPSILON7","scalar","max","magnitude","generateArc","posLength","combinedPositions","Float64Array","SceneMode","scratchPosition","scratchCarto","positionProperty","_heightReference","_extrudedHeightReference","_positionProperty","_position","_cartographicPosition","_normal","_terrainHeight","_removeCallbackFunc","_removeEventListener","_removeModeListener","globe","terrainProviderChanged","_updateClamping","morphComplete","ZERO","surface","_surface","cartographicPosition","getHeight","updateHeight","clampedPosition","mode","SCENE3D","carto","EPSILON10","normal","CorridorGeometryLibrary","scratch3","scratch4","scaleArray2","cartesian1","cartesian2","cartesian3","cartesian4","cartesian5","cartesian6","cartesian7","cartesian8","cartesian9","cartesian10","cornerPoint","size","array","computeMiteredCorner","leftCornerDirection","lastPoint","addShiftedPositions","calculatedPositions","rightPositions","leftPositions","scaledLeft","scaledRight","rightIndex","leftIndex","rightPos","leftPos","addAttribute","attribute","front","back","params","saveAttributes","previousPos","calculatedLefts","calculatedNormals","endPositions","corners","leftEdge","firstEndCap","midpoint","rightEdge","addEndCaps","lefts","normals","CylinderGeometryLibrary","topRadius","bottomRadius","slices","topZ","bottomZ","twoSlice","tbIndex","bottomOffset","topOffset","TWO_PI","cos","sin","bottomX","bottomY","topX","topY","AssociativeArray","DynamicGeometryBatch","_dynamicUpdaters","updater","dynamicUpdater","geometries","len","removeAllPrimitives","EllipseGeometryLibrary","rotAxis","tempVec","unitQuat","rotMtx","pointOnEllipsoid","theta","rotation","northVec","eastVec","aSqr","ab","bSqr","mag","unitPos","azimuth","cosThetaSquared","sinThetaSquared","sqrt","scratchNormal","raisePositionsToHeight","extrude","i2","extrudedPosition","scaledNormal","unitPosScratch","eastVecScratch","northVecScratch","computeEllipsePositions","addFillPositions","addEdgePositions","semiMinorAxis","semiMajorAxis","UNIT_Z","numPts","PI_OVER_TWO","deltaTheta","numInterior","t","interiorPosition","positionIndex","reflectedPosition","outerPositionsLength","outerRightIndex","outerLeftIndex","outerPositions","PI","lerp","r","IntersectionTests","OrientedBoundingBox","CoplanarPolygonGeometryLibrary","scratchIntersectionPoint","scratchXAxis","scratchYAxis","scratchZAxis","obbScratch","projectTo2D","axis1","axis2","v","fromElements","validOutline","halfAxes","fromPoints","xAxis","getColumn","yAxis","zAxis","xMag","yMag","zMag","computeProjectTo2DArguments","centerResult","planeAxis1Result","planeAxis2Result","planeAxis1","planeAxis2","orientedBoundingBox","min","createProjectPointsTo2DFunction","positionResults","createProjectPointTo2DFunction","ColorGeometryInstanceAttribute","OffsetGeometryInstanceAttribute","ShowGeometryInstanceAttribute","colorScratch","distanceDisplayConditionScratch","defaultOffset","offsetScratch","Batch","appearanceType","depthFailAppearanceType","depthFailMaterialProperty","removeMaterialSubscription","depthFailMaterial","createPrimitive","waitingOnCreate","oldPrimitive","updaters","updatersWithAttributes","subscriptions","showsUpdated","itemsToRemove","invalidated","onMaterialChanged","StaticGeometryColorBatch","_solidItems","_translucentItems","_appearanceType","_depthFailAppearanceType","_shadows","removeItem","item","splice","moveItems","batch","itemsMoved","itemsToMoveLength","updateItems","isUpdated","updatersLength","contains","isMaterial","updaterMaterial","instance","unsubscribe","removedCount","depthFailAppearance","colorProperty","resultColor","_lastColor","depthFailColorProperty","depthColor","_lastDepthFailColor","depthFailColor","_lastDistanceDisplayCondition","offsetProperty","offset","_lastOffset","updateShows","solidsMoved","translucentsMoved","updaterDepthFailMaterial","StaticGeometryPerMaterialBatch","_items","PolygonPipeline","WindingOrder","WallGeometryLibrary","latLonEquals","c0","c1","latitude","EPSILON14","longitude","scratchCartographic1","scratchCartographic2","positionsArrayScratch","heightsArrayScratch","generateArcOptionsScratch","wallPositions","maximumHeights","minimumHeights","duplicateCorners","o","topHeights","bottomHeights","hasBottomHeights","hasTopHeights","hasAllZeroHeights","cleanedTopHeights","cleanedBottomHeights","removeDuplicates","positions2D","projectPointsOntoPlane","computeWindingOrder2D","CLOCKWISE","reverse","topPositions","bottomPositions","numCorners","minDistance","chordLength","maximumRadius","generateArcOptions","count","numberOfPoints","generateArcPositions","generateArcHeights","PrimitiveCollection","OrderedGroundPrimitiveCollection","_length","_collections","_collectionsArray","destroyPrimitives","doNotDestroy","collections","frameState","BoundingRectangle","NearFarScalar","HorizontalOrigin","VerticalOrigin","defaultColor","defaultEyeOffset","defaultHeightReference","defaultPixelOffset","defaultAlignedAxis","defaultHorizontalOrigin","CENTER","defaultVerticalOrigin","positionScratch","eyeOffsetScratch","pixelOffsetScratch","scaleByDistanceScratch","translucencyByDistanceScratch","pixelOffsetScaleByDistanceScratch","boundingRectangleScratch","EntityData","billboard","textureValue","BillboardVisualizer","entityCluster","entityCollection","_cluster","_entityCollection","returnPrimitive","cluster","removeBillboard","billboardGraphics","_billboard","_show","_image","_clusterDirty","getBillboard","image","_color","eyeOffset","_eyeOffset","pixelOffset","_pixelOffset","_scale","_rotation","alignedAxis","_alignedAxis","horizontalOrigin","_horizontalOrigin","verticalOrigin","_verticalOrigin","_width","_height","scaleByDistance","_scaleByDistance","translucencyByDistance","_translucencyByDistance","pixelOffsetScaleByDistance","_pixelOffsetScaleByDistance","sizeInMeters","_sizeInMeters","_distanceDisplayCondition","disableDepthTestDistance","_disableDepthTestDistance","subRegion","_imageSubRegion","setImageSubRegion","_imageId","_clampedPosition","radius","entities","changed","BoxGeometryUpdater","CorridorGeometryUpdater","CylinderGeometryUpdater","EllipseGeometryUpdater","EllipsoidGeometryUpdater","PlaneGeometryUpdater","PolygonGeometryUpdater","PolylineVolumeGeometryUpdater","RectangleGeometryUpdater","StaticGroundGeometryColorBatch","StaticGroundGeometryPerMaterialBatch","StaticOutlineGeometryBatch","WallGeometryUpdater","emptyArray","geometryUpdaters","GeometryUpdaterSet","_removeEntitySubscription","GeometryVisualizer","_groundPrimitives","_addedObjects","_removedObjects","_changedObjects","numberOfShadowModes","NUMBER_OF_SHADOW_MODES","_outlineBatches","_closedColorBatches","_closedMaterialBatches","_openColorBatches","_openMaterialBatches","numberOfClassificationTypes","NUMBER_OF_CLASSIFICATION_TYPES","groundColorBatches","groundMaterialBatches","_groundColorBatches","_groundMaterialBatches","_dynamicBatch","_batches","concat","_subscriptions","_updaterSets","forEach","updaterSet","addedObjects","removedObjects","changedObjects","_removeUpdater","_insertUpdaterIntoBatch","_onGeometryChanged","batches","getBoundingSphereArrayScratch","getBoundingSphereBoundingSphereScratch","boundingSpheres","tmp","state","batchesLength","fromBoundingSpheres","updaterSets","BoxGeometry","BoxOutlineGeometry","GeometryInstance","heightReferenceOnEntityPropertyChanged","scratchColor","BoxGeometryOptions","dimensions","offsetAttribute","box","DynamicBoxGeometryUpdater","currentColor","fromColor","fromCartesian3","fromDimensions","modelMatrix","computeModelMatrixForHeightReference","mapProjection","orientation","CorridorGeometry","CorridorOutlineGeometry","Rectangle","scratchRectangle","CorridorGeometryOptions","corridor","DynamicCorridorGeometryUpdater","floor","heightValue","heightReferenceValue","extrudedHeightValue","extrudedHeightReferenceValue","getMinimumMaximumHeights","computeRectangle","minimumTerrainHeight","arrayFill","arrayRemoveDuplicates","Geometry","GeometryAttribute","GeometryAttributes","IndexDatatype","PrimitiveType","addNormals","attr","tangents","bitangents","tangent","bitangent","combine","computedPositions","corner","computedLefts","computedNormals","leftCount","rightCount","indicesLength","leftSide","endPositionLength","addEndPositions","UL","LL","UR","LR","halfLength","indices","createTypedArray","firstEndPositions","rightNormal","leftNormal","posIndex","compIndex","l","outsidePoint","previousPoint","nextPoint","lastEndPositions","DOUBLE","st","rightSt","leftSt","stIndex","a","halfEndPos","addWallPositions","computePositionsExtruded","topVertexFormat","shadowVolume","newPositions","extrudedPositions","scaleToGeodeticHeight","topNormals","topBitangents","threeSize","twoSize","sixSize","topPosition","bottomPosition","attrIndex","attrIndexOffset","topTangents","topSt","s","extrudedAttributes","extrudeNormals","extrudeDirection","applyOffset","Uint8Array","applyOffsetValue","UNSIGNED_BYTE","iLength","newIndices","v2","scratchCartographic","computeOffsetPoints","position1","position2","halfWidth","direction","offsetDirection","minLat","minLon","maxLat","maxLon","lat","lon","scratchCartesianOffset","scratchCartesianEnds","scratchCartographicMin","scratchCartographicMax","cleanPositions","POSITIVE_INFINITY","NEGATIVE_INFINITY","first","last","rectangle","north","south","east","_positions","DEFAULT","_extrudedHeight","RADIANS_PER_DEGREE","_shadowVolume","_workerName","_offsetAttribute","_rectangle","packedLength","pack","startingIndex","scratchEllipsoid","UNIT_SPHERE","scratchVertexFormat","scratchOptions","unpack","createGeometry","corridorGeometry","EPSILON2","fromVertices","primitiveType","TRIANGLES","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","POSITION_ONLY","textureCoordinateRotationPoints","wallIndices","corridorOutlineGeometry","offsetValue","LINES","CylinderGeometry","CylinderOutlineGeometry","CylinderGeometryOptions","numberOfVerticalLines","cylinder","DynamicCylinderGeometryUpdater","radiusScratch","normalScratch","bitangentScratch","tangentScratch","_topRadius","_bottomRadius","_slices","unitCylinderGeometry","cylinderGeometry","twoSlices","threeSlices","numVertices","computeNormal","computeTangent","normalIndex","tangentIndex","bitangentIndex","atan2","normalScale","numIndices","textureCoordIndex","rad","getUnitCylinder","_numberOfVerticalLines","numSide","numSideLines","round","EllipseGeometry","EllipseOutlineGeometry","EllipseGeometryOptions","stRotation","ellipse","DynamicEllipseGeometryUpdater","GeographicProjection","GeometryPipeline","texCoordScratch","textureMatrixScratch","tangentMatrixScratch","quaternionScratch","scratchTangent","scratchBitangent","projectedCenterScratch","scratchMinTexCoord","scratchMaxTexCoord","computeTopBottomAttributes","textureCoordinates","projection","projectedCenter","project","geodeticNormal","textureMatrix","tangentMatrix","minTexCoord","maxTexCoord","stOffset","rotatedPoint","projectedPoint","k","topIndices","prevIndex","indicesIndex","boundingSphereCenter","topBoundingSphere","bottomBoundingSphere","computeExtrudedEllipse","cep","union","topBottomAttributes","topBottomIndices","topBottomGeo","wallAttributes","bottom","computeWallAttributes","computeWallIndices","wallGeo","geo","combineInstances","positionsFlat","positionsCount","fromCartesianArray","_center","_semiMajorAxis","_semiMinorAxis","_stRotation","_textureCoordinateRotationPoints","scratchCenter","ellipseGeometry","computeEllipse","clamp","maxI","EllipsoidGeometry","EllipsoidOutlineGeometry","radiiScratch","unitSphere","EllipsoidGeometryOptions","radii","stackPartitions","slicePartitions","subdivisions","DynamicEllipsoidGeometryUpdater","_modelMatrix","_attributes","_outlineAttributes","_lastSceneMode","_lastShow","_lastOutlineShow","_lastOutlineWidth","_lastOutlineColor","skipModelMatrix","modelMatrixResult","showFill","showOutline","getValueOrClonedDefault","sceneMode","in3D","outlineAttributes","multiplyByScale","PlaneGeometry","PlaneOutlineGeometry","PlaneGeometryOptions","plane","DynamicPlaneGeometryUpdater","distanceDisplayConditionAttribute","planeGraphics","computeModelMatrix","createPrimitiveMatrix","isColorMaterial","scratchAxis","scratchAxis2","scratchTranslation","scratchScale","scratchQuaternion","scratchMatrix3","distance","transformedNormal","up","EPSILON8","rotationMatrix","setColumn","fromRotationMatrix","fromTranslationQuaternionRotationScale","planeGeometry","texCoords","Uint16Array","ArcType","CoplanarPolygonGeometry","CoplanarPolygonOutlineGeometry","PolygonGeometry","PolygonOutlineGeometry","scratch2DPositions","cart2Scratch","PolygonGeometryOptions","polygonHierarchy","perPositionHeight","closeTop","closeBottom","arcType","polygon","DyanmicPolygonGeometryUpdater","hierarchy","area","centroid2D","p2","f","sum","projectPointOntoEllipsoid","perPositionHeightProperty","perPositionHeightEnabled","hierarchyValue","perPositionHeightValue","GEODESIC","isExtruded","PolygonGeometryLibrary","scratchBR","stScratch","textureCoordinatesOrigin","axis1Scratch","axis2Scratch","tangentRotationScratch","surfaceNormalScratch","createGeometryFromPolygon","projectPointTo2D","triangulate","holes","tangentRotation","stOrigin","flatPositions","stx","sty","_polygonHierarchy","computeHierarchyPackedLength","fromPositions","packPolygonHierarchy","unpackPolygonHierarchy","polygonGeometry","EPSILON6","projectPoints","projectPoint","results","polygonsFromHierarchy","polygons","outerRing","computeBoundingRectangle","geometryInstance","createGeometryFromPositions","polygonOutlinesFromHierarchy","EllipsoidGeodesic","EllipsoidRhumbLine","Matrix2","scratchCarto1","scratchCarto2","adjustPosHeightsForNormal","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","appendTextureCoordinatesMatrix3","computeAttributes","wall","top","origin","recomputeNormal","tangentRotationMatrix","_plane","bottomOffset2","p","attrIndex1","attrIndex2","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","RHUMB","swap","inverseChordLength","positionsLength","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","interpolatedCartographicScratch","segmentLength","surfaceDistance","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","geos","walls","numPositions","topGeo","edgePoints","topBottomPositions","ilength","topAndBottom","windingOrder","slice","computeWallGeometry","hole","COUNTER_CLOCKWISE","perPositionHeightExtrude","_closeTop","_closeBottom","_perPositionHeight","_perPositionHeightExtrude","_arcType","dummyOptions","splitGeometry","scaleToGeodeticHeightExtruded","Queue","createGeometryFromPositionsPositions","createGeometryFromPositionsSubdivided","subdividedPositions","subdivideLineCount","subdivideRhumbLineCount","tempPositions","subdivideLine","subdivideRhumbLine","tempPositionsLength","indicesSize","cornersLength","PolylineVolumeGeometry","PolylineVolumeOutlineGeometry","PolylineVolumeGeometryOptions","polylinePositions","polylineVolume","DynamicPolylineVolumeGeometryUpdater","_shape","numComponents","brScratch","polylineVolumeGeometry","ll","ul","ur","lr","shapeLength","vertexCount","firstEndIndices","indicesCount","lengthSt","heightSt","stindex","endOffset","computeTangentAndBitangent","e","polylineVolumeOutlineGeometry","shapeCount","firstOffset","secondOffset","RectangleGeometry","RectangleOutlineGeometry","scratchCenterRect","RectangleGeometryOptions","DynamicRectangleGeometryUpdater","rect","coordinates","toCartesian","key","isDirty","scratchArray","_classificationType","fillColor","newColor","toBytes","bs","batchKey","Uint32Array","buffer","batchesArray","batchCount","oldBatch","newBatch","batchesArrayCopy","batchesCopyCount","RectangleCollisionChecker","ShadowVolumeAppearance","usingSphericalTextureCoordinates","rectangleCollisionCheck","overlapping","collides","insert","shouldUseSphericalCoordinates","rbush","_tree","RectangleWithId","minX","minY","maxX","maxY","idCompare","b","fromRectangleAndId","withId","removalScratch","collisionScratch","quickselect","maxEntries","format","_maxEntries","_minEntries","_initFormat","clear","findItem","equalsFn","calcBBox","node","toBBox","distBBox","children","destNode","createNode","Infinity","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersects","multiSelect","arr","right","compare","mid","stack","pop","all","_all","search","bbox","childBBox","nodesToSearch","load","_build","_splitRoot","tmpNode","_insert","parent","goingUp","path","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","log","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","defaultCompare","quickselectStep","exp","sd","newLeft","newRight","_solidBatches","_translucentBatches","solidBatches","solidBatchesLength","translucentBatches","translucentBatchesLength","needUpdate","solidsToMoveLength","translucentToMoveLength","solidBatch","translucentBatch","WallGeometry","WallOutlineGeometry","WallGeometryOptions","DynamicWallGeometryUpdater","scratchCartesian3Position1","scratchCartesian3Position2","scratchCartesian3Position3","scratchCartesian3Position4","scratchCartesian3Position5","_minimumHeights","_maximumHeights","fromConstantHeights","minHeights","maxHeights","minimumHeight","maximumHeight","doMin","doMax","wallGeometry","ds","i3","nextTop","groundPosition","scalednextPosition","scaledGroundPosition","edgeIndex","pl","pr","LabelStyle","defaultStyle","FILL","defaultFillColor","defaultBackgroundColor","defaultBackgroundPadding","fillColorScratch","outlineColorScratch","backgroundColorScratch","backgroundPaddingScratch","label","LabelVisualizer","removeLabel","text","labelGraphics","_label","_text","updateClamping","getLabel","font","_font","style","_style","_fillColor","_outlineColor","showBackground","_showBackground","backgroundColor","_backgroundColor","backgroundPadding","_backgroundPadding","Resource","Axis","ColorBlendMode","Model","ModelAnimationLoop","ENABLED","defaultSilhouetteColor","RED","defaultColorBlendMode","HIGHLIGHT","defaultImageBasedLightingFactor","defaultUpAxis","Y","modelMatrixScratch","nodeMatrixScratch","ModelVisualizer","_modelHash","_entitiesToVisualize","removeModel","visualizer","modelHash","modelData","modelPrimitive","clearNodeTransformationsArticulationsScratch","nodeTransformationsScratch","articulationsScratch","checkModelLoad","model","readyPromise","otherwise","error","console","loadFail","resource","modelGraphics","_model","createIfNeeded","_uri","url","fromGltf","incrementallyLoadTextures","_incrementallyLoadTextures","animationsRunning","minimumPixelSize","_minimumPixelSize","maximumScale","_maximumScale","silhouetteColor","_silhouetteColor","silhouetteSize","_silhouetteSize","colorBlendMode","_colorBlendMode","colorBlendAmount","_colorBlendAmount","clippingPlanes","_clippingPlanes","clampAnimations","_clampAnimations","imageBasedLightingFactor","_imageBasedLightingFactor","lightColor","_lightColor","_upAxis","_forwardAxis","runAnimations","_runAnimations","activeAnimations","addAll","loop","REPEAT","nodeTransformations","_nodeTransformations","nodeNames","keys","nodeIndex","nodeLength","nodeName","nodeTransformation","modelNode","getNode","transformationMatrix","fromTranslationRotationScale","matrix","multiply","originalMatrix","anyArticulationUpdated","articulations","_articulations","articulationStageKeys","numKeys","articulationStageValue","setArticulationStage","applyArticulations","_clampedModelMatrix","_heightChanged","JulianDate","TimeInterval","PolylineCollection","ConstantPositionProperty","SampledPositionProperty","TimeIntervalCollectionPositionProperty","scratchTimeInterval","subSampleCompositePropertyScratch","subSampleIntervalPropertyScratch","polyline","reallySubSample","stop","updateTime","maximumStep","times","sampleStepsToTake","sampleStepsTaken","sampleStepSize","steppedOnNow","lessThanOrEquals","greaterThanOrEquals","current","loopStop","sampling","greaterThan","lessThan","secondsUntilNext","secondsDifference","addSeconds","subSampleSampledProperty","_property","_times","intersect","intervalStart","intervalStop","sampleStart","sampleStop","subSampleCompositeProperty","isStartIncluded","isStopIncluded","subSampleIntervalProperty","subSampleConstantProperty","stepSize","subSampleGenericProperty","subSample","toFixedScratch","PolylineUpdater","_unusedIndexes","_polylineCollection","PathVisualizer","_updaters","INERTIAL","toFixed","computeIcrfToFixedMatrix","computeTemeToPseudoFixedMatrix","updateObject","pathGraphics","_path","showProperty","leadTime","_leadTime","trailTime","_trailTime","_availability","hasAvailability","hasLeadTime","hasTrailTime","unusedIndexes","resolution","_resolution","removeObject","hasOwnProperty","lastUpdater","frameToVisualize","currentUpdater","_subSample","createBillboardPointCallback","pointPrimitive","pixelSize","PointVisualizer","removePoint","pointGraphics","_point","needsRedraw","getPoint","_pixelSize","newOutlineColor","newOutlineWidth","newPixelSize","centerAlpha","alpha","cssColor","toCssColorString","cssOutlineColor","textureId","JSON","stringify","setImage","PolylineColorAppearance","PolylineMaterialAppearance","PolylineGeometryUpdater","StaticGroundPolylinePerMaterialBatch","removeUpdater","insertUpdaterIntoBatch","clampToGround","_groundBatches","multiplier","_colorBatches","_materialBatches","PolylineVisualizer","GroundPolylineGeometry","PolylineGeometry","GroundPolylinePrimitive","polylineCollections","GeometryOptions","GroundGeometryOptions","_entitySubscription","_depthFailMaterialProperty","_geometryOptions","_groundGeometryOptions","_clampToGround","_supportsPolylinesOnTerrain","supportsPolylinesOnTerrain","positionsProperty","groundGeometryOptions","generateCartesianArcOptions","_line","_groundPolylinePrimitive","getLine","dynamicGeometryUpdater","sceneId","polylineCollection","line","extractHeights","generateCartesianArc","groundPolylinePrimitive","GeometryType","scratchInterpolateColorsArray","interpolateColors","color0","color1","colors","r0","red","g0","green","b0","blue","a0","r1","g1","b1","a1","redPerVertex","greenPerVertex","bluePerVertex","alphaPerVertex","colorsPerVertex","_colors","_colorsPerVertex","scratchPrevPosition","scratchNextPosition","polylineGeometry","subdivisionSize","numberOfPointsFunction","numberOfPointsRhumbLine","colorLength","newColors","newColorIndex","numColors","interpolatedColors","interpolatedColorsLength","generateCartesianRhumbArc","prevPositions","nextPositions","expandAndWidth","finalColors","expandAndWidthIndex","colorIndex","endK","floatToByte","prevPosition","geometryType","POLYLINES","_asynchronous","createGuid","CustomDataSource","DataSourceDisplay","_displayID","initializeTerrainHeights","dataSourceCollection","dataSourceAdded","_onDataSourceAdded","dataSourceRemoved","_onDataSourceRemoved","dataSourceMoved","_onDataSourceMoved","_dataSourceCollection","_visualizersCallback","visualizersCallback","defaultVisualizersCallback","primitivesAdded","removeDefaultDataSoureListener","removeDataSourceCollectionListener","defaultDataSource","_defaultDataSource","addPrimitives","_removeDefaultDataSoureListener","_removeDataSourceCollectionListener","_ready","dataSource","dataSources","initialized","visualizers","vLength","_visualizersByDisplayID","allowPartial","d","_visualizers","visualizersLength","displayPrimitives","displayGroundPrimitives","clustering","_initialize","newIndex","oldIndex","raise","lower","lowerToBottom","raiseToTop"],"mappings":"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","file":"1.TerriaJS-specs.js","sourcesContent":["define([\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError'\n    ], function(\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError) {\n    'use strict';\n\n    /**\n     * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.\n     *\n     * @alias DistanceDisplayConditionGeometryInstanceAttribute\n     * @constructor\n     *\n     * @param {Number} [near=0.0] The near distance.\n     * @param {Number} [far=Number.MAX_VALUE] The far distance.\n     *\n     * @exception {DeveloperError} far must be greater than near.\n     *\n     * @example\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : new Cesium.BoxGeometry({\n     *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,\n     *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),\n     *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)\n     *   }),\n     *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(\n     *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),\n     *   id : 'box',\n     *   attributes : {\n     *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)\n     *   }\n     * });\n     *\n     * @see GeometryInstance\n     * @see GeometryInstanceAttribute\n     */\n    function DistanceDisplayConditionGeometryInstanceAttribute(near, far) {\n        near = defaultValue(near, 0.0);\n        far = defaultValue(far, Number.MAX_VALUE);\n\n        \n\n        /**\n         * The values for the attributes stored in a typed array.\n         *\n         * @type Float32Array\n         *\n         * @default [0.0, 0.0, Number.MAX_VALUE]\n         */\n        this.value = new Float32Array([near, far]);\n    }\n\n    defineProperties(DistanceDisplayConditionGeometryInstanceAttribute.prototype, {\n        /**\n         * The datatype of each component in the attribute, e.g., individual elements in\n         * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {ComponentDatatype}\n         * @readonly\n         *\n         * @default {@link ComponentDatatype.FLOAT}\n         */\n        componentDatatype : {\n            get : function() {\n                return ComponentDatatype.FLOAT;\n            }\n        },\n\n        /**\n         * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Number}\n         * @readonly\n         *\n         * @default 3\n         */\n        componentsPerAttribute : {\n            get : function() {\n                return 2;\n            }\n        },\n\n        /**\n         * When <code>true</code> and <code>componentDatatype</code> is an integer format,\n         * indicate that the components should be mapped to the range [0, 1] (unsigned)\n         * or [-1, 1] (signed) when they are accessed as floating-point for rendering.\n         *\n         * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        normalize : {\n            get : function() {\n                return false;\n            }\n        }\n    });\n\n    /**\n     * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.\n     * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.\n     *\n     * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near\n     *\n     * @example\n     * var distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);\n     * var instance = new Cesium.GeometryInstance({\n     *   geometry : geometry,\n     *   attributes : {\n     *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n     *   }\n     * });\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition = function(distanceDisplayCondition) {\n        \n\n        return new DistanceDisplayConditionGeometryInstanceAttribute(distanceDisplayCondition.near, distanceDisplayCondition.far);\n    };\n\n    /**\n     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.\n     *\n     * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.\n     * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.\n     * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.\n     *\n     * @example\n     * var attributes = primitive.getGeometryInstanceAttributes('an id');\n     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n     */\n    DistanceDisplayConditionGeometryInstanceAttribute.toValue = function(distanceDisplayCondition, result) {\n        \n\n        if (!defined(result)) {\n            return new Float32Array([distanceDisplayCondition.near, distanceDisplayCondition.far]);\n        }\n        result[0] = distanceDisplayCondition.near;\n        result[1] = distanceDisplayCondition.far;\n        return result;\n    };\n\n    return DistanceDisplayConditionGeometryInstanceAttribute;\n});\n","define([\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/freezeObject',\n        '../Core/VertexFormat',\n        '../Shaders/Appearances/AllMaterialAppearanceFS',\n        '../Shaders/Appearances/AllMaterialAppearanceVS',\n        '../Shaders/Appearances/BasicMaterialAppearanceFS',\n        '../Shaders/Appearances/BasicMaterialAppearanceVS',\n        '../Shaders/Appearances/TexturedMaterialAppearanceFS',\n        '../Shaders/Appearances/TexturedMaterialAppearanceVS',\n        './Appearance',\n        './Material'\n    ], function(\n        defaultValue,\n        defined,\n        defineProperties,\n        freezeObject,\n        VertexFormat,\n        AllMaterialAppearanceFS,\n        AllMaterialAppearanceVS,\n        BasicMaterialAppearanceFS,\n        BasicMaterialAppearanceVS,\n        TexturedMaterialAppearanceFS,\n        TexturedMaterialAppearanceVS,\n        Appearance,\n        Material) {\n    'use strict';\n\n    /**\n     * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)\n     * that supports shading with materials.\n     *\n     * @alias MaterialAppearance\n     * @constructor\n     *\n     * @param {Object} [options] Object with the following properties:\n     * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n     * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n     * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.\n     * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.\n     * @param {MaterialAppearance.MaterialSupport} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.\n     * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n     * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n     * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n     * @param {RenderState} [options.renderState] Optional render state to override the default render state.\n     *\n     * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}\n     *\n     * @example\n     * var primitive = new Cesium.Primitive({\n     *   geometryInstances : new Cesium.GeometryInstance({\n     *     geometry : new Cesium.WallGeometry({\n            materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,\n     *       // ...\n     *     })\n     *   }),\n     *   appearance : new Cesium.MaterialAppearance({\n     *     material : Cesium.Material.fromType('Color'),\n     *     faceForward : true\n     *   })\n     *\n     * });\n     */\n    function MaterialAppearance(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var translucent = defaultValue(options.translucent, true);\n        var closed = defaultValue(options.closed, false);\n        var materialSupport = defaultValue(options.materialSupport, MaterialAppearance.MaterialSupport.TEXTURED);\n\n        /**\n         * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}\n         * properties, this is not read-only, so an appearance's material can change on the fly.\n         *\n         * @type Material\n         *\n         * @default {@link Material.ColorType}\n         *\n         * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}\n         */\n        this.material = (defined(options.material)) ? options.material : Material.fromType(Material.ColorType);\n\n        /**\n         * When <code>true</code>, the geometry is expected to appear translucent.\n         *\n         * @type {Boolean}\n         *\n         * @default true\n         */\n        this.translucent = translucent;\n\n        this._vertexShaderSource = defaultValue(options.vertexShaderSource, materialSupport.vertexShaderSource);\n        this._fragmentShaderSource = defaultValue(options.fragmentShaderSource, materialSupport.fragmentShaderSource);\n        this._renderState = Appearance.getDefaultRenderState(translucent, closed, options.renderState);\n        this._closed = closed;\n\n        // Non-derived members\n\n        this._materialSupport = materialSupport;\n        this._vertexFormat = materialSupport.vertexFormat;\n        this._flat = defaultValue(options.flat, false);\n        this._faceForward = defaultValue(options.faceForward, !closed);\n    }\n\n    defineProperties(MaterialAppearance.prototype, {\n        /**\n         * The GLSL source code for the vertex shader.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        vertexShaderSource : {\n            get : function() {\n                return this._vertexShaderSource;\n            }\n        },\n\n        /**\n         * The GLSL source code for the fragment shader.  The full fragment shader\n         * source is built procedurally taking into account {@link MaterialAppearance#material},\n         * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n         * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {String}\n         * @readonly\n         */\n        fragmentShaderSource : {\n            get : function() {\n                return this._fragmentShaderSource;\n            }\n        },\n\n        /**\n         * The WebGL fixed-function state to use when rendering the geometry.\n         * <p>\n         * The render state can be explicitly defined when constructing a {@link MaterialAppearance}\n         * instance, or it is set implicitly via {@link MaterialAppearance#translucent}\n         * and {@link MaterialAppearance#closed}.\n         * </p>\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Object}\n         * @readonly\n         */\n        renderState : {\n            get : function() {\n                return this._renderState;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the geometry is expected to be closed so\n         * {@link MaterialAppearance#renderState} has backface culling enabled.\n         * If the viewer enters the geometry, it will not be visible.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        closed : {\n            get : function() {\n                return this._closed;\n            }\n        },\n\n        /**\n         * The type of materials supported by this instance.  This impacts the required\n         * {@link VertexFormat} and the complexity of the vertex and fragment shaders.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {MaterialAppearance.MaterialSupport}\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}\n         */\n        materialSupport : {\n            get : function() {\n                return this._materialSupport;\n            }\n        },\n\n        /**\n         * The {@link VertexFormat} that this appearance instance is compatible with.\n         * A geometry can have more vertex attributes and still be compatible - at a\n         * potential performance cost - but it can't have less.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type VertexFormat\n         * @readonly\n         *\n         * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}\n         */\n        vertexFormat : {\n            get : function() {\n                return this._vertexFormat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, flat shading is used in the fragment shader,\n         * which means lighting is not taking into account.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default false\n         */\n        flat : {\n            get : function() {\n                return this._flat;\n            }\n        },\n\n        /**\n         * When <code>true</code>, the fragment shader flips the surface normal\n         * as needed to ensure that the normal faces the viewer to avoid\n         * dark spots.  This is useful when both sides of a geometry should be\n         * shaded like {@link WallGeometry}.\n         *\n         * @memberof MaterialAppearance.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         *\n         * @default true\n         */\n        faceForward : {\n            get : function() {\n                return this._faceForward;\n            }\n        }\n    });\n\n    /**\n     * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},\n     * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},\n     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.\n     *\n     * @function\n     *\n     * @returns {String} The full GLSL fragment shader source.\n     */\n    MaterialAppearance.prototype.getFragmentShaderSource = Appearance.prototype.getFragmentShaderSource;\n\n    /**\n     * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.\n     *\n     * @function\n     *\n     * @returns {Boolean} <code>true</code> if the appearance is translucent.\n     */\n    MaterialAppearance.prototype.isTranslucent = Appearance.prototype.isTranslucent;\n\n    /**\n     * Creates a render state.  This is not the final render state instance; instead,\n     * it can contain a subset of render state properties identical to the render state\n     * created in the context.\n     *\n     * @function\n     *\n     * @returns {Object} The render state.\n     */\n    MaterialAppearance.prototype.getRenderState = Appearance.prototype.getRenderState;\n\n    /**\n     * Determines the type of {@link Material} that is supported by a\n     * {@link MaterialAppearance} instance.  This is a trade-off between\n     * flexibility (a wide array of materials) and memory/performance\n     * (required vertex format and GLSL shader complexity.\n     * @exports MaterialAppearance.MaterialSupport\n     */\n    MaterialAppearance.MaterialSupport = {\n        /**\n         * Only basic materials, which require just <code>position</code> and\n         * <code>normal</code> vertex attributes, are supported.\n         *\n         * @constant\n         */\n        BASIC : freezeObject({\n            vertexFormat : VertexFormat.POSITION_AND_NORMAL,\n            vertexShaderSource : BasicMaterialAppearanceVS,\n            fragmentShaderSource : BasicMaterialAppearanceFS\n        }),\n        /**\n         * Materials with textures, which require <code>position</code>,\n         * <code>normal</code>, and <code>st</code> vertex attributes,\n         * are supported.  The vast majority of materials fall into this category.\n         *\n         * @constant\n         */\n        TEXTURED : freezeObject({\n            vertexFormat : VertexFormat.POSITION_NORMAL_AND_ST,\n            vertexShaderSource : TexturedMaterialAppearanceVS,\n            fragmentShaderSource : TexturedMaterialAppearanceFS\n        }),\n        /**\n         * All materials, including those that work in tangent space, are supported.\n         * This requires <code>position</code>, <code>normal</code>, <code>st</code>,\n         * <code>tangent</code>, and <code>bitangent</code> vertex attributes.\n         *\n         * @constant\n         */\n        ALL : freezeObject({\n            vertexFormat : VertexFormat.ALL,\n            vertexShaderSource : AllMaterialAppearanceVS,\n            fragmentShaderSource : AllMaterialAppearanceFS\n        })\n    };\n\n    return MaterialAppearance;\n});\n","define([\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayCondition',\n        '../Core/Event',\n        '../Core/Iso8601',\n        '../Core/oneTimeWarning',\n        '../Scene/ClassificationType',\n        '../Scene/ShadowMode',\n        './ColorMaterialProperty',\n        './ConstantProperty',\n        './Entity',\n        './Property'\n    ], function(\n        Check,\n        Color,\n        defaultValue,\n        defined,\n        defineProperties,\n        destroyObject,\n        DeveloperError,\n        DistanceDisplayCondition,\n        Event,\n        Iso8601,\n        oneTimeWarning,\n        ClassificationType,\n        ShadowMode,\n        ColorMaterialProperty,\n        ConstantProperty,\n        Entity,\n        Property) {\n    'use strict';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultFill = new ConstantProperty(true);\n    var defaultOutline = new ConstantProperty(false);\n    var defaultOutlineColor = new ConstantProperty(Color.BLACK);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    /**\n     * An abstract class for updating geometry entites.\n     * @alias GeometryUpdater\n     * @constructor\n     *\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GeometryUpdater(options) {\n        \n\n        var entity = options.entity;\n        var geometryPropertyName = options.geometryPropertyName;\n\n        this._entity = entity;\n        this._scene = options.scene;\n        this._fillEnabled = false;\n        this._isClosed = false;\n        this._onTerrain = false;\n        this._dynamic = false;\n        this._outlineEnabled = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._showOutlineProperty = undefined;\n        this._outlineColorProperty = undefined;\n        this._outlineWidth = 1.0;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._options = options.geometryOptions;\n        this._geometryPropertyName = geometryPropertyName;\n        this._id = geometryPropertyName + '-' + entity.id;\n        this._observedPropertyNames = options.observedPropertyNames;\n        this._supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(options.scene);\n    }\n\n    defineProperties(GeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof GeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id : {\n            get : function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._fillProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            get : function() {\n                return this._outlineEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            get : function() {\n                return !this._outlineEnabled ||\n                       (!defined(this._entity.availability) &&\n                        Property.isConstant(this._showProperty) &&\n                        Property.isConstant(this._showOutlineProperty));\n            }\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            get : function() {\n                return this._outlineColorProperty;\n            }\n        },\n        /**\n         * Gets the constant with of the geometry outline, in pixels.\n         * This value is only valid if isDynamic is false.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        outlineWidth : {\n            get : function() {\n                return this._outlineWidth;\n            }\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from each light source.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            get : function() {\n                return this._isClosed;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry should be drawn on terrain.\n         * @memberof EllipseGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        onTerrain : {\n            get : function() {\n                return this._onTerrain;\n            }\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof GeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isOutlineVisible = function(time) {\n        var entity = this._entity;\n        var visible = this._outlineEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    GeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time) && this._fillProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    GeometryUpdater.prototype.createFillGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @function\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    GeometryUpdater.prototype.createOutlineGeometryInstance = DeveloperError.throwInstantiationError;\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GeometryUpdater.prototype.destroy = function() {\n        destroyObject(this);\n    };\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isHidden = function(entity, geometry) {\n        var show = geometry.show;\n        return defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE);\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return false;\n    };\n\n    /**\n     * @param {GeometryOptions} options\n     * @private\n     */\n    GeometryUpdater.prototype._getIsClosed = function(options) {\n        return true;\n    };\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._isDynamic = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {Object} geometry\n     * @private\n     */\n    GeometryUpdater.prototype._setStaticOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * @param {Entity} entity\n     * @param {String} propertyName\n     * @param {*} newValue\n     * @param {*} oldValue\n     * @private\n     */\n    GeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n\n        if (!defined(geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var fillProperty = geometry.fill;\n        var fillEnabled = defined(fillProperty) && fillProperty.isConstant ? fillProperty.getValue(Iso8601.MINIMUM_VALUE) : true;\n\n        var outlineProperty = geometry.outline;\n        var outlineEnabled = defined(outlineProperty);\n        if (outlineEnabled && outlineProperty.isConstant) {\n            outlineEnabled = outlineProperty.getValue(Iso8601.MINIMUM_VALUE);\n        }\n\n        if (!fillEnabled && !outlineEnabled) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var show = geometry.show;\n        if (this._isHidden(entity, geometry)) {\n            if (this._fillEnabled || this._outlineEnabled) {\n                this._fillEnabled = false;\n                this._outlineEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        this._materialProperty = defaultValue(geometry.material, defaultMaterial);\n        this._fillProperty = defaultValue(fillProperty, defaultFill);\n        this._showProperty = defaultValue(show, defaultShow);\n        this._showOutlineProperty = defaultValue(geometry.outline, defaultOutline);\n        this._outlineColorProperty = outlineEnabled ? defaultValue(geometry.outlineColor, defaultOutlineColor) : undefined;\n        this._shadowsProperty = defaultValue(geometry.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(geometry.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(geometry.classificationType, defaultClassificationType);\n\n        this._fillEnabled = fillEnabled;\n\n        var onTerrain = this._isOnTerrain(entity, geometry) &&\n            (this._supportsMaterialsforEntitiesOnTerrain || this._materialProperty instanceof ColorMaterialProperty);\n\n        if (outlineEnabled && onTerrain) {\n            oneTimeWarning(oneTimeWarning.geometryOutlines);\n            outlineEnabled = false;\n        }\n\n        this._onTerrain = onTerrain;\n        this._outlineEnabled = outlineEnabled;\n\n        if (this._isDynamic(entity, geometry)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            this._setStaticOptions(entity, geometry);\n            this._isClosed = this._getIsClosed(this._options);\n            var outlineWidth = geometry.outlineWidth;\n            this._outlineWidth = defined(outlineWidth) ? outlineWidth.getValue(Iso8601.MINIMUM_VALUE) : 1.0;\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection} [groundPrimitives] The primitive collection to use for ground primitives.\n     *\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    GeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new this.constructor.DynamicGeometryUpdater(this, primitives, groundPrimitives);\n    };\n\n    return GeometryUpdater;\n});\n","define([\n        '../Core/BoundingSphere',\n        '../Core/Check',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Scene/GroundPrimitive',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        '../Scene/Primitive',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        BoundingSphere,\n        Check,\n        defined,\n        destroyObject,\n        DeveloperError,\n        GroundPrimitive,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        Primitive,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    /**\n     * Defines the interface for a dynamic geometry updater.  A DynamicGeometryUpdater\n     * is responsible for handling visualization of a specific type of geometry\n     * that needs to be recomputed based on simulation time.\n     * This object is never used directly by client code, but is instead created by\n     * {@link GeometryUpdater} implementations which contain dynamic geometry.\n     *\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias DynamicGeometryUpdater\n     * @constructor\n     * @private\n     */\n    function DynamicGeometryUpdater(geometryUpdater, primitives, orderedGroundPrimitives) {\n        \n\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._primitive = undefined;\n        this._outlinePrimitive = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._options = geometryUpdater._options;\n        this._entity = geometryUpdater._entity;\n        this._material = undefined;\n    }\n\n    DynamicGeometryUpdater.prototype._isHidden = function(entity, geometry, time) {\n        return !entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(geometry.show, time, true);\n    };\n\n    DynamicGeometryUpdater.prototype._setOptions = DeveloperError.throwInstantiationError;\n\n    /**\n     * Updates the geometry to the specified time.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @param {JulianDate} time The current time.\n     */\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        \n\n        var geometryUpdater = this._geometryUpdater;\n        var onTerrain = geometryUpdater._onTerrain;\n\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._outlinePrimitive = undefined;\n        }\n        this._primitive = undefined;\n\n        var entity = this._entity;\n        var geometry = entity[this._geometryUpdater._geometryPropertyName];\n        this._setOptions(entity, geometry, time);\n        if (this._isHidden(entity, geometry, time)) {\n            return;\n        }\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n        var options = this._options;\n        if (!defined(geometry.fill) || geometry.fill.getValue(time)) {\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var isColorAppearance = fillMaterialProperty instanceof ColorMaterialProperty;\n            var appearance;\n            var closed = geometryUpdater._getIsClosed(options);\n            if (isColorAppearance) {\n                appearance = new PerInstanceColorAppearance({\n                    closed: closed,\n                    flat : onTerrain && !geometryUpdater._supportsMaterialsforEntitiesOnTerrain\n                });\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                this._material = material;\n                appearance = new MaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent(),\n                    closed : closed\n                });\n            }\n\n            if (onTerrain) {\n                options.vertexFormat = PerInstanceColorAppearance.VERTEX_FORMAT;\n                this._primitive = orderedGroundPrimitives.add(new GroundPrimitive({\n                    geometryInstances : this._geometryUpdater.createFillGeometryInstance(time),\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows,\n                    classificationType : this._geometryUpdater.classificationTypeProperty.getValue(time)\n                }), Property.getValueOrUndefined(this._geometryUpdater.zIndex, time));\n            } else {\n                options.vertexFormat = appearance.vertexFormat;\n\n                var fillInstance = this._geometryUpdater.createFillGeometryInstance(time);\n\n                if (isColorAppearance) {\n                    appearance.translucent = fillInstance.attributes.color.value[3] !== 255;\n                }\n\n                this._primitive = primitives.add(new Primitive({\n                    geometryInstances : fillInstance,\n                    appearance : appearance,\n                    asynchronous : false,\n                    shadows : shadows\n                }));\n            }\n        }\n\n        if (!onTerrain && defined(geometry.outline) && geometry.outline.getValue(time)) {\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time);\n            var outlineWidth = Property.getValueOrDefault(geometry.outlineWidth, time, 1.0);\n\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n        }\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     * @function\n     *\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n        var entity = this._entity;\n        var primitive = this._primitive;\n        var outlinePrimitive = this._outlinePrimitive;\n\n        var attributes;\n\n        //Outline and Fill geometries have the same bounding sphere, so just use whichever one is defined and ready\n        if (defined(primitive) && primitive.show && primitive.ready) {\n            attributes = primitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if (defined(outlinePrimitive) && outlinePrimitive.show && outlinePrimitive.ready) {\n            attributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n            if (defined(attributes) && defined(attributes.boundingSphere)) {\n                BoundingSphere.clone(attributes.boundingSphere, result);\n                return BoundingSphereState.DONE;\n            }\n        }\n\n        if ((defined(primitive) && !primitive.ready) || (defined(outlinePrimitive) && !outlinePrimitive.ready)) {\n            return BoundingSphereState.PENDING;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     * @memberof DynamicGeometryUpdater\n     * @function\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var primitives = this._primitives;\n        var orderedGroundPrimitives = this._orderedGroundPrimitives;\n        if (this._geometryUpdater._onTerrain) {\n            orderedGroundPrimitives.remove(this._primitive);\n        } else {\n            primitives.removeAndDestroy(this._primitive);\n        }\n        primitives.removeAndDestroy(this._outlinePrimitive);\n        destroyObject(this);\n    };\n\n    return DynamicGeometryUpdater;\n});\n","define([\n        './freezeObject'\n    ], function(\n        freezeObject) {\n    'use strict';\n\n    /**\n     * Style options for corners.\n     *\n     * @demo The {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html&label=Geometries|Corridor Demo}\n     * demonstrates the three corner types, as used by {@link CorridorGraphics}.\n     *\n     * @exports CornerType\n     */\n    var CornerType = {\n        /**\n         * <img src=\"Images/CornerTypeRounded.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner has a smooth edge.\n         * @type {Number}\n         * @constant\n         */\n        ROUNDED : 0,\n\n        /**\n         * <img src=\"Images/CornerTypeMitered.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner point is the intersection of adjacent edges.\n         * @type {Number}\n         * @constant\n         */\n        MITERED : 1,\n\n        /**\n         * <img src=\"Images/CornerTypeBeveled.png\" style=\"vertical-align: middle;\" width=\"186\" height=\"189\" />\n         *\n         * Corner is clipped.\n         * @type {Number}\n         * @constant\n         */\n        BEVELED : 2\n    };\n\n    return freezeObject(CornerType);\n});\n","define([\n        '../Core/Color',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Scene/Material'\n    ], function(\n        Color,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Material) {\n    'use strict';\n\n    /**\n     * The interface for all {@link Property} objects that represent {@link Material} uniforms.\n     * This type defines an interface and cannot be instantiated directly.\n     *\n     * @alias MaterialProperty\n     * @constructor\n     *\n     * @see ColorMaterialProperty\n     * @see CompositeMaterialProperty\n     * @see GridMaterialProperty\n     * @see ImageMaterialProperty\n     * @see PolylineGlowMaterialProperty\n     * @see PolylineOutlineMaterialProperty\n     * @see StripeMaterialProperty\n     */\n    function MaterialProperty() {\n        DeveloperError.throwInstantiationError();\n    }\n\n    defineProperties(MaterialProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : DeveloperError.throwInstantiationError\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is considered to have changed if a call to getValue would return\n         * a different result for the same time.\n         * @memberof MaterialProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : DeveloperError.throwInstantiationError\n        }\n    });\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    MaterialProperty.prototype.getType = DeveloperError.throwInstantiationError;\n\n    /**\n     * Gets the value of the property at the provided time.\n     * @function\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    MaterialProperty.prototype.getValue = DeveloperError.throwInstantiationError;\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     * @function\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    MaterialProperty.prototype.equals = DeveloperError.throwInstantiationError;\n\n    /**\n     * @private\n     */\n    MaterialProperty.getValue = function(time, materialProperty, material) {\n        var type;\n\n        if (defined(materialProperty)) {\n            type = materialProperty.getType(time);\n            if (defined(type)) {\n                if (!defined(material) || (material.type !== type)) {\n                    material = Material.fromType(type);\n                }\n                materialProperty.getValue(time, material.uniforms);\n                return material;\n            }\n        }\n\n        if (!defined(material) || (material.type !== Material.ColorType)) {\n            material = Material.fromType(Material.ColorType);\n        }\n        Color.clone(Color.WHITE, material.uniforms.color);\n\n        return material;\n    };\n\n    return MaterialProperty;\n});\n","define([\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        '../Core/EventHelper',\n        '../Core/TimeIntervalCollection',\n        './Property'\n    ], function(\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        EventHelper,\n        TimeIntervalCollection,\n        Property) {\n    'use strict';\n\n    function subscribeAll(property, eventHelper, definitionChanged, intervals) {\n        function callback() {\n            definitionChanged.raiseEvent(property);\n        }\n        var items = [];\n        eventHelper.removeAll();\n        var length = intervals.length;\n        for (var i = 0; i < length; i++) {\n            var interval = intervals.get(i);\n            if (defined(interval.data) && items.indexOf(interval.data) === -1) {\n                eventHelper.add(interval.data.definitionChanged, callback);\n            }\n        }\n    }\n\n    /**\n     * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the\n     * data property of each {@link TimeInterval} is another Property instance which is\n     * evaluated at the provided time.\n     *\n     * @alias CompositeProperty\n     * @constructor\n     *\n     *\n     * @example\n     * var constantProperty = ...;\n     * var sampledProperty = ...;\n     *\n     * //Create a composite property from two previously defined properties\n     * //where the property is valid on August 1st, 2012 and uses a constant\n     * //property for the first half of the day and a sampled property for the\n     * //remaining half.\n     * var composite = new Cesium.CompositeProperty();\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',\n     *     data : constantProperty\n     * }));\n     * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({\n     *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',\n     *     isStartIncluded : false,\n     *     isStopIncluded : false,\n     *     data : sampledProperty\n     * }));\n     *\n     * @see CompositeMaterialProperty\n     * @see CompositePositionProperty\n     */\n    function CompositeProperty() {\n        this._eventHelper = new EventHelper();\n        this._definitionChanged = new Event();\n        this._intervals = new TimeIntervalCollection();\n        this._intervals.changedEvent.addEventListener(CompositeProperty.prototype._intervalsChanged, this);\n    }\n\n    defineProperties(CompositeProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._intervals.isEmpty;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositeProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._intervals;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositeProperty.prototype.getValue = function(time, result) {\n        \n\n        var innerProperty = this._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValue(time, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositeProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositeProperty && //\n                this._intervals.equals(other._intervals, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositeProperty.prototype._intervalsChanged = function() {\n        subscribeAll(this, this._eventHelper, this._definitionChanged, this._intervals);\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    return CompositeProperty;\n});\n","define([\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        '../Core/ReferenceFrame',\n        './CompositeProperty',\n        './Property'\n    ], function(\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        ReferenceFrame,\n        CompositeProperty,\n        Property) {\n    'use strict';\n\n    /**\n     * A {@link CompositeProperty} which is also a {@link PositionProperty}.\n     *\n     * @alias CompositePositionProperty\n     * @constructor\n     *\n     * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.\n     */\n    function CompositePositionProperty(referenceFrame) {\n        this._referenceFrame = defaultValue(referenceFrame, ReferenceFrame.FIXED);\n        this._definitionChanged = new Event();\n        this._composite = new CompositeProperty();\n        this._composite.definitionChanged.addEventListener(CompositePositionProperty.prototype._raiseDefinitionChanged, this);\n    }\n\n    defineProperties(CompositePositionProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.  A property is considered\n         * constant if getValue always returns the same result for the current definition.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return this._composite.isConstant;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever setValue is called with data different\n         * than the current value.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the interval collection.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {TimeIntervalCollection}\n         */\n        intervals : {\n            get : function() {\n                return this._composite.intervals;\n            }\n        },\n        /**\n         * Gets or sets the reference frame which this position presents itself as.\n         * Each PositionProperty making up this object has it's own reference frame,\n         * so this property merely exposes a \"preferred\" reference frame for clients\n         * to use.\n         * @memberof CompositePositionProperty.prototype\n         *\n         * @type {ReferenceFrame}\n         */\n        referenceFrame : {\n            get : function() {\n                return this._referenceFrame;\n            },\n            set : function(value) {\n                this._referenceFrame = value;\n            }\n        }\n    });\n\n    /**\n     * Gets the value of the property at the provided time in the fixed frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    CompositePositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        var innerProperty = this._composite._intervals.findDataForIntervalContainingDate(time);\n        if (defined(innerProperty)) {\n            return innerProperty.getValueInReferenceFrame(time, referenceFrame, result);\n        }\n        return undefined;\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    CompositePositionProperty.prototype.equals = function(other) {\n        return this === other || //\n               (other instanceof CompositePositionProperty && //\n                this._referenceFrame === other._referenceFrame && //\n                this._composite.equals(other._composite, Property.equals));\n    };\n\n    /**\n     * @private\n     */\n    CompositePositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    return CompositePositionProperty;\n});\n","define([\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Event',\n        '../Core/RuntimeError',\n        './Property'\n    ], function(\n        defined,\n        defineProperties,\n        DeveloperError,\n        Event,\n        RuntimeError,\n        Property) {\n    'use strict';\n\n    function resolveEntity(that) {\n        var entityIsResolved = true;\n        if (that._resolveEntity) {\n            var targetEntity = that._targetCollection.getById(that._targetId);\n\n            if (defined(targetEntity)) {\n                targetEntity.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, that);\n                that._targetEntity = targetEntity;\n                that._resolveEntity = false;\n            } else {\n                //The property has become detached.  It has a valid value but is not currently resolved to an entity in the collection\n                targetEntity = that._targetEntity;\n                entityIsResolved = false;\n            }\n\n            if (!defined(targetEntity)) {\n                throw new RuntimeError('target entity \"' + that._targetId + '\" could not be resolved.');\n            }\n        }\n        return entityIsResolved;\n    }\n\n    function resolve(that) {\n        var targetProperty = that._targetProperty;\n\n        if (that._resolveProperty) {\n            var entityIsResolved = resolveEntity(that);\n\n            var names = that._targetPropertyNames;\n            targetProperty = that._targetEntity;\n            var length = names.length;\n            for (var i = 0; i < length && defined(targetProperty); i++) {\n                targetProperty = targetProperty[names[i]];\n            }\n\n            if (defined(targetProperty)) {\n                that._targetProperty = targetProperty;\n                that._resolveProperty = !entityIsResolved;\n            } else if (!defined(that._targetProperty)) {\n                throw new RuntimeError('targetProperty \"' + that._targetId + '.' + names.join('.') + '\" could not be resolved.');\n            }\n        }\n\n        return targetProperty;\n    }\n\n    /**\n     * A {@link Property} which transparently links to another property on a provided object.\n     *\n     * @alias ReferenceProperty\n     * @constructor\n     *\n     * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.\n     * @param {String} targetId The id of the entity which is being referenced.\n     * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.\n     *\n     * @example\n     * var collection = new Cesium.EntityCollection();\n     *\n     * //Create a new entity and assign a billboard scale.\n     * var object1 = new Cesium.Entity({id:'object1'});\n     * object1.billboard = new Cesium.BillboardGraphics();\n     * object1.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object1);\n     *\n     * //Create a second entity and reference the scale from the first one.\n     * var object2 = new Cesium.Entity({id:'object2'});\n     * object2.model = new Cesium.ModelGraphics();\n     * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);\n     * collection.add(object2);\n     *\n     * //Create a third object, but use the fromString helper function.\n     * var object3 = new Cesium.Entity({id:'object3'});\n     * object3.billboard = new Cesium.BillboardGraphics();\n     * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');\n     * collection.add(object3);\n     *\n     * //You can refer to an entity with a # or . in id and property names by escaping them.\n     * var object4 = new Cesium.Entity({id:'#object.4'});\n     * object4.billboard = new Cesium.BillboardGraphics();\n     * object4.billboard.scale = new Cesium.ConstantProperty(2.0);\n     * collection.add(object4);\n     *\n     * var object5 = new Cesium.Entity({id:'object5'});\n     * object5.billboard = new Cesium.BillboardGraphics();\n     * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\\\#object\\\\.4#billboard.scale');\n     * collection.add(object5);\n     */\n    function ReferenceProperty(targetCollection, targetId, targetPropertyNames) {\n        \n\n        this._targetCollection = targetCollection;\n        this._targetId = targetId;\n        this._targetPropertyNames = targetPropertyNames;\n        this._targetProperty = undefined;\n        this._targetEntity = undefined;\n        this._definitionChanged = new Event();\n        this._resolveEntity = true;\n        this._resolveProperty = true;\n\n        targetCollection.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged, this);\n    }\n\n    defineProperties(ReferenceProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof ReferenceProperty.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return Property.isConstant(resolve(this));\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * The definition is changed whenever the referenced property's definition is changed.\n         * @memberof ReferenceProperty.prototype\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        /**\n         * Gets the reference frame that the position is defined in.\n         * This property is only valid if the referenced property is a {@link PositionProperty}.\n         * @memberof ReferenceProperty.prototype\n         * @type {ReferenceFrame}\n         * @readonly\n         */\n        referenceFrame : {\n            get : function() {\n                return resolve(this).referenceFrame;\n            }\n        },\n        /**\n         * Gets the id of the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {String}\n         * @readonly\n         */\n        targetId : {\n            get : function() {\n                return this._targetId;\n            }\n        },\n        /**\n         * Gets the collection containing the entity being referenced.\n         * @memberof ReferenceProperty.prototype\n         * @type {EntityCollection}\n         * @readonly\n         */\n        targetCollection : {\n            get : function() {\n                return this._targetCollection;\n            }\n        },\n        /**\n         * Gets the array of property names used to retrieve the referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {String[]}\n         * @readonly\n         */\n        targetPropertyNames : {\n            get : function() {\n                return this._targetPropertyNames;\n            }\n        },\n        /**\n         * Gets the resolved instance of the underlying referenced property.\n         * @memberof ReferenceProperty.prototype\n         * @type {Property}\n         * @readonly\n         */\n        resolvedProperty : {\n            get : function() {\n                return resolve(this);\n            }\n        }\n    });\n\n    /**\n     * Creates a new instance given the entity collection that will\n     * be used to resolve it and a string indicating the target entity id and property.\n     * The format of the string is \"objectId#foo.bar\", where # separates the id from\n     * property path and . separates sub-properties.  If the reference identifier or\n     * or any sub-properties contains a # . or \\ they must be escaped.\n     *\n     * @param {EntityCollection} targetCollection\n     * @param {String} referenceString\n     * @returns {ReferenceProperty} A new instance of ReferenceProperty.\n     *\n     * @exception {DeveloperError} invalid referenceString.\n     */\n    ReferenceProperty.fromString = function(targetCollection, referenceString) {\n        \n\n        var identifier;\n        var values = [];\n\n        var inIdentifier = true;\n        var isEscaped = false;\n        var token = '';\n        for (var i = 0; i < referenceString.length; ++i) {\n            var c = referenceString.charAt(i);\n\n            if (isEscaped) {\n                token += c;\n                isEscaped = false;\n            } else if (c === '\\\\') {\n                isEscaped = true;\n            } else if (inIdentifier && c === '#') {\n                identifier = token;\n                inIdentifier = false;\n                token = '';\n            } else if (!inIdentifier && c === '.') {\n                values.push(token);\n                token = '';\n            } else {\n                token += c;\n            }\n        }\n        values.push(token);\n\n        return new ReferenceProperty(targetCollection, identifier, values);\n    };\n\n    /**\n     * Gets the value of the property at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValue = function(time, result) {\n        return resolve(this).getValue(time, result);\n    };\n\n    /**\n     * Gets the value of the property at the provided time and in the provided reference frame.\n     * This method is only valid if the property being referenced is a {@link PositionProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the value.\n     * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.\n     * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.\n     * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.\n     */\n    ReferenceProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        return resolve(this).getValueInReferenceFrame(time, referenceFrame, result);\n    };\n\n    /**\n     * Gets the {@link Material} type at the provided time.\n     * This method is only valid if the property being referenced is a {@link MaterialProperty}.\n     *\n     * @param {JulianDate} time The time for which to retrieve the type.\n     * @returns {String} The type of material.\n     */\n    ReferenceProperty.prototype.getType = function(time) {\n        return resolve(this).getType(time);\n    };\n\n    /**\n     * Compares this property to the provided property and returns\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\n     *\n     * @param {Property} [other] The other property.\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n     */\n    ReferenceProperty.prototype.equals = function(other) {\n        if (this === other) {\n            return true;\n        }\n\n        var names = this._targetPropertyNames;\n        var otherNames = other._targetPropertyNames;\n\n        if (this._targetCollection !== other._targetCollection || //\n            this._targetId !== other._targetId || //\n            names.length !== otherNames.length) {\n            return false;\n        }\n\n        var length = this._targetPropertyNames.length;\n        for (var i = 0; i < length; i++) {\n            if (names[i] !== otherNames[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    ReferenceProperty.prototype._onTargetEntityDefinitionChanged = function(targetEntity, name, value, oldValue) {\n        if (this._targetPropertyNames[0] === name) {\n            this._resolveProperty = true;\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ReferenceProperty.prototype._onCollectionChanged = function(collection, added, removed) {\n        var targetEntity = this._targetEntity;\n        if (defined(targetEntity)) {\n            if (removed.indexOf(targetEntity) !== -1) {\n                targetEntity.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged, this);\n                this._resolveEntity = true;\n                this._resolveProperty = true;\n            } else if (this._resolveEntity) {\n                //If targetEntity is defined but resolveEntity is true, then the entity is detached\n                //and any change to the collection needs to incur an attempt to resolve in order to re-attach.\n                //without this if block, a reference that becomes re-attached will not signal definitionChanged\n                resolve(this);\n                if (!this._resolveEntity) {\n                    this._definitionChanged.raiseEvent(this);\n                }\n            }\n        }\n    };\n\n    return ReferenceProperty;\n});\n","define([\n        '../Core/ApproximateTerrainHeights',\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/oneTimeWarning',\n        '../Scene/GroundPrimitive',\n        '../Scene/HeightReference',\n        './CallbackProperty',\n        './ConstantProperty',\n        './GeometryUpdater',\n        './Property',\n        './TerrainOffsetProperty'\n    ], function(\n        ApproximateTerrainHeights,\n        Cartesian3,\n        Check,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        GeometryOffsetAttribute,\n        Iso8601,\n        oneTimeWarning,\n        GroundPrimitive,\n        HeightReference,\n        CallbackProperty,\n        ConstantProperty,\n        GeometryUpdater,\n        Property,\n        TerrainOffsetProperty) {\n    'use strict';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    /**\n     * An abstract class for updating ground geometry entities.\n     * @constructor\n     * @alias GroundGeometryUpdater\n     * @param {Object} options An object with the following properties:\n     * @param {Entity} options.entity The entity containing the geometry to be visualized.\n     * @param {Scene} options.scene The scene where visualization is taking place.\n     * @param {Object} options.geometryOptions Options for the geometry\n     * @param {String} options.geometryPropertyName The geometry property name\n     * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about\n     */\n    function GroundGeometryUpdater(options) {\n        GeometryUpdater.call(this, options);\n\n        this._zIndex = 0;\n        this._terrainOffsetProperty = undefined;\n    }\n\n    if (defined(Object.create)) {\n        GroundGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        GroundGeometryUpdater.prototype.constructor = GroundGeometryUpdater;\n    }\n\n    defineProperties(GroundGeometryUpdater.prototype, {\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        },\n\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof GroundGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    GroundGeometryUpdater.prototype._isOnTerrain = function(entity, geometry) {\n        return this._fillEnabled && !defined(geometry.height) && !defined(geometry.extrudedHeight) && GroundPrimitive.isSupported(this._scene);\n    };\n\n    GroundGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        return height === 0 || (defined(extrudedHeight) && extrudedHeight !== height);\n    };\n\n    GroundGeometryUpdater.prototype._computeCenter = DeveloperError.throwInstantiationError;\n\n    GroundGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n        if (defined(geometry.zIndex) && (defined(geometry.height) || defined(geometry.extrudedHeight))) {\n            oneTimeWarning(oneTimeWarning.geometryZIndex);\n        }\n\n        this._zIndex = defaultValue(geometry.zIndex, defaultZIndex);\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n        var extrudedHeightReferenceProperty = geometry.extrudedHeightReference;\n\n        if (defined(heightReferenceProperty) || defined(extrudedHeightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty, extrudedHeightReferenceProperty);\n        }\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    GroundGeometryUpdater.prototype.destroy = function() {\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        GeometryUpdater.prototype.destroy.call(this);\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryHeight = function(height, heightReference) {\n        \n        if (!defined(height)) {\n            if (heightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryHeightReference);\n            }\n            return;\n        }\n\n        if (heightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return height;\n        }\n        return 0.0;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.getGeometryExtrudedHeight = function(extrudedHeight, extrudedHeightReference) {\n        \n        if (!defined(extrudedHeight)) {\n            if (extrudedHeightReference !== HeightReference.NONE) {\n                oneTimeWarning(oneTimeWarning.geometryExtrudedHeightReference);\n            }\n            return;\n        }\n        if (extrudedHeightReference !== HeightReference.CLAMP_TO_GROUND) {\n            return extrudedHeight;\n        }\n\n        return GroundGeometryUpdater.CLAMP_TO_GROUND;\n    };\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.CLAMP_TO_GROUND = 'clamp';\n\n    /**\n     * @private\n     */\n    GroundGeometryUpdater.computeGeometryOffsetAttribute = function(height, heightReference, extrudedHeight, extrudedHeightReference) {\n        if (!defined(height) || !defined(heightReference)) {\n            heightReference = HeightReference.NONE;\n        }\n        if (!defined(extrudedHeight) || !defined(extrudedHeightReference)) {\n            extrudedHeightReference = HeightReference.NONE;\n        }\n        var n = 0;\n        if (heightReference !== HeightReference.NONE) {\n            n++;\n        }\n        if (extrudedHeightReference === HeightReference.RELATIVE_TO_GROUND) {\n            n++;\n        }\n        if (n === 2) {\n            return GeometryOffsetAttribute.ALL;\n        }\n        if (n === 1) {\n            return GeometryOffsetAttribute.TOP;\n        }\n\n        return undefined;\n    };\n\n    return GroundGeometryUpdater;\n});\n","define([\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/Ellipsoid',\n        '../Core/Event',\n        '../Core/ReferenceFrame',\n        './Property'\n    ], function(\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid,\n        Event,\n        ReferenceFrame,\n        Property) {\n    'use strict';\n\n    /**\n     * This is a temporary class for scaling position properties to the WGS84 surface.\n     * It will go away or be refactored to support data with arbitrary height references.\n     * @private\n     */\n    function ScaledPositionProperty(value) {\n        this._definitionChanged = new Event();\n        this._value = undefined;\n        this._removeSubscription = undefined;\n        this.setValue(value);\n    }\n\n    defineProperties(ScaledPositionProperty.prototype, {\n        isConstant : {\n            get : function() {\n                return Property.isConstant(this._value);\n            }\n        },\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        },\n        referenceFrame : {\n            get : function() {\n                return defined(this._value) ? this._value.referenceFrame : ReferenceFrame.FIXED;\n            }\n        }\n    });\n\n    ScaledPositionProperty.prototype.getValue = function(time, result) {\n        return this.getValueInReferenceFrame(time, ReferenceFrame.FIXED, result);\n    };\n\n    ScaledPositionProperty.prototype.setValue = function(value) {\n        if (this._value !== value) {\n            this._value = value;\n\n            if (defined(this._removeSubscription)) {\n                this._removeSubscription();\n                this._removeSubscription = undefined;\n            }\n\n            if (defined(value)) {\n                this._removeSubscription = value.definitionChanged.addEventListener(this._raiseDefinitionChanged, this);\n            }\n            this._definitionChanged.raiseEvent(this);\n        }\n    };\n\n    ScaledPositionProperty.prototype.getValueInReferenceFrame = function(time, referenceFrame, result) {\n        \n\n        if (!defined(this._value)) {\n            return undefined;\n        }\n\n        result = this._value.getValueInReferenceFrame(time, referenceFrame, result);\n        return defined(result) ? Ellipsoid.WGS84.scaleToGeodeticSurface(result, result) : undefined;\n    };\n\n    ScaledPositionProperty.prototype.equals = function(other) {\n        return this === other || (other instanceof ScaledPositionProperty && this._value === other._value);\n    };\n\n    ScaledPositionProperty.prototype._raiseDefinitionChanged = function() {\n        this._definitionChanged.raiseEvent(this);\n    };\n\n    return ScaledPositionProperty;\n});\n","define([\n        '../Core/defaultValue',\n        '../Core/defined',\n        './CallbackProperty',\n        './GeometryUpdater',\n        './TerrainOffsetProperty'\n    ], function(\n        defaultValue,\n        defined,\n        CallbackProperty,\n        GeometryUpdater,\n        TerrainOffsetProperty) {\n    'use strict';\n\n    function heightReferenceOnEntityPropertyChanged(entity, propertyName, newValue, oldValue) {\n        GeometryUpdater.prototype._onEntityPropertyChanged.call(this, entity, propertyName, newValue, oldValue);\n        if (this._observedPropertyNames.indexOf(propertyName) === -1) {\n            return;\n        }\n\n        var geometry = this._entity[this._geometryPropertyName];\n        if (!defined(geometry)) {\n            return;\n        }\n\n        if (defined(this._terrainOffsetProperty)) {\n            this._terrainOffsetProperty.destroy();\n            this._terrainOffsetProperty = undefined;\n        }\n\n        var heightReferenceProperty = geometry.heightReference;\n\n        if (defined(heightReferenceProperty)) {\n            var centerPosition = new CallbackProperty(this._computeCenter.bind(this), !this._dynamic);\n            this._terrainOffsetProperty = new TerrainOffsetProperty(this._scene, centerPosition, heightReferenceProperty);\n        }\n    }\n\n    return heightReferenceOnEntityPropertyChanged;\n});\n","define([\n        './Cartesian2',\n        './Cartesian3',\n        './Cartesian4',\n        './Cartographic',\n        './CornerType',\n        './EllipsoidTangentPlane',\n        './Math',\n        './Matrix3',\n        './Matrix4',\n        './PolylinePipeline',\n        './Quaternion',\n        './Transforms'\n    ], function(\n        Cartesian2,\n        Cartesian3,\n        Cartesian4,\n        Cartographic,\n        CornerType,\n        EllipsoidTangentPlane,\n        CesiumMath,\n        Matrix3,\n        Matrix4,\n        PolylinePipeline,\n        Quaternion,\n        Transforms) {\n    'use strict';\n\n    var scratch2Array = [new Cartesian3(), new Cartesian3()];\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var scratchCartesian5 = new Cartesian3();\n    var scratchCartesian6 = new Cartesian3();\n    var scratchCartesian7 = new Cartesian3();\n    var scratchCartesian8 = new Cartesian3();\n    var scratchCartesian9 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    /**\n     * @private\n     */\n    var PolylineVolumeGeometryLibrary = {};\n\n    var cartographic = new Cartographic();\n    function scaleToSurface(positions, ellipsoid) {\n        var heights = new Array(positions.length);\n        for (var i = 0; i < positions.length; i++) {\n            var pos = positions[i];\n            cartographic = ellipsoid.cartesianToCartographic(pos, cartographic);\n            heights[i] = cartographic.height;\n            positions[i] = ellipsoid.scaleToGeodeticSurface(pos, pos);\n        }\n        return heights;\n    }\n\n    function subdivideHeights(points, h0, h1, granularity) {\n        var p0 = points[0];\n        var p1 = points[1];\n        var angleBetween = Cartesian3.angleBetween(p0, p1);\n        var numPoints = Math.ceil(angleBetween / granularity);\n        var heights = new Array(numPoints);\n        var i;\n        if (h0 === h1) {\n            for (i = 0; i < numPoints; i++) {\n                heights[i] = h0;\n            }\n            heights.push(h1);\n            return heights;\n        }\n\n        var dHeight = h1 - h0;\n        var heightPerVertex = dHeight / (numPoints);\n\n        for (i = 1; i < numPoints; i++) {\n            var h = h0 + i * heightPerVertex;\n            heights[i] = h;\n        }\n\n        heights[0] = h0;\n        heights.push(h1);\n        return heights;\n    }\n\n    var nextScratch = new Cartesian3();\n    var prevScratch = new Cartesian3();\n\n    function computeRotationAngle(start, end, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, start, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, end, prevScratch), prevScratch);\n        var angle = Cartesian2.angleBetween(next, prev);\n\n        return (prev.x * next.y - prev.y * next.x >= 0.0) ? -angle : angle;\n    }\n\n    var negativeX = new Cartesian3(-1, 0, 0);\n    var transform = new Matrix4();\n    var translation = new Matrix4();\n    var rotationZ = new Matrix3();\n    var scaleMatrix = Matrix3.IDENTITY.clone();\n    var westScratch = new Cartesian3();\n    var finalPosScratch = new Cartesian4();\n    var heightCartesian = new Cartesian3();\n    function addPosition(center, left, shape, finalPositions, ellipsoid, height, xScalar, repeat) {\n        var west = westScratch;\n        var finalPosition = finalPosScratch;\n        transform = Transforms.eastNorthUpToFixedFrame(center, ellipsoid, transform);\n\n        west = Matrix4.multiplyByPointAsVector(transform, negativeX, west);\n        west = Cartesian3.normalize(west, west);\n        var angle = computeRotationAngle(west, left, center, ellipsoid);\n        rotationZ = Matrix3.fromRotationZ(angle, rotationZ);\n\n        heightCartesian.z = height;\n        transform = Matrix4.multiplyTransformation(transform, Matrix4.fromRotationTranslation(rotationZ, heightCartesian, translation), transform);\n        var scale = scaleMatrix;\n        scale[0] = xScalar;\n\n        for (var j = 0; j < repeat; j++) {\n            for (var i = 0; i < shape.length; i += 3) {\n                finalPosition = Cartesian3.fromArray(shape, i, finalPosition);\n                finalPosition = Matrix3.multiplyByVector(scale, finalPosition, finalPosition);\n                finalPosition = Matrix4.multiplyByPoint(transform, finalPosition, finalPosition);\n                finalPositions.push(finalPosition.x, finalPosition.y, finalPosition.z);\n            }\n        }\n\n        return finalPositions;\n    }\n\n    var centerScratch = new Cartesian3();\n    function addPositions(centers, left, shape, finalPositions, ellipsoid, heights, xScalar) {\n        for (var i = 0; i < centers.length; i += 3) {\n            var center = Cartesian3.fromArray(centers, i, centerScratch);\n            finalPositions = addPosition(center, left, shape, finalPositions, ellipsoid, heights[i / 3], xScalar, 1);\n        }\n        return finalPositions;\n    }\n\n    function convertShapeTo3DDuplicate(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0), duplicate points\n        var length = shape2D.length;\n        var shape = new Array(length * 6);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        var point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n        for (var i = 1; i < length; i++) {\n            point = shape2D[i];\n            var x = point.x - xOffset;\n            var z = point.y - yOffset;\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n\n            shape[index++] = x;\n            shape[index++] = 0.0;\n            shape[index++] = z;\n        }\n        point = shape2D[0];\n        shape[index++] = point.x - xOffset;\n        shape[index++] = 0.0;\n        shape[index++] = point.y - yOffset;\n\n        return shape;\n    }\n\n    function convertShapeTo3D(shape2D, boundingRectangle) { //orientate 2D shape to XZ plane center at (0, 0, 0)\n        var length = shape2D.length;\n        var shape = new Array(length * 3);\n        var index = 0;\n        var xOffset = boundingRectangle.x + boundingRectangle.width / 2;\n        var yOffset = boundingRectangle.y + boundingRectangle.height / 2;\n\n        for (var i = 0; i < length; i++) {\n            shape[index++] = shape2D[i].x - xOffset;\n            shape[index++] = 0;\n            shape[index++] = shape2D[i].y - yOffset;\n        }\n\n        return shape;\n    }\n\n    var quaterion = new Quaternion();\n    var startPointScratch = new Cartesian3();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(pivot, startPoint, endPoint, cornerType, leftIsOutside, ellipsoid, finalPositions, shape, height, duplicatePoints) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, pivot, scratch1), Cartesian3.subtract(endPoint, pivot, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 0 : Math.ceil(angle / CesiumMath.toRadians(5));\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(pivot, scratch1), angle / (granularity + 1), quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(pivot, angle / (granularity + 1), quaterion), rotMatrix);\n        }\n\n        var left;\n        var surfacePoint;\n        startPoint = Cartesian3.clone(startPoint, startPointScratch);\n        if (granularity > 0) {\n            var repeat = duplicatePoints ? 2 : 1;\n            for (var i = 0; i < granularity; i++) {\n                startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n                left = Cartesian3.subtract(startPoint, pivot, scratch1);\n                left = Cartesian3.normalize(left, left);\n                if (!leftIsOutside) {\n                    left = Cartesian3.negate(left, left);\n                }\n                surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n                finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, repeat);\n            }\n        } else {\n            left = Cartesian3.subtract(startPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(startPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n\n            endPoint = Cartesian3.clone(endPoint, startPointScratch);\n            left = Cartesian3.subtract(endPoint, pivot, scratch1);\n            left = Cartesian3.normalize(left, left);\n            if (!leftIsOutside) {\n                left = Cartesian3.negate(left, left);\n            }\n            surfacePoint = ellipsoid.scaleToGeodeticSurface(endPoint, scratch2);\n            finalPositions = addPosition(surfacePoint, left, shape, finalPositions, ellipsoid, height, 1, 1);\n        }\n\n        return finalPositions;\n    }\n\n    PolylineVolumeGeometryLibrary.removeDuplicatesFromShape = function(shapePositions) {\n        var length = shapePositions.length;\n        var cleanedPositions = [];\n        for (var i0 = length - 1, i1 = 0; i1 < length; i0 = i1++) {\n            var v0 = shapePositions[i0];\n            var v1 = shapePositions[i1];\n\n            if (!Cartesian2.equals(v0, v1)) {\n                cleanedPositions.push(v1); // Shallow copy!\n            }\n        }\n\n        return cleanedPositions;\n    };\n\n    PolylineVolumeGeometryLibrary.angleIsGreaterThanPi = function(forward, backward, position, ellipsoid) {\n        var tangentPlane = new EllipsoidTangentPlane(position, ellipsoid);\n        var next = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, forward, nextScratch), nextScratch);\n        var prev = tangentPlane.projectPointOntoPlane(Cartesian3.add(position, backward, prevScratch), prevScratch);\n\n        return ((prev.x * next.y) - (prev.y * next.x)) >= 0.0;\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    PolylineVolumeGeometryLibrary.computePositions = function(positions, shape2D, boundingRectangle, geometry, duplicatePoints) {\n        var ellipsoid = geometry._ellipsoid;\n        var heights = scaleToSurface(positions, ellipsoid);\n        var granularity = geometry._granularity;\n        var cornerType = geometry._cornerType;\n        var shapeForSides = duplicatePoints ? convertShapeTo3DDuplicate(shape2D, boundingRectangle) : convertShapeTo3D(shape2D, boundingRectangle);\n        var shapeForEnds = duplicatePoints ? convertShapeTo3D(shape2D, boundingRectangle) : undefined;\n        var heightOffset = boundingRectangle.height / 2;\n        var width = boundingRectangle.width / 2;\n        var length = positions.length;\n        var finalPositions = [];\n        var ends = duplicatePoints ? [] : undefined;\n\n        var forward = scratchCartesian1;\n        var backward = scratchCartesian2;\n        var cornerDirection = scratchCartesian3;\n        var surfaceNormal = scratchCartesian4;\n        var pivot = scratchCartesian5;\n        var start = scratchCartesian6;\n        var end = scratchCartesian7;\n        var left = scratchCartesian8;\n        var previousPosition = scratchCartesian9;\n\n        var position = positions[0];\n        var nextPosition = positions[1];\n        surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n        forward = Cartesian3.subtract(nextPosition, position, forward);\n        forward = Cartesian3.normalize(forward, forward);\n        left = Cartesian3.cross(surfaceNormal, forward, left);\n        left = Cartesian3.normalize(left, left);\n        var h0 = heights[0];\n        var h1 = heights[1];\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h0 + heightOffset, 1, 1);\n        }\n        previousPosition = Cartesian3.clone(position, previousPosition);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n        var subdividedHeights;\n        var subdividedPositions;\n        for (var i = 1; i < length - 1; i++) {\n            var repeat = duplicatePoints ? 2 : 1;\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.subtract(nextPosition, position, forward);\n            forward = Cartesian3.normalize(forward, forward);\n            cornerDirection = Cartesian3.add(forward, backward, cornerDirection);\n            cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n            surfaceNormal = ellipsoid.geodeticSurfaceNormal(position, surfaceNormal);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(forward, surfaceNormal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(surfaceNormal, Cartesian3.dot(backward, surfaceNormal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, surfaceNormal, cornerDirection);\n                cornerDirection = Cartesian3.cross(surfaceNormal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = 1 / Math.max(0.25, (Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1))));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                if (leftIsOutside) {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        cornerDirection = Cartesian3.negate(cornerDirection, cornerDirection);\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                } else {\n                    pivot = Cartesian3.add(position, Cartesian3.multiplyByScalar(cornerDirection, scalar * width, cornerDirection), pivot);\n                    start = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, start), start);\n                    scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n                    scratch2Array[1] = Cartesian3.clone(start, scratch2Array[1]);\n                    subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scratch2Array,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n                    left = Cartesian3.cross(surfaceNormal, forward, left);\n                    left = Cartesian3.normalize(left, left);\n                    end = Cartesian3.add(pivot, Cartesian3.multiplyByScalar(left, -width, end), end);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        computeRoundCorner(pivot, start, end, cornerType, leftIsOutside, ellipsoid, finalPositions, shapeForSides, h1 + heightOffset, duplicatePoints);\n                    } else {\n                        finalPositions = addPosition(position, cornerDirection, shapeForSides, finalPositions, ellipsoid, h1 + heightOffset, scalar, repeat);\n                    }\n                    previousPosition = Cartesian3.clone(end, previousPosition);\n                }\n                backward = Cartesian3.negate(forward, backward);\n            } else {\n                finalPositions = addPosition(previousPosition, left, shapeForSides, finalPositions, ellipsoid, h0 + heightOffset, 1, 1);\n                previousPosition = position;\n            }\n            h0 = h1;\n            h1 = heights[i + 1];\n            position = nextPosition;\n        }\n\n        scratch2Array[0] = Cartesian3.clone(previousPosition, scratch2Array[0]);\n        scratch2Array[1] = Cartesian3.clone(position, scratch2Array[1]);\n        subdividedHeights = subdivideHeights(scratch2Array, h0 + heightOffset, h1 + heightOffset, granularity);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scratch2Array,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        finalPositions = addPositions(subdividedPositions, left, shapeForSides, finalPositions, ellipsoid, subdividedHeights, 1);\n        if (duplicatePoints) {\n            ends = addPosition(position, left, shapeForEnds, ends, ellipsoid, h1 + heightOffset, 1, 1);\n        }\n\n        length = finalPositions.length;\n        var posLength = duplicatePoints ? length + ends.length : length;\n        var combinedPositions = new Float64Array(posLength);\n        combinedPositions.set(finalPositions);\n        if (duplicatePoints) {\n            combinedPositions.set(ends, length);\n        }\n\n        return combinedPositions;\n    };\n\n    return PolylineVolumeGeometryLibrary;\n});\n","define([\n    '../Core/Cartesian3',\n    '../Core/Cartographic',\n    '../Core/Check',\n    '../Core/defined',\n    '../Core/defineProperties',\n    '../Core/destroyObject',\n    '../Core/Event',\n    '../Core/Iso8601',\n    '../Core/Math',\n    '../Scene/HeightReference',\n    '../Scene/SceneMode',\n    './Property'\n], function(\n    Cartesian3,\n    Cartographic,\n    Check,\n    defined,\n    defineProperties,\n    destroyObject,\n    Event,\n    Iso8601,\n    CesiumMath,\n    HeightReference,\n    SceneMode,\n    Property) {\n    'use strict';\n\n    var scratchPosition = new Cartesian3();\n    var scratchCarto = new Cartographic();\n\n    /**\n     * @private\n     */\n    function TerrainOffsetProperty(scene, positionProperty, heightReferenceProperty, extrudedHeightReferenceProperty) {\n        \n\n        this._scene = scene;\n        this._heightReference = heightReferenceProperty;\n        this._extrudedHeightReference = extrudedHeightReferenceProperty;\n        this._positionProperty = positionProperty;\n\n        this._position = new Cartesian3();\n        this._cartographicPosition = new Cartographic();\n        this._normal = new Cartesian3();\n\n        this._definitionChanged = new Event();\n        this._terrainHeight = 0;\n        this._removeCallbackFunc = undefined;\n        this._removeEventListener = undefined;\n        this._removeModeListener = undefined;\n\n        var that = this;\n        if (defined(scene.globe)) {\n            this._removeEventListener = scene.terrainProviderChanged.addEventListener(function() {\n                that._updateClamping();\n            });\n            this._removeModeListener = scene.morphComplete.addEventListener(function() {\n                that._updateClamping();\n            });\n        }\n\n        if (positionProperty.isConstant) {\n            var position = positionProperty.getValue(Iso8601.MINIMUM_VALUE, scratchPosition);\n            if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n                return;\n            }\n            this._position = Cartesian3.clone(position, this._position);\n\n            this._updateClamping();\n\n            this._normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        }\n    }\n\n    defineProperties(TerrainOffsetProperty.prototype, {\n        /**\n         * Gets a value indicating if this property is constant.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isConstant : {\n            get : function() {\n                return false;\n            }\n        },\n        /**\n         * Gets the event that is raised whenever the definition of this property changes.\n         * @memberof TerrainOffsetProperty.prototype\n         *\n         * @type {Event}\n         * @readonly\n         */\n        definitionChanged : {\n            get : function() {\n                return this._definitionChanged;\n            }\n        }\n    });\n\n    /**\n     * @private\n     */\n    TerrainOffsetProperty.prototype._updateClamping = function() {\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n\n        var scene = this._scene;\n        var globe = scene.globe;\n        var position = this._position;\n\n        if (!defined(globe) || Cartesian3.equals(position, Cartesian3.ZERO)) {\n            this._terrainHeight = 0;\n            return;\n        }\n        var ellipsoid = globe.ellipsoid;\n        var surface = globe._surface;\n\n        var that = this;\n        var cartographicPosition = ellipsoid.cartesianToCartographic(position, this._cartographicPosition);\n        var height = globe.getHeight(cartographicPosition);\n        if (defined(height)) {\n            this._terrainHeight = height;\n        } else {\n            this._terrainHeight = 0;\n        }\n\n        function updateFunction(clampedPosition) {\n            if (scene.mode === SceneMode.SCENE3D) {\n                var carto = ellipsoid.cartesianToCartographic(clampedPosition, scratchCarto);\n                that._terrainHeight = carto.height;\n            } else {\n                that._terrainHeight = clampedPosition.x;\n            }\n            that.definitionChanged.raiseEvent();\n        }\n        this._removeCallbackFunc = surface.updateHeight(cartographicPosition, updateFunction);\n    };\n\n    /**\n     * Gets the height relative to the terrain based on the positions.\n     *\n     * @returns {Cartesian3} The offset\n     */\n    TerrainOffsetProperty.prototype.getValue = function(time, result) {\n        var heightReference = Property.getValueOrDefault(this._heightReference, time, HeightReference.NONE);\n        var extrudedHeightReference = Property.getValueOrDefault(this._extrudedHeightReference, time, HeightReference.NONE);\n\n        if (heightReference === HeightReference.NONE && extrudedHeightReference !== HeightReference.RELATIVE_TO_GROUND) {\n            this._position = Cartesian3.clone(Cartesian3.ZERO, this._position);\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (this._positionProperty.isConstant) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        var scene = this._scene;\n        var position = this._positionProperty.getValue(time, scratchPosition);\n        if (!defined(position) || Cartesian3.equals(position, Cartesian3.ZERO) || !defined(scene.globe)) {\n            return Cartesian3.clone(Cartesian3.ZERO, result);\n        }\n\n        if (Cartesian3.equalsEpsilon(this._position, position, CesiumMath.EPSILON10)) {\n            return Cartesian3.multiplyByScalar(this._normal, this._terrainHeight, result);\n        }\n\n        this._position = Cartesian3.clone(position, this._position);\n\n        this._updateClamping();\n\n        var normal = scene.globe.ellipsoid.geodeticSurfaceNormal(position, this._normal);\n        return Cartesian3.multiplyByScalar(normal, this._terrainHeight, result);\n    };\n\n    TerrainOffsetProperty.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    TerrainOffsetProperty.prototype.destroy = function() {\n        if (defined(this._removeEventListener)) {\n            this._removeEventListener();\n        }\n        if (defined(this._removeModeListener)) {\n            this._removeModeListener();\n        }\n        if (defined(this._removeCallbackFunc)) {\n            this._removeCallbackFunc();\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * A function which creates one or more providers.\n     * @callback TerrainOffsetProperty~PositionFunction\n     * @param {JulianDate} time The clock time at which to retrieve the position\n     * @param {Cartesian3} result The result position\n     * @returns {Cartesian3} The position at which to do the terrain height check\n     */\n\n    return TerrainOffsetProperty;\n});\n","define([\n        './Cartesian3',\n        './CornerType',\n        './defined',\n        './Math',\n        './Matrix3',\n        './PolylinePipeline',\n        './PolylineVolumeGeometryLibrary',\n        './Quaternion'\n    ], function(\n        Cartesian3,\n        CornerType,\n        defined,\n        CesiumMath,\n        Matrix3,\n        PolylinePipeline,\n        PolylineVolumeGeometryLibrary,\n        Quaternion) {\n    'use strict';\n\n    /**\n     * @private\n     */\n    var CorridorGeometryLibrary = {};\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n    var scratch3 = new Cartesian3();\n    var scratch4 = new Cartesian3();\n\n    var scaleArray2 = [new Cartesian3(), new Cartesian3()];\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n    var cartesian7 = new Cartesian3();\n    var cartesian8 = new Cartesian3();\n    var cartesian9 = new Cartesian3();\n    var cartesian10 = new Cartesian3();\n\n    var quaterion = new Quaternion();\n    var rotMatrix = new Matrix3();\n    function computeRoundCorner(cornerPoint, startPoint, endPoint, cornerType, leftIsOutside) {\n        var angle = Cartesian3.angleBetween(Cartesian3.subtract(startPoint, cornerPoint, scratch1), Cartesian3.subtract(endPoint, cornerPoint, scratch2));\n        var granularity = (cornerType === CornerType.BEVELED) ? 1 : Math.ceil(angle / CesiumMath.toRadians(5)) + 1;\n\n        var size = granularity * 3;\n        var array = new Array(size);\n\n        array[size - 3] = endPoint.x;\n        array[size - 2] = endPoint.y;\n        array[size - 1] = endPoint.z;\n\n        var m;\n        if (leftIsOutside) {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(cornerPoint, scratch1), angle / granularity, quaterion), rotMatrix);\n        } else {\n            m = Matrix3.fromQuaternion(Quaternion.fromAxisAngle(cornerPoint, angle / granularity, quaterion), rotMatrix);\n        }\n\n        var index = 0;\n        startPoint = Cartesian3.clone(startPoint, scratch1);\n        for (var i = 0; i < granularity; i++) {\n            startPoint = Matrix3.multiplyByVector(m, startPoint, startPoint);\n            array[index++] = startPoint.x;\n            array[index++] = startPoint.y;\n            array[index++] = startPoint.z;\n        }\n\n        return array;\n    }\n\n    function addEndCaps(calculatedPositions) {\n        var cornerPoint = cartesian1;\n        var startPoint = cartesian2;\n        var endPoint = cartesian3;\n\n        var leftEdge = calculatedPositions[1];\n        startPoint = Cartesian3.fromArray(calculatedPositions[1], leftEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(calculatedPositions[0], 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var firstEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        var length = calculatedPositions.length - 1;\n        var rightEdge = calculatedPositions[length - 1];\n        leftEdge = calculatedPositions[length];\n        startPoint = Cartesian3.fromArray(rightEdge, rightEdge.length - 3, startPoint);\n        endPoint = Cartesian3.fromArray(leftEdge, 0, endPoint);\n        cornerPoint = Cartesian3.midpoint(startPoint, endPoint, cornerPoint);\n        var lastEndCap = computeRoundCorner(cornerPoint, startPoint, endPoint, CornerType.ROUNDED, false);\n\n        return [firstEndCap, lastEndCap];\n    }\n\n    function computeMiteredCorner(position, leftCornerDirection, lastPoint, leftIsOutside) {\n        var cornerPoint = scratch1;\n        if (leftIsOutside) {\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        } else {\n            leftCornerDirection = Cartesian3.negate(leftCornerDirection, leftCornerDirection);\n            cornerPoint = Cartesian3.add(position, leftCornerDirection, cornerPoint);\n        }\n        return [cornerPoint.x, cornerPoint.y, cornerPoint.z, lastPoint.x, lastPoint.y, lastPoint.z];\n    }\n\n    function addShiftedPositions(positions, left, scalar, calculatedPositions) {\n        var rightPositions = new Array(positions.length);\n        var leftPositions = new Array(positions.length);\n        var scaledLeft = Cartesian3.multiplyByScalar(left, scalar, scratch1);\n        var scaledRight = Cartesian3.negate(scaledLeft, scratch2);\n        var rightIndex = 0;\n        var leftIndex = positions.length - 1;\n\n        for (var i = 0; i < positions.length; i += 3) {\n            var pos = Cartesian3.fromArray(positions, i, scratch3);\n            var rightPos = Cartesian3.add(pos, scaledRight, scratch4);\n            rightPositions[rightIndex++] = rightPos.x;\n            rightPositions[rightIndex++] = rightPos.y;\n            rightPositions[rightIndex++] = rightPos.z;\n\n            var leftPos = Cartesian3.add(pos, scaledLeft, scratch4);\n            leftPositions[leftIndex--] = leftPos.z;\n            leftPositions[leftIndex--] = leftPos.y;\n            leftPositions[leftIndex--] = leftPos.x;\n        }\n        calculatedPositions.push(rightPositions, leftPositions);\n\n        return calculatedPositions;\n    }\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.addAttribute = function(attribute, value, front, back) {\n        var x = value.x;\n        var y = value.y;\n        var z = value.z;\n        if (defined(front)) {\n            attribute[front] = x;\n            attribute[front + 1] = y;\n            attribute[front + 2] = z;\n        }\n        if (defined(back)) {\n            attribute[back] = z;\n            attribute[back - 1] = y;\n            attribute[back - 2] = x;\n        }\n    };\n\n    var scratchForwardProjection = new Cartesian3();\n    var scratchBackwardProjection = new Cartesian3();\n\n    /**\n     * @private\n     */\n    CorridorGeometryLibrary.computePositions = function(params) {\n        var granularity = params.granularity;\n        var positions = params.positions;\n        var ellipsoid = params.ellipsoid;\n        var width = params.width / 2;\n        var cornerType = params.cornerType;\n        var saveAttributes = params.saveAttributes;\n        var normal = cartesian1;\n        var forward = cartesian2;\n        var backward = cartesian3;\n        var left = cartesian4;\n        var cornerDirection = cartesian5;\n        var startPoint = cartesian6;\n        var previousPos = cartesian7;\n        var rightPos = cartesian8;\n        var leftPos = cartesian9;\n        var center = cartesian10;\n        var calculatedPositions = [];\n        var calculatedLefts = (saveAttributes) ? [] : undefined;\n        var calculatedNormals = (saveAttributes) ? [] : undefined;\n        var position = positions[0]; //add first point\n        var nextPosition = positions[1];\n\n        forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n        previousPos = Cartesian3.clone(position, previousPos);\n        position = nextPosition;\n        backward = Cartesian3.negate(forward, backward);\n\n        var subdividedPositions;\n        var corners = [];\n        var i;\n        var length = positions.length;\n        for (i = 1; i < length - 1; i++) { // add middle points and corners\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n            nextPosition = positions[i + 1];\n            forward = Cartesian3.normalize(Cartesian3.subtract(nextPosition, position, forward), forward);\n            cornerDirection = Cartesian3.normalize(Cartesian3.add(forward, backward, cornerDirection), cornerDirection);\n\n            var forwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(forward, normal), scratchForwardProjection);\n            Cartesian3.subtract(forward, forwardProjection, forwardProjection);\n            Cartesian3.normalize(forwardProjection, forwardProjection);\n\n            var backwardProjection = Cartesian3.multiplyByScalar(normal, Cartesian3.dot(backward, normal), scratchBackwardProjection);\n            Cartesian3.subtract(backward, backwardProjection, backwardProjection);\n            Cartesian3.normalize(backwardProjection, backwardProjection);\n\n            var doCorner = !CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(forwardProjection, backwardProjection)), 1.0, CesiumMath.EPSILON7);\n\n            if (doCorner) {\n                cornerDirection = Cartesian3.cross(cornerDirection, normal, cornerDirection);\n                cornerDirection = Cartesian3.cross(normal, cornerDirection, cornerDirection);\n                cornerDirection = Cartesian3.normalize(cornerDirection, cornerDirection);\n                var scalar = width / Math.max(0.25, Cartesian3.magnitude(Cartesian3.cross(cornerDirection, backward, scratch1)));\n                var leftIsOutside = PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(forward, backward, position, ellipsoid);\n                cornerDirection = Cartesian3.multiplyByScalar(cornerDirection, scalar, cornerDirection);\n                if (leftIsOutside) {\n                    rightPos = Cartesian3.add(position, cornerDirection, rightPos);\n                    center = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, center), center);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(leftPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    leftPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width * 2, leftPos), leftPos);\n                    previousPos = Cartesian3.add(rightPos, Cartesian3.multiplyByScalar(left, width, previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            leftPositions : computeRoundCorner(rightPos, startPoint, leftPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            leftPositions : computeMiteredCorner(position, Cartesian3.negate(cornerDirection, cornerDirection), leftPos, leftIsOutside)\n                        });\n                    }\n                } else {\n                    leftPos = Cartesian3.add(position, cornerDirection, leftPos);\n                    center = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, center), center), center);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n                    scaleArray2[1] = Cartesian3.clone(center, scaleArray2[1]);\n                    subdividedPositions = PolylinePipeline.generateArc({\n                        positions: scaleArray2,\n                        granularity: granularity,\n                        ellipsoid: ellipsoid\n                    });\n                    calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n                    if (saveAttributes) {\n                        calculatedLefts.push(left.x, left.y, left.z);\n                        calculatedNormals.push(normal.x, normal.y, normal.z);\n                    }\n                    startPoint = Cartesian3.clone(rightPos, startPoint);\n                    left = Cartesian3.normalize(Cartesian3.cross(normal, forward, left), left);\n                    rightPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width * 2, rightPos), rightPos), rightPos);\n                    previousPos = Cartesian3.add(leftPos, Cartesian3.negate(Cartesian3.multiplyByScalar(left, width, previousPos), previousPos), previousPos);\n                    if (cornerType === CornerType.ROUNDED || cornerType === CornerType.BEVELED) {\n                        corners.push({\n                            rightPositions : computeRoundCorner(leftPos, startPoint, rightPos, cornerType, leftIsOutside)\n                        });\n                    } else {\n                        corners.push({\n                            rightPositions : computeMiteredCorner(position, cornerDirection, rightPos, leftIsOutside)\n                        });\n                    }\n                }\n                backward = Cartesian3.negate(forward, backward);\n            }\n            position = nextPosition;\n        }\n\n        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n        scaleArray2[0] = Cartesian3.clone(previousPos, scaleArray2[0]);\n        scaleArray2[1] = Cartesian3.clone(position, scaleArray2[1]);\n        subdividedPositions = PolylinePipeline.generateArc({\n            positions: scaleArray2,\n            granularity: granularity,\n            ellipsoid: ellipsoid\n        });\n        calculatedPositions = addShiftedPositions(subdividedPositions, left, width, calculatedPositions);\n        if (saveAttributes) {\n            calculatedLefts.push(left.x, left.y, left.z);\n            calculatedNormals.push(normal.x, normal.y, normal.z);\n        }\n\n        var endPositions;\n        if (cornerType === CornerType.ROUNDED) {\n            endPositions = addEndCaps(calculatedPositions);\n        }\n\n        return {\n            positions : calculatedPositions,\n            corners : corners,\n            lefts : calculatedLefts,\n            normals : calculatedNormals,\n            endPositions : endPositions\n        };\n    };\n\n    return CorridorGeometryLibrary;\n});\n","define([\n        './Math'\n    ], function(\n        CesiumMath) {\n    'use strict';\n\n    /**\n     * @private\n     */\n    var CylinderGeometryLibrary = {};\n\n    /**\n     * @private\n     */\n    CylinderGeometryLibrary.computePositions = function(length, topRadius, bottomRadius, slices, fill){\n        var topZ = length * 0.5;\n        var bottomZ = -topZ;\n\n        var twoSlice = slices + slices;\n        var size = (fill) ? 2 * twoSlice : twoSlice;\n        var positions = new Float64Array(size*3);\n        var i;\n        var index = 0;\n        var tbIndex = 0;\n        var bottomOffset = (fill) ? twoSlice*3 : 0;\n        var topOffset = (fill) ? (twoSlice + slices)*3 : slices*3;\n\n        for (i = 0; i < slices; i++) {\n            var angle = i / slices * CesiumMath.TWO_PI;\n            var x = Math.cos(angle);\n            var y = Math.sin(angle);\n            var bottomX = x * bottomRadius;\n            var bottomY = y * bottomRadius;\n            var topX = x * topRadius;\n            var topY = y * topRadius;\n\n            positions[tbIndex + bottomOffset] = bottomX;\n            positions[tbIndex + bottomOffset + 1] = bottomY;\n            positions[tbIndex + bottomOffset + 2] = bottomZ;\n\n            positions[tbIndex + topOffset] = topX;\n            positions[tbIndex + topOffset + 1] = topY;\n            positions[tbIndex + topOffset + 2] = topZ;\n            tbIndex += 3;\n            if (fill) {\n                positions[index++] = bottomX;\n                positions[index++] = bottomY;\n                positions[index++] = bottomZ;\n                positions[index++] = topX;\n                positions[index++] = topY;\n                positions[index++] = topZ;\n            }\n        }\n\n        return positions;\n    };\n\n    return CylinderGeometryLibrary;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/defined',\n        './BoundingSphereState'\n    ], function(\n        AssociativeArray,\n        defined,\n        BoundingSphereState) {\n    'use strict';\n\n    /**\n     * @private\n     */\n    function DynamicGeometryBatch(primitives, orderedGroundPrimitives) {\n        this._primitives = primitives;\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._dynamicUpdaters = new AssociativeArray();\n    }\n\n    DynamicGeometryBatch.prototype.add = function(time, updater) {\n        this._dynamicUpdaters.set(updater.id, updater.createDynamicUpdater(this._primitives, this._orderedGroundPrimitives));\n    };\n\n    DynamicGeometryBatch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var dynamicUpdater = this._dynamicUpdaters.get(id);\n        if (defined(dynamicUpdater)) {\n            this._dynamicUpdaters.remove(id);\n            dynamicUpdater.destroy();\n        }\n    };\n\n    DynamicGeometryBatch.prototype.update = function(time) {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].update(time);\n        }\n        return true;\n    };\n\n    DynamicGeometryBatch.prototype.removeAllPrimitives = function() {\n        var geometries = this._dynamicUpdaters.values;\n        for (var i = 0, len = geometries.length; i < len; i++) {\n            geometries[i].destroy();\n        }\n        this._dynamicUpdaters.removeAll();\n    };\n\n    DynamicGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        updater = this._dynamicUpdaters.get(updater.id);\n        if (defined(updater) && defined(updater.getBoundingSphere)) {\n            return updater.getBoundingSphere(result);\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    return DynamicGeometryBatch;\n});\n","define([\n        './Cartesian3',\n        './Math',\n        './Matrix3',\n        './Quaternion'\n    ], function(\n        Cartesian3,\n        CesiumMath,\n        Matrix3,\n        Quaternion) {\n    'use strict';\n\n    var EllipseGeometryLibrary = {};\n\n    var rotAxis = new Cartesian3();\n    var tempVec = new Cartesian3();\n    var unitQuat = new Quaternion();\n    var rotMtx = new Matrix3();\n\n    function pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, result) {\n        var azimuth = theta + rotation;\n\n        Cartesian3.multiplyByScalar(eastVec, Math.cos(azimuth), rotAxis);\n        Cartesian3.multiplyByScalar(northVec, Math.sin(azimuth), tempVec);\n        Cartesian3.add(rotAxis, tempVec, rotAxis);\n\n        var cosThetaSquared = Math.cos(theta);\n        cosThetaSquared = cosThetaSquared * cosThetaSquared;\n\n        var sinThetaSquared = Math.sin(theta);\n        sinThetaSquared = sinThetaSquared * sinThetaSquared;\n\n        var radius = ab / Math.sqrt(bSqr * cosThetaSquared + aSqr * sinThetaSquared);\n        var angle = radius / mag;\n\n        // Create the quaternion to rotate the position vector to the boundary of the ellipse.\n        Quaternion.fromAxisAngle(rotAxis, angle, unitQuat);\n        Matrix3.fromQuaternion(unitQuat, rotMtx);\n\n        Matrix3.multiplyByVector(rotMtx, unitPos, result);\n        Cartesian3.normalize(result, result);\n        Cartesian3.multiplyByScalar(result, mag, result);\n        return result;\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    /**\n     * Returns the positions raised to the given heights\n     * @private\n     */\n    EllipseGeometryLibrary.raisePositionsToHeight = function(positions, options, extrude) {\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n\n        var finalPositions = new Float64Array(size * 3);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            ellipsoid.scaleToGeodeticSurface(position, position);\n\n            var extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian3);\n            Cartesian3.add(position, scaledNormal, position);\n\n            if (extrude) {\n                Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n                Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n                finalPositions[i + bottomOffset] = extrudedPosition.x;\n                finalPositions[i1 + bottomOffset] = extrudedPosition.y;\n                finalPositions[i2 + bottomOffset] = extrudedPosition.z;\n            }\n\n            finalPositions[i] = position.x;\n            finalPositions[i1] = position.y;\n            finalPositions[i2] = position.z;\n        }\n\n        return finalPositions;\n    };\n\n    var unitPosScratch = new Cartesian3();\n    var eastVecScratch = new Cartesian3();\n    var northVecScratch = new Cartesian3();\n    /**\n     * Returns an array of positions that make up the ellipse.\n     * @private\n     */\n    EllipseGeometryLibrary.computeEllipsePositions = function(options, addFillPositions, addEdgePositions) {\n        var semiMinorAxis = options.semiMinorAxis;\n        var semiMajorAxis = options.semiMajorAxis;\n        var rotation = options.rotation;\n        var center = options.center;\n\n        // Computing the arc-length of the ellipse is too expensive to be practical. Estimating it using the\n        // arc length of the sphere is too inaccurate and creates sharp edges when either the semi-major or\n        // semi-minor axis is much bigger than the other. Instead, scale the angle delta to make\n        // the distance along the ellipse boundary more closely match the granularity.\n        var granularity = options.granularity * 8.0;\n\n        var aSqr = semiMinorAxis * semiMinorAxis;\n        var bSqr = semiMajorAxis * semiMajorAxis;\n        var ab = semiMajorAxis * semiMinorAxis;\n\n        var mag = Cartesian3.magnitude(center);\n\n        var unitPos = Cartesian3.normalize(center, unitPosScratch);\n        var eastVec = Cartesian3.cross(Cartesian3.UNIT_Z, center, eastVecScratch);\n        eastVec = Cartesian3.normalize(eastVec, eastVec);\n        var northVec = Cartesian3.cross(unitPos, eastVec, northVecScratch);\n\n        // The number of points in the first quadrant\n        var numPts = 1 + Math.ceil(CesiumMath.PI_OVER_TWO / granularity);\n\n        var deltaTheta = CesiumMath.PI_OVER_TWO / (numPts - 1);\n        var theta = CesiumMath.PI_OVER_TWO - numPts * deltaTheta;\n        if (theta < 0.0) {\n            numPts -= Math.ceil(Math.abs(theta) / deltaTheta);\n        }\n\n        // If the number of points were three, the ellipse\n        // would be tessellated like below:\n        //\n        //         *---*\n        //       / | \\ | \\\n        //     *---*---*---*\n        //   / | \\ | \\ | \\ | \\\n        //  / .*---*---*---*. \\\n        // * ` | \\ | \\ | \\ | `*\n        //  \\`.*---*---*---*.`/\n        //   \\ | \\ | \\ | \\ | /\n        //     *---*---*---*\n        //       \\ | \\ | /\n        //         *---*\n        // The first and last column have one position and fan to connect to the adjacent column.\n        // Each other vertical column contains an even number of positions.\n        var size = 2 * (numPts * (numPts + 2));\n        var positions = (addFillPositions) ? new Array(size * 3) : undefined;\n        var positionIndex = 0;\n        var position = scratchCartesian1;\n        var reflectedPosition = scratchCartesian2;\n\n        var outerPositionsLength = (numPts * 4) * 3;\n        var outerRightIndex = outerPositionsLength - 1;\n        var outerLeftIndex = 0;\n        var outerPositions = (addEdgePositions) ? new Array(outerPositionsLength) : undefined;\n\n        var i;\n        var j;\n        var numInterior;\n        var t;\n        var interiorPosition;\n\n        // Compute points in the 'eastern' half of the ellipse\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n        }\n        theta = CesiumMath.PI_OVER_TWO -  deltaTheta;\n        for (i = 1; i < numPts + 1; ++i) {\n            position = pointOnEllipsoid(theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(Math.PI - theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * i + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n\n            theta = CesiumMath.PI_OVER_TWO - (i + 1) * deltaTheta;\n        }\n\n        // Compute points in the 'western' half of the ellipse\n        for (i = numPts; i > 1; --i) {\n            theta = CesiumMath.PI_OVER_TWO - (i - 1) * deltaTheta;\n\n            position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n            reflectedPosition = pointOnEllipsoid(theta + Math.PI, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, reflectedPosition);\n\n            if (addFillPositions) {\n                positions[positionIndex++] = position.x;\n                positions[positionIndex++] = position.y;\n                positions[positionIndex++] = position.z;\n\n                numInterior = 2 * (i - 1) + 2;\n                for (j = 1; j < numInterior - 1; ++j) {\n                    t = j / (numInterior - 1);\n                    interiorPosition = Cartesian3.lerp(position, reflectedPosition, t, scratchCartesian3);\n                    positions[positionIndex++] = interiorPosition.x;\n                    positions[positionIndex++] = interiorPosition.y;\n                    positions[positionIndex++] = interiorPosition.z;\n                }\n\n                positions[positionIndex++] = reflectedPosition.x;\n                positions[positionIndex++] = reflectedPosition.y;\n                positions[positionIndex++] = reflectedPosition.z;\n            }\n\n            if (addEdgePositions) {\n                outerPositions[outerRightIndex--] = position.z;\n                outerPositions[outerRightIndex--] = position.y;\n                outerPositions[outerRightIndex--] = position.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.x;\n                outerPositions[outerLeftIndex++] = reflectedPosition.y;\n                outerPositions[outerLeftIndex++] = reflectedPosition.z;\n            }\n        }\n\n        theta = CesiumMath.PI_OVER_TWO;\n        position = pointOnEllipsoid(-theta, rotation, northVec, eastVec, aSqr, ab, bSqr, mag, unitPos, position);\n\n        var r = {};\n        if (addFillPositions) {\n            positions[positionIndex++] = position.x;\n            positions[positionIndex++] = position.y;\n            positions[positionIndex++] = position.z;\n            r.positions = positions;\n            r.numPts = numPts;\n        }\n        if (addEdgePositions) {\n            outerPositions[outerRightIndex--] = position.z;\n            outerPositions[outerRightIndex--] = position.y;\n            outerPositions[outerRightIndex--] = position.x;\n            r.outerPositions = outerPositions;\n        }\n\n        return r;\n    };\n\n    return EllipseGeometryLibrary;\n});\n","define([\n        './defined',\n        './Cartesian2',\n        './Cartesian3',\n        './Check',\n        './IntersectionTests',\n        './Math',\n        './Matrix3',\n        './OrientedBoundingBox'\n    ], function(\n        defined,\n        Cartesian2,\n        Cartesian3,\n        Check,\n        IntersectionTests,\n        CesiumMath,\n        Matrix3,\n        OrientedBoundingBox\n    ) {\n    'use strict';\n\n    /**\n     * @private\n     */\n    var CoplanarPolygonGeometryLibrary = {};\n\n    var scratchIntersectionPoint = new Cartesian3();\n    var scratchXAxis = new Cartesian3();\n    var scratchYAxis = new Cartesian3();\n    var scratchZAxis = new Cartesian3();\n    var obbScratch = new OrientedBoundingBox();\n\n    CoplanarPolygonGeometryLibrary.validOutline = function(positions) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        return !((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0));\n    };\n\n    // call after removeDuplicates\n    CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments = function(positions, centerResult, planeAxis1Result, planeAxis2Result) {\n        \n\n        var orientedBoundingBox = OrientedBoundingBox.fromPoints(positions, obbScratch);\n        var halfAxes = orientedBoundingBox.halfAxes;\n        var xAxis = Matrix3.getColumn(halfAxes, 0, scratchXAxis);\n        var yAxis = Matrix3.getColumn(halfAxes, 1, scratchYAxis);\n        var zAxis = Matrix3.getColumn(halfAxes, 2, scratchZAxis);\n\n        var xMag = Cartesian3.magnitude(xAxis);\n        var yMag = Cartesian3.magnitude(yAxis);\n        var zMag = Cartesian3.magnitude(zAxis);\n        var min = Math.min(xMag, yMag, zMag);\n\n        // If all the points are on a line return undefined because we can't draw a polygon\n        if ((xMag === 0 && (yMag === 0 || zMag === 0)) || (yMag === 0 && zMag === 0)) {\n            return false;\n        }\n\n        var planeAxis1;\n        var planeAxis2;\n\n        if (min === yMag || min === zMag) {\n            planeAxis1 = xAxis;\n        }\n        if (min === xMag) {\n            planeAxis1 = yAxis;\n        } else if (min === zMag) {\n            planeAxis2 = yAxis;\n        }\n        if (min === xMag || min === yMag) {\n            planeAxis2 = zAxis;\n        }\n\n        Cartesian3.normalize(planeAxis1, planeAxis1Result);\n        Cartesian3.normalize(planeAxis2, planeAxis2Result);\n        Cartesian3.clone(orientedBoundingBox.center, centerResult);\n        return true;\n    };\n\n    function projectTo2D(position, center, axis1, axis2, result) {\n        var v = Cartesian3.subtract(position, center, scratchIntersectionPoint);\n        var x = Cartesian3.dot(axis1, v);\n        var y = Cartesian3.dot(axis2, v);\n\n        return Cartesian2.fromElements(x, y, result);\n    }\n\n    CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction = function(center, axis1, axis2) {\n        return function(positions) {\n            var positionResults = new Array(positions.length);\n            for (var i = 0; i < positions.length; i++) {\n                positionResults[i] = projectTo2D(positions[i], center, axis1, axis2);\n            }\n\n            return positionResults;\n        };\n    };\n\n    CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction = function(center, axis1, axis2) {\n        return function(position, result) {\n            return projectTo2D(position, center, axis1, axis2, result);\n        };\n    };\n\n    return CoplanarPolygonGeometryLibrary;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Cartesian3',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/Primitive',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        AssociativeArray,\n        Cartesian3,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        OffsetGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        Primitive,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, appearanceType, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.translucent = translucent;\n        this.appearanceType = appearanceType;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.depthFailMaterial = undefined;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.invalidated = false;\n\n        var removeMaterialSubscription;\n        if (defined(depthFailMaterialProperty)) {\n            removeMaterialSubscription = depthFailMaterialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        }\n        this.removeMaterialSubscription = removeMaterialSubscription;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.depthFailMaterialProperty;\n        var updaterMaterial = updater.depthFailMaterialProperty;\n        if (updaterMaterial === material) {\n            return true;\n        }\n        if (defined(material)) {\n            return material.equals(updaterMaterial);\n        }\n        return false;\n    };\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                var depthFailAppearance;\n                if (defined(this.depthFailAppearanceType)) {\n                    if (defined(this.depthFailMaterialProperty)) {\n                        this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    }\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.translucent,\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        translucent : this.translucent,\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                if (defined(this.depthFailAppearanceType) && updater.depthFailMaterialProperty instanceof ColorMaterialProperty && (!updater.depthFailMaterialProperty.isConstant || waitingOnCreate)) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        if (defined(this.removeMaterialSubscription)) {\n            this.removeMaterialSubscription();\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryColorBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._solidItems = [];\n        this._translucentItems = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryColorBatch.prototype.add = function(time, updater) {\n        var items;\n        var translucent;\n        var instance = updater.createFillGeometryInstance(time);\n        if (instance.attributes.color.value[3] === 255) {\n            items = this._solidItems;\n            translucent = false;\n        } else {\n            items = this._translucentItems;\n            translucent = true;\n        }\n\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(updater, instance);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, translucent, this._appearanceType, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(updater, instance);\n        items.push(batch);\n    };\n\n    function removeItem(items, updater) {\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    StaticGeometryColorBatch.prototype.remove = function(updater) {\n        if (!removeItem(this._solidItems, updater)) {\n            removeItem(this._translucentItems, updater);\n        }\n    };\n\n    function moveItems(batch, items, time) {\n        var itemsMoved = false;\n        var length = items.length;\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            var itemsToRemove = item.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            if (itemsToMoveLength > 0) {\n                for (i = 0; i < itemsToMoveLength; i++) {\n                    var updater = itemsToRemove[i];\n                    item.remove(updater);\n                    batch.add(time, updater);\n                    itemsMoved = true;\n                }\n            }\n        }\n        return itemsMoved;\n    }\n\n    function updateItems(batch, items, time, isUpdated) {\n        var length = items.length;\n        var i;\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    batch.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        length = items.length;\n        for (i = 0; i < length; ++i) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    }\n\n    StaticGeometryColorBatch.prototype.update = function(time) {\n        //Perform initial update\n        var isUpdated = updateItems(this, this._solidItems, time, true);\n        isUpdated = updateItems(this, this._translucentItems, time, isUpdated) && isUpdated;\n\n        //If any items swapped between solid/translucent, we need to\n        //move them between batches\n        var solidsMoved = moveItems(this, this._solidItems, time);\n        var translucentsMoved = moveItems(this, this._translucentItems, time);\n\n        //If we moved anything around, we need to re-build the primitive\n        if (solidsMoved || translucentsMoved) {\n            isUpdated = updateItems(this, this._solidItems, time, isUpdated) && isUpdated;\n            isUpdated = updateItems(this, this._translucentItems, time, isUpdated)&& isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    function getBoundingSphere(items, updater, result) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    }\n\n    StaticGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var boundingSphere = getBoundingSphere(this._solidItems, updater, result);\n        if (boundingSphere === BoundingSphereState.FAILED) {\n            return getBoundingSphere(this._translucentItems, updater, result);\n        }\n        return boundingSphere;\n    };\n\n    function removeAllPrimitives(items) {\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        items.length = 0;\n    }\n\n    StaticGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        removeAllPrimitives(this._solidItems);\n        removeAllPrimitives(this._translucentItems);\n    };\n\n    return StaticGeometryColorBatch;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Cartesian3',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/Primitive',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        AssociativeArray,\n        Cartesian3,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        OffsetGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        Primitive,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, appearanceType, materialProperty, depthFailAppearanceType, depthFailMaterialProperty, closed, shadows) {\n        this.primitives = primitives;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.depthFailAppearanceType = depthFailAppearanceType;\n        this.depthFailMaterialProperty = depthFailMaterialProperty;\n        this.closed = closed;\n        this.shadows = shadows;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.depthFailMaterial = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n        var depthFailMaterial = this.depthFailMaterialProperty;\n        var updaterDepthFailMaterial = updater.depthFailMaterialProperty;\n\n        if (updaterMaterial === material && updaterDepthFailMaterial === depthFailMaterial) {\n            return true;\n        }\n        var equals = defined(material) && material.equals(updaterMaterial);\n        equals = ((!defined(depthFailMaterial) && !defined(updaterDepthFailMaterial)) || (defined(depthFailMaterial) && depthFailMaterial.equals(updaterDepthFailMaterial))) && equals;\n        return equals;\n    };\n\n    Batch.prototype.add = function(time, updater) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, updater.createFillGeometryInstance(time));\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)  || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var colorScratch = new Color();\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                var depthFailAppearance;\n                if (defined(this.depthFailMaterialProperty)) {\n                    this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                    depthFailAppearance = new this.depthFailAppearanceType({\n                        material : this.depthFailMaterial,\n                        translucent : this.depthFailMaterial.isTranslucent(),\n                        closed : this.closed\n                    });\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        material : this.material,\n                        translucent : this.material.isTranslucent(),\n                        closed : this.closed\n                    }),\n                    depthFailAppearance : depthFailAppearance,\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            if (defined(this.depthFailAppearanceType) && !(this.depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                this.depthFailMaterial = MaterialProperty.getValue(time, this.depthFailMaterialProperty, this.depthFailMaterial);\n                this.primitive.depthFailAppearance.material = this.depthFailMaterial;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (defined(this.depthFailAppearanceType) && this.depthFailMaterialProperty instanceof ColorMaterialProperty && !updater.depthFailMaterialProperty.isConstant) {\n                    var depthFailColorProperty = updater.depthFailMaterialProperty.color;\n                    var depthFailColor = Property.getValueOrDefault(depthFailColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastDepthFailColor, depthFailColor)) {\n                        attributes._lastDepthFailColor = Color.clone(depthFailColor, attributes._lastDepthFailColor);\n                        attributes.depthFailColor = ColorGeometryInstanceAttribute.toValue(depthFailColor, attributes.depthFailColor);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGeometryPerMaterialBatch(primitives, appearanceType, depthFailAppearanceType, closed, shadows) {\n        this._items = [];\n        this._primitives = primitives;\n        this._appearanceType = appearanceType;\n        this._depthFailAppearanceType = depthFailAppearanceType;\n        this._closed = closed;\n        this._shadows = shadows;\n    }\n\n    StaticGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.isMaterial(updater)) {\n                item.add(time, updater);\n                return;\n            }\n        }\n        var batch = new Batch(this._primitives, this._appearanceType, updater.fillMaterialProperty, this._depthFailAppearanceType, updater.depthFailMaterialProperty, this._closed, this._shadows);\n        batch.add(time, updater);\n        items.push(batch);\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\n\n    return StaticGeometryPerMaterialBatch;\n});\n","define([\n        './Cartographic',\n        './defined',\n        './EllipsoidTangentPlane',\n        './Math',\n        './PolygonPipeline',\n        './PolylinePipeline',\n        './WindingOrder'\n    ], function(\n        Cartographic,\n        defined,\n        EllipsoidTangentPlane,\n        CesiumMath,\n        PolygonPipeline,\n        PolylinePipeline,\n        WindingOrder) {\n    'use strict';\n\n    /**\n     * private\n     */\n    var WallGeometryLibrary = {};\n\n    function latLonEquals(c0, c1) {\n        return ((CesiumMath.equalsEpsilon(c0.latitude, c1.latitude, CesiumMath.EPSILON14)) && (CesiumMath.equalsEpsilon(c0.longitude, c1.longitude, CesiumMath.EPSILON14)));\n    }\n\n    var scratchCartographic1 = new Cartographic();\n    var scratchCartographic2 = new Cartographic();\n    function removeDuplicates(ellipsoid, positions, topHeights, bottomHeights) {\n        var length = positions.length;\n        if (length < 2) {\n            return;\n        }\n\n        var hasBottomHeights = defined(bottomHeights);\n        var hasTopHeights = defined(topHeights);\n        var hasAllZeroHeights = true;\n\n        var cleanedPositions = new Array(length);\n        var cleanedTopHeights = new Array(length);\n        var cleanedBottomHeights = new Array(length);\n\n        var v0 = positions[0];\n        cleanedPositions[0] = v0;\n\n        var c0 = ellipsoid.cartesianToCartographic(v0, scratchCartographic1);\n        if (hasTopHeights) {\n            c0.height = topHeights[0];\n        }\n\n        hasAllZeroHeights = hasAllZeroHeights && c0.height <= 0;\n\n        cleanedTopHeights[0] = c0.height;\n\n        if (hasBottomHeights) {\n            cleanedBottomHeights[0] = bottomHeights[0];\n        } else {\n            cleanedBottomHeights[0] = 0.0;\n        }\n\n        var index = 1;\n        for (var i = 1; i < length; ++i) {\n            var v1 = positions[i];\n            var c1 = ellipsoid.cartesianToCartographic(v1, scratchCartographic2);\n            if (hasTopHeights) {\n                c1.height = topHeights[i];\n            }\n            hasAllZeroHeights = hasAllZeroHeights && c1.height <= 0;\n\n            if (!latLonEquals(c0, c1)) {\n                cleanedPositions[index] = v1; // Shallow copy!\n                cleanedTopHeights[index] = c1.height;\n\n                if (hasBottomHeights) {\n                    cleanedBottomHeights[index] = bottomHeights[i];\n                } else {\n                    cleanedBottomHeights[index] = 0.0;\n                }\n\n                Cartographic.clone(c1, c0);\n                ++index;\n            } else if (c0.height < c1.height) {\n                cleanedTopHeights[index - 1] = c1.height;\n            }\n        }\n\n        if (hasAllZeroHeights || index < 2) {\n            return;\n        }\n\n        cleanedPositions.length = index;\n        cleanedTopHeights.length = index;\n        cleanedBottomHeights.length = index;\n\n        return {\n            positions: cleanedPositions,\n            topHeights: cleanedTopHeights,\n            bottomHeights: cleanedBottomHeights\n        };\n    }\n\n    var positionsArrayScratch = new Array(2);\n    var heightsArrayScratch = new Array(2);\n    var generateArcOptionsScratch = {\n        positions : undefined,\n        height : undefined,\n        granularity : undefined,\n        ellipsoid : undefined\n    };\n\n    /**\n     * @private\n     */\n    WallGeometryLibrary.computePositions = function(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, duplicateCorners) {\n        var o = removeDuplicates(ellipsoid, wallPositions, maximumHeights, minimumHeights);\n\n        if (!defined(o)) {\n            return;\n        }\n\n        wallPositions = o.positions;\n        maximumHeights = o.topHeights;\n        minimumHeights = o.bottomHeights;\n\n        if (wallPositions.length >= 3) {\n            // Order positions counter-clockwise\n            var tangentPlane = EllipsoidTangentPlane.fromPoints(wallPositions, ellipsoid);\n            var positions2D = tangentPlane.projectPointsOntoPlane(wallPositions);\n\n            if (PolygonPipeline.computeWindingOrder2D(positions2D) === WindingOrder.CLOCKWISE) {\n                wallPositions.reverse();\n                maximumHeights.reverse();\n                minimumHeights.reverse();\n            }\n        }\n\n        var length = wallPositions.length;\n        var numCorners = length - 2;\n        var topPositions;\n        var bottomPositions;\n\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var generateArcOptions = generateArcOptionsScratch;\n        generateArcOptions.minDistance = minDistance;\n        generateArcOptions.ellipsoid = ellipsoid;\n\n        if (duplicateCorners) {\n            var count = 0;\n            var i;\n\n            for (i = 0; i < length - 1; i++) {\n                count += PolylinePipeline.numberOfPoints(wallPositions[i], wallPositions[i+1], minDistance) + 1;\n            }\n\n            topPositions = new Float64Array(count * 3);\n            bottomPositions = new Float64Array(count * 3);\n\n            var generateArcPositions = positionsArrayScratch;\n            var generateArcHeights = heightsArrayScratch;\n            generateArcOptions.positions = generateArcPositions;\n            generateArcOptions.height = generateArcHeights;\n\n            var offset = 0;\n            for (i = 0; i < length - 1; i++) {\n                generateArcPositions[0] = wallPositions[i];\n                generateArcPositions[1] = wallPositions[i + 1];\n\n                generateArcHeights[0] = maximumHeights[i];\n                generateArcHeights[1] = maximumHeights[i + 1];\n\n                var pos = PolylinePipeline.generateArc(generateArcOptions);\n                topPositions.set(pos, offset);\n\n                generateArcHeights[0] = minimumHeights[i];\n                generateArcHeights[1] = minimumHeights[i + 1];\n\n                bottomPositions.set(PolylinePipeline.generateArc(generateArcOptions), offset);\n\n                offset += pos.length;\n            }\n        } else {\n            generateArcOptions.positions = wallPositions;\n            generateArcOptions.height = maximumHeights;\n            topPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n\n            generateArcOptions.height = minimumHeights;\n            bottomPositions = new Float64Array(PolylinePipeline.generateArc(generateArcOptions));\n        }\n\n        return {\n            bottomPositions: bottomPositions,\n            topPositions: topPositions,\n            numCorners: numCorners\n        };\n    };\n\n    return WallGeometryLibrary;\n});\n","define([\n    '../Core/defaultValue',\n    '../Core/defined',\n    '../Core/defineProperties',\n    '../Core/destroyObject',\n    '../Core/Check',\n    '../Core/DeveloperError',\n    './PrimitiveCollection'\n], function(\n    defaultValue,\n    defined,\n    defineProperties,\n    destroyObject,\n    Check,\n    DeveloperError,\n    PrimitiveCollection) {\n    'use strict';\n\n    /**\n     * A primitive collection for helping maintain the order or ground primitives based on a z-index\n     *\n     * @private\n     */\n    function OrderedGroundPrimitiveCollection() {\n        this._length = 0;\n        this._collections = {};\n        this._collectionsArray = [];\n\n        this.show = true;\n    }\n\n    defineProperties(OrderedGroundPrimitiveCollection.prototype, {\n        /**\n         * Gets the number of primitives in the collection.\n         *\n         * @memberof OrderedGroundPrimitiveCollection.prototype\n         *\n         * @type {Number}\n         * @readonly\n         */\n        length : {\n            get : function() {\n                return this._length;\n            }\n        }\n    });\n\n    /**\n     * Adds a primitive to the collection.\n     *\n     * @param {GroundPrimitive} primitive The primitive to add.\n     * @param {Number} [zIndex = 0] The index of the primitive\n     * @returns {GroundPrimitive} The primitive added to the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.add = function(primitive, zIndex) {\n        \n\n        zIndex = defaultValue(zIndex, 0);\n        var collection = this._collections[zIndex];\n        if (!defined(collection)) {\n            collection = new PrimitiveCollection({ destroyPrimitives: false });\n            collection._zIndex = zIndex;\n            this._collections[zIndex] = collection;\n            var array = this._collectionsArray;\n            var i = 0;\n            while (i < array.length && array[i]._zIndex < zIndex) {\n                i++;\n            }\n            array.splice(i, 0, collection);\n        }\n\n        collection.add(primitive);\n        this._length++;\n        primitive._zIndex = zIndex;\n\n        return primitive;\n    };\n\n    /**\n     * Adjusts the z-index\n     * @param {GroundPrimitive} primitive\n     * @param {Number} zIndex\n     */\n    OrderedGroundPrimitiveCollection.prototype.set = function(primitive, zIndex) {\n        \n\n        if (zIndex === primitive._zIndex) {\n            return primitive;\n        }\n\n        this.remove(primitive, true);\n        this.add(primitive, zIndex);\n\n        return primitive;\n    };\n\n    /**\n     * Removes a primitive from the collection.\n     *\n     * @param {Object} primitive The primitive to remove.\n     * @param {Boolean} [doNotDestroy = false]\n     * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.remove = function(primitive, doNotDestroy) {\n        if (this.contains(primitive)) {\n            var index = primitive._zIndex;\n            var collection = this._collections[index];\n            var result;\n            if (doNotDestroy) {\n                result = collection.remove(primitive);\n            } else {\n                result = collection.removeAndDestroy(primitive);\n            }\n\n            if (result) {\n                this._length--;\n            }\n\n            if (collection.length === 0) {\n                this._collectionsArray.splice(this._collectionsArray.indexOf(collection), 1);\n                this._collections[index] = undefined;\n                collection.destroy();\n            }\n\n            return result;\n        }\n\n        return false;\n    };\n\n    /**\n     * Removes all primitives in the collection.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroyPrimitives\n     */\n    OrderedGroundPrimitiveCollection.prototype.removeAll = function() {\n        var collections = this._collectionsArray;\n        for (var i = 0; i < collections.length; i++) {\n            var collection = collections[i];\n            collection.destroyPrimitives = true;\n            collection.destroy();\n        }\n\n        this._collections = {};\n        this._collectionsArray = [];\n        this._length = 0;\n    };\n\n    /**\n     * Determines if this collection contains a primitive.\n     *\n     * @param {Object} primitive The primitive to check for.\n     * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.\n     */\n    OrderedGroundPrimitiveCollection.prototype.contains = function(primitive) {\n        if (!defined(primitive)) {\n            return false;\n        }\n        var collection = this._collections[primitive._zIndex];\n        return defined(collection) && collection.contains(primitive);\n    };\n\n    /**\n     * @private\n     */\n    OrderedGroundPrimitiveCollection.prototype.update = function(frameState) {\n        if (!this.show) {\n            return;\n        }\n\n        var collections = this._collectionsArray;\n        for (var i = 0 ; i < collections.length; i++) {\n            collections[i].update(frameState);\n        }\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see OrderedGroundPrimitiveCollection#destroy\n     */\n    OrderedGroundPrimitiveCollection.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this\n     * collection allows for deterministic release of WebGL resources, instead of relying on the garbage\n     * collector to destroy this collection.\n     * <br /><br />\n     * Since destroying a collection destroys all the contained primitives, only destroy a collection\n     * when you are sure no other code is still using any of the contained primitives.\n     * <br /><br />\n     * Once this collection is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * primitives = primitives && primitives.destroy();\n     *\n     * @see OrderedGroundPrimitiveCollection#isDestroyed\n     */\n    OrderedGroundPrimitiveCollection.prototype.destroy = function() {\n        this.removeAll();\n        return destroyObject(this);\n    };\n\n    return OrderedGroundPrimitiveCollection;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/BoundingRectangle',\n        '../Core/Cartesian2',\n        '../Core/Cartesian3',\n        '../Core/Color',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayCondition',\n        '../Core/NearFarScalar',\n        '../Scene/HeightReference',\n        '../Scene/HorizontalOrigin',\n        '../Scene/VerticalOrigin',\n        './BoundingSphereState',\n        './Property'\n    ], function(\n        AssociativeArray,\n        BoundingRectangle,\n        Cartesian2,\n        Cartesian3,\n        Color,\n        defined,\n        destroyObject,\n        DeveloperError,\n        DistanceDisplayCondition,\n        NearFarScalar,\n        HeightReference,\n        HorizontalOrigin,\n        VerticalOrigin,\n        BoundingSphereState,\n        Property) {\n    'use strict';\n\n    var defaultColor = Color.WHITE;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultScale = 1.0;\n    var defaultRotation = 0.0;\n    var defaultAlignedAxis = Cartesian3.ZERO;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n    var defaultSizeInMeters = false;\n\n    var positionScratch = new Cartesian3();\n    var colorScratch = new Color();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var boundingRectangleScratch = new BoundingRectangle();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.billboard = undefined;\n        this.textureValue = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.\n     * @alias BillboardVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function BillboardVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    BillboardVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var billboardGraphics = entity._billboard;\n            var textureValue;\n            var billboard = item.billboard;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(billboardGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                textureValue = Property.getValueOrUndefined(billboardGraphics._image, time);\n                show = defined(position) && defined(textureValue);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            if (!defined(billboard)) {\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n            }\n\n            billboard.show = show;\n            if (!defined(billboard.image) || item.textureValue !== textureValue) {\n                billboard.image = textureValue;\n                item.textureValue = textureValue;\n            }\n            billboard.position = position;\n            billboard.color = Property.getValueOrDefault(billboardGraphics._color, time, defaultColor, colorScratch);\n            billboard.eyeOffset = Property.getValueOrDefault(billboardGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            billboard.heightReference = Property.getValueOrDefault(billboardGraphics._heightReference, time, defaultHeightReference);\n            billboard.pixelOffset = Property.getValueOrDefault(billboardGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            billboard.scale = Property.getValueOrDefault(billboardGraphics._scale, time, defaultScale);\n            billboard.rotation = Property.getValueOrDefault(billboardGraphics._rotation, time, defaultRotation);\n            billboard.alignedAxis = Property.getValueOrDefault(billboardGraphics._alignedAxis, time, defaultAlignedAxis);\n            billboard.horizontalOrigin = Property.getValueOrDefault(billboardGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            billboard.verticalOrigin = Property.getValueOrDefault(billboardGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            billboard.width = Property.getValueOrUndefined(billboardGraphics._width, time);\n            billboard.height = Property.getValueOrUndefined(billboardGraphics._height, time);\n            billboard.scaleByDistance = Property.getValueOrUndefined(billboardGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            billboard.translucencyByDistance = Property.getValueOrUndefined(billboardGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            billboard.pixelOffsetScaleByDistance = Property.getValueOrUndefined(billboardGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            billboard.sizeInMeters = Property.getValueOrDefault(billboardGraphics._sizeInMeters, time, defaultSizeInMeters);\n            billboard.distanceDisplayCondition = Property.getValueOrUndefined(billboardGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            billboard.disableDepthTestDistance = Property.getValueOrUndefined(billboardGraphics._disableDepthTestDistance, time);\n\n            var subRegion = Property.getValueOrUndefined(billboardGraphics._imageSubRegion, time, boundingRectangleScratch);\n            if (defined(subRegion)) {\n                billboard.setImageSubRegion(billboard._imageId, subRegion);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    BillboardVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.billboard)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var billboard = item.billboard;\n        if (billboard.heightReference === HeightReference.NONE) {\n            result.center = Cartesian3.clone(billboard.position, result.center);\n        } else {\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    BillboardVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    BillboardVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeBillboard(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    BillboardVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._billboard) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.billboard = undefined;\n            cluster.removeBillboard(entity);\n        }\n    }\n\n    return BillboardVisualizer;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/BoundingSphere',\n        '../Core/Check',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/Event',\n        '../Core/EventHelper',\n        '../Scene/ClassificationType',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        '../Scene/ShadowMode',\n        './BoundingSphereState',\n        './BoxGeometryUpdater',\n        './ColorMaterialProperty',\n        './CorridorGeometryUpdater',\n        './CylinderGeometryUpdater',\n        './DynamicGeometryBatch',\n        './EllipseGeometryUpdater',\n        './EllipsoidGeometryUpdater',\n        './Entity',\n        './PlaneGeometryUpdater',\n        './PolygonGeometryUpdater',\n        './PolylineVolumeGeometryUpdater',\n        './RectangleGeometryUpdater',\n        './StaticGeometryColorBatch',\n        './StaticGeometryPerMaterialBatch',\n        './StaticGroundGeometryColorBatch',\n        './StaticGroundGeometryPerMaterialBatch',\n        './StaticOutlineGeometryBatch',\n        './WallGeometryUpdater'\n    ], function(\n        AssociativeArray,\n        BoundingSphere,\n        Check,\n        defaultValue,\n        defined,\n        destroyObject,\n        Event,\n        EventHelper,\n        ClassificationType,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ShadowMode,\n        BoundingSphereState,\n        BoxGeometryUpdater,\n        ColorMaterialProperty,\n        CorridorGeometryUpdater,\n        CylinderGeometryUpdater,\n        DynamicGeometryBatch,\n        EllipseGeometryUpdater,\n        EllipsoidGeometryUpdater,\n        Entity,\n        PlaneGeometryUpdater,\n        PolygonGeometryUpdater,\n        PolylineVolumeGeometryUpdater,\n        RectangleGeometryUpdater,\n        StaticGeometryColorBatch,\n        StaticGeometryPerMaterialBatch,\n        StaticGroundGeometryColorBatch,\n        StaticGroundGeometryPerMaterialBatch,\n        StaticOutlineGeometryBatch,\n        WallGeometryUpdater) {\n    'use strict';\n\n    var emptyArray = [];\n\n    var geometryUpdaters = [BoxGeometryUpdater, CylinderGeometryUpdater, CorridorGeometryUpdater, EllipseGeometryUpdater, EllipsoidGeometryUpdater, PlaneGeometryUpdater,\n                            PolygonGeometryUpdater, PolylineVolumeGeometryUpdater, RectangleGeometryUpdater, WallGeometryUpdater];\n\n    function GeometryUpdaterSet(entity, scene) {\n        this.entity = entity;\n        this.scene = scene;\n        var updaters = new Array(geometryUpdaters.length);\n        var geometryChanged = new Event();\n        function raiseEvent(geometry) {\n            geometryChanged.raiseEvent(geometry);\n        }\n        var eventHelper = new EventHelper();\n        for (var i = 0; i < updaters.length; i++) {\n            var updater = new geometryUpdaters[i](entity, scene);\n            eventHelper.add(updater.geometryChanged, raiseEvent);\n            updaters[i] = updater;\n        }\n        this.updaters = updaters;\n        this.geometryChanged = geometryChanged;\n        this.eventHelper = eventHelper;\n\n        this._removeEntitySubscription = entity.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged, this);\n    }\n\n    GeometryUpdaterSet.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i]._onEntityPropertyChanged(entity, propertyName, newValue, oldValue);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.forEach = function (callback) {\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            callback(updaters[i]);\n        }\n    };\n\n    GeometryUpdaterSet.prototype.destroy = function() {\n        this.eventHelper.removeAll();\n        var updaters = this.updaters;\n        for (var i = 0; i < updaters.length; i++) {\n            updaters[i].destroy();\n        }\n        this._removeEntitySubscription();\n        destroyObject(this);\n    };\n\n    /**\n     * A general purpose visualizer for geometry represented by {@link Primitive} instances.\n     * @alias GeometryVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function GeometryVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        primitives = defaultValue(primitives, scene.primitives);\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._outlineBatches = new Array(numberOfShadowModes*2);\n        this._closedColorBatches = new Array(numberOfShadowModes*2);\n        this._closedMaterialBatches = new Array(numberOfShadowModes*2);\n        this._openColorBatches = new Array(numberOfShadowModes*2);\n        this._openMaterialBatches = new Array(numberOfShadowModes*2);\n\n        var supportsMaterialsforEntitiesOnTerrain = Entity.supportsMaterialsforEntitiesOnTerrain(scene);\n        this._supportsMaterialsforEntitiesOnTerrain = supportsMaterialsforEntitiesOnTerrain;\n\n        var i;\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._outlineBatches[i] = new StaticOutlineGeometryBatch(primitives, scene, i, false);\n            this._outlineBatches[numberOfShadowModes + i] = new StaticOutlineGeometryBatch(primitives, scene, i, true);\n\n            this._closedColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, true);\n            this._closedColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, true, i, false);\n\n            this._closedMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, true);\n            this._closedMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, true, i, false);\n\n            this._openColorBatches[i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, true);\n            this._openColorBatches[numberOfShadowModes + i] = new StaticGeometryColorBatch(primitives, PerInstanceColorAppearance, undefined, false, i, false);\n\n            this._openMaterialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, true);\n            this._openMaterialBatches[numberOfShadowModes + i] = new StaticGeometryPerMaterialBatch(primitives, MaterialAppearance, undefined, false, i, false);\n        }\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        var groundColorBatches = new Array(numberOfClassificationTypes);\n        var groundMaterialBatches = [];\n        if (supportsMaterialsforEntitiesOnTerrain) {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundMaterialBatches.push(new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, MaterialAppearance));\n                groundColorBatches[i] = new StaticGroundGeometryPerMaterialBatch(groundPrimitives, i, PerInstanceColorAppearance);\n            }\n        } else {\n            for (i = 0; i < numberOfClassificationTypes; ++i) {\n                groundColorBatches[i] = new StaticGroundGeometryColorBatch(groundPrimitives, i);\n            }\n        }\n\n        this._groundColorBatches = groundColorBatches;\n        this._groundMaterialBatches = groundMaterialBatches;\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        this._batches = this._outlineBatches.concat(this._closedColorBatches, this._closedMaterialBatches, this._openColorBatches, this._openMaterialBatches, this._groundColorBatches, this._groundMaterialBatches, this._dynamicBatch);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaterSets = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    GeometryVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updaterSet;\n        var that = this;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updaterSet.entity === entity) {\n                updaterSet.forEach(function(updater) {\n                    that._removeUpdater(updater);\n                    that._insertUpdaterIntoBatch(time, updater);\n                });\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updaterSet = this._updaterSets.get(id);\n            updaterSet.forEach(this._removeUpdater.bind(this));\n            updaterSet.destroy();\n            this._updaterSets.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updaterSet = new GeometryUpdaterSet(entity, this._scene);\n            this._updaterSets.set(id, updaterSet);\n            updaterSet.forEach(function(updater) {\n                that._insertUpdaterIntoBatch(time, updater);\n            });\n            this._subscriptions.set(id, updaterSet.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    GeometryVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n\n        var id = entity.id;\n        var updaters = this._updaterSets.get(id).updaters;\n\n        for (var j = 0; j < updaters.length; j++) {\n            var updater = updaters[j];\n            for (var i = 0; i < batchesLength; i++) {\n                state = batches[i].getBoundingSphere(updater, tmp);\n                if (state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    GeometryVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    GeometryVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n\n        var updaterSets = this._updaterSets.values;\n        length = updaterSets.length;\n        for (i = 0; i < length; i++) {\n            updaterSets[i].destroy();\n        }\n        this._updaterSets.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._removeUpdater = function(updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = this._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._insertUpdaterIntoBatch = function(time, updater) {\n        if (updater.isDynamic) {\n            this._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.outlineEnabled || updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        if (updater.outlineEnabled) {\n            if (defined(updater.terrainOffsetProperty)) {\n                this._outlineBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._outlineBatches[shadows].add(time, updater);\n            }\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.onTerrain) {\n                var classificationType = updater.classificationTypeProperty.getValue(time);\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    this._groundColorBatches[classificationType].add(time, updater);\n                } else {\n                    // If unsupported, updater will not be on terrain.\n                    this._groundMaterialBatches[classificationType].add(time, updater);\n                }\n            } else if (updater.isClosed) {\n                if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                    if (defined(updater.terrainOffsetProperty)) {\n                        this._closedColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                    } else {\n                        this._closedColorBatches[shadows].add(time, updater);\n                    }\n                } else if (defined(updater.terrainOffsetProperty)) {\n                    this._closedMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._closedMaterialBatches[shadows].add(time, updater);\n                }\n            } else if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                if (defined(updater.terrainOffsetProperty)) {\n                    this._openColorBatches[numberOfShadowModes + shadows].add(time, updater);\n                } else {\n                    this._openColorBatches[shadows].add(time, updater);\n                }\n            } else if (defined(updater.terrainOffsetProperty)) {\n                this._openMaterialBatches[numberOfShadowModes + shadows].add(time, updater);\n            } else {\n                this._openMaterialBatches[shadows].add(time, updater);\n            }\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    GeometryVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\n\n    return GeometryVisualizer;\n});\n","//This file is automatically rebuilt by the Cesium build process.\ndefine(function() {\n    'use strict';\n    return \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n});","//This file is automatically rebuilt by the Cesium build process.\ndefine(function() {\n    'use strict';\n    return \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec3 tangent;\\n\\\nattribute vec3 bitangent;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec3 v_tangentEC;\\n\\\nvarying vec3 v_bitangentEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\\n\\\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n});","//This file is automatically rebuilt by the Cesium build process.\ndefine(function() {\n    'use strict';\n    return \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n});","//This file is automatically rebuilt by the Cesium build process.\ndefine(function() {\n    'use strict';\n    return \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n});","//This file is automatically rebuilt by the Cesium build process.\ndefine(function() {\n    'use strict';\n    return \"varying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n\\n\\\n    vec3 normalEC = normalize(v_normalEC);\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    czm_materialInput materialInput;\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n    materialInput.st = v_st;\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n});","//This file is automatically rebuilt by the Cesium build process.\ndefine(function() {\n    'use strict';\n    return \"attribute vec3 position3DHigh;\\n\\\nattribute vec3 position3DLow;\\n\\\nattribute vec3 normal;\\n\\\nattribute vec2 st;\\n\\\nattribute float batchId;\\n\\\n\\n\\\nvarying vec3 v_positionEC;\\n\\\nvarying vec3 v_normalEC;\\n\\\nvarying vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\\n\\\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n});","define([\n        '../Core/BoxGeometry',\n        '../Core/BoxOutlineGeometry',\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/GeometryInstance',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './heightReferenceOnEntityPropertyChanged',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './Property'\n    ], function(\n        BoxGeometry,\n        BoxOutlineGeometry,\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        defineProperties,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        heightReferenceOnEntityPropertyChanged,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        Property) {\n    'use strict';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function BoxGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.dimensions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for boxes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias BoxGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function BoxGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new BoxGeometryOptions(entity),\n            geometryPropertyName : 'box',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'box']\n        });\n\n        this._onEntityPropertyChanged(entity, 'box', entity.box, undefined);\n    }\n\n    if (defined(Object.create)) {\n        BoxGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        BoxGeometryUpdater.prototype.constructor = BoxGeometryUpdater;\n    }\n\n    defineProperties(BoxGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof BoxGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    BoxGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    BoxGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : BoxOutlineGeometry.fromDimensions(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.box.heightReference, this._options.dimensions.z * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    BoxGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    BoxGeometryUpdater.prototype._isHidden = function(entity, box) {\n        return !defined(box.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, box);\n    };\n\n    BoxGeometryUpdater.prototype._isDynamic = function(entity, box) {\n        return !entity.position.isConstant ||  !Property.isConstant(entity.orientation) ||  !box.dimensions.isConstant ||  !Property.isConstant(box.outlineWidth);\n    };\n\n    BoxGeometryUpdater.prototype._setStaticOptions = function(entity, box) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.dimensions = box.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    BoxGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    BoxGeometryUpdater.DynamicGeometryUpdater = DynamicBoxGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicBoxGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicBoxGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicBoxGeometryUpdater.prototype.constructor = DynamicBoxGeometryUpdater;\n    }\n\n    DynamicBoxGeometryUpdater.prototype._isHidden = function(entity, box, time) {\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        var dimensions = this._options.dimensions;\n        return !defined(position) || !defined(dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, box, time);\n    };\n\n    DynamicBoxGeometryUpdater.prototype._setOptions = function(entity, box, time) {\n        var heightReference = Property.getValueOrDefault(box.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.dimensions = Property.getValueOrUndefined(box.dimensions, time, options.dimensions);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    return BoxGeometryUpdater;\n});\n","define([\n        '../Core/ApproximateTerrainHeights',\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/CorridorGeometry',\n        '../Core/CorridorOutlineGeometry',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/GeometryInstance',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/Rectangle',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/GroundPrimitive',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './GroundGeometryUpdater',\n        './Property'\n    ], function(\n        ApproximateTerrainHeights,\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        CorridorGeometry,\n        CorridorOutlineGeometry,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        Rectangle,\n        ShowGeometryInstanceAttribute,\n        GroundPrimitive,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        GroundGeometryUpdater,\n        Property) {\n    'use strict';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function CorridorGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.cornerType = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for corridors.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CorridorGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CorridorGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new CorridorGeometryOptions(entity),\n            geometryPropertyName : 'corridor',\n            observedPropertyNames : ['availability', 'corridor']\n        });\n\n        this._onEntityPropertyChanged(entity, 'corridor', entity.corridor, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CorridorGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        CorridorGeometryUpdater.prototype.constructor = CorridorGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CorridorGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CorridorGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CorridorOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    CorridorGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var positions = Property.getValueOrUndefined(this._entity.corridor.positions, time);\n        if (!defined(positions) || positions.length === 0) {\n            return;\n        }\n        return Cartesian3.clone(positions[Math.floor(positions.length / 2.0)], result);\n    };\n\n    CorridorGeometryUpdater.prototype._isHidden = function(entity, corridor) {\n        return !defined(corridor.positions) || !defined(corridor.width) || GeometryUpdater.prototype._isHidden.call(this, entity, corridor);\n    };\n\n    CorridorGeometryUpdater.prototype._isDynamic = function(entity, corridor) {\n        return !corridor.positions.isConstant || //\n               !Property.isConstant(corridor.height) || //\n               !Property.isConstant(corridor.extrudedHeight) || //\n               !Property.isConstant(corridor.granularity) || //\n               !Property.isConstant(corridor.width) || //\n               !Property.isConstant(corridor.outlineWidth) || //\n               !Property.isConstant(corridor.cornerType) || //\n               !Property.isConstant(corridor.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    CorridorGeometryUpdater.prototype._setStaticOptions = function(entity, corridor) {\n        var heightValue = Property.getValueOrUndefined(corridor.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = corridor.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.width = corridor.width.getValue(Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, Iso8601.MINIMUM_VALUE);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    CorridorGeometryUpdater.DynamicGeometryUpdater = DynamicCorridorGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCorridorGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCorridorGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCorridorGeometryUpdater.prototype.constructor = DynamicCorridorGeometryUpdater;\n    }\n\n    DynamicCorridorGeometryUpdater.prototype._isHidden = function(entity, corridor, time) {\n        var options = this._options;\n        return !defined(options.positions) || !defined(options.width) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, corridor, time);\n    };\n\n    DynamicCorridorGeometryUpdater.prototype._setOptions = function(entity, corridor, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(corridor.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(corridor.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(corridor.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(corridor.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.positions = Property.getValueOrUndefined(corridor.positions, time);\n        options.width = Property.getValueOrUndefined(corridor.width, time);\n        options.granularity = Property.getValueOrUndefined(corridor.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(corridor.cornerType, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    return CorridorGeometryUpdater;\n});\n","define([\n        './arrayFill',\n        './arrayRemoveDuplicates',\n        './BoundingSphere',\n        './Cartesian3',\n        './Cartographic',\n        './Check',\n        './ComponentDatatype',\n        './CornerType',\n        './CorridorGeometryLibrary',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryOffsetAttribute',\n        './IndexDatatype',\n        './Math',\n        './PolygonPipeline',\n        './PrimitiveType',\n        './Rectangle',\n        './VertexFormat'\n    ], function(\n        arrayFill,\n        arrayRemoveDuplicates,\n        BoundingSphere,\n        Cartesian3,\n        Cartographic,\n        Check,\n        ComponentDatatype,\n        CornerType,\n        CorridorGeometryLibrary,\n        defaultValue,\n        defined,\n        defineProperties,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryOffsetAttribute,\n        IndexDatatype,\n        CesiumMath,\n        PolygonPipeline,\n        PrimitiveType,\n        Rectangle,\n        VertexFormat) {\n    'use strict';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n    var cartesian4 = new Cartesian3();\n    var cartesian5 = new Cartesian3();\n    var cartesian6 = new Cartesian3();\n\n    var scratch1 = new Cartesian3();\n    var scratch2 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function addNormals(attr, normal, left, front, back, vertexFormat) {\n        var normals = attr.normals;\n        var tangents = attr.tangents;\n        var bitangents = attr.bitangents;\n        var forward = Cartesian3.normalize(Cartesian3.cross(left, normal, scratch1), scratch1);\n        if (vertexFormat.normal) {\n            CorridorGeometryLibrary.addAttribute(normals, normal, front, back);\n        }\n        if (vertexFormat.tangent) {\n            CorridorGeometryLibrary.addAttribute(tangents, forward, front, back);\n        }\n        if (vertexFormat.bitangent) {\n            CorridorGeometryLibrary.addAttribute(bitangents, left, front, back);\n        }\n    }\n\n    function combine(computedPositions, vertexFormat, ellipsoid) {\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var computedLefts = computedPositions.lefts;\n        var computedNormals = computedPositions.normals;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length*2;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 6;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var normals = (vertexFormat.normal) ? new Float32Array(size) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size) : undefined;\n        var attr = {\n            normals : normals,\n            tangents : tangents,\n            bitangents : bitangents\n        };\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var normal = cartesian1;\n        var left = cartesian2;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength);\n        var index = 0;\n        if (addEndPositions) { // add rounded end\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var firstEndPositions = endPositions[0];\n            normal = Cartesian3.fromArray(computedNormals, 0, normal);\n            left = Cartesian3.fromArray(computedLefts, 0, left);\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var compIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        left = Cartesian3.fromArray(computedLefts, compIndex, left);\n        var rightNormal;\n        var leftNormal;\n        length = leftEdge.length - 3;\n        for (i = 0; i < length; i += 3) {\n            rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, i, scratch1), scratch1);\n            leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - i, scratch2), scratch2);\n            normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n            addNormals(attr, normal, left, front, back, vertexFormat);\n\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, length, scratch1), scratch1);\n        leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length, scratch2), scratch2);\n        normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n        compIndex += 3;\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var pivot;\n            var start;\n            var outsidePoint = cartesian6;\n            var previousPoint = cartesian3;\n            var nextPoint = cartesian4;\n            normal = Cartesian3.fromArray(computedNormals, compIndex, normal);\n            if (defined(l)) {\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n                pivot = LR;\n                start = UR;\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    previousPoint = Cartesian3.fromArray(finalPositions, (start - j - 1) * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, pivot * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, undefined, back, vertexFormat);\n                    back -= 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start - j) * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.add(previousPoint, nextPoint, left), left);\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n            } else {\n                addNormals(attr, normal, left, front, undefined, vertexFormat);\n                front += 3;\n                pivot = UR;\n                start = LR;\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = pivot;\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    previousPoint = Cartesian3.fromArray(finalPositions, pivot * 3, previousPoint);\n                    nextPoint = Cartesian3.fromArray(finalPositions, (start + j) * 3, nextPoint);\n                    left = Cartesian3.normalize(Cartesian3.subtract(previousPoint, nextPoint, left), left);\n                    addNormals(attr, normal, left, front, undefined, vertexFormat);\n                    front += 3;\n                }\n                outsidePoint = Cartesian3.fromArray(finalPositions, pivot * 3, outsidePoint);\n                previousPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, (start + j) * 3, previousPoint), outsidePoint, previousPoint);\n                nextPoint = Cartesian3.subtract(Cartesian3.fromArray(finalPositions, start * 3, nextPoint), outsidePoint, nextPoint);\n                left = Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(nextPoint, previousPoint, left), left), left);\n                addNormals(attr, normal, left, undefined, back, vertexFormat);\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            compIndex += 3;\n            left = Cartesian3.fromArray(computedLefts, compIndex, left);\n            for (j = 0; j < leftEdge.length; j += 3) {\n                rightNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(rightEdge, j, scratch1), scratch1);\n                leftNormal = ellipsoid.geodeticSurfaceNormal(Cartesian3.fromArray(leftEdge, length - j, scratch2), scratch2);\n                normal = Cartesian3.normalize(Cartesian3.add(rightNormal, leftNormal, normal), normal);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n        }\n        normal = Cartesian3.fromArray(computedNormals, computedNormals.length - 3, normal);\n        addNormals(attr, normal, left, front, back, vertexFormat);\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian3;\n            rightPos = cartesian4;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                addNormals(attr, normal, left, front, back, vertexFormat);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = LL;\n                indices[index++] = UR;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        if (vertexFormat.st) {\n            var st = new Float32Array(size / 3 * 2);\n            var rightSt;\n            var leftSt;\n            var stIndex = 0;\n            if (addEndPositions) {\n                leftCount /= 3;\n                rightCount /= 3;\n                var theta = Math.PI / (endPositionLength + 1);\n                leftSt = 1 / (leftCount - endPositionLength + 1);\n                rightSt = 1 / (rightCount - endPositionLength + 1);\n                var a;\n                var halfEndPos = endPositionLength / 2;\n                for (i = halfEndPos + 1; i < endPositionLength + 1; i++) { // lower left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = 1; i < rightCount - endPositionLength + 1; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = endPositionLength; i > halfEndPos; i--) { // lower right rounded end\n                    a = CesiumMath.PI_OVER_TWO - i * theta;\n                    st[stIndex++] = 1 - rightSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = halfEndPos; i > 0; i--) { // upper right rounded end\n                    a = CesiumMath.PI_OVER_TWO - theta * i;\n                    st[stIndex++] = 1 - leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n                for (i = leftCount - endPositionLength; i > 0; i--) { // top edge\n                    st[stIndex++] = i * leftSt;\n                    st[stIndex++] = 1;\n                }\n                for (i = 1; i < halfEndPos + 1; i++) { // upper left rounded end\n                    a = CesiumMath.PI_OVER_TWO + theta * i;\n                    st[stIndex++] = leftSt * (1 + Math.cos(a));\n                    st[stIndex++] = 0.5 * (1 + Math.sin(a));\n                }\n            } else {\n                leftCount /= 3;\n                rightCount /= 3;\n                leftSt = 1 / (leftCount - 1);\n                rightSt = 1 / (rightCount - 1);\n                for (i = 0; i < rightCount; i++) { // bottom edge\n                    st[stIndex++] = i * rightSt;\n                    st[stIndex++] = 0;\n                }\n                for (i = leftCount; i > 0; i--) { // top edge\n                    st[stIndex++] = (i - 1) * leftSt;\n                    st[stIndex++] = 1;\n                }\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : attr.bitangents\n            });\n        }\n\n        return {\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function extrudedAttributes(attributes, vertexFormat) {\n        if (!vertexFormat.normal && !vertexFormat.tangent && !vertexFormat.bitangent && !vertexFormat.st) {\n            return attributes;\n        }\n        var positions = attributes.position.values;\n        var topNormals;\n        var topBitangents;\n        if (vertexFormat.normal || vertexFormat.bitangent) {\n            topNormals = attributes.normal.values;\n            topBitangents = attributes.bitangent.values;\n        }\n        var size = attributes.position.values.length / 18;\n        var threeSize = size * 3;\n        var twoSize = size * 2;\n        var sixSize = threeSize * 2;\n        var i;\n        if (vertexFormat.normal || vertexFormat.bitangent || vertexFormat.tangent) {\n            var normals = (vertexFormat.normal) ? new Float32Array(threeSize * 6) : undefined;\n            var tangents = (vertexFormat.tangent) ? new Float32Array(threeSize * 6) : undefined;\n            var bitangents = (vertexFormat.bitangent) ? new Float32Array(threeSize * 6) : undefined;\n            var topPosition = cartesian1;\n            var bottomPosition = cartesian2;\n            var previousPosition = cartesian3;\n            var normal = cartesian4;\n            var tangent = cartesian5;\n            var bitangent = cartesian6;\n            var attrIndex = sixSize;\n            for (i = 0; i < threeSize; i += 3) {\n                var attrIndexOffset = attrIndex + sixSize;\n                topPosition      = Cartesian3.fromArray(positions, i, topPosition);\n                bottomPosition   = Cartesian3.fromArray(positions, i + threeSize, bottomPosition);\n                previousPosition = Cartesian3.fromArray(positions, (i + 3) % threeSize, previousPosition);\n                bottomPosition   = Cartesian3.subtract(bottomPosition,   topPosition, bottomPosition);\n                previousPosition = Cartesian3.subtract(previousPosition, topPosition, previousPosition);\n                normal = Cartesian3.normalize(Cartesian3.cross(bottomPosition, previousPosition, normal), normal);\n                if (vertexFormat.normal) {\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndexOffset + 3);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex);\n                    CorridorGeometryLibrary.addAttribute(normals, normal, attrIndex + 3);\n                }\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\n                    bitangent = Cartesian3.fromArray(topNormals, i, bitangent);\n                    if (vertexFormat.bitangent) {\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(bitangents, bitangent, attrIndex + 3);\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndexOffset + 3);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex);\n                        CorridorGeometryLibrary.addAttribute(tangents, tangent, attrIndex + 3);\n                    }\n                }\n                attrIndex += 6;\n            }\n\n            if (vertexFormat.normal) {\n                normals.set(topNormals); //top\n                for (i = 0; i < threeSize; i += 3) { //bottom normals\n                    normals[i + threeSize] = -topNormals[i];\n                    normals[i + threeSize + 1] = -topNormals[i + 1];\n                    normals[i + threeSize + 2] = -topNormals[i + 2];\n                }\n                attributes.normal.values = normals;\n            } else {\n                attributes.normal = undefined;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents.set(topBitangents); //top\n                bitangents.set(topBitangents, threeSize); //bottom\n                attributes.bitangent.values = bitangents;\n            } else {\n                attributes.bitangent = undefined;\n            }\n\n            if (vertexFormat.tangent) {\n                var topTangents = attributes.tangent.values;\n                tangents.set(topTangents); //top\n                tangents.set(topTangents, threeSize); //bottom\n                attributes.tangent.values = tangents;\n            }\n        }\n        if (vertexFormat.st) {\n            var topSt = attributes.st.values;\n            var st = new Float32Array(twoSize * 6);\n            st.set(topSt); //top\n            st.set(topSt, twoSize); //bottom\n            var index = twoSize * 2;\n\n            for ( var j = 0; j < 2; j++) {\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n                for (i = 2; i < twoSize; i += 2) {\n                    var s = topSt[i];\n                    var t = topSt[i + 1];\n                    st[index++] = s;\n                    st[index++] = t;\n                    st[index++] = s;\n                    st[index++] = t;\n                }\n                st[index++] = topSt[0];\n                st[index++] = topSt[1];\n            }\n            attributes.st.values = st;\n        }\n\n        return attributes;\n    }\n\n    function addWallPositions(positions, index, wallPositions) {\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n        for ( var i = 3; i < positions.length; i += 3) {\n            var x = positions[i];\n            var y = positions[i + 1];\n            var z = positions[i + 2];\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n            wallPositions[index++] = x;\n            wallPositions[index++] = y;\n            wallPositions[index++] = z;\n        }\n        wallPositions[index++] = positions[0];\n        wallPositions[index++] = positions[1];\n        wallPositions[index++] = positions[2];\n\n        return wallPositions;\n    }\n\n    function computePositionsExtruded(params, vertexFormat) {\n        var topVertexFormat = new VertexFormat({\n            position : vertexFormat.position,\n            normal : (vertexFormat.normal || vertexFormat.bitangent || params.shadowVolume),\n            tangent : vertexFormat.tangent,\n            bitangent : (vertexFormat.normal || vertexFormat.bitangent),\n            st : vertexFormat.st\n        });\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, topVertexFormat, ellipsoid);\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var newPositions = new Float64Array(length * 6);\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var wallPositions = new Float64Array(length * 4);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        wallPositions = addWallPositions(positions, 0, wallPositions);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        wallPositions = addWallPositions(extrudedPositions, length * 2, wallPositions);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        newPositions.set(wallPositions, length * 2);\n        attributes.position.values = newPositions;\n\n        attributes = extrudedAttributes(attributes, vertexFormat);\n        var i;\n        var size = length / 3;\n        if (params.shadowVolume) {\n            var topNormals = attributes.normal.values;\n            length = topNormals.length;\n\n            var extrudeNormals = new Float32Array(length * 6);\n            for (i = 0; i < length; i ++) {\n                topNormals[i] = -topNormals[i];\n            }\n            //only get normals for bottom layer that's going to be pushed down\n            extrudeNormals.set(topNormals, length); //bottom face\n            extrudeNormals = addWallPositions(topNormals, length*4, extrudeNormals); //bottom wall\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n            if (!vertexFormat.normal) {\n                attributes.normal = undefined;\n            }\n        }\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(size * 6);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, size); // top face\n                applyOffset = arrayFill(applyOffset, 1, size*2, size * 4); // top wall\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var iLength = indices.length;\n        var twoSize = size + size;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, iLength * 2 + twoSize * 3);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 3) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            var v2 = indices[i + 2];\n            newIndices[index++] = v2 + size;\n            newIndices[index++] = v1 + size;\n            newIndices[index++] = v0 + size;\n        }\n\n        var UL, LL, UR, LR;\n\n        for (i = 0; i < twoSize; i += 2) { //wall indices\n            UL = i + twoSize;\n            LL = UL + twoSize;\n            UR = UL + 1;\n            LR = LL + 1;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n            newIndices[index++] = UR;\n            newIndices[index++] = UR;\n            newIndices[index++] = LL;\n            newIndices[index++] = LR;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartographic = new Cartographic();\n\n    function computeOffsetPoints(position1, position2, ellipsoid, halfWidth, min, max) {\n        // Compute direction of offset the point\n        var direction = Cartesian3.subtract(position2, position1, scratchCartesian1);\n        Cartesian3.normalize(direction, direction);\n        var normal = ellipsoid.geodeticSurfaceNormal(position1, scratchCartesian2);\n        var offsetDirection = Cartesian3.cross(direction, normal, scratchCartesian1);\n        Cartesian3.multiplyByScalar(offsetDirection, halfWidth, offsetDirection);\n\n        var minLat = min.latitude;\n        var minLon = min.longitude;\n        var maxLat = max.latitude;\n        var maxLon = max.longitude;\n\n        // Compute 2 offset points\n        Cartesian3.add(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        var lat = scratchCartographic.latitude;\n        var lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        Cartesian3.subtract(position1, offsetDirection, scratchCartesian2);\n        ellipsoid.cartesianToCartographic(scratchCartesian2, scratchCartographic);\n\n        lat = scratchCartographic.latitude;\n        lon = scratchCartographic.longitude;\n        minLat = Math.min(minLat, lat);\n        minLon = Math.min(minLon, lon);\n        maxLat = Math.max(maxLat, lat);\n        maxLon = Math.max(maxLon, lon);\n\n        min.latitude = minLat;\n        min.longitude = minLon;\n        max.latitude = maxLat;\n        max.longitude = maxLon;\n    }\n\n    var scratchCartesianOffset = new Cartesian3();\n    var scratchCartesianEnds = new Cartesian3();\n    var scratchCartographicMin = new Cartographic();\n    var scratchCartographicMax = new Cartographic();\n\n    function computeRectangle(positions, ellipsoid, width, cornerType, result) {\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var length = cleanPositions.length;\n        if (length < 2 || width <= 0) {\n            return new Rectangle();\n        }\n        var halfWidth = width * 0.5;\n\n        scratchCartographicMin.latitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMin.longitude = Number.POSITIVE_INFINITY;\n        scratchCartographicMax.latitude = Number.NEGATIVE_INFINITY;\n        scratchCartographicMax.longitude = Number.NEGATIVE_INFINITY;\n\n        var lat, lon;\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute start cap\n            var first = cleanPositions[0];\n            Cartesian3.subtract(first, cleanPositions[1], scratchCartesianOffset);\n            Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n            Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n            Cartesian3.add(first, scratchCartesianOffset, scratchCartesianEnds);\n\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        // Compute the rest\n        for (var i = 0; i < length-1; ++i) {\n            computeOffsetPoints(cleanPositions[i], cleanPositions[i+1], ellipsoid, halfWidth,\n                scratchCartographicMin, scratchCartographicMax);\n        }\n\n        // Compute ending point\n        var last = cleanPositions[length-1];\n        Cartesian3.subtract(last, cleanPositions[length-2], scratchCartesianOffset);\n        Cartesian3.normalize(scratchCartesianOffset, scratchCartesianOffset);\n        Cartesian3.multiplyByScalar(scratchCartesianOffset, halfWidth, scratchCartesianOffset);\n        Cartesian3.add(last, scratchCartesianOffset, scratchCartesianEnds);\n        computeOffsetPoints(last, scratchCartesianEnds, ellipsoid, halfWidth,\n            scratchCartographicMin, scratchCartographicMax);\n\n        if (cornerType === CornerType.ROUNDED) {\n            // Compute end cap\n            ellipsoid.cartesianToCartographic(scratchCartesianEnds, scratchCartographic);\n            lat = scratchCartographic.latitude;\n            lon = scratchCartographic.longitude;\n            scratchCartographicMin.latitude = Math.min(scratchCartographicMin.latitude, lat);\n            scratchCartographicMin.longitude = Math.min(scratchCartographicMin.longitude, lon);\n            scratchCartographicMax.latitude = Math.max(scratchCartographicMax.latitude, lat);\n            scratchCartographicMax.longitude = Math.max(scratchCartographicMax.longitude, lon);\n        }\n\n        var rectangle = defined(result) ? result : new Rectangle();\n        rectangle.north = scratchCartographicMax.latitude;\n        rectangle.south = scratchCartographicMin.latitude;\n        rectangle.east = scratchCartographicMax.longitude;\n        rectangle.west = scratchCartographicMin.longitude;\n\n        return rectangle;\n    }\n\n    /**\n     * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias CorridorGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorGeometry.createGeometry\n     * @see Packable\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}\n     *\n     * @example\n     * var corridor = new Cesium.CorridorGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createCorridorGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._rectangle = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 7;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorGeometry} [result] The object into which to store the result.\n     * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.\n     */\n    CorridorGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new CorridorGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.\n     * @param {Number} options.width The distance between the edges of the corridor in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle.\n     */\n    CorridorGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n\n        return computeRectangle(positions, ellipsoid, width, cornerType, result);\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorGeometry} corridorGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorGeometry.createGeometry = function(corridorGeometry) {\n        var positions = corridorGeometry._positions;\n        var width = corridorGeometry._width;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorGeometry._height;\n        var extrudedHeight = corridorGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var vertexFormat = corridorGeometry._vertexFormat;\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorGeometry._cornerType,\n            granularity : corridorGeometry._granularity,\n            saveAttributes: true\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.shadowVolume = corridorGeometry._shadowVolume;\n            params.offsetAttribute = corridorGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params, vertexFormat);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, vertexFormat, ellipsoid);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorGeometry._offsetAttribute)) {\n                var applyOffsetValue = corridorGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                arrayFill(applyOffset, applyOffsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n        if (!vertexFormat.position) {\n            attr.attributes.position.values = undefined;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    CorridorGeometry.createShadowVolume = function(corridorGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = corridorGeometry._granularity;\n        var ellipsoid = corridorGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new CorridorGeometry({\n            positions : corridorGeometry._positions,\n            width : corridorGeometry._width,\n            cornerType : corridorGeometry._cornerType,\n            ellipsoid : ellipsoid,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    defineProperties(CorridorGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._positions, this._ellipsoid, this._width, this._cornerType);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering CorridorGeometries as GroundPrimitives.\n         *\n         * Corridors don't support stRotation,\n         * so just return the corners of the original system.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                return [0, 0, 0, 1, 1, 0];\n            }\n        }\n    });\n\n    return CorridorGeometry;\n});\n","define([\n        './arrayFill',\n        './arrayRemoveDuplicates',\n        './BoundingSphere',\n        './Cartesian3',\n        './Check',\n        './ComponentDatatype',\n        './CornerType',\n        './CorridorGeometryLibrary',\n        './defaultValue',\n        './defined',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryOffsetAttribute',\n        './IndexDatatype',\n        './Math',\n        './PolygonPipeline',\n        './PrimitiveType'\n    ], function(\n        arrayFill,\n        arrayRemoveDuplicates,\n        BoundingSphere,\n        Cartesian3,\n        Check,\n        ComponentDatatype,\n        CornerType,\n        CorridorGeometryLibrary,\n        defaultValue,\n        defined,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryOffsetAttribute,\n        IndexDatatype,\n        CesiumMath,\n        PolygonPipeline,\n        PrimitiveType) {\n    'use strict';\n\n    var cartesian1 = new Cartesian3();\n    var cartesian2 = new Cartesian3();\n    var cartesian3 = new Cartesian3();\n\n    function scaleToSurface(positions, ellipsoid) {\n        for (var i = 0; i < positions.length; i++) {\n            positions[i] = ellipsoid.scaleToGeodeticSurface(positions[i], positions[i]);\n        }\n        return positions;\n    }\n\n    function combine(computedPositions, cornerType) {\n        var wallIndices = [];\n        var positions = computedPositions.positions;\n        var corners = computedPositions.corners;\n        var endPositions = computedPositions.endPositions;\n        var attributes = new GeometryAttributes();\n        var corner;\n        var leftCount = 0;\n        var rightCount = 0;\n        var i;\n        var indicesLength = 0;\n        var length;\n        for (i = 0; i < positions.length; i += 2) {\n            length = positions[i].length - 3;\n            leftCount += length; //subtracting 3 to account for duplicate points at corners\n            indicesLength += length / 3 * 4;\n            rightCount += positions[i + 1].length - 3;\n        }\n        leftCount += 3; //add back count for end positions\n        rightCount += 3;\n        for (i = 0; i < corners.length; i++) {\n            corner = corners[i];\n            var leftSide = corners[i].leftPositions;\n            if (defined(leftSide)) {\n                length = leftSide.length;\n                leftCount += length;\n                indicesLength += length / 3 * 2;\n            } else {\n                length = corners[i].rightPositions.length;\n                rightCount += length;\n                indicesLength += length / 3 * 2;\n            }\n        }\n\n        var addEndPositions = defined(endPositions);\n        var endPositionLength;\n        if (addEndPositions) {\n            endPositionLength = endPositions[0].length - 3;\n            leftCount += endPositionLength;\n            rightCount += endPositionLength;\n            endPositionLength /= 3;\n            indicesLength += endPositionLength * 4;\n        }\n        var size = leftCount + rightCount;\n        var finalPositions = new Float64Array(size);\n        var front = 0;\n        var back = size - 1;\n        var UL, LL, UR, LR;\n        var rightPos, leftPos;\n        var halfLength = endPositionLength / 2;\n\n        var indices = IndexDatatype.createTypedArray(size / 3, indicesLength + 4);\n        var index = 0;\n\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n        if (addEndPositions) { // add rounded end\n            wallIndices.push(front / 3);\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var firstEndPositions = endPositions[0];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(firstEndPositions, (halfLength - 1 - i) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(firstEndPositions, (halfLength + i) * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n\n                LL = front / 3;\n                LR = LL + 1;\n                UL = (back - 2) / 3;\n                UR = UL - 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n        }\n\n        var posIndex = 0;\n        var rightEdge = positions[posIndex++]; //add first two edges\n        var leftEdge = positions[posIndex++];\n        finalPositions.set(rightEdge, front);\n        finalPositions.set(leftEdge, back - leftEdge.length + 1);\n\n        length = leftEdge.length - 3;\n        wallIndices.push(front / 3, (back - 2) / 3);\n        for (i = 0; i < length; i += 3) {\n            LL = front / 3;\n            LR = LL + 1;\n            UL = (back - 2) / 3;\n            UR = UL - 1;\n            indices[index++] = UL;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n\n            front += 3;\n            back -= 3;\n        }\n\n        for (i = 0; i < corners.length; i++) {\n            var j;\n            corner = corners[i];\n            var l = corner.leftPositions;\n            var r = corner.rightPositions;\n            var start;\n            var outsidePoint = cartesian3;\n            if (defined(l)) {\n                back -= 3;\n                start = UR;\n                wallIndices.push(LR);\n                for (j = 0; j < l.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(l, j * 3, outsidePoint);\n                    indices[index++] = start - j - 1;\n                    indices[index++] = start - j;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, undefined, back);\n                    back -= 3;\n                }\n                wallIndices.push(start - Math.floor(l.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push((back - 2) / 3 + 1);\n                }\n                front += 3;\n            } else {\n                front += 3;\n                start = LR;\n                wallIndices.push(UR);\n                for (j = 0; j < r.length / 3; j++) {\n                    outsidePoint = Cartesian3.fromArray(r, j * 3, outsidePoint);\n                    indices[index++] = start + j;\n                    indices[index++] = start + j + 1;\n                    CorridorGeometryLibrary.addAttribute(finalPositions, outsidePoint, front);\n                    front += 3;\n                }\n                wallIndices.push(start + Math.floor(r.length / 6));\n                if (cornerType === CornerType.BEVELED) {\n                    wallIndices.push(front / 3 - 1);\n                }\n                back -= 3;\n            }\n            rightEdge = positions[posIndex++];\n            leftEdge = positions[posIndex++];\n            rightEdge.splice(0, 3); //remove duplicate points added by corner\n            leftEdge.splice(leftEdge.length - 3, 3);\n            finalPositions.set(rightEdge, front);\n            finalPositions.set(leftEdge, back - leftEdge.length + 1);\n            length = leftEdge.length - 3;\n\n            for (j = 0; j < leftEdge.length; j += 3) {\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n                front += 3;\n                back -= 3;\n            }\n            front -= 3;\n            back += 3;\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n\n        if (addEndPositions) { // add rounded end\n            front += 3;\n            back -= 3;\n            leftPos = cartesian1;\n            rightPos = cartesian2;\n            var lastEndPositions = endPositions[1];\n            for (i = 0; i < halfLength; i++) {\n                leftPos = Cartesian3.fromArray(lastEndPositions, (endPositionLength - i - 1) * 3, leftPos);\n                rightPos = Cartesian3.fromArray(lastEndPositions, i * 3, rightPos);\n                CorridorGeometryLibrary.addAttribute(finalPositions, leftPos, undefined, back);\n                CorridorGeometryLibrary.addAttribute(finalPositions, rightPos, front);\n\n                LR = front / 3;\n                LL = LR - 1;\n                UR = (back - 2) / 3;\n                UL = UR + 1;\n                indices[index++] = UL;\n                indices[index++] = UR;\n                indices[index++] = LL;\n                indices[index++] = LR;\n\n                front += 3;\n                back -= 3;\n            }\n\n            wallIndices.push(front / 3);\n        } else {\n            wallIndices.push(front / 3, (back - 2) / 3);\n        }\n        indices[index++] = front / 3;\n        indices[index++] = (back - 2) / 3;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        return {\n            attributes : attributes,\n            indices : indices,\n            wallIndices : wallIndices\n        };\n    }\n\n    function computePositionsExtruded(params) {\n        var ellipsoid = params.ellipsoid;\n        var computedPositions = CorridorGeometryLibrary.computePositions(params);\n        var attr = combine(computedPositions, params.cornerType);\n        var wallIndices = attr.wallIndices;\n        var height = params.height;\n        var extrudedHeight = params.extrudedHeight;\n        var attributes = attr.attributes;\n        var indices = attr.indices;\n        var positions = attributes.position.values;\n        var length = positions.length;\n        var extrudedPositions = new Float64Array(length);\n        extrudedPositions.set(positions);\n        var newPositions = new Float64Array(length * 2);\n\n        positions = PolygonPipeline.scaleToGeodeticHeight(positions, height, ellipsoid);\n        extrudedPositions = PolygonPipeline.scaleToGeodeticHeight(extrudedPositions, extrudedHeight, ellipsoid);\n        newPositions.set(positions);\n        newPositions.set(extrudedPositions, length);\n        attributes.position.values = newPositions;\n\n        length /= 3;\n        if (defined(params.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length * 2);\n            if (params.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length);\n            } else {\n                var applyOffsetValue = params.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, applyOffsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var i;\n        var iLength = indices.length;\n        var newIndices = IndexDatatype.createTypedArray(newPositions.length / 3, (iLength + wallIndices.length) * 2);\n        newIndices.set(indices);\n        var index = iLength;\n        for (i = 0; i < iLength; i += 2) { // bottom indices\n            var v0 = indices[i];\n            var v1 = indices[i + 1];\n            newIndices[index++] = v0 + length;\n            newIndices[index++] = v1 + length;\n        }\n\n        var UL, LL;\n        for (i = 0; i < wallIndices.length; i++) { //wall indices\n            UL = wallIndices[i];\n            LL = UL + length;\n            newIndices[index++] = UL;\n            newIndices[index++] = LL;\n        }\n\n        return {\n            attributes : attributes,\n            indices : newIndices\n        };\n    }\n\n    /**\n     * A description of a corridor outline.\n     *\n     * @alias CorridorOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.\n     * @param {Number} options.width The distance between the edges of the corridor outline.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see CorridorOutlineGeometry.createGeometry\n     *\n     * @example\n     * var corridor = new Cesium.CorridorOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),\n     *   width : 100000\n     * });\n     */\n    function CorridorOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var width = options.width;\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._positions = positions;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._width = width;\n        this._height = Math.max(height, extrudedHeight);\n        this._extrudedHeight = Math.min(height, extrudedHeight);\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCorridorOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = 1 + positions.length * Cartesian3.packedLength + Ellipsoid.packedLength + 6;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CorridorOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CorridorOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        ellipsoid : scratchEllipsoid,\n        width : undefined,\n        height : undefined,\n        extrudedHeight : undefined,\n        cornerType : undefined,\n        granularity : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CorridorOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.\n     */\n    CorridorOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (var i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var width = array[startingIndex++];\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.width = width;\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CorridorOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._width = width;\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CorridorOutlineGeometry.createGeometry = function(corridorOutlineGeometry) {\n        var positions = corridorOutlineGeometry._positions;\n        var width = corridorOutlineGeometry._width;\n        var ellipsoid = corridorOutlineGeometry._ellipsoid;\n\n        positions = scaleToSurface(positions, ellipsoid);\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n\n        if ((cleanPositions.length < 2) || (width <= 0)) {\n            return;\n        }\n\n        var height = corridorOutlineGeometry._height;\n        var extrudedHeight = corridorOutlineGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var params = {\n            ellipsoid : ellipsoid,\n            positions : cleanPositions,\n            width : width,\n            cornerType : corridorOutlineGeometry._cornerType,\n            granularity : corridorOutlineGeometry._granularity,\n            saveAttributes : false\n        };\n        var attr;\n        if (extrude) {\n            params.height = height;\n            params.extrudedHeight = extrudedHeight;\n            params.offsetAttribute = corridorOutlineGeometry._offsetAttribute;\n            attr = computePositionsExtruded(params);\n        } else {\n            var computedPositions = CorridorGeometryLibrary.computePositions(params);\n            attr = combine(computedPositions, params.cornerType);\n            attr.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(attr.attributes.position.values, height, ellipsoid);\n\n            if (defined(corridorOutlineGeometry._offsetAttribute)) {\n                var length = attr.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = corridorOutlineGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                attr.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n        var attributes = attr.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values, undefined, 3);\n\n        return new Geometry({\n            attributes : attributes,\n            indices : attr.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : corridorOutlineGeometry._offsetAttribute\n        });\n    };\n\n    return CorridorOutlineGeometry;\n});\n","define([\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/CylinderGeometry',\n        '../Core/CylinderOutlineGeometry',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/GeometryInstance',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './heightReferenceOnEntityPropertyChanged',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './Property'\n    ], function(\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        CylinderGeometry,\n        CylinderOutlineGeometry,\n        defined,\n        defineProperties,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        heightReferenceOnEntityPropertyChanged,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        Property) {\n    'use strict';\n\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function CylinderGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.length = undefined;\n        this.topRadius = undefined;\n        this.bottomRadius = undefined;\n        this.slices = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for cylinders.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias CylinderGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function CylinderGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity: entity,\n            scene: scene,\n            geometryOptions: new CylinderGeometryOptions(entity),\n            geometryPropertyName: 'cylinder',\n            observedPropertyNames: ['availability', 'position', 'orientation', 'cylinder']\n        });\n\n        this._onEntityPropertyChanged(entity, 'cylinder', entity.cylinder, undefined);\n    }\n\n    if (defined(Object.create)) {\n        CylinderGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        CylinderGeometryUpdater.prototype.constructor = CylinderGeometryUpdater;\n    }\n\n    defineProperties(CylinderGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof CylinderGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    CylinderGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    CylinderGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new CylinderOutlineGeometry(this._options),\n            modelMatrix : entity.computeModelMatrixForHeightReference(time, entity.cylinder.heightReference, this._options.length * 0.5, this._scene.mapProjection.ellipsoid),\n            attributes : attributes\n        });\n    };\n\n    CylinderGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    CylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder) {\n        return !defined(entity.position) || !defined(cylinder.length) || !defined(cylinder.topRadius) || !defined(cylinder.bottomRadius) || GeometryUpdater.prototype._isHidden.call(this, entity, cylinder);\n    };\n\n    CylinderGeometryUpdater.prototype._isDynamic = function(entity, cylinder) {\n        return !entity.position.isConstant || //\n                !Property.isConstant(entity.orientation) || //\n                !cylinder.length.isConstant || //\n                !cylinder.topRadius.isConstant || //\n                !cylinder.bottomRadius.isConstant || //\n                !Property.isConstant(cylinder.slices) || //\n                !Property.isConstant(cylinder.outlineWidth) || //\n                !Property.isConstant(cylinder.numberOfVerticalLines);\n    };\n\n    CylinderGeometryUpdater.prototype._setStaticOptions = function(entity, cylinder) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.length = cylinder.length.getValue(Iso8601.MINIMUM_VALUE);\n        options.topRadius = cylinder.topRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.bottomRadius = cylinder.bottomRadius.getValue(Iso8601.MINIMUM_VALUE);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    CylinderGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    CylinderGeometryUpdater.DynamicGeometryUpdater = DynamicCylinderGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicCylinderGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicCylinderGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicCylinderGeometryUpdater.prototype.constructor = DynamicCylinderGeometryUpdater;\n    }\n\n    DynamicCylinderGeometryUpdater.prototype._isHidden = function(entity, cylinder, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.length) || !defined(options.topRadius) || //\n               !defined(options.bottomRadius) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, cylinder, time);\n    };\n\n    DynamicCylinderGeometryUpdater.prototype._setOptions = function(entity, cylinder, time) {\n        var heightReference = Property.getValueOrDefault(cylinder.heightReference, time, HeightReference.NONE);\n        var options = this._options;\n        options.length = Property.getValueOrUndefined(cylinder.length, time);\n        options.topRadius = Property.getValueOrUndefined(cylinder.topRadius, time);\n        options.bottomRadius = Property.getValueOrUndefined(cylinder.bottomRadius, time);\n        options.slices = Property.getValueOrUndefined(cylinder.slices, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(cylinder.numberOfVerticalLines, time);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    return CylinderGeometryUpdater;\n});\n","define([\n        './arrayFill',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './ComponentDatatype',\n        './CylinderGeometryLibrary',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryOffsetAttribute',\n        './IndexDatatype',\n        './Math',\n        './PrimitiveType',\n        './VertexFormat'\n    ], function(\n        arrayFill,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        ComponentDatatype,\n        CylinderGeometryLibrary,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryOffsetAttribute,\n        IndexDatatype,\n        CesiumMath,\n        PrimitiveType,\n        VertexFormat) {\n    'use strict';\n\n    var radiusScratch = new Cartesian2();\n    var normalScratch = new Cartesian3();\n    var bitangentScratch = new Cartesian3();\n    var tangentScratch = new Cartesian3();\n    var positionScratch = new Cartesian3();\n\n    /**\n     * A description of a cylinder.\n     *\n     * @alias CylinderGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);\n     */\n    function CylinderGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var slices = defaultValue(options.slices, 128);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._slices = slices;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderGeometry.packedLength = VertexFormat.packedLength + 5;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat : scratchVertexFormat,\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderGeometry} [result] The object into which to store the result.\n     * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.\n     */\n    CylinderGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var vertexFormat = cylinderGeometry._vertexFormat;\n        var slices = cylinderGeometry._slices;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var twoSlices = slices + slices;\n        var threeSlices = slices + twoSlices;\n        var numVertices = twoSlices + twoSlices;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, true);\n\n        var st = (vertexFormat.st) ? new Float32Array(numVertices * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(numVertices * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(numVertices * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(numVertices * 3) : undefined;\n\n        var i;\n        var computeNormal = (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent);\n\n        if (computeNormal) {\n            var computeTangent = (vertexFormat.tangent || vertexFormat.bitangent);\n\n            var normalIndex = 0;\n            var tangentIndex = 0;\n            var bitangentIndex = 0;\n\n            var theta = Math.atan2(bottomRadius - topRadius, length);\n            var normal = normalScratch;\n            normal.z = Math.sin(theta);\n            var normalScale = Math.cos(theta);\n            var tangent = tangentScratch;\n            var bitangent = bitangentScratch;\n\n            for (i = 0; i < slices; i++) {\n                var angle = i / slices * CesiumMath.TWO_PI;\n                var x = normalScale * Math.cos(angle);\n                var y = normalScale * Math.sin(angle);\n                if (computeNormal) {\n                    normal.x = x;\n                    normal.y = y;\n\n                    if (computeTangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                    }\n\n                    if (vertexFormat.normal) {\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                        normals[normalIndex++] = normal.x;\n                        normals[normalIndex++] = normal.y;\n                        normals[normalIndex++] = normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                        tangents[tangentIndex++] = tangent.x;\n                        tangents[tangentIndex++] = tangent.y;\n                        tangents[tangentIndex++] = tangent.z;\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                        bitangents[bitangentIndex++] = bitangent.x;\n                        bitangents[bitangentIndex++] = bitangent.y;\n                        bitangents[bitangentIndex++] = bitangent.z;\n                    }\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = -1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = -1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n\n            for (i = 0; i < slices; i++) {\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 0;\n                    normals[normalIndex++] = 1;\n                }\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = 1;\n                    tangents[tangentIndex++] = 0;\n                    tangents[tangentIndex++] = 0;\n                }\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = 0;\n                    bitangents[bitangentIndex++] = 1;\n                    bitangents[bitangentIndex++] = 0;\n                }\n            }\n        }\n\n        var numIndices = 12 * slices - 12;\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices);\n        var index = 0;\n        var j = 0;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = j;\n            indices[index++] = j + 2;\n            indices[index++] = j + 3;\n\n            indices[index++] = j;\n            indices[index++] = j + 3;\n            indices[index++] = j + 1;\n\n            j += 2;\n        }\n\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 0;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 2;\n        indices[index++] = 1;\n        indices[index++] = twoSlices - 1;\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = twoSlices + i + 1;\n            indices[index++] = twoSlices + i;\n            indices[index++] = twoSlices;\n        }\n\n        for (i = 1; i < slices - 1; i++) {\n            indices[index++] = threeSlices;\n            indices[index++] = threeSlices + i;\n            indices[index++] = threeSlices + i + 1;\n        }\n\n        var textureCoordIndex = 0;\n        if (vertexFormat.st) {\n            var rad = Math.max(topRadius, bottomRadius);\n            for (i = 0; i < numVertices; i++) {\n                var position = Cartesian3.fromArray(positions, i * 3, positionScratch);\n                st[textureCoordIndex++] = (position.x + rad) / (2.0 * rad);\n                st[textureCoordIndex++] = (position.y + rad) / (2.0 * rad);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype: ComponentDatatype.DOUBLE,\n                componentsPerAttribute: 3,\n                values: positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\n\n    var unitCylinderGeometry;\n\n    /**\n     * Returns the geometric representation of a unit cylinder, including its vertices, indices, and a bounding sphere.\n     * @returns {Geometry} The computed vertices and indices.\n     *\n     * @private\n     */\n    CylinderGeometry.getUnitCylinder = function() {\n        if (!defined(unitCylinderGeometry)) {\n            unitCylinderGeometry = CylinderGeometry.createGeometry(new CylinderGeometry({\n                topRadius : 1.0,\n                bottomRadius : 1.0,\n                length : 1.0,\n                vertexFormat : VertexFormat.POSITION_ONLY\n            }));\n        }\n        return unitCylinderGeometry;\n    };\n\n    return CylinderGeometry;\n});\n","\ndefine([\n        './arrayFill',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './Check',\n        './ComponentDatatype',\n        './CylinderGeometryLibrary',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryOffsetAttribute',\n        './IndexDatatype',\n        './PrimitiveType'\n    ], function(\n        arrayFill,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        Check,\n        ComponentDatatype,\n        CylinderGeometryLibrary,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryOffsetAttribute,\n        IndexDatatype,\n        PrimitiveType) {\n    'use strict';\n\n    var radiusScratch = new Cartesian2();\n\n    /**\n     * A description of the outline of a cylinder.\n     *\n     * @alias CylinderOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Number} options.length The length of the cylinder.\n     * @param {Number} options.topRadius The radius of the top of the cylinder.\n     * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.\n     * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.\n     *\n     * @exception {DeveloperError} options.length must be greater than 0.\n     * @exception {DeveloperError} options.topRadius must be greater than 0.\n     * @exception {DeveloperError} options.bottomRadius must be greater than 0.\n     * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.\n     * @exception {DeveloperError} options.slices must be greater than or equal to 3.\n     *\n     * @see CylinderOutlineGeometry.createGeometry\n     *\n     * @example\n     * // create cylinder geometry\n     * var cylinder = new Cesium.CylinderOutlineGeometry({\n     *     length: 200000,\n     *     topRadius: 80000,\n     *     bottomRadius: 200000,\n     * });\n     * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);\n     */\n    function CylinderOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var length = options.length;\n        var topRadius = options.topRadius;\n        var bottomRadius = options.bottomRadius;\n        var slices = defaultValue(options.slices, 128);\n        var numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n\n        \n\n        this._length = length;\n        this._topRadius = topRadius;\n        this._bottomRadius = bottomRadius;\n        this._slices = slices;\n        this._numberOfVerticalLines = numberOfVerticalLines;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createCylinderOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    CylinderOutlineGeometry.packedLength = 6;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CylinderOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CylinderOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        array[startingIndex++] = value._length;\n        array[startingIndex++] = value._topRadius;\n        array[startingIndex++] = value._bottomRadius;\n        array[startingIndex++] = value._slices;\n        array[startingIndex++] = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchOptions = {\n        length : undefined,\n        topRadius : undefined,\n        bottomRadius : undefined,\n        slices : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CylinderOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.\n     */\n    CylinderOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var length = array[startingIndex++];\n        var topRadius = array[startingIndex++];\n        var bottomRadius = array[startingIndex++];\n        var slices = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.length = length;\n            scratchOptions.topRadius = topRadius;\n            scratchOptions.bottomRadius = bottomRadius;\n            scratchOptions.slices = slices;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n            return new CylinderOutlineGeometry(scratchOptions);\n        }\n\n        result._length = length;\n        result._topRadius = topRadius;\n        result._bottomRadius = bottomRadius;\n        result._slices = slices;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CylinderOutlineGeometry.createGeometry = function(cylinderGeometry) {\n        var length = cylinderGeometry._length;\n        var topRadius = cylinderGeometry._topRadius;\n        var bottomRadius = cylinderGeometry._bottomRadius;\n        var slices = cylinderGeometry._slices;\n        var numberOfVerticalLines = cylinderGeometry._numberOfVerticalLines;\n\n        if ((length <= 0) || (topRadius < 0) || (bottomRadius < 0) || ((topRadius === 0) && (bottomRadius === 0))) {\n            return;\n        }\n\n        var numVertices = slices * 2;\n\n        var positions = CylinderGeometryLibrary.computePositions(length, topRadius, bottomRadius, slices, false);\n        var numIndices = slices * 2;\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, slices);\n            numSide = Math.round(slices / numSideLines);\n            numIndices += numSideLines;\n        }\n\n        var indices = IndexDatatype.createTypedArray(numVertices, numIndices * 2);\n        var index = 0;\n        var i;\n        for (i = 0; i < slices - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n            indices[index++] = i + slices;\n            indices[index++] = i + 1 + slices;\n        }\n\n        indices[index++] = slices - 1;\n        indices[index++] = 0;\n        indices[index++] = slices + slices - 1;\n        indices[index++] = slices;\n\n        if (numberOfVerticalLines > 0) {\n            for (i = 0; i < slices; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + slices;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        radiusScratch.x = length * 0.5;\n        radiusScratch.y = Math.max(bottomRadius, topRadius);\n\n        var boundingSphere = new BoundingSphere(Cartesian3.ZERO, Cartesian2.magnitude(radiusScratch));\n\n        if (defined(cylinderGeometry._offsetAttribute)) {\n            length = positions.length;\n            var applyOffset = new Uint8Array(length / 3);\n            var offsetValue = cylinderGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n            arrayFill(applyOffset, offsetValue);\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : boundingSphere,\n            offsetAttribute : cylinderGeometry._offsetAttribute\n        });\n    };\n\n    return CylinderOutlineGeometry;\n});\n","define([\n        '../Core/ApproximateTerrainHeights',\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/EllipseGeometry',\n        '../Core/EllipseOutlineGeometry',\n        '../Core/GeometryInstance',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/Rectangle',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/GroundPrimitive',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './GroundGeometryUpdater',\n        './Property'\n    ], function(\n        ApproximateTerrainHeights,\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        EllipseGeometry,\n        EllipseOutlineGeometry,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        Rectangle,\n        ShowGeometryInstanceAttribute,\n        GroundPrimitive,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        GroundGeometryUpdater,\n        Property) {\n    'use strict';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n\n    function EllipseGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.center = undefined;\n        this.semiMajorAxis = undefined;\n        this.semiMinorAxis = undefined;\n        this.rotation = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.numberOfVerticalLines = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipses.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipseGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipseGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipseGeometryOptions(entity),\n            geometryPropertyName : 'ellipse',\n            observedPropertyNames : ['availability', 'position', 'ellipse']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipse', entity.ellipse, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipseGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        EllipseGeometryUpdater.prototype.constructor = EllipseGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipseGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipseGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipseOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    EllipseGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse) {\n        var position = entity.position;\n\n        return !defined(position) || !defined(ellipse.semiMajorAxis) || !defined(ellipse.semiMinorAxis) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipse);\n    };\n\n    EllipseGeometryUpdater.prototype._isDynamic = function(entity, ellipse) {\n        return !entity.position.isConstant || //\n               !ellipse.semiMajorAxis.isConstant || //\n               !ellipse.semiMinorAxis.isConstant || //\n               !Property.isConstant(ellipse.rotation) || //\n               !Property.isConstant(ellipse.height) || //\n               !Property.isConstant(ellipse.extrudedHeight) || //\n               !Property.isConstant(ellipse.granularity) || //\n               !Property.isConstant(ellipse.stRotation) || //\n               !Property.isConstant(ellipse.outlineWidth) || //\n               !Property.isConstant(ellipse.numberOfVerticalLines) || //\n               !Property.isConstant(ellipse.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    EllipseGeometryUpdater.prototype._setStaticOptions = function(entity, ellipse) {\n        var heightValue = Property.getValueOrUndefined(ellipse.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = (this._materialProperty instanceof ColorMaterialProperty) ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.center = entity.position.getValue(Iso8601.MINIMUM_VALUE, options.center);\n        options.semiMajorAxis = ellipse.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMajorAxis);\n        options.semiMinorAxis = ellipse.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE, options.semiMinorAxis);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, Iso8601.MINIMUM_VALUE);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, Iso8601.MINIMUM_VALUE);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    EllipseGeometryUpdater.DynamicGeometryUpdater = DynamicEllipseGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipseGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipseGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipseGeometryUpdater.prototype.constructor = DynamicEllipseGeometryUpdater;\n    }\n\n    DynamicEllipseGeometryUpdater.prototype._isHidden = function(entity, ellipse, time) {\n        var options = this._options;\n        return !defined(options.center) || !defined(options.semiMajorAxis) || !defined(options.semiMinorAxis) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, ellipse, time);\n    };\n\n    DynamicEllipseGeometryUpdater.prototype._setOptions = function(entity, ellipse, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(ellipse.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(ellipse.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(ellipse.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(ellipse.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.center = Property.getValueOrUndefined(entity.position, time, options.center);\n        options.semiMajorAxis = Property.getValueOrUndefined(ellipse.semiMajorAxis, time);\n        options.semiMinorAxis = Property.getValueOrUndefined(ellipse.semiMinorAxis, time);\n        options.rotation = Property.getValueOrUndefined(ellipse.rotation, time);\n        options.granularity = Property.getValueOrUndefined(ellipse.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(ellipse.stRotation, time);\n        options.numberOfVerticalLines = Property.getValueOrUndefined(ellipse.numberOfVerticalLines, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    return EllipseGeometryUpdater;\n});\n","define([\n        './arrayFill',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './Cartographic',\n        './Check',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './EllipseGeometryLibrary',\n        './Ellipsoid',\n        './GeographicProjection',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryInstance',\n        './GeometryOffsetAttribute',\n        './GeometryPipeline',\n        './IndexDatatype',\n        './Math',\n        './Matrix3',\n        './PrimitiveType',\n        './Quaternion',\n        './Rectangle',\n        './VertexFormat'\n    ], function(\n        arrayFill,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        Cartographic,\n        Check,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        EllipseGeometryLibrary,\n        Ellipsoid,\n        GeographicProjection,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        GeometryPipeline,\n        IndexDatatype,\n        CesiumMath,\n        Matrix3,\n        PrimitiveType,\n        Quaternion,\n        Rectangle,\n        VertexFormat) {\n    'use strict';\n\n    var scratchCartesian1 = new Cartesian3();\n    var scratchCartesian2 = new Cartesian3();\n    var scratchCartesian3 = new Cartesian3();\n    var scratchCartesian4 = new Cartesian3();\n    var texCoordScratch = new Cartesian2();\n    var textureMatrixScratch = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n    var quaternionScratch = new Quaternion();\n\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n\n    var scratchCartographic = new Cartographic();\n    var projectedCenterScratch = new Cartesian3();\n\n    var scratchMinTexCoord = new Cartesian2();\n    var scratchMaxTexCoord = new Cartesian2();\n\n    function computeTopBottomAttributes(positions, options, extrude) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var stRotation = options.stRotation;\n        var size = (extrude) ? positions.length / 3 * 2 : positions.length / 3;\n        var shadowVolume = options.shadowVolume;\n\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n\n        var textureMatrix = textureMatrixScratch;\n        var tangentMatrix = tangentMatrixScratch;\n        if (stRotation !== 0) {\n            var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            rotation = Quaternion.fromAxisAngle(geodeticNormal, -stRotation, quaternionScratch);\n            tangentMatrix = Matrix3.fromQuaternion(rotation, tangentMatrix);\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n            tangentMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentMatrix);\n        }\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var bottomOffset = (extrude) ? length : 0;\n        var stOffset = bottomOffset / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                if (extrude) {\n                    textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                    textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n                }\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n                if (shadowVolume) {\n                    extrudeNormals[i + bottomOffset] = -normal.x;\n                    extrudeNormals[i1 + bottomOffset] = -normal.y;\n                    extrudeNormals[i2 + bottomOffset] = -normal.z;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                    if (vertexFormat.tangent || vertexFormat.bitangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent), tangent);\n                        Matrix3.multiplyByVector(tangentMatrix, tangent, tangent);\n                    }\n                    if (vertexFormat.normal) {\n                        normals[i] = normal.x;\n                        normals[i1] = normal.y;\n                        normals[i2] = normal.z;\n                        if (extrude) {\n                            normals[i + bottomOffset] = -normal.x;\n                            normals[i1 + bottomOffset] = -normal.y;\n                            normals[i2 + bottomOffset] = -normal.z;\n                        }\n                    }\n\n                    if (vertexFormat.tangent) {\n                        tangents[i] = tangent.x;\n                        tangents[i1] = tangent.y;\n                        tangents[i2] = tangent.z;\n                        if (extrude) {\n                            tangents[i + bottomOffset] = -tangent.x;\n                            tangents[i1 + bottomOffset] = -tangent.y;\n                            tangents[i2 + bottomOffset] = -tangent.z;\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                        bitangents[i ] = bitangent.x;\n                        bitangents[i1] = bitangent.y;\n                        bitangents[i2] = bitangent.z;\n                        if (extrude) {\n                            bitangents[i + bottomOffset] = bitangent.x;\n                            bitangents[i1 + bottomOffset] = bitangent.y;\n                            bitangents[i2 + bottomOffset] = bitangent.z;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            var finalPositions = EllipseGeometryLibrary.raisePositionsToHeight(positions, options, extrude);\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (extrude && defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function topIndices(numPts) {\n        // numTriangles in half = 3 + 8 + 12 + ... = -1 + 4 + (4 + 4) + (4 + 4 + 4) + ... = -1 + 4 * (1 + 2 + 3 + ...)\n        //              = -1 + 4 * ((n * ( n + 1)) / 2)\n        // total triangles = 2 * numTrangles in half\n        // indices = total triangles * 3;\n        // Substitute numPts for n above\n\n        var indices = new Array(12 * (numPts * ( numPts + 1)) - 6);\n        var indicesIndex = 0;\n        var prevIndex;\n        var numInterior;\n        var positionIndex;\n        var i;\n        var j;\n        // Indices triangles to the 'right' of the north vector\n\n        prevIndex = 0;\n        positionIndex = 1;\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        for (i = 2; i < numPts + 1; ++i) {\n            positionIndex = i * (i + 1) - 1;\n            prevIndex = (i - 1) * i - 1;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        // Indices for center column of triangles\n        numInterior = numPts * 2;\n        ++positionIndex;\n        ++prevIndex;\n        for (i = 0; i < numInterior - 1; ++i) {\n            indices[indicesIndex++] = positionIndex;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n\n            indices[indicesIndex++] = positionIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n\n        indices[indicesIndex++] = positionIndex;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        indices[indicesIndex++] = positionIndex++;\n        indices[indicesIndex++] = prevIndex++;\n        indices[indicesIndex++] = prevIndex;\n\n        // Reverse the process creating indices to the 'left' of the north vector\n        ++prevIndex;\n        for (i = numPts - 1; i > 1; --i) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n\n            numInterior = 2 * i;\n            for (j = 0; j < numInterior - 1; ++j) {\n                indices[indicesIndex++] = positionIndex;\n                indices[indicesIndex++] = prevIndex++;\n                indices[indicesIndex++] = prevIndex;\n\n                indices[indicesIndex++] = positionIndex++;\n                indices[indicesIndex++] = prevIndex;\n                indices[indicesIndex++] = positionIndex;\n            }\n\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = positionIndex++;\n        }\n\n        for (i = 0; i < 3; i++) {\n            indices[indicesIndex++] = prevIndex++;\n            indices[indicesIndex++] = prevIndex;\n            indices[indicesIndex++] = positionIndex;\n        }\n        return indices;\n    }\n\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, false);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var attributes = computeTopBottomAttributes(positions, options, false);\n        var indices = topIndices(numPts);\n        indices = IndexDatatype.createTypedArray(positions.length / 3, indices);\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    function computeWallAttributes(positions, options) {\n        var vertexFormat = options.vertexFormat;\n        var center = options.center;\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var ellipsoid = options.ellipsoid;\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var stRotation = options.stRotation;\n        var size = positions.length / 3 * 2;\n\n        var finalPositions = new Float64Array(size * 3);\n        var textureCoordinates = (vertexFormat.st) ? new Float32Array(size * 2) : undefined;\n        var normals = (vertexFormat.normal) ? new Float32Array(size * 3) : undefined;\n        var tangents = (vertexFormat.tangent) ? new Float32Array(size * 3) : undefined;\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(size * 3) : undefined;\n\n        var shadowVolume = options.shadowVolume;\n        var extrudeNormals = (shadowVolume) ? new Float32Array(size * 3) : undefined;\n\n        var textureCoordIndex = 0;\n\n        // Raise positions to a height above the ellipsoid and compute the\n        // texture coordinates, normals, tangents, and bitangents.\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n\n        var projection = new GeographicProjection(ellipsoid);\n        var projectedCenter = projection.project(ellipsoid.cartesianToCartographic(center, scratchCartographic), projectedCenterScratch);\n\n        var geodeticNormal = ellipsoid.scaleToGeodeticSurface(center, scratchCartesian1);\n        ellipsoid.geodeticSurfaceNormal(geodeticNormal, geodeticNormal);\n        var rotation = Quaternion.fromAxisAngle(geodeticNormal, stRotation, quaternionScratch);\n        var textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrixScratch);\n\n        var minTexCoord = Cartesian2.fromElements(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, scratchMinTexCoord);\n        var maxTexCoord = Cartesian2.fromElements(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, scratchMaxTexCoord);\n\n        var length = positions.length;\n        var stOffset = length / 3 * 2;\n        for (var i = 0; i < length; i += 3) {\n            var i1 = i + 1;\n            var i2 = i + 2;\n            var position = Cartesian3.fromArray(positions, i, scratchCartesian1);\n            var extrudedPosition;\n\n            if (vertexFormat.st) {\n                var rotatedPoint = Matrix3.multiplyByVector(textureMatrix, position, scratchCartesian2);\n                var projectedPoint = projection.project(ellipsoid.cartesianToCartographic(rotatedPoint, scratchCartographic), scratchCartesian3);\n                Cartesian3.subtract(projectedPoint, projectedCenter, projectedPoint);\n\n                texCoordScratch.x = (projectedPoint.x + semiMajorAxis) / (2.0 * semiMajorAxis);\n                texCoordScratch.y = (projectedPoint.y + semiMinorAxis) / (2.0 * semiMinorAxis);\n\n                minTexCoord.x = Math.min(texCoordScratch.x, minTexCoord.x);\n                minTexCoord.y = Math.min(texCoordScratch.y, minTexCoord.y);\n                maxTexCoord.x = Math.max(texCoordScratch.x, maxTexCoord.x);\n                maxTexCoord.y = Math.max(texCoordScratch.y, maxTexCoord.y);\n\n                textureCoordinates[textureCoordIndex + stOffset] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex + 1 + stOffset] = texCoordScratch.y;\n\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.x;\n                textureCoordinates[textureCoordIndex++] = texCoordScratch.y;\n            }\n\n            position = ellipsoid.scaleToGeodeticSurface(position, position);\n            extrudedPosition = Cartesian3.clone(position, scratchCartesian2);\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n\n            if (shadowVolume) {\n                extrudeNormals[i + length] = -normal.x;\n                extrudeNormals[i1 + length] = -normal.y;\n                extrudeNormals[i2 + length] = -normal.z;\n            }\n\n            var scaledNormal = Cartesian3.multiplyByScalar(normal, height, scratchCartesian4);\n            position = Cartesian3.add(position, scaledNormal, position);\n            scaledNormal = Cartesian3.multiplyByScalar(normal, extrudedHeight, scaledNormal);\n            extrudedPosition = Cartesian3.add(extrudedPosition, scaledNormal, extrudedPosition);\n\n            if (vertexFormat.position) {\n                finalPositions[i + length] = extrudedPosition.x;\n                finalPositions[i1 + length] = extrudedPosition.y;\n                finalPositions[i2 + length] = extrudedPosition.z;\n\n                finalPositions[i] = position.x;\n                finalPositions[i1] = position.y;\n                finalPositions[i2] = position.z;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n\n                bitangent = Cartesian3.clone(normal, bitangent);\n                var next = Cartesian3.fromArray(positions, (i + 3) % length, scratchCartesian4);\n                Cartesian3.subtract(next, position, next);\n                var bottom = Cartesian3.subtract(extrudedPosition, position, scratchCartesian3);\n\n                normal = Cartesian3.normalize(Cartesian3.cross(bottom, next, normal), normal);\n\n                if (vertexFormat.normal) {\n                    normals[i] = normal.x;\n                    normals[i1] = normal.y;\n                    normals[i2] = normal.z;\n\n                    normals[i + length] = normal.x;\n                    normals[i1 + length] = normal.y;\n                    normals[i2 + length] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                    tangents[i] = tangent.x;\n                    tangents[i1] = tangent.y;\n                    tangents[i2] = tangent.z;\n\n                    tangents[i + length] = tangent.x;\n                    tangents[i + 1 + length] = tangent.y;\n                    tangents[i + 2 + length] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[i ] = bitangent.x;\n                    bitangents[i1] = bitangent.y;\n                    bitangents[i2] = bitangent.z;\n\n                    bitangents[i + length] = bitangent.x;\n                    bitangents[i1 + length] = bitangent.y;\n                    bitangents[i2 + length] = bitangent.z;\n                }\n            }\n        }\n\n        if (vertexFormat.st) {\n            length = textureCoordinates.length;\n            for (var k = 0; k < length; k += 2) {\n                textureCoordinates[k] = (textureCoordinates[k] - minTexCoord.x) / (maxTexCoord.x - minTexCoord.x);\n                textureCoordinates[k + 1] = (textureCoordinates[k + 1] - minTexCoord.y) / (maxTexCoord.y - minTexCoord.y);\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : finalPositions\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (shadowVolume) {\n            attributes.extrudeDirection = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : extrudeNormals\n            });\n        }\n\n        if (defined(options.offsetAttribute)) {\n            var offsetAttribute = new Uint8Array(size);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return attributes;\n    }\n\n    function computeWallIndices(positions) {\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 6);\n        var index = 0;\n        for (var i = 0; i < length; i++) {\n            var UL = i;\n            var LL = i + length;\n            var UR = (UL + 1) % length;\n            var LR = UR + length;\n            indices[index++] = UL;\n            indices[index++] = LL;\n            indices[index++] = UR;\n            indices[index++] = UR;\n            indices[index++] = LL;\n            indices[index++] = LR;\n        }\n\n        return indices;\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions(options, true, true);\n        var positions = cep.positions;\n        var numPts = cep.numPts;\n        var outerPositions = cep.outerPositions;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var topBottomAttributes = computeTopBottomAttributes(positions, options, true);\n        var indices = topIndices(numPts);\n        var length = indices.length;\n        indices.length = length * 2;\n        var posLength = positions.length / 3;\n        for (var i = 0; i < length; i += 3) {\n            indices[i + length] = indices[i + 2] + posLength;\n            indices[i + 1 + length] = indices[i + 1] + posLength;\n            indices[i + 2 + length] = indices[i] + posLength;\n        }\n\n        var topBottomIndices = IndexDatatype.createTypedArray(posLength * 2 / 3, indices);\n\n        var topBottomGeo = new Geometry({\n            attributes : topBottomAttributes,\n            indices : topBottomIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var wallAttributes = computeWallAttributes(outerPositions, options);\n        indices = computeWallIndices(outerPositions);\n        var wallIndices = IndexDatatype.createTypedArray(outerPositions.length * 2 / 3, indices);\n\n        var wallGeo = new Geometry({\n            attributes : wallAttributes,\n            indices : wallIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        var geo = GeometryPipeline.combineInstances([\n            new GeometryInstance({\n                geometry : topBottomGeo\n            }),\n            new GeometryInstance({\n                geometry : wallGeo\n            })\n        ]);\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : geo[0].attributes,\n            indices : geo[0].indices\n        };\n    }\n\n    function computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result) {\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : center,\n            semiMajorAxis : semiMajorAxis,\n            semiMinorAxis : semiMinorAxis,\n            rotation : rotation,\n            granularity : granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n        var rectangle = Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        // Rectangle width goes beyond 180 degrees when the ellipse crosses a pole.\n        // When this happens, make the rectangle into a \"circle\" around the pole\n        if (rectangle.width > CesiumMath.PI) {\n            rectangle.north = rectangle.north > 0.0 ? CesiumMath.PI_OVER_TWO - CesiumMath.EPSILON7 : rectangle.north;\n            rectangle.south = rectangle.south < 0.0 ? CesiumMath.EPSILON7 - CesiumMath.PI_OVER_TWO : rectangle.south;\n            rectangle.east = CesiumMath.PI;\n            rectangle.west = -CesiumMath.PI;\n        }\n        return rectangle;\n    }\n\n    /**\n     * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias EllipseGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     *\n     * @example\n     * // Create an ellipse.\n     * var ellipse = new Cesium.EllipseGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);\n     *\n     * @see EllipseGeometry.createGeometry\n     */\n    function EllipseGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createEllipseGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + VertexFormat.packedLength + 9;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        stRotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        shadowVolume: undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseGeometry} [result] The object into which to store the result.\n     * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.\n     */\n    EllipseGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.stRotation = stRotation;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.shadowVolume = shadowVolume;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._stRotation = stRotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the bounding rectangle based on the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.\n     * @param {Rectangle} [result] An object in which to store the result\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    EllipseGeometry.computeRectangle = function(options, result) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var rotation = defaultValue(options.rotation, 0.0);\n\n        \n\n        return computeRectangle(center, semiMajorAxis, semiMinorAxis, rotation, granularity, ellipsoid, result);\n    };\n\n    /**\n     * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            vertexFormat : ellipseGeometry._vertexFormat,\n            stRotation : ellipseGeometry._stRotation\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.shadowVolume = ellipseGeometry._shadowVolume;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    EllipseGeometry.createShadowVolume = function(ellipseGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = ellipseGeometry._granularity;\n        var ellipsoid = ellipseGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new EllipseGeometry({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            stRotation : ellipseGeometry._stRotation,\n            granularity : granularity,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true\n        });\n    };\n\n    function textureCoordinateRotationPoints(ellipseGeometry) {\n        var stRotation = -ellipseGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n\n        var cep = EllipseGeometryLibrary.computeEllipsePositions({\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            rotation : ellipseGeometry._rotation,\n            granularity : ellipseGeometry._granularity\n        }, false, true);\n        var positionsFlat = cep.outerPositions;\n        var positionsCount = positionsFlat.length / 3;\n        var positions = new Array(positionsCount);\n        for (var i = 0; i < positionsCount; ++i) {\n            positions[i] = Cartesian3.fromArray(positionsFlat, i * 3);\n        }\n\n        var ellipsoid = ellipseGeometry._ellipsoid;\n        var boundingRectangle = ellipseGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(EllipseGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    this._rectangle = computeRectangle(this._center, this._semiMajorAxis, this._semiMinorAxis, this._rotation, this._granularity, this._ellipsoid);\n                }\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering EllipseGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\n\n    return EllipseGeometry;\n});\n","define([\n        './arrayFill',\n        './BoundingSphere',\n        './Cartesian3',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './EllipseGeometryLibrary',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryOffsetAttribute',\n        './IndexDatatype',\n        './Math',\n        './PrimitiveType'\n    ], function(\n        arrayFill,\n        BoundingSphere,\n        Cartesian3,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        EllipseGeometryLibrary,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryOffsetAttribute,\n        IndexDatatype,\n        CesiumMath,\n        PrimitiveType) {\n    'use strict';\n\n    var scratchCartesian1 = new Cartesian3();\n    var boundingSphereCenter = new Cartesian3();\n\n    function computeEllipse(options) {\n        var center = options.center;\n        boundingSphereCenter = Cartesian3.multiplyByScalar(options.ellipsoid.geodeticSurfaceNormal(center, boundingSphereCenter), options.height, boundingSphereCenter);\n        boundingSphereCenter = Cartesian3.add(center, boundingSphereCenter, boundingSphereCenter);\n        var boundingSphere = new BoundingSphere(boundingSphereCenter, options.semiMajorAxis);\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, false)\n            })\n        });\n\n        var length = positions.length / 3;\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n        var index = 0;\n        for ( var i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    var topBoundingSphere = new BoundingSphere();\n    var bottomBoundingSphere = new BoundingSphere();\n    function computeExtrudedEllipse(options) {\n        var center = options.center;\n        var ellipsoid = options.ellipsoid;\n        var semiMajorAxis = options.semiMajorAxis;\n        var scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scratchCartesian1), options.height, scratchCartesian1);\n        topBoundingSphere.center = Cartesian3.add(center, scaledNormal, topBoundingSphere.center);\n        topBoundingSphere.radius = semiMajorAxis;\n\n        scaledNormal = Cartesian3.multiplyByScalar(ellipsoid.geodeticSurfaceNormal(center, scaledNormal), options.extrudedHeight, scaledNormal);\n        bottomBoundingSphere.center = Cartesian3.add(center, scaledNormal, bottomBoundingSphere.center);\n        bottomBoundingSphere.radius = semiMajorAxis;\n\n        var positions = EllipseGeometryLibrary.computeEllipsePositions(options, false, true).outerPositions;\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : EllipseGeometryLibrary.raisePositionsToHeight(positions, options, true)\n            })\n        });\n\n        positions = attributes.position.values;\n        var boundingSphere = BoundingSphere.union(topBoundingSphere, bottomBoundingSphere);\n        var length = positions.length/3;\n\n        if (defined(options.offsetAttribute)) {\n            var applyOffset = new Uint8Array(length);\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                applyOffset = arrayFill(applyOffset, 1, 0, length / 2);\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                applyOffset = arrayFill(applyOffset, offsetValue);\n            }\n\n            attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values: applyOffset\n            });\n        }\n\n        var numberOfVerticalLines = defaultValue(options.numberOfVerticalLines, 16);\n        numberOfVerticalLines = CesiumMath.clamp(numberOfVerticalLines, 0, length/2);\n\n        var indices = IndexDatatype.createTypedArray(length, length * 2 + numberOfVerticalLines * 2);\n\n        length /= 2;\n        var index = 0;\n        var i;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        var numSide;\n        if (numberOfVerticalLines > 0) {\n            var numSideLines = Math.min(numberOfVerticalLines, length);\n            numSide = Math.round(length / numSideLines);\n\n            var maxI = Math.min(numSide * numberOfVerticalLines, length);\n            for (i = 0; i < maxI; i += numSide) {\n                indices[index++] = i;\n                indices[index++] = i + length;\n            }\n        }\n\n        return {\n            boundingSphere : boundingSphere,\n            attributes : attributes,\n            indices : indices\n        };\n    }\n\n    /**\n     * A description of the outline of an ellipse on an ellipsoid.\n     *\n     * @alias EllipseOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.\n     * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.\n     * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.\n     * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.\n     * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.\n     * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.\n     * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.\n     *\n     * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.\n     * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.\n     * @exception {DeveloperError} granularity must be greater than zero.\n     *\n     * @see EllipseOutlineGeometry.createGeometry\n     *\n     * @example\n     * var ellipse = new Cesium.EllipseOutlineGeometry({\n     *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),\n     *   semiMajorAxis : 500000.0,\n     *   semiMinorAxis : 300000.0,\n     *   rotation : Cesium.Math.toRadians(60.0)\n     * });\n     * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);\n     */\n    function EllipseOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var center = options.center;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var semiMajorAxis = options.semiMajorAxis;\n        var semiMinorAxis = options.semiMinorAxis;\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n\n        \n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        this._center = Cartesian3.clone(center);\n        this._semiMajorAxis = semiMajorAxis;\n        this._semiMinorAxis = semiMinorAxis;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._rotation = defaultValue(options.rotation, 0.0);\n        this._height = Math.max(extrudedHeight, height);\n        this._granularity = granularity;\n        this._extrudedHeight = Math.min(extrudedHeight, height);\n        this._numberOfVerticalLines = Math.max(defaultValue(options.numberOfVerticalLines, 16), 0);\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createEllipseOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    EllipseOutlineGeometry.packedLength = Cartesian3.packedLength + Ellipsoid.packedLength + 8;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {EllipseOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    EllipseOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        Cartesian3.pack(value._center, array, startingIndex);\n        startingIndex += Cartesian3.packedLength;\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._semiMajorAxis;\n        array[startingIndex++] = value._semiMinorAxis;\n        array[startingIndex++] = value._rotation;\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++]   = value._numberOfVerticalLines;\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\n\n        return array;\n    };\n\n    var scratchCenter = new Cartesian3();\n    var scratchEllipsoid = new Ellipsoid();\n    var scratchOptions = {\n        center : scratchCenter,\n        ellipsoid : scratchEllipsoid,\n        semiMajorAxis : undefined,\n        semiMinorAxis : undefined,\n        rotation : undefined,\n        height : undefined,\n        granularity : undefined,\n        extrudedHeight : undefined,\n        numberOfVerticalLines : undefined,\n        offsetAttribute: undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {EllipseOutlineGeometry} [result] The object into which to store the result.\n     * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.\n     */\n    EllipseOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var center = Cartesian3.unpack(array, startingIndex, scratchCenter);\n        startingIndex += Cartesian3.packedLength;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var semiMajorAxis = array[startingIndex++];\n        var semiMinorAxis = array[startingIndex++];\n        var rotation = array[startingIndex++];\n        var height = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var numberOfVerticalLines = array[startingIndex++];\n        var offsetAttribute = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.height = height;\n            scratchOptions.extrudedHeight = extrudedHeight;\n            scratchOptions.granularity = granularity;\n            scratchOptions.rotation = rotation;\n            scratchOptions.semiMajorAxis = semiMajorAxis;\n            scratchOptions.semiMinorAxis = semiMinorAxis;\n            scratchOptions.numberOfVerticalLines = numberOfVerticalLines;\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n            return new EllipseOutlineGeometry(scratchOptions);\n        }\n\n        result._center = Cartesian3.clone(center, result._center);\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._semiMajorAxis = semiMajorAxis;\n        result._semiMinorAxis = semiMinorAxis;\n        result._rotation = rotation;\n        result._height = height;\n        result._granularity = granularity;\n        result._extrudedHeight = extrudedHeight;\n        result._numberOfVerticalLines = numberOfVerticalLines;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    EllipseOutlineGeometry.createGeometry = function(ellipseGeometry) {\n        if ((ellipseGeometry._semiMajorAxis <= 0.0) || (ellipseGeometry._semiMinorAxis <= 0.0)) {\n            return;\n        }\n\n        var height = ellipseGeometry._height;\n        var extrudedHeight = ellipseGeometry._extrudedHeight;\n        var extrude = !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        ellipseGeometry._center = ellipseGeometry._ellipsoid.scaleToGeodeticSurface(ellipseGeometry._center, ellipseGeometry._center);\n        var options = {\n            center : ellipseGeometry._center,\n            semiMajorAxis : ellipseGeometry._semiMajorAxis,\n            semiMinorAxis : ellipseGeometry._semiMinorAxis,\n            ellipsoid : ellipseGeometry._ellipsoid,\n            rotation : ellipseGeometry._rotation,\n            height : height,\n            granularity : ellipseGeometry._granularity,\n            numberOfVerticalLines : ellipseGeometry._numberOfVerticalLines\n        };\n        var geometry;\n        if (extrude) {\n            options.extrudedHeight = extrudedHeight;\n            options.offsetAttribute = ellipseGeometry._offsetAttribute;\n            geometry = computeExtrudedEllipse(options);\n        } else {\n            geometry = computeEllipse(options);\n\n            if (defined(ellipseGeometry._offsetAttribute)) {\n                var length = geometry.attributes.position.values.length;\n                var applyOffset = new Uint8Array(length / 3);\n                var offsetValue = ellipseGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                arrayFill(applyOffset, offsetValue);\n                geometry.attributes.applyOffset = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                    componentsPerAttribute : 1,\n                    values: applyOffset\n                });\n            }\n        }\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : geometry.boundingSphere,\n            offsetAttribute : ellipseGeometry._offsetAttribute\n        });\n    };\n\n    return EllipseOutlineGeometry;\n});\n","define([\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/EllipsoidGeometry',\n        '../Core/EllipsoidOutlineGeometry',\n        '../Core/GeometryInstance',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/Matrix4',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        '../Scene/Primitive',\n        '../Scene/SceneMode',\n        './heightReferenceOnEntityPropertyChanged',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defaultValue,\n        defined,\n        defineProperties,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        EllipsoidGeometry,\n        EllipsoidOutlineGeometry,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        Matrix4,\n        ShowGeometryInstanceAttribute,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        Primitive,\n        SceneMode,\n        heightReferenceOnEntityPropertyChanged,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultOffset = Cartesian3.ZERO;\n\n    var offsetScratch = new Cartesian3();\n    var radiiScratch = new Cartesian3();\n    var scratchColor = new Color();\n    var unitSphere = new Cartesian3(1, 1, 1);\n\n    function EllipsoidGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.radii = undefined;\n        this.stackPartitions = undefined;\n        this.slicePartitions = undefined;\n        this.subdivisions = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for ellipsoids.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias EllipsoidGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function EllipsoidGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new EllipsoidGeometryOptions(entity),\n            geometryPropertyName : 'ellipsoid',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'ellipsoid']\n        });\n\n        this._onEntityPropertyChanged(entity, 'ellipsoid', entity.ellipsoid, undefined);\n    }\n\n    if (defined(Object.create)) {\n        EllipsoidGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        EllipsoidGeometryUpdater.prototype.constructor = EllipsoidGeometryUpdater;\n    }\n\n    defineProperties(EllipsoidGeometryUpdater.prototype, {\n        /**\n         * Gets the terrain offset property\n         * @type {TerrainOffsetProperty}\n         * @memberof EllipsoidGeometryUpdater.prototype\n         * @readonly\n         */\n        terrainOffsetProperty: {\n            get: function() {\n                return this._terrainOffsetProperty;\n            }\n        }\n    });\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createFillGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute,\n            color : undefined,\n            offset: undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes.color = color;\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance\n     * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance = function(time, skipModelMatrix, modelMatrixResult) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new EllipsoidOutlineGeometry(this._options),\n            modelMatrix : skipModelMatrix ? undefined : entity.computeModelMatrixForHeightReference(time, entity.ellipsoid.heightReference, this._options.radii.z * 0.5, this._scene.mapProjection.ellipsoid, modelMatrixResult),\n            attributes : attributes\n        });\n    };\n\n    EllipsoidGeometryUpdater.prototype._computeCenter = function(time, result) {\n        return Property.getValueOrUndefined(this._entity.position, time, result);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isHidden = function(entity, ellipsoid) {\n        return !defined(entity.position) || !defined(ellipsoid.radii) || GeometryUpdater.prototype._isHidden.call(this, entity, ellipsoid);\n    };\n\n    EllipsoidGeometryUpdater.prototype._isDynamic = function(entity, ellipsoid) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !ellipsoid.radii.isConstant || //\n               !Property.isConstant(ellipsoid.stackPartitions) || //\n               !Property.isConstant(ellipsoid.slicePartitions) || //\n               !Property.isConstant(ellipsoid.outlineWidth) || //\n               !Property.isConstant(ellipsoid.subdivisions);\n    };\n\n    EllipsoidGeometryUpdater.prototype._setStaticOptions = function(entity, ellipsoid) {\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var options = this._options;\n        options.vertexFormat = this._materialProperty instanceof ColorMaterialProperty ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.radii = ellipsoid.radii.getValue(Iso8601.MINIMUM_VALUE, options.radii);\n        options.stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, Iso8601.MINIMUM_VALUE);\n        options.slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, Iso8601.MINIMUM_VALUE);\n        options.subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n    };\n\n    EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged = heightReferenceOnEntityPropertyChanged;\n\n    EllipsoidGeometryUpdater.DynamicGeometryUpdater = DynamicEllipsoidGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicEllipsoidGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n\n        this._scene = geometryUpdater._scene;\n        this._modelMatrix = new Matrix4();\n        this._attributes = undefined;\n        this._outlineAttributes = undefined;\n        this._lastSceneMode = undefined;\n        this._lastShow = undefined;\n        this._lastOutlineShow = undefined;\n        this._lastOutlineWidth = undefined;\n        this._lastOutlineColor = undefined;\n        this._lastOffset = new Cartesian3();\n        this._material = {};\n    }\n\n    if (defined(Object.create)) {\n        DynamicEllipsoidGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicEllipsoidGeometryUpdater.prototype.constructor = DynamicEllipsoidGeometryUpdater;\n    }\n\n    DynamicEllipsoidGeometryUpdater.prototype.update = function(time) {\n        \n\n        var entity = this._entity;\n        var ellipsoid = entity.ellipsoid;\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(ellipsoid.show, time, true)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        var radii = Property.getValueOrUndefined(ellipsoid.radii, time, radiiScratch);\n        var modelMatrix = defined(radii) ? entity.computeModelMatrixForHeightReference(time, ellipsoid.heightReference, radii.z * 0.5, this._scene.mapProjection.ellipsoid, this._modelMatrix) : undefined;\n        if (!defined(modelMatrix) || !defined(radii)) {\n            if (defined(this._primitive)) {\n                this._primitive.show = false;\n            }\n\n            if (defined(this._outlinePrimitive)) {\n                this._outlinePrimitive.show = false;\n            }\n            return;\n        }\n\n        //Compute attributes and material.\n        var showFill = Property.getValueOrDefault(ellipsoid.fill, time, true);\n        var showOutline = Property.getValueOrDefault(ellipsoid.outline, time, false);\n        var outlineColor = Property.getValueOrClonedDefault(ellipsoid.outlineColor, time, Color.BLACK, scratchColor);\n        var material = MaterialProperty.getValue(time, defaultValue(ellipsoid.material, defaultMaterial), this._material);\n\n        // Check properties that could trigger a primitive rebuild.\n        var stackPartitions = Property.getValueOrUndefined(ellipsoid.stackPartitions, time);\n        var slicePartitions = Property.getValueOrUndefined(ellipsoid.slicePartitions, time);\n        var subdivisions = Property.getValueOrUndefined(ellipsoid.subdivisions, time);\n        var outlineWidth = Property.getValueOrDefault(ellipsoid.outlineWidth, time, 1.0);\n        var heightReference = Property.getValueOrDefault(ellipsoid.heightReference, time, HeightReference.NONE);\n        var offsetAttribute = heightReference !== HeightReference.NONE ? GeometryOffsetAttribute.ALL : undefined;\n\n        //In 3D we use a fast path by modifying Primitive.modelMatrix instead of regenerating the primitive every frame.\n        //Also check for height reference because this method doesn't work when the height is relative to terrain.\n        var sceneMode = this._scene.mode;\n        var in3D = sceneMode === SceneMode.SCENE3D && heightReference === HeightReference.NONE;\n\n        var options = this._options;\n\n        var shadows = this._geometryUpdater.shadowsProperty.getValue(time);\n\n        var distanceDisplayConditionProperty = this._geometryUpdater.distanceDisplayConditionProperty;\n        var distanceDisplayCondition = distanceDisplayConditionProperty.getValue(time);\n\n        var offset = Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty, time, defaultOffset, offsetScratch);\n\n        //We only rebuild the primitive if something other than the radii has changed\n        //For the radii, we use unit sphere and then deform it with a scale matrix.\n        var rebuildPrimitives = !in3D || this._lastSceneMode !== sceneMode || !defined(this._primitive) || //\n                                options.stackPartitions !== stackPartitions || options.slicePartitions !== slicePartitions || //\n                                options.subdivisions !== subdivisions || this._lastOutlineWidth !== outlineWidth || options.offsetAttribute !== offsetAttribute;\n\n        if (rebuildPrimitives) {\n            var primitives = this._primitives;\n            primitives.removeAndDestroy(this._primitive);\n            primitives.removeAndDestroy(this._outlinePrimitive);\n            this._primitive = undefined;\n            this._outlinePrimitive = undefined;\n            this._lastSceneMode = sceneMode;\n            this._lastOutlineWidth = outlineWidth;\n\n            options.stackPartitions = stackPartitions;\n            options.slicePartitions = slicePartitions;\n            options.subdivisions = subdivisions;\n            options.offsetAttribute = offsetAttribute;\n            options.radii = in3D ? unitSphere : radii;\n\n            var appearance = new MaterialAppearance({\n                material : material,\n                translucent : material.isTranslucent(),\n                closed : true\n            });\n            options.vertexFormat = appearance.vertexFormat;\n\n            var fillInstance = this._geometryUpdater.createFillGeometryInstance(time, in3D, this._modelMatrix);\n\n            this._primitive = primitives.add(new Primitive({\n                geometryInstances : fillInstance,\n                appearance : appearance,\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            var outlineInstance = this._geometryUpdater.createOutlineGeometryInstance(time, in3D, this._modelMatrix);\n            this._outlinePrimitive = primitives.add(new Primitive({\n                geometryInstances : outlineInstance,\n                appearance : new PerInstanceColorAppearance({\n                    flat : true,\n                    translucent : outlineInstance.attributes.color.value[3] !== 255,\n                    renderState : {\n                        lineWidth : this._geometryUpdater._scene.clampLineWidth(outlineWidth)\n                    }\n                }),\n                asynchronous : false,\n                shadows : shadows\n            }));\n\n            this._lastShow = showFill;\n            this._lastOutlineShow = showOutline;\n            this._lastOutlineColor = Color.clone(outlineColor, this._lastOutlineColor);\n            this._lastDistanceDisplayCondition = distanceDisplayCondition;\n            this._lastOffset = Cartesian3.clone(offset, this._lastOffset);\n        } else if (this._primitive.ready) {\n            //Update attributes only.\n            var primitive = this._primitive;\n            var outlinePrimitive = this._outlinePrimitive;\n\n            primitive.show = true;\n            outlinePrimitive.show = true;\n            primitive.appearance.material = material;\n\n            var attributes = this._attributes;\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(entity);\n                this._attributes = attributes;\n            }\n            if (showFill !== this._lastShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(showFill, attributes.show);\n                this._lastShow = showFill;\n            }\n\n            var outlineAttributes = this._outlineAttributes;\n\n            if (!defined(outlineAttributes)) {\n                outlineAttributes = outlinePrimitive.getGeometryInstanceAttributes(entity);\n                this._outlineAttributes = outlineAttributes;\n            }\n\n            if (showOutline !== this._lastOutlineShow) {\n                outlineAttributes.show = ShowGeometryInstanceAttribute.toValue(showOutline, outlineAttributes.show);\n                this._lastOutlineShow = showOutline;\n            }\n\n            if (!Color.equals(outlineColor, this._lastOutlineColor)) {\n                outlineAttributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, outlineAttributes.color);\n                Color.clone(outlineColor, this._lastOutlineColor);\n            }\n\n            if (!DistanceDisplayCondition.equals(distanceDisplayCondition, this._lastDistanceDisplayCondition)) {\n                attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                outlineAttributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, outlineAttributes.distanceDisplayCondition);\n                DistanceDisplayCondition.clone(distanceDisplayCondition, this._lastDistanceDisplayCondition);\n            }\n\n            if (!Cartesian3.equals(offset, this._lastOffset)) {\n                attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                outlineAttributes.offset  = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                Cartesian3.clone(offset, this._lastOffset);\n            }\n        }\n\n        if (in3D) {\n            //Since we are scaling a unit sphere, we can't let any of the values go to zero.\n            //Instead we clamp them to a small value.  To the naked eye, this produces the same results\n            //that you get passing EllipsoidGeometry a radii with a zero component.\n            radii.x = Math.max(radii.x, 0.001);\n            radii.y = Math.max(radii.y, 0.001);\n            radii.z = Math.max(radii.z, 0.001);\n\n            modelMatrix = Matrix4.multiplyByScale(modelMatrix, radii, modelMatrix);\n            this._primitive.modelMatrix = modelMatrix;\n            this._outlinePrimitive.modelMatrix = modelMatrix;\n        }\n    };\n\n    return EllipsoidGeometryUpdater;\n});\n","define([\n        '../Core/Cartesian2',\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/GeometryInstance',\n        '../Core/Iso8601',\n        '../Core/Math',\n        '../Core/Matrix3',\n        '../Core/Matrix4',\n        '../Core/PlaneGeometry',\n        '../Core/PlaneOutlineGeometry',\n        '../Core/Quaternion',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './Property'\n    ], function(\n        Cartesian2,\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        GeometryInstance,\n        Iso8601,\n        CesiumMath,\n        Matrix3,\n        Matrix4,\n        PlaneGeometry,\n        PlaneOutlineGeometry,\n        Quaternion,\n        ShowGeometryInstanceAttribute,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        Property) {\n    'use strict';\n\n    var positionScratch = new Cartesian3();\n    var scratchColor = new Color();\n\n    function PlaneGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.plane = undefined;\n        this.dimensions = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for planes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PlaneGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PlaneGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PlaneGeometryOptions(entity),\n            geometryPropertyName : 'plane',\n            observedPropertyNames : ['availability', 'position', 'orientation', 'plane']\n        });\n\n        this._onEntityPropertyChanged(entity, 'plane', entity.plane, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PlaneGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PlaneGeometryUpdater.prototype.constructor = PlaneGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PlaneGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneGeometry(this._options),\n            modelMatrix : modelMatrix,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PlaneGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var planeGraphics = entity.plane;\n        var options = this._options;\n        var modelMatrix = entity.computeModelMatrix(time);\n        var plane = Property.getValueOrDefault(planeGraphics.plane, time, options.plane);\n        var dimensions = Property.getValueOrUndefined(planeGraphics.dimensions, time, options.dimensions);\n\n        options.plane = plane;\n        options.dimensions = dimensions;\n\n        modelMatrix = createPrimitiveMatrix(plane, dimensions, modelMatrix, this._scene.mapProjection.ellipsoid, modelMatrix);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PlaneOutlineGeometry(),\n            modelMatrix : modelMatrix,\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PlaneGeometryUpdater.prototype._isHidden = function(entity, plane) {\n        return !defined(plane.plane) || !defined(plane.dimensions) || !defined(entity.position) || GeometryUpdater.prototype._isHidden.call(this, entity, plane);\n    };\n\n    PlaneGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    PlaneGeometryUpdater.prototype._isDynamic = function(entity, plane) {\n        return !entity.position.isConstant || //\n               !Property.isConstant(entity.orientation) || //\n               !plane.plane.isConstant || //\n               !plane.dimensions.isConstant || //\n               !Property.isConstant(plane.outlineWidth);\n    };\n\n    PlaneGeometryUpdater.prototype._setStaticOptions = function(entity, plane) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.plane = plane.plane.getValue(Iso8601.MINIMUM_VALUE, options.plane);\n        options.dimensions = plane.dimensions.getValue(Iso8601.MINIMUM_VALUE, options.dimensions);\n    };\n\n    PlaneGeometryUpdater.DynamicGeometryUpdater = DynamicPlaneGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPlaneGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPlaneGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPlaneGeometryUpdater.prototype.constructor = DynamicPlaneGeometryUpdater;\n    }\n\n    DynamicPlaneGeometryUpdater.prototype._isHidden = function(entity, plane, time) {\n        var options = this._options;\n        var position = Property.getValueOrUndefined(entity.position, time, positionScratch);\n        return !defined(position) || !defined(options.plane) || !defined(options.dimensions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, plane, time);\n    };\n\n    DynamicPlaneGeometryUpdater.prototype._setOptions = function(entity, plane, time) {\n        var options = this._options;\n        options.plane = Property.getValueOrDefault(plane.plane, time, options.plane);\n        options.dimensions = Property.getValueOrUndefined(plane.dimensions, time, options.dimensions);\n    };\n\n    var scratchAxis = new Cartesian3();\n    var scratchAxis2 = new Cartesian3();\n    var scratchTranslation = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchScale = new Cartesian3();\n    var scratchQuaternion = new Quaternion();\n    var scratchMatrix3 = new Matrix3();\n    function createPrimitiveMatrix(plane, dimensions, transform, ellipsoid, result) {\n        var normal = plane.normal;\n        var distance = plane.distance;\n\n        var translation = Cartesian3.multiplyByScalar(normal, -distance, scratchTranslation);\n        translation = Matrix4.multiplyByPoint(transform, translation, translation);\n\n        var transformedNormal = Matrix4.multiplyByPointAsVector(transform, normal, scratchNormal);\n        Cartesian3.normalize(transformedNormal, transformedNormal);\n\n        var up = ellipsoid.geodeticSurfaceNormal(translation, scratchAxis2);\n        if (CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(up, transformedNormal)), 1.0, CesiumMath.EPSILON8)) {\n            up = Cartesian3.clone(Cartesian3.UNIT_Z, up);\n        }\n\n        var left = Cartesian3.cross(up, transformedNormal, scratchAxis);\n        up = Cartesian3.cross(transformedNormal, left, up);\n        Cartesian3.normalize(left, left);\n        Cartesian3.normalize(up, up);\n\n        var rotationMatrix = scratchMatrix3;\n        Matrix3.setColumn(rotationMatrix, 0, left, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 1, up, rotationMatrix);\n        Matrix3.setColumn(rotationMatrix, 2, transformedNormal, rotationMatrix);\n        var rotation = Quaternion.fromRotationMatrix(rotationMatrix, scratchQuaternion);\n\n        var scale = Cartesian2.clone(dimensions, scratchScale);\n        scale.z = 1.0;\n\n        return Matrix4.fromTranslationQuaternionRotationScale(translation, rotation, scale, result);\n    }\n\n    /**\n     * @private\n     */\n    PlaneGeometryUpdater.createPrimitiveMatrix = createPrimitiveMatrix;\n\n    return PlaneGeometryUpdater;\n});\n","define([\n        './BoundingSphere',\n        './Cartesian3',\n        './Check',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './PrimitiveType',\n        './VertexFormat'\n    ], function(\n        BoundingSphere,\n        Cartesian3,\n        Check,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        PrimitiveType,\n        VertexFormat) {\n    'use strict';\n\n    /**\n     * Describes geometry representing a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @example\n     * var planeGeometry = new Cesium.PlaneGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY\n     * });\n     */\n    function PlaneGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n\n        this._vertexFormat = vertexFormat;\n        this._workerName = 'createPlaneGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneGeometry.packedLength = VertexFormat.packedLength;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n\n        return array;\n    };\n\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        vertexFormat: scratchVertexFormat\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneGeometry} [result] The object into which to store the result.\n     * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.\n     */\n    PlaneGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n\n        if (!defined(result)) {\n            return new PlaneGeometry(scratchOptions);\n        }\n\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PlaneGeometry} planeGeometry A description of the plane.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneGeometry.createGeometry = function(planeGeometry) {\n        var vertexFormat = planeGeometry._vertexFormat;\n\n        var attributes = new GeometryAttributes();\n        var indices;\n        var positions;\n\n        if (vertexFormat.position) {\n            // 4 corner points.  Duplicated 3 times each for each incident edge/face.\n            positions = new Float64Array(4 * 3);\n\n            // +z face\n            positions[0]  = min.x;\n            positions[1]  = min.y;\n            positions[2]  = 0.0;\n            positions[3]  = max.x;\n            positions[4]  = min.y;\n            positions[5]  = 0.0;\n            positions[6]  = max.x;\n            positions[7]  = max.y;\n            positions[8]  = 0.0;\n            positions[9]  = min.x;\n            positions[10] = max.y;\n            positions[11] = 0.0;\n\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n\n            if (vertexFormat.normal) {\n                var normals = new Float32Array(4 * 3);\n\n                // +z face\n                normals[0]  = 0.0;\n                normals[1]  = 0.0;\n                normals[2]  = 1.0;\n                normals[3]  = 0.0;\n                normals[4]  = 0.0;\n                normals[5]  = 1.0;\n                normals[6]  = 0.0;\n                normals[7]  = 0.0;\n                normals[8]  = 1.0;\n                normals[9]  = 0.0;\n                normals[10] = 0.0;\n                normals[11] = 1.0;\n\n                attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.st) {\n                var texCoords = new Float32Array(4 * 2);\n\n                // +z face\n                texCoords[0]  = 0.0;\n                texCoords[1]  = 0.0;\n                texCoords[2]  = 1.0;\n                texCoords[3]  = 0.0;\n                texCoords[4]  = 1.0;\n                texCoords[5]  = 1.0;\n                texCoords[6]  = 0.0;\n                texCoords[7]  = 1.0;\n\n                attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : texCoords\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                var tangents = new Float32Array(4 * 3);\n\n                // +z face\n                tangents[0]  = 1.0;\n                tangents[1]  = 0.0;\n                tangents[2]  = 0.0;\n                tangents[3]  = 1.0;\n                tangents[4]  = 0.0;\n                tangents[5]  = 0.0;\n                tangents[6]  = 1.0;\n                tangents[7]  = 0.0;\n                tangents[8]  = 0.0;\n                tangents[9]  = 1.0;\n                tangents[10] = 0.0;\n                tangents[11] = 0.0;\n\n                attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                var bitangents = new Float32Array(4 * 3);\n\n                // +z face\n                bitangents[0] = 0.0;\n                bitangents[1] = 1.0;\n                bitangents[2] = 0.0;\n                bitangents[3] = 0.0;\n                bitangents[4] = 1.0;\n                bitangents[5] = 0.0;\n                bitangents[6] = 0.0;\n                bitangents[7] = 1.0;\n                bitangents[8] = 0.0;\n                bitangents[9] = 0.0;\n                bitangents[10] = 1.0;\n                bitangents[11] = 0.0;\n\n                attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            // 2 triangles\n            indices = new Uint16Array(2 * 3);\n\n            // +z face\n            indices[0] = 0;\n            indices[1] = 1;\n            indices[2] = 2;\n            indices[3] = 0;\n            indices[4] = 2;\n            indices[5] = 3;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\n\n    return PlaneGeometry;\n});\n","define([\n        './BoundingSphere',\n        './Cartesian3',\n        './Check',\n        './ComponentDatatype',\n        './defined',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './PrimitiveType'\n    ], function(\n        BoundingSphere,\n        Cartesian3,\n        Check,\n        ComponentDatatype,\n        defined,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        PrimitiveType) {\n    'use strict';\n\n    /**\n     * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.\n     *\n     * @alias PlaneOutlineGeometry\n     * @constructor\n     *\n     */\n    function PlaneOutlineGeometry() {\n        this._workerName = 'createPlaneOutlineGeometry';\n    }\n\n    /**\n     * The number of elements used to pack the object into an array.\n     * @type {Number}\n     */\n    PlaneOutlineGeometry.packedLength = 0;\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PlaneOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PlaneOutlineGeometry.pack = function(value, array) {\n        \n\n        return array;\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PlaneOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.\n     */\n    PlaneOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        if (!defined(result)) {\n            return new PlaneOutlineGeometry();\n        }\n\n        return result;\n    };\n\n    var min = new Cartesian3(-0.5, -0.5, 0.0);\n    var max = new Cartesian3( 0.5,  0.5, 0.0);\n\n    /**\n     * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.\n     *\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PlaneOutlineGeometry.createGeometry = function() {\n        var attributes = new GeometryAttributes();\n        var indices = new Uint16Array(4 * 2);\n        var positions = new Float64Array(4 * 3);\n\n        positions[0] = min.x;\n        positions[1] = min.y;\n        positions[2] = min.z;\n        positions[3] = max.x;\n        positions[4] = min.y;\n        positions[5] = min.z;\n        positions[6] = max.x;\n        positions[7] = max.y;\n        positions[8] = min.z;\n        positions[9] = min.x;\n        positions[10] = max.y;\n        positions[11] = min.z;\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        indices[0] = 0;\n        indices[1] = 1;\n        indices[2] = 1;\n        indices[3] = 2;\n        indices[4] = 2;\n        indices[5] = 3;\n        indices[6] = 3;\n        indices[7] = 0;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere(Cartesian3.ZERO, Math.sqrt(2.0))\n        });\n    };\n\n    return PlaneOutlineGeometry;\n});\n","define([\n        '../Core/ApproximateTerrainHeights',\n        '../Core/ArcType',\n        '../Core/Cartesian2',\n        '../Core/Cartesian3',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/CoplanarPolygonGeometry',\n        '../Core/CoplanarPolygonOutlineGeometry',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/EllipsoidTangentPlane',\n        '../Core/GeometryInstance',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/oneTimeWarning',\n        '../Core/PolygonGeometry',\n        '../Core/PolygonOutlineGeometry',\n        '../Core/Rectangle',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './GroundGeometryUpdater',\n        './Property'\n    ], function(\n        ApproximateTerrainHeights,\n        ArcType,\n        Cartesian2,\n        Cartesian3,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        CoplanarPolygonGeometry,\n        CoplanarPolygonOutlineGeometry,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        EllipsoidTangentPlane,\n        GeometryInstance,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        oneTimeWarning,\n        PolygonGeometry,\n        PolygonOutlineGeometry,\n        Rectangle,\n        ShowGeometryInstanceAttribute,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        GroundGeometryUpdater,\n        Property) {\n    'use strict';\n\n    var heightAndPerPositionHeightWarning = 'Entity polygons cannot have both height and perPositionHeight.  height will be ignored';\n    var heightReferenceAndPerPositionHeightWarning = 'heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratch2DPositions = [];\n    var cart2Scratch = new Cartesian2();\n\n    function PolygonGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polygonHierarchy = undefined;\n        this.perPositionHeight = undefined;\n        this.closeTop = undefined;\n        this.closeBottom = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.offsetAttribute = undefined;\n        this.arcType = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polygons.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolygonGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolygonGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolygonGeometryOptions(entity),\n            geometryPropertyName : 'polygon',\n            observedPropertyNames : ['availability', 'polygon']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polygon', entity.polygon, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolygonGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        PolygonGeometryUpdater.prototype.constructor = PolygonGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolygonGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonGeometry(options);\n        } else {\n            geometry = new PolygonGeometry(options);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolygonGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var options = this._options;\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        var geometry;\n        if (options.perPositionHeight && !defined(options.extrudedHeight)) {\n            geometry = new CoplanarPolygonOutlineGeometry(options);\n        } else {\n            geometry = new PolygonOutlineGeometry(options);\n        }\n        return new GeometryInstance({\n            id : entity,\n            geometry : geometry,\n            attributes : attributes\n        });\n    };\n\n    PolygonGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var hierarchy = Property.getValueOrUndefined(this._entity.polygon.hierarchy, time);\n        if (!defined(hierarchy)) {\n            return;\n        }\n        var positions = hierarchy.positions;\n        if (positions.length === 0) {\n            return;\n        }\n        var ellipsoid = this._scene.mapProjection.ellipsoid;\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, scratch2DPositions);\n\n        var length = positions2D.length;\n        var area = 0;\n        var j = length - 1;\n        var centroid2D = new Cartesian2();\n        for (var i = 0; i < length; j = i++) {\n            var p1 = positions2D[i];\n            var p2 = positions2D[j];\n            var f = p1.x * p2.y - p2.x * p1.y;\n\n            var sum = Cartesian2.add(p1, p2, cart2Scratch);\n            sum = Cartesian2.multiplyByScalar(sum, f, sum);\n            centroid2D = Cartesian2.add(centroid2D, sum, centroid2D);\n\n            area += f;\n        }\n\n        var a = 1.0 / (area * 3.0);\n        centroid2D = Cartesian2.multiplyByScalar(centroid2D, a, centroid2D);\n        return tangentPlane.projectPointOntoEllipsoid(centroid2D, result);\n    };\n\n    PolygonGeometryUpdater.prototype._isHidden = function(entity, polygon) {\n        return !defined(polygon.hierarchy) || GeometryUpdater.prototype._isHidden.call(this, entity, polygon);\n    };\n\n    PolygonGeometryUpdater.prototype._isOnTerrain = function(entity, polygon) {\n        var onTerrain = GroundGeometryUpdater.prototype._isOnTerrain.call(this, entity, polygon);\n        var perPositionHeightProperty = polygon.perPositionHeight;\n        var perPositionHeightEnabled = defined(perPositionHeightProperty) && (perPositionHeightProperty.isConstant ? perPositionHeightProperty.getValue(Iso8601.MINIMUM_VALUE) : true);\n        return onTerrain && !perPositionHeightEnabled;\n    };\n\n    PolygonGeometryUpdater.prototype._isDynamic = function(entity, polygon) {\n        return !polygon.hierarchy.isConstant || //\n               !Property.isConstant(polygon.height) || //\n               !Property.isConstant(polygon.extrudedHeight) || //\n               !Property.isConstant(polygon.granularity) || //\n               !Property.isConstant(polygon.stRotation) || //\n               !Property.isConstant(polygon.outlineWidth) || //\n               !Property.isConstant(polygon.perPositionHeight) || //\n               !Property.isConstant(polygon.closeTop) || //\n               !Property.isConstant(polygon.closeBottom) || //\n               !Property.isConstant(polygon.zIndex) || //\n               !Property.isConstant(polygon.arcType) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    PolygonGeometryUpdater.prototype._setStaticOptions = function(entity, polygon) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n\n        var hierarchyValue = polygon.hierarchy.getValue(Iso8601.MINIMUM_VALUE);\n        var heightValue = Property.getValueOrUndefined(polygon.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var perPositionHeightValue = Property.getValueOrDefault(polygon.perPositionHeight, Iso8601.MINIMUM_VALUE, false);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.polygonHierarchy = hierarchyValue;\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, Iso8601.MINIMUM_VALUE);\n        options.perPositionHeight = perPositionHeightValue;\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, Iso8601.MINIMUM_VALUE, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, Iso8601.MINIMUM_VALUE, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, Iso8601.MINIMUM_VALUE, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    PolygonGeometryUpdater.prototype._getIsClosed = function(options) {\n        var height = options.height;\n        var extrudedHeight = options.extrudedHeight;\n        var isExtruded = defined(extrudedHeight) && extrudedHeight !== height;\n        return !options.perPositionHeight && (!isExtruded && height === 0 || (isExtruded && options.closeTop && options.closeBottom));\n    };\n\n    PolygonGeometryUpdater.DynamicGeometryUpdater = DyanmicPolygonGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DyanmicPolygonGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DyanmicPolygonGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DyanmicPolygonGeometryUpdater.prototype.constructor = DyanmicPolygonGeometryUpdater;\n    }\n\n    DyanmicPolygonGeometryUpdater.prototype._isHidden = function(entity, polygon, time) {\n        return !defined(this._options.polygonHierarchy) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polygon, time);\n    };\n\n    DyanmicPolygonGeometryUpdater.prototype._setOptions = function(entity, polygon, time) {\n        var options = this._options;\n\n        options.polygonHierarchy = Property.getValueOrUndefined(polygon.hierarchy, time);\n\n        var heightValue = Property.getValueOrUndefined(polygon.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(polygon.heightReference, time, HeightReference.NONE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(polygon.extrudedHeightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(polygon.extrudedHeight, time);\n        var perPositionHeightValue = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n\n        heightValue = GroundGeometryUpdater.getGeometryHeight(heightValue, extrudedHeightReferenceValue);\n\n        var offsetAttribute;\n        if (perPositionHeightValue) {\n            if (defined(heightValue)) {\n                heightValue = undefined;\n                oneTimeWarning(heightAndPerPositionHeightWarning);\n            }\n            if (heightReferenceValue !== HeightReference.NONE && perPositionHeightValue) {\n                heightValue = undefined;\n                oneTimeWarning(heightReferenceAndPerPositionHeightWarning);\n            }\n        } else {\n            if (defined(extrudedHeightValue) && !defined(heightValue)) {\n                heightValue = 0;\n            }\n\n            offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        }\n\n        options.granularity = Property.getValueOrUndefined(polygon.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(polygon.stRotation, time);\n        options.perPositionHeight = Property.getValueOrUndefined(polygon.perPositionHeight, time);\n        options.closeTop = Property.getValueOrDefault(polygon.closeTop, time, true);\n        options.closeBottom = Property.getValueOrDefault(polygon.closeBottom, time, true);\n        options.offsetAttribute = offsetAttribute;\n        options.height = heightValue;\n        options.arcType = Property.getValueOrDefault(polygon.arcType, time, ArcType.GEODESIC);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(PolygonGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    return PolygonGeometryUpdater;\n});\n","/*global define*/\ndefine([\n        './arrayRemoveDuplicates',\n        './BoundingRectangle',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './Check',\n        './ComponentDatatype',\n        './CoplanarPolygonGeometryLibrary',\n        './defaultValue',\n        './defined',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryInstance',\n        './GeometryPipeline',\n        './IndexDatatype',\n        './Math',\n        './Matrix3',\n        './PolygonGeometryLibrary',\n        './PolygonPipeline',\n        './PrimitiveType',\n        './Quaternion',\n        './VertexFormat'\n    ], function(\n        arrayRemoveDuplicates,\n        BoundingRectangle,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        Check,\n        ComponentDatatype,\n        CoplanarPolygonGeometryLibrary,\n        defaultValue,\n        defined,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryInstance,\n        GeometryPipeline,\n        IndexDatatype,\n        CesiumMath,\n        Matrix3,\n        PolygonGeometryLibrary,\n        PolygonPipeline,\n        PrimitiveType,\n        Quaternion,\n        VertexFormat) {\n    'use strict';\n\n    var scratchPosition = new Cartesian3();\n    var scratchBR = new BoundingRectangle();\n    var stScratch = new Cartesian2();\n    var textureCoordinatesOrigin = new Cartesian2();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var centerScratch = new Cartesian3();\n    var axis1Scratch = new Cartesian3();\n    var axis2Scratch = new Cartesian3();\n    var quaternionScratch = new Quaternion();\n    var textureMatrixScratch = new Matrix3();\n    var tangentRotationScratch = new Matrix3();\n    var surfaceNormalScratch = new Cartesian3();\n\n    function createGeometryFromPolygon(polygon, vertexFormat, boundingRectangle, stRotation, projectPointTo2D, normal, tangent, bitangent) {\n        var positions = polygon.positions;\n        var indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n        /* If polygon is completely unrenderable, just use the first three vertices */\n        if (indices.length < 3) {\n            indices = [0, 1, 2];\n        }\n\n        var newIndices = IndexDatatype.createTypedArray(positions.length, indices.length);\n        newIndices.set(indices);\n\n        var textureMatrix = textureMatrixScratch;\n        if (stRotation !== 0.0) {\n            var rotation = Quaternion.fromAxisAngle(normal, stRotation, quaternionScratch);\n            textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n            if (vertexFormat.tangent || vertexFormat.bitangent) {\n                rotation = Quaternion.fromAxisAngle(normal, -stRotation, quaternionScratch);\n                var tangentRotation = Matrix3.fromQuaternion(rotation, tangentRotationScratch);\n\n                tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotation, tangent, tangent), tangent);\n                if (vertexFormat.bitangent) {\n                    bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                }\n            }\n        } else {\n            textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n        }\n\n        var stOrigin = textureCoordinatesOrigin;\n        if (vertexFormat.st) {\n            stOrigin.x = boundingRectangle.x;\n            stOrigin.y = boundingRectangle.y;\n        }\n\n        var length = positions.length;\n        var size = length * 3;\n        var flatPositions = new Float64Array(size);\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(length * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            if (vertexFormat.st) {\n                var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                var st = projectPointTo2D(p, stScratch);\n                Cartesian2.subtract(st, stOrigin, st);\n\n                var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                textureCoordinates[stIndex++] = stx;\n                textureCoordinates[stIndex++] = sty;\n            }\n\n            if (vertexFormat.normal) {\n                normals[normalIndex++] = normal.x;\n                normals[normalIndex++] = normal.y;\n                normals[normalIndex++] = normal.z;\n            }\n\n            if (vertexFormat.tangent) {\n                tangents[tangentIndex++] = tangent.x;\n                tangents[tangentIndex++] = tangent.y;\n                tangents[tangentIndex++] = tangent.z;\n            }\n\n            if (vertexFormat.bitangent) {\n                bitangents[bitangentIndex++] = bitangent.x;\n                bitangents[bitangentIndex++] = bitangent.y;\n                bitangents[bitangentIndex++] = bitangent.z;\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : newIndices,\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n    }\n\n    /**\n     * A description of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @example\n     * var polygon = new Cesium.CoplanarPolygonGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);\n     *\n     * @see CoplanarPolygonGeometry.createGeometry\n     */\n    function CoplanarPolygonGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._polygonHierarchy = polygonHierarchy;\n        this._stRotation = defaultValue(options.stRotation, 0.0);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createCoplanarPolygonGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + VertexFormat.packedLength + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * A description of a coplanar polygon from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @returns {CoplanarPolygonGeometry}\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    CoplanarPolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid\n        };\n        return new CoplanarPolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.\n     */\n    CoplanarPolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var stRotation = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._stRotation = stRotation;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var stRotation = polygonGeometry._stRotation;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var axis1 = axis1Scratch;\n        var axis2 = axis2Scratch;\n\n        var validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(outerPositions, centerScratch, axis1, axis2);\n        if (!validGeometry) {\n            return undefined;\n        }\n\n        normal = Cartesian3.cross(axis1, axis2, normal);\n        normal = Cartesian3.normalize(normal, normal);\n\n        if (!Cartesian3.equalsEpsilon(centerScratch, Cartesian3.ZERO, CesiumMath.EPSILON6)) {\n            var surfaceNormal = polygonGeometry._ellipsoid.geodeticSurfaceNormal(centerScratch, surfaceNormalScratch);\n            if (Cartesian3.dot(normal, surfaceNormal) < 0) {\n                normal = Cartesian3.negate(normal, normal);\n                axis1 = Cartesian3.negate(axis1, axis1);\n            }\n        }\n\n        var projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch, axis1, axis2);\n        var projectPoint = CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch, axis1, axis2);\n\n        if (vertexFormat.tangent) {\n            tangent = Cartesian3.clone(axis1, tangent);\n        }\n        if (vertexFormat.bitangent) {\n            bitangent = Cartesian3.clone(axis2, bitangent);\n        }\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, projectPoints, false);\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n        outerPositions = hierarchy[0].outerRing;\n\n        var boundingSphere = BoundingSphere.fromPoints(outerPositions);\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(normal, projectPoint, outerPositions, stRotation, scratchBR);\n\n        var geometries = [];\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPolygon(polygons[i], vertexFormat, boundingRectangle, stRotation, projectPoint, normal, tangent, bitangent)\n            });\n\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\n\n    return CoplanarPolygonGeometry;\n});\n","/*global define*/\ndefine([\n    './arrayRemoveDuplicates',\n    './BoundingSphere',\n    './Cartesian3',\n    './Check',\n    './ComponentDatatype',\n    './CoplanarPolygonGeometryLibrary',\n    './defaultValue',\n    './defined',\n    './Geometry',\n    './GeometryAttribute',\n    './GeometryAttributes',\n    './GeometryInstance',\n    './GeometryPipeline',\n    './IndexDatatype',\n    './PolygonGeometryLibrary',\n    './PolygonPipeline',\n    './PrimitiveType'\n], function(\n    arrayRemoveDuplicates,\n    BoundingSphere,\n    Cartesian3,\n    Check,\n    ComponentDatatype,\n    CoplanarPolygonGeometryLibrary,\n    defaultValue,\n    defined,\n    Geometry,\n    GeometryAttribute,\n    GeometryAttributes,\n    GeometryInstance,\n    GeometryPipeline,\n    IndexDatatype,\n    PolygonGeometryLibrary,\n    PolygonPipeline,\n    PrimitiveType) {\n    'use strict';\n\n    function createGeometryFromPositions(positions){\n        var length = positions.length;\n        var flatPositions = new Float64Array(length * 3);\n        var indices = IndexDatatype.createTypedArray(length, length * 2);\n\n        var positionIndex = 0;\n        var index = 0;\n\n        for (var i = 0; i < length; i++) {\n            var position = positions[i];\n            flatPositions[positionIndex++] = position.x;\n            flatPositions[positionIndex++] = position.y;\n            flatPositions[positionIndex++] = position.z;\n\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n        }\n\n        var attributes = new GeometryAttributes({\n            position: new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : flatPositions\n            })\n        });\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon composed of arbitrary coplanar positions.\n     *\n     * @alias CoplanarPolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     *\n     * @see CoplanarPolygonOutlineGeometry.createGeometry\n     *\n     * @example\n     * var polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *      -90.0, 30.0, 0.0,\n     *      -90.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 1000.0,\n     *      -80.0, 30.0, 0.0\n     *   ])\n     * });\n     * var geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);\n     */\n    function CoplanarPolygonOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var polygonHierarchy = options.polygonHierarchy;\n        \n\n        this._polygonHierarchy = polygonHierarchy;\n        this._workerName = 'createCoplanarPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + 1;\n    }\n\n    /**\n     * A description of a coplanar polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @returns {CoplanarPolygonOutlineGeometry}\n     */\n    CoplanarPolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            }\n        };\n        return new CoplanarPolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    CoplanarPolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchOptions = {\n        polygonHierarchy : {}\n    };\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.\n     */\n    CoplanarPolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new CoplanarPolygonOutlineGeometry(scratchOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    CoplanarPolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n\n        var outerPositions = polygonHierarchy.positions;\n        outerPositions = arrayRemoveDuplicates(outerPositions, Cartesian3.equalsEpsilon, true);\n        if (outerPositions.length < 3) {\n            return;\n        }\n        var isValid = CoplanarPolygonGeometryLibrary.validOutline(outerPositions);\n        if (!isValid) {\n            return undefined;\n        }\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, false);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometries = [];\n\n        for (var i = 0; i < polygons.length; i++) {\n            var geometryInstance = new GeometryInstance({\n                geometry : createGeometryFromPositions(polygons[i])\n            });\n            geometries.push(geometryInstance);\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromPoints(polygonHierarchy.positions);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere\n        });\n    };\n\n    return CoplanarPolygonOutlineGeometry;\n});\n","define([\n        './ArcType',\n        './arrayFill',\n        './BoundingRectangle',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './Cartographic',\n        './Check',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './defineProperties',\n        './DeveloperError',\n        './Ellipsoid',\n        './EllipsoidGeodesic',\n        './EllipsoidRhumbLine',\n        './EllipsoidTangentPlane',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryInstance',\n        './GeometryOffsetAttribute',\n        './GeometryPipeline',\n        './IndexDatatype',\n        './Math',\n        './Matrix2',\n        './Matrix3',\n        './PolygonGeometryLibrary',\n        './PolygonPipeline',\n        './Quaternion',\n        './Rectangle',\n        './VertexFormat',\n        './WindingOrder'\n    ], function(\n        ArcType,\n        arrayFill,\n        BoundingRectangle,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        Cartographic,\n        Check,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        defineProperties,\n        DeveloperError,\n        Ellipsoid,\n        EllipsoidGeodesic,\n        EllipsoidRhumbLine,\n        EllipsoidTangentPlane,\n        Geometry,\n        GeometryAttribute,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        GeometryPipeline,\n        IndexDatatype,\n        CesiumMath,\n        Matrix2,\n        Matrix3,\n        PolygonGeometryLibrary,\n        PolygonPipeline,\n        Quaternion,\n        Rectangle,\n        VertexFormat,\n        WindingOrder) {\n    'use strict';\n\n    var scratchCarto1 = new Cartographic();\n    var scratchCarto2 = new Cartographic();\n    function adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\n        var carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\n        var height = carto1.height;\n        var p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\n        p1Carto.height = height;\n        ellipsoid.cartographicToCartesian(p1Carto, p1);\n\n        var p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\n        p2Carto.height = height - 100;\n        ellipsoid.cartographicToCartesian(p2Carto, p2);\n    }\n\n    var scratchBoundingRectangle = new BoundingRectangle();\n    var scratchPosition = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var p1Scratch = new Cartesian3();\n    var p2Scratch = new Cartesian3();\n    var scratchPerPosNormal = new Cartesian3();\n    var scratchPerPosTangent = new Cartesian3();\n    var scratchPerPosBitangent = new Cartesian3();\n\n    var appendTextureCoordinatesOrigin = new Cartesian2();\n    var appendTextureCoordinatesCartesian2 = new Cartesian2();\n    var appendTextureCoordinatesCartesian3 = new Cartesian3();\n    var appendTextureCoordinatesQuaternion = new Quaternion();\n    var appendTextureCoordinatesMatrix3 = new Matrix3();\n    var tangentMatrixScratch = new Matrix3();\n\n    function computeAttributes(options) {\n        var vertexFormat = options.vertexFormat;\n        var geometry = options.geometry;\n        var shadowVolume = options.shadowVolume;\n        var flatPositions = geometry.attributes.position.values;\n        var length = flatPositions.length;\n        var wall = options.wall;\n        var top = options.top || wall;\n        var bottom = options.bottom || wall;\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n            // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\n            // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\n            var boundingRectangle = options.boundingRectangle;\n            var tangentPlane = options.tangentPlane;\n            var ellipsoid = options.ellipsoid;\n            var stRotation = options.stRotation;\n            var perPositionHeight = options.perPositionHeight;\n\n            var origin = appendTextureCoordinatesOrigin;\n            origin.x = boundingRectangle.x;\n            origin.y = boundingRectangle.y;\n\n            var textureCoordinates = vertexFormat.st ? new Float32Array(2 * (length / 3)) : undefined;\n            var normals;\n            if (vertexFormat.normal) {\n                if (perPositionHeight && top && !wall) {\n                    normals = geometry.attributes.normal.values;\n                } else {\n                    normals = new Float32Array(length);\n                }\n            }\n            var tangents = vertexFormat.tangent ? new Float32Array(length) : undefined;\n            var bitangents = vertexFormat.bitangent ? new Float32Array(length) : undefined;\n            var extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\n\n            var textureCoordIndex = 0;\n            var attrIndex = 0;\n\n            var normal = scratchNormal;\n            var tangent = scratchTangent;\n            var bitangent = scratchBitangent;\n            var recomputeNormal = true;\n\n            var textureMatrix = appendTextureCoordinatesMatrix3;\n            var tangentRotationMatrix = tangentMatrixScratch;\n            if (stRotation !== 0.0) {\n                var rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, stRotation, appendTextureCoordinatesQuaternion);\n                textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\n\n                rotation = Quaternion.fromAxisAngle(tangentPlane._plane.normal, -stRotation, appendTextureCoordinatesQuaternion);\n                tangentRotationMatrix = Matrix3.fromQuaternion(rotation, tangentRotationMatrix);\n            } else {\n                textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\n                tangentRotationMatrix = Matrix3.clone(Matrix3.IDENTITY, tangentRotationMatrix);\n            }\n\n            var bottomOffset = 0;\n            var bottomOffset2 = 0;\n\n            if (top && bottom) {\n                bottomOffset = length / 2;\n                bottomOffset2 = length / 3;\n\n                length /= 2;\n            }\n\n            for ( var i = 0; i < length; i += 3) {\n                var position = Cartesian3.fromArray(flatPositions, i, appendTextureCoordinatesCartesian3);\n\n                if (vertexFormat.st) {\n                    var p = Matrix3.multiplyByVector(textureMatrix, position, scratchPosition);\n                    p = ellipsoid.scaleToGeodeticSurface(p,p);\n                    var st = tangentPlane.projectPointOntoPlane(p, appendTextureCoordinatesCartesian2);\n                    Cartesian2.subtract(st, origin, st);\n\n                    var stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\n                    var sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\n                    if (bottom) {\n                        textureCoordinates[textureCoordIndex + bottomOffset2] = stx;\n                        textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = sty;\n                    }\n                    if (top) {\n                        textureCoordinates[textureCoordIndex] = stx;\n                        textureCoordinates[textureCoordIndex + 1] = sty;\n                    }\n\n                    textureCoordIndex += 2;\n                }\n\n                if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent || shadowVolume) {\n                    var attrIndex1 = attrIndex + 1;\n                    var attrIndex2 = attrIndex + 2;\n\n                    if (wall) {\n                        if (i + 3 < length) {\n                            var p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\n\n                            if (recomputeNormal) {\n                                var p2 = Cartesian3.fromArray(flatPositions, i + length, p2Scratch);\n                                if (perPositionHeight) {\n                                    adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\n                                }\n                                Cartesian3.subtract(p1, position, p1);\n                                Cartesian3.subtract(p2, position, p2);\n                                normal = Cartesian3.normalize(Cartesian3.cross(p2, p1, normal), normal);\n                                recomputeNormal = false;\n                            }\n\n                            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) { // if we've reached a corner\n                                recomputeNormal = true;\n                            }\n                        }\n\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\n                            if (vertexFormat.tangent) {\n                                tangent = Cartesian3.normalize(Cartesian3.cross(bitangent, normal, tangent), tangent);\n                            }\n                        }\n                    } else {\n                        normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        if (vertexFormat.tangent || vertexFormat.bitangent) {\n                            if (perPositionHeight) {\n                                scratchPerPosNormal = Cartesian3.fromArray(normals, attrIndex, scratchPerPosNormal);\n                                scratchPerPosTangent = Cartesian3.cross(Cartesian3.UNIT_Z, scratchPerPosNormal, scratchPerPosTangent);\n                                scratchPerPosTangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, scratchPerPosTangent, scratchPerPosTangent), scratchPerPosTangent);\n                                if (vertexFormat.bitangent) {\n                                    scratchPerPosBitangent = Cartesian3.normalize(Cartesian3.cross(scratchPerPosNormal, scratchPerPosTangent, scratchPerPosBitangent), scratchPerPosBitangent);\n                                }\n                            }\n\n                            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\n                            tangent = Cartesian3.normalize(Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent), tangent);\n                            if (vertexFormat.bitangent) {\n                                bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.normal) {\n                        if (options.wall) {\n                            normals[attrIndex + bottomOffset] = normal.x;\n                            normals[attrIndex1 + bottomOffset] = normal.y;\n                            normals[attrIndex2 + bottomOffset] = normal.z;\n                        } else if (bottom){\n                            normals[attrIndex + bottomOffset] = -normal.x;\n                            normals[attrIndex1 + bottomOffset] = -normal.y;\n                            normals[attrIndex2 + bottomOffset] = -normal.z;\n                        }\n\n                        if ((top && !perPositionHeight) || wall) {\n                            normals[attrIndex] = normal.x;\n                            normals[attrIndex1] = normal.y;\n                            normals[attrIndex2] = normal.z;\n                        }\n                    }\n\n                    if (shadowVolume) {\n                        if (wall) {\n                            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\n                        }\n                        extrudeNormals[attrIndex + bottomOffset] = -normal.x;\n                        extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\n                        extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\n                    }\n\n                    if (vertexFormat.tangent) {\n                        if (options.wall) {\n                            tangents[attrIndex + bottomOffset] = tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = tangent.z;\n                        } else if (bottom) {\n                            tangents[attrIndex + bottomOffset] = -tangent.x;\n                            tangents[attrIndex1 + bottomOffset] = -tangent.y;\n                            tangents[attrIndex2 + bottomOffset] = -tangent.z;\n                        }\n\n                        if(top) {\n                            if (perPositionHeight) {\n                                tangents[attrIndex] = scratchPerPosTangent.x;\n                                tangents[attrIndex1] = scratchPerPosTangent.y;\n                                tangents[attrIndex2] = scratchPerPosTangent.z;\n                            } else {\n                                tangents[attrIndex] = tangent.x;\n                                tangents[attrIndex1] = tangent.y;\n                                tangents[attrIndex2] = tangent.z;\n                            }\n                        }\n                    }\n\n                    if (vertexFormat.bitangent) {\n                        if (bottom) {\n                            bitangents[attrIndex + bottomOffset] = bitangent.x;\n                            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\n                            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\n                        }\n                        if (top) {\n                            if (perPositionHeight) {\n                                bitangents[attrIndex] = scratchPerPosBitangent.x;\n                                bitangents[attrIndex1] = scratchPerPosBitangent.y;\n                                bitangents[attrIndex2] = scratchPerPosBitangent.z;\n                            } else {\n                                bitangents[attrIndex] = bitangent.x;\n                                bitangents[attrIndex1] = bitangent.y;\n                                bitangents[attrIndex2] = bitangent.z;\n                            }\n                        }\n                    }\n                    attrIndex += 3;\n                }\n            }\n\n            if (vertexFormat.st) {\n                geometry.attributes.st = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 2,\n                    values : textureCoordinates\n                });\n            }\n\n            if (vertexFormat.normal) {\n                geometry.attributes.normal = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : normals\n                });\n            }\n\n            if (vertexFormat.tangent) {\n                geometry.attributes.tangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : tangents\n                });\n            }\n\n            if (vertexFormat.bitangent) {\n                geometry.attributes.bitangent = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : bitangents\n                });\n            }\n\n            if (shadowVolume) {\n                geometry.attributes.extrudeDirection = new GeometryAttribute({\n                    componentDatatype : ComponentDatatype.FLOAT,\n                    componentsPerAttribute : 3,\n                    values : extrudeNormals\n                });\n            }\n        }\n\n        if (options.extrude && defined(options.offsetAttribute)) {\n            var size = flatPositions.length / 3;\n            var offsetAttribute = new Uint8Array(size);\n\n            if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\n                if ((top && bottom) || wall) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                } else if (top) {\n                    offsetAttribute = arrayFill(offsetAttribute, 1);\n                }\n            } else {\n                var offsetValue = options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n            }\n\n            geometry.attributes.applyOffset = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 1,\n                values : offsetAttribute\n            });\n        }\n\n        return geometry;\n    }\n\n    var startCartographicScratch = new Cartographic();\n    var endCartographicScratch = new Cartographic();\n    var idlCross = {\n        westOverIDL : 0.0,\n        eastOverIDL : 0.0\n    };\n    var ellipsoidGeodesic = new EllipsoidGeodesic();\n    function computeRectangle(positions, ellipsoid, arcType, granularity, result) {\n        result = defaultValue(result, new Rectangle());\n        if (!defined(positions) || positions.length < 3) {\n            result.west = 0.0;\n            result.north = 0.0;\n            result.south = 0.0;\n            result.east = 0.0;\n            return result;\n        }\n\n        if (arcType === ArcType.RHUMB) {\n            return Rectangle.fromCartesianArray(positions, ellipsoid, result);\n        }\n\n        if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\n            ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\n        }\n\n        result.west = Number.POSITIVE_INFINITY;\n        result.east = Number.NEGATIVE_INFINITY;\n        result.south = Number.POSITIVE_INFINITY;\n        result.north = Number.NEGATIVE_INFINITY;\n\n        idlCross.westOverIDL = Number.POSITIVE_INFINITY;\n        idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\n\n        var inverseChordLength = 1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n        var positionsLength = positions.length;\n        var endCartographic = ellipsoid.cartesianToCartographic(positions[0], endCartographicScratch);\n        var startCartographic = startCartographicScratch;\n        var swap;\n\n        for (var i = 1; i < positionsLength; i++) {\n            swap = startCartographic;\n            startCartographic = endCartographic;\n            endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\n            ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n            interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n        }\n\n        swap = startCartographic;\n        startCartographic = endCartographic;\n        endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\n        ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\n        interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross);\n\n        if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\n            result.west = idlCross.westOverIDL;\n            result.east = idlCross.eastOverIDL;\n\n            if (result.east > CesiumMath.PI) {\n                result.east = result.east - CesiumMath.TWO_PI;\n            }\n            if (result.west > CesiumMath.PI) {\n                result.west = result.west - CesiumMath.TWO_PI;\n            }\n        }\n\n        return result;\n    }\n\n    var interpolatedCartographicScratch = new Cartographic();\n    function interpolateAndGrowRectangle(ellipsoidGeodesic, inverseChordLength, result, idlCross) {\n        var segmentLength = ellipsoidGeodesic.surfaceDistance;\n\n        var numPoints = Math.ceil(segmentLength * inverseChordLength);\n        var subsegmentDistance = numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\n        var interpolationDistance = 0.0;\n\n        for (var i = 0; i < numPoints; i++) {\n            var interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(interpolationDistance, interpolatedCartographicScratch);\n            interpolationDistance += subsegmentDistance;\n            var longitude = interpolatedCartographic.longitude;\n            var latitude = interpolatedCartographic.latitude;\n\n            result.west = Math.min(result.west, longitude);\n            result.east = Math.max(result.east, longitude);\n            result.south = Math.min(result.south, latitude);\n            result.north = Math.max(result.north, latitude);\n\n            var lonAdjusted = longitude >= 0 ?  longitude : longitude +  CesiumMath.TWO_PI;\n            idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\n            idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\n        }\n    }\n\n    var createGeometryFromPositionsExtrudedPositions = [];\n\n    function createGeometryFromPositionsExtruded(ellipsoid, polygon, granularity, hierarchy, perPositionHeight, closeTop, closeBottom, vertexFormat, arcType) {\n        var geos = {\n            walls : []\n        };\n        var i;\n\n        if (closeTop || closeBottom) {\n            var topGeo = PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygon, granularity, perPositionHeight, vertexFormat, arcType);\n\n            var edgePoints = topGeo.attributes.position.values;\n            var indices = topGeo.indices;\n            var numPositions;\n            var newIndices;\n\n            if (closeTop && closeBottom) {\n                var topBottomPositions = edgePoints.concat(edgePoints);\n\n                numPositions = topBottomPositions.length / 3;\n\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length * 2);\n                newIndices.set(indices);\n                var ilength = indices.length;\n\n                var length = numPositions / 2;\n\n                for (i = 0; i < ilength; i += 3) {\n                    var i0 = newIndices[i] + length;\n                    var i1 = newIndices[i + 1] + length;\n                    var i2 = newIndices[i + 2] + length;\n\n                    newIndices[i + ilength] = i2;\n                    newIndices[i + 1 + ilength] = i1;\n                    newIndices[i + 2 + ilength] = i0;\n                }\n\n                topGeo.attributes.position.values = topBottomPositions;\n                if (perPositionHeight && vertexFormat.normal) {\n                    var normals = topGeo.attributes.normal.values;\n                    topGeo.attributes.normal.values = new Float32Array(topBottomPositions.length);\n                    topGeo.attributes.normal.values.set(normals);\n                }\n                topGeo.indices = newIndices;\n            } else if (closeBottom) {\n                numPositions = edgePoints.length / 3;\n                newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\n\n                for (i = 0; i < indices.length; i += 3) {\n                    newIndices[i] = indices[i + 2];\n                    newIndices[i + 1] = indices[i + 1];\n                    newIndices[i + 2] = indices[i];\n                }\n\n                topGeo.indices = newIndices;\n            }\n\n            geos.topAndBottom = new GeometryInstance({\n                geometry : topGeo\n            });\n        }\n\n        var outerRing = hierarchy.outerRing;\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(outerRing, createGeometryFromPositionsExtrudedPositions);\n\n        var windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (windingOrder === WindingOrder.CLOCKWISE) {\n            outerRing = outerRing.slice().reverse();\n        }\n\n        var wallGeo = PolygonGeometryLibrary.computeWallGeometry(outerRing, ellipsoid, granularity, perPositionHeight, arcType);\n        geos.walls.push(new GeometryInstance({\n            geometry : wallGeo\n        }));\n\n        var holes = hierarchy.holes;\n        for (i = 0; i < holes.length; i++) {\n            var hole = holes[i];\n\n            tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\n            positions2D = tangentPlane.projectPointsOntoPlane(hole, createGeometryFromPositionsExtrudedPositions);\n\n            windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n            if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\n                hole = hole.slice().reverse();\n            }\n\n            wallGeo = PolygonGeometryLibrary.computeWallGeometry(hole, ellipsoid, granularity, perPositionHeight, arcType);\n            geos.walls.push(new GeometryInstance({\n                geometry : wallGeo\n            }));\n        }\n\n        return geos;\n    }\n\n    /**\n     * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @alias PolygonGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonGeometry#createGeometry\n     * @see PolygonGeometry#fromPositions\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\n     *\n     * @example\n     * // 1. create a polygon from points\n     * var polygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes\n     * var polygonWithHole = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon\n     * var extrudedPolygon = new Cesium.PolygonGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var stRotation = defaultValue(options.stRotation, 0.0);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._stRotation = stRotation;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._closeTop = defaultValue(options.closeTop, true);\n        this._closeBottom = defaultValue(options.closeBottom, true);\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._shadowVolume = defaultValue(options.shadowVolume, false);\n        this._workerName = 'createPolygonGeometry';\n        this._offsetAttribute = options.offsetAttribute;\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        this._rectangle = undefined;\n        this._textureCoordinateRotationPoints = undefined;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + VertexFormat.packedLength + 12;\n    }\n\n    /**\n     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\n     * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);\n     *\n     * @see PolygonGeometry#createGeometry\n     */\n    PolygonGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            vertexFormat : options.vertexFormat,\n            stRotation : options.stRotation,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            closeTop : options.closeTop,\n            closeBottom : options.closeBottom,\n            offsetAttribute : options.offsetAttribute,\n            arcType : options.arcType\n        };\n        return new PolygonGeometry(newOptions);\n    };\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._stRotation;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\n        array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\n        array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex++] = value._arcType;\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n\n    //Only used to avoid inability to default construct.\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonGeometry} [result] The object into which to store the result.\n     */\n    PolygonGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var stRotation = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var closeTop = array[startingIndex++] === 1.0;\n        var closeBottom = array[startingIndex++] === 1.0;\n        var shadowVolume = array[startingIndex++] === 1.0;\n        var offsetAttribute = array[startingIndex++];\n        var arcType = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._stRotation = stRotation;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._perPositionHeight = perPositionHeight;\n        result._closeTop = closeTop;\n        result._closeBottom = closeBottom;\n        result._shadowVolume = shadowVolume;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result._arcType = arcType;\n        result.packedLength = packedLength;\n        return result;\n    };\n\n    /**\n     * Returns the bounding rectangle given the provided options\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Rectangle} [result] An object in which to store the result.\n     *\n     * @returns {Rectangle} The result rectangle\n     */\n    PolygonGeometry.computeRectangle = function(options, result) {\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        return computeRectangle(polygonHierarchy.positions, ellipsoid, arcType, granularity, result);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonGeometry} polygonGeometry A description of the polygon.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonGeometry.createGeometry = function(polygonGeometry) {\n        var vertexFormat = polygonGeometry._vertexFormat;\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var stRotation = polygonGeometry._stRotation;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var closeTop = polygonGeometry._closeTop;\n        var closeBottom = polygonGeometry._closeBottom;\n        var arcType = polygonGeometry._arcType;\n\n        var outerPositions = polygonHierarchy.positions;\n        if (outerPositions.length < 3) {\n            return;\n        }\n\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(outerPositions, ellipsoid);\n\n        var results = PolygonGeometryLibrary.polygonsFromHierarchy(polygonHierarchy, tangentPlane.projectPointsOntoPlane.bind(tangentPlane), !perPositionHeight, ellipsoid);\n        var hierarchy = results.hierarchy;\n        var polygons = results.polygons;\n\n        if (hierarchy.length === 0) {\n            return;\n        }\n\n        outerPositions = hierarchy[0].outerRing;\n        var boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(tangentPlane.plane.normal, tangentPlane.projectPointOntoPlane.bind(tangentPlane), outerPositions, stRotation, scratchBoundingRectangle);\n\n        var geometries = [];\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n\n        var options = {\n            perPositionHeight: perPositionHeight,\n            vertexFormat: vertexFormat,\n            geometry: undefined,\n            tangentPlane: tangentPlane,\n            boundingRectangle: boundingRectangle,\n            ellipsoid: ellipsoid,\n            stRotation: stRotation,\n            bottom: false,\n            top: true,\n            wall: false,\n            extrude: false,\n            arcType: arcType\n        };\n\n        var i;\n\n        if (extrude) {\n            options.extrude = true;\n            options.top = closeTop;\n            options.bottom = closeBottom;\n            options.shadowVolume = polygonGeometry._shadowVolume;\n            options.offsetAttribute = polygonGeometry._offsetAttribute;\n            for (i = 0; i < polygons.length; i++) {\n                var splitGeometry = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], granularity, hierarchy[i], perPositionHeight, closeTop, closeBottom, vertexFormat, arcType);\n\n                var topAndBottom;\n                if (closeTop && closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(topAndBottom.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                } else if (closeTop) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                    options.geometry = topAndBottom.geometry;\n                } else if (closeBottom) {\n                    topAndBottom = splitGeometry.topAndBottom;\n                    topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(topAndBottom.geometry.attributes.position.values, extrudedHeight, ellipsoid, true);\n                    options.geometry = topAndBottom.geometry;\n                }\n                if (closeTop || closeBottom) {\n                    options.wall = false;\n                    topAndBottom.geometry = computeAttributes(options);\n                    geometries.push(topAndBottom);\n                }\n\n                var walls = splitGeometry.walls;\n                options.wall = true;\n                for ( var k = 0; k < walls.length; k++) {\n                    var wall = walls[k];\n                    options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(wall.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                    wall.geometry = computeAttributes(options);\n                    geometries.push(wall);\n                }\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                var geometryInstance = new GeometryInstance({\n                    geometry : PolygonGeometryLibrary.createGeometryFromPositions(ellipsoid, polygons[i], granularity, perPositionHeight, vertexFormat, arcType)\n                });\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n                options.geometry = geometryInstance.geometry;\n                geometryInstance.geometry = computeAttributes(options);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    var offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        geometry.attributes.position.values = new Float64Array(geometry.attributes.position.values);\n        geometry.indices = IndexDatatype.createTypedArray(geometry.attributes.position.values.length / 3, geometry.indices);\n\n        var attributes = geometry.attributes;\n        var boundingSphere = BoundingSphere.fromVertices(attributes.position.values);\n\n        if (!vertexFormat.position) {\n            delete attributes.position;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\n\n    /**\n     * @private\n     */\n    PolygonGeometry.createShadowVolume = function(polygonGeometry, minHeightFunc, maxHeightFunc) {\n        var granularity = polygonGeometry._granularity;\n        var ellipsoid = polygonGeometry._ellipsoid;\n\n        var minHeight = minHeightFunc(granularity, ellipsoid);\n        var maxHeight = maxHeightFunc(granularity, ellipsoid);\n\n        return new PolygonGeometry({\n            polygonHierarchy : polygonGeometry._polygonHierarchy,\n            ellipsoid : ellipsoid,\n            stRotation : polygonGeometry._stRotation,\n            granularity : granularity,\n            perPositionHeight : false,\n            extrudedHeight : minHeight,\n            height : maxHeight,\n            vertexFormat : VertexFormat.POSITION_ONLY,\n            shadowVolume: true,\n            arcType : polygonGeometry._arcType\n        });\n    };\n\n    function textureCoordinateRotationPoints(polygonGeometry) {\n        var stRotation = -polygonGeometry._stRotation;\n        if (stRotation === 0.0) {\n            return [0, 0, 0, 1, 1, 0];\n        }\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var positions = polygonGeometry._polygonHierarchy.positions;\n        var boundingRectangle = polygonGeometry.rectangle;\n        return Geometry._textureCoordinateRotationPoints(positions, stRotation, ellipsoid, boundingRectangle);\n    }\n\n    defineProperties(PolygonGeometry.prototype, {\n        /**\n         * @private\n         */\n        rectangle : {\n            get : function() {\n                if (!defined(this._rectangle)) {\n                    var positions = this._polygonHierarchy.positions;\n                    this._rectangle = computeRectangle(positions, this._ellipsoid, this._arcType, this._granularity);\n                }\n\n                return this._rectangle;\n            }\n        },\n        /**\n         * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\n         * @private\n         */\n        textureCoordinateRotationPoints : {\n            get : function() {\n                if (!defined(this._textureCoordinateRotationPoints)) {\n                    this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(this);\n                }\n                return this._textureCoordinateRotationPoints;\n            }\n        }\n    });\n\n    return PolygonGeometry;\n});\n","define([\n        './ArcType',\n        './arrayFill',\n        './arrayRemoveDuplicates',\n        './BoundingSphere',\n        './Cartesian3',\n        './Check',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './EllipsoidTangentPlane',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryInstance',\n        './GeometryOffsetAttribute',\n        './GeometryPipeline',\n        './IndexDatatype',\n        './Math',\n        './PolygonGeometryLibrary',\n        './PolygonPipeline',\n        './PrimitiveType',\n        './Queue',\n        './WindingOrder'\n    ], function(\n        ArcType,\n        arrayFill,\n        arrayRemoveDuplicates,\n        BoundingSphere,\n        Cartesian3,\n        Check,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        EllipsoidTangentPlane,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        GeometryPipeline,\n        IndexDatatype,\n        CesiumMath,\n        PolygonGeometryLibrary,\n        PolygonPipeline,\n        PrimitiveType,\n        Queue,\n        WindingOrder) {\n    'use strict';\n    var createGeometryFromPositionsPositions = [];\n    var createGeometryFromPositionsSubdivided = [];\n\n    function createGeometryFromPositions(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n            subdividedPositions = new Float64Array(numVertices * 3);\n            for (i = 0; i < length; i++) {\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3);\n            for (i = 0; i < length; i++) {\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / 3;\n        var indicesSize = length * 2;\n        var indices = IndexDatatype.createTypedArray(length, indicesSize);\n        index = 0;\n        for (i = 0; i < length - 1; i++) {\n            indices[index++] = i;\n            indices[index++] = i + 1;\n        }\n        indices[index++] = length - 1;\n        indices[index++] = 0;\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    function createGeometryFromPositionsExtruded(ellipsoid, positions, minDistance, perPositionHeight, arcType) {\n        var tangentPlane = EllipsoidTangentPlane.fromPoints(positions, ellipsoid);\n        var positions2D = tangentPlane.projectPointsOntoPlane(positions, createGeometryFromPositionsPositions);\n\n        var originalWindingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\n        if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n            positions2D.reverse();\n            positions = positions.slice().reverse();\n        }\n\n        var subdividedPositions;\n        var i;\n\n        var length = positions.length;\n        var corners = new Array(length);\n        var index = 0;\n\n        if (!perPositionHeight) {\n            var numVertices = 0;\n            if (arcType === ArcType.GEODESIC) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideLineCount(positions[i], positions[(i + 1) % length], minDistance);\n                }\n            } else if (arcType === ArcType.RHUMB) {\n                for (i = 0; i < length; i++) {\n                    numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(ellipsoid, positions[i], positions[(i + 1) % length], minDistance);\n                }\n            }\n\n            subdividedPositions = new Float64Array(numVertices * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var tempPositions;\n                if (arcType === ArcType.GEODESIC) {\n                    tempPositions = PolygonGeometryLibrary.subdivideLine(positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                } else if (arcType === ArcType.RHUMB) {\n                    tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(ellipsoid, positions[i], positions[(i + 1) % length], minDistance, createGeometryFromPositionsSubdivided);\n                }\n                var tempPositionsLength = tempPositions.length;\n                for (var j = 0; j < tempPositionsLength; ++j) {\n                    subdividedPositions[index++] = tempPositions[j];\n                }\n            }\n        } else {\n            subdividedPositions = new Float64Array(length * 2 * 3 * 2);\n            for (i = 0; i < length; ++i) {\n                corners[i] = index / 3;\n                var p0 = positions[i];\n                var p1 = positions[(i + 1) % length];\n\n                subdividedPositions[index++] = p0.x;\n                subdividedPositions[index++] = p0.y;\n                subdividedPositions[index++] = p0.z;\n                subdividedPositions[index++] = p1.x;\n                subdividedPositions[index++] = p1.y;\n                subdividedPositions[index++] = p1.z;\n            }\n        }\n\n        length = subdividedPositions.length / (3 * 2);\n        var cornersLength = corners.length;\n\n        var indicesSize = ((length * 2) + cornersLength) * 2;\n        var indices = IndexDatatype.createTypedArray(length + cornersLength, indicesSize);\n\n        index = 0;\n        for (i = 0; i < length; ++i) {\n            indices[index++] = i;\n            indices[index++] = (i + 1) % length;\n            indices[index++] = i + length;\n            indices[index++] = ((i + 1) % length) + length;\n        }\n\n        for (i = 0; i < cornersLength; i++) {\n            var corner = corners[i];\n            indices[index++] = corner;\n            indices[index++] = corner + length;\n        }\n\n        return new GeometryInstance({\n            geometry : new Geometry({\n                attributes : new GeometryAttributes({\n                    position : new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.DOUBLE,\n                        componentsPerAttribute : 3,\n                        values : subdividedPositions\n                    })\n                }),\n                indices : indices,\n                primitiveType : PrimitiveType.LINES\n            })\n        });\n    }\n\n    /**\n     * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.\n     *\n     * @alias PolygonOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\n     * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\n     * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     * @see PolygonOutlineGeometry#fromPositions\n     *\n     * @example\n     * // 1. create a polygon outline from points\n     * var polygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * // 2. create a nested polygon with holes outline\n     * var polygonWithHole = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -109.0, 30.0,\n     *       -95.0, 30.0,\n     *       -95.0, 40.0,\n     *       -109.0, 40.0\n     *     ]),\n     *     [new Cesium.PolygonHierarchy(\n     *       Cesium.Cartesian3.fromDegreesArray([\n     *         -107.0, 31.0,\n     *         -107.0, 39.0,\n     *         -97.0, 39.0,\n     *         -97.0, 31.0\n     *       ]),\n     *       [new Cesium.PolygonHierarchy(\n     *         Cesium.Cartesian3.fromDegreesArray([\n     *           -105.0, 33.0,\n     *           -99.0, 33.0,\n     *           -99.0, 37.0,\n     *           -105.0, 37.0\n     *         ]),\n     *         [new Cesium.PolygonHierarchy(\n     *           Cesium.Cartesian3.fromDegreesArray([\n     *             -103.0, 34.0,\n     *             -101.0, 34.0,\n     *             -101.0, 36.0,\n     *             -103.0, 36.0\n     *           ])\n     *         )]\n     *       )]\n     *     )]\n     *   )\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);\n     *\n     * // 3. create extruded polygon outline\n     * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({\n     *   polygonHierarchy : new Cesium.PolygonHierarchy(\n     *     Cesium.Cartesian3.fromDegreesArray([\n     *       -72.0, 40.0,\n     *       -70.0, 35.0,\n     *       -75.0, 30.0,\n     *       -70.0, 30.0,\n     *       -68.0, 40.0\n     *     ])\n     *   ),\n     *   extrudedHeight: 300000\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);\n     */\n    function PolygonOutlineGeometry(options) {\n        \n\n        var polygonHierarchy = options.polygonHierarchy;\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var perPositionHeight = defaultValue(options.perPositionHeight, false);\n        var perPositionHeightExtrude = perPositionHeight && defined(options.extrudedHeight);\n        var arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n\n        var height = defaultValue(options.height, 0.0);\n        var extrudedHeight = defaultValue(options.extrudedHeight, height);\n\n        if (!perPositionHeightExtrude) {\n            var h = Math.max(height, extrudedHeight);\n            extrudedHeight = Math.min(height, extrudedHeight);\n            height = h;\n        }\n\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._granularity = granularity;\n        this._height = height;\n        this._extrudedHeight = extrudedHeight;\n        this._arcType = arcType;\n        this._polygonHierarchy = polygonHierarchy;\n        this._perPositionHeight = perPositionHeight;\n        this._perPositionHeightExtrude = perPositionHeightExtrude;\n        this._offsetAttribute = options.offsetAttribute;\n        this._workerName = 'createPolygonOutlineGeometry';\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = PolygonGeometryLibrary.computeHierarchyPackedLength(polygonHierarchy) + Ellipsoid.packedLength + 8;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolygonOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolygonOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(value._polygonHierarchy, array, startingIndex);\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._height;\n        array[startingIndex++] = value._extrudedHeight;\n        array[startingIndex++] = value._granularity;\n        array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\n        array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\n        array[startingIndex] = value.packedLength;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var dummyOptions = {\n        polygonHierarchy : {}\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolygonOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.\n     */\n    PolygonOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(array, startingIndex);\n        startingIndex = polygonHierarchy.startingIndex;\n        delete polygonHierarchy.startingIndex;\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var height = array[startingIndex++];\n        var extrudedHeight = array[startingIndex++];\n        var granularity = array[startingIndex++];\n        var perPositionHeightExtrude = array[startingIndex++] === 1.0;\n        var perPositionHeight = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var offsetAttribute = array[startingIndex++];\n        var packedLength = array[startingIndex];\n\n        if (!defined(result)) {\n            result = new PolygonOutlineGeometry(dummyOptions);\n        }\n\n        result._polygonHierarchy = polygonHierarchy;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._height = height;\n        result._extrudedHeight = extrudedHeight;\n        result._granularity = granularity;\n        result._perPositionHeight = perPositionHeight;\n        result._perPositionHeightExtrude = perPositionHeightExtrude;\n        result._arcType = arcType;\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\n        result.packedLength = packedLength;\n\n        return result;\n    };\n\n    /**\n     * A description of a polygon outline from an array of positions.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\n     * @param {Number} [options.height=0.0] The height of the polygon.\n     * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.\n     * @returns {PolygonOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a polygon from points\n     * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0,\n     *     -75.0, 30.0,\n     *     -70.0, 30.0,\n     *     -68.0, 40.0\n     *   ])\n     * });\n     * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);\n     *\n     * @see PolygonOutlineGeometry#createGeometry\n     */\n    PolygonOutlineGeometry.fromPositions = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        \n\n        var newOptions = {\n            polygonHierarchy : {\n                positions : options.positions\n            },\n            height : options.height,\n            extrudedHeight : options.extrudedHeight,\n            ellipsoid : options.ellipsoid,\n            granularity : options.granularity,\n            perPositionHeight : options.perPositionHeight,\n            arcType: options.arcType,\n            offsetAttribute : options.offsetAttribute\n        };\n        return new PolygonOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolygonOutlineGeometry.createGeometry = function(polygonGeometry) {\n        var ellipsoid = polygonGeometry._ellipsoid;\n        var granularity = polygonGeometry._granularity;\n        var polygonHierarchy = polygonGeometry._polygonHierarchy;\n        var perPositionHeight = polygonGeometry._perPositionHeight;\n        var arcType = polygonGeometry._arcType;\n\n        var polygons = PolygonGeometryLibrary.polygonOutlinesFromHierarchy(polygonHierarchy, !perPositionHeight, ellipsoid);\n\n        if (polygons.length === 0) {\n            return undefined;\n        }\n\n        var geometryInstance;\n        var geometries = [];\n        var minDistance = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n\n        var height = polygonGeometry._height;\n        var extrudedHeight = polygonGeometry._extrudedHeight;\n        var extrude = polygonGeometry._perPositionHeightExtrude || !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\n        var offsetValue;\n        var i;\n        if (extrude) {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositionsExtruded(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(geometryInstance.geometry, height, extrudedHeight, ellipsoid, perPositionHeight);\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var size = geometryInstance.geometry.attributes.position.values.length / 3;\n                    var offsetAttribute = new Uint8Array(size);\n                    if (polygonGeometry._offsetAttribute === GeometryOffsetAttribute.TOP) {\n                        offsetAttribute = arrayFill(offsetAttribute, 1, 0, size / 2);\n                    } else {\n                        offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                        offsetAttribute = arrayFill(offsetAttribute, offsetValue);\n                    }\n\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values : offsetAttribute\n                    });\n                }\n                geometries.push(geometryInstance);\n            }\n        } else {\n            for (i = 0; i < polygons.length; i++) {\n                geometryInstance = createGeometryFromPositions(ellipsoid, polygons[i], minDistance, perPositionHeight, arcType);\n                geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(geometryInstance.geometry.attributes.position.values, height, ellipsoid, !perPositionHeight);\n\n                if (defined(polygonGeometry._offsetAttribute)) {\n                    var length = geometryInstance.geometry.attributes.position.values.length;\n                    var applyOffset = new Uint8Array(length / 3);\n                    offsetValue = polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\n                    arrayFill(applyOffset, offsetValue);\n                    geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute({\n                        componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                        componentsPerAttribute : 1,\n                        values: applyOffset\n                    });\n                }\n\n                geometries.push(geometryInstance);\n            }\n        }\n\n        var geometry = GeometryPipeline.combineInstances(geometries)[0];\n        var boundingSphere = BoundingSphere.fromVertices(geometry.attributes.position.values);\n\n        return new Geometry({\n            attributes : geometry.attributes,\n            indices : geometry.indices,\n            primitiveType : geometry.primitiveType,\n            boundingSphere : boundingSphere,\n            offsetAttribute : polygonGeometry._offsetAttribute\n        });\n    };\n\n    return PolygonOutlineGeometry;\n});\n","define([\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/GeometryInstance',\n        '../Core/Iso8601',\n        '../Core/PolylineVolumeGeometry',\n        '../Core/PolylineVolumeOutlineGeometry',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './Property'\n    ], function(\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        GeometryInstance,\n        Iso8601,\n        PolylineVolumeGeometry,\n        PolylineVolumeOutlineGeometry,\n        ShowGeometryInstanceAttribute,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        Property) {\n    'use strict';\n\n    var scratchColor = new Color();\n\n    function PolylineVolumeGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.polylinePositions = undefined;\n        this.shapePositions = undefined;\n        this.cornerType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polyline volumes.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineVolumeGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineVolumeGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new PolylineVolumeGeometryOptions(entity),\n            geometryPropertyName : 'polylineVolume',\n            observedPropertyNames : ['availability', 'polylineVolume']\n        });\n\n        this._onEntityPropertyChanged(entity, 'polylineVolume', entity.polylineVolume, undefined);\n    }\n\n    if (defined(Object.create)) {\n        PolylineVolumeGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        PolylineVolumeGeometryUpdater.prototype.constructor = PolylineVolumeGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineVolumeOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume) {\n        return !defined(polylineVolume.positions) || !defined(polylineVolume.shape) || GeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._isDynamic = function(entity, polylineVolume) {\n        return !polylineVolume.positions.isConstant || //\n               !polylineVolume.shape.isConstant || //\n               !Property.isConstant(polylineVolume.granularity) || //\n               !Property.isConstant(polylineVolume.outlineWidth) || //\n               !Property.isConstant(polylineVolume.cornerType);\n    };\n\n    PolylineVolumeGeometryUpdater.prototype._setStaticOptions = function(entity, polylineVolume) {\n        var granularity = polylineVolume.granularity;\n        var cornerType = polylineVolume.cornerType;\n\n        var options = this._options;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.polylinePositions = polylineVolume.positions.getValue(Iso8601.MINIMUM_VALUE, options.polylinePositions);\n        options.shapePositions = polylineVolume.shape.getValue(Iso8601.MINIMUM_VALUE, options.shape);\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n        options.cornerType = defined(cornerType) ? cornerType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    PolylineVolumeGeometryUpdater.DynamicGeometryUpdater = DynamicPolylineVolumeGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicPolylineVolumeGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicPolylineVolumeGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicPolylineVolumeGeometryUpdater.prototype.constructor = DynamicPolylineVolumeGeometryUpdater;\n    }\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._isHidden = function(entity, polylineVolume, time) {\n        var options = this._options;\n        return !defined(options.polylinePositions) || !defined(options.shapePositions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, polylineVolume, time);\n    };\n\n    DynamicPolylineVolumeGeometryUpdater.prototype._setOptions = function(entity, polylineVolume, time) {\n        var options = this._options;\n        options.polylinePositions = Property.getValueOrUndefined(polylineVolume.positions, time, options.polylinePositions);\n        options.shapePositions = Property.getValueOrUndefined(polylineVolume.shape, time);\n        options.granularity = Property.getValueOrUndefined(polylineVolume.granularity, time);\n        options.cornerType = Property.getValueOrUndefined(polylineVolume.cornerType, time);\n    };\n\n    return PolylineVolumeGeometryUpdater;\n});\n","define([\n        './arrayRemoveDuplicates',\n        './BoundingRectangle',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './ComponentDatatype',\n        './CornerType',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryPipeline',\n        './IndexDatatype',\n        './Math',\n        './oneTimeWarning',\n        './PolygonPipeline',\n        './PolylineVolumeGeometryLibrary',\n        './PrimitiveType',\n        './VertexFormat',\n        './WindingOrder'\n    ], function(\n        arrayRemoveDuplicates,\n        BoundingRectangle,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        ComponentDatatype,\n        CornerType,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryPipeline,\n        IndexDatatype,\n        CesiumMath,\n        oneTimeWarning,\n        PolygonPipeline,\n        PolylineVolumeGeometryLibrary,\n        PrimitiveType,\n        VertexFormat,\n        WindingOrder) {\n    'use strict';\n\n    function computeAttributes(combinedPositions, shape, boundingRectangle, vertexFormat) {\n        var attributes = new GeometryAttributes();\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : combinedPositions\n            });\n        }\n        var shapeLength = shape.length;\n        var vertexCount = combinedPositions.length / 3;\n        var length = (vertexCount - shapeLength * 2) / (shapeLength * 2);\n        var firstEndIndices = PolygonPipeline.triangulate(shape);\n\n        var indicesCount = (length - 1) * (shapeLength) * 6 + firstEndIndices.length * 2;\n        var indices = IndexDatatype.createTypedArray(vertexCount, indicesCount);\n        var i, j;\n        var ll, ul, ur, lr;\n        var offset = shapeLength * 2;\n        var index = 0;\n        for (i = 0; i < length - 1; i++) {\n            for (j = 0; j < shapeLength - 1; j++) {\n                ll = j * 2 + i * shapeLength * 2;\n                lr = ll + offset;\n                ul = ll + 1;\n                ur = ul + offset;\n\n                indices[index++] = ul;\n                indices[index++] = ll;\n                indices[index++] = ur;\n                indices[index++] = ur;\n                indices[index++] = ll;\n                indices[index++] = lr;\n            }\n            ll = shapeLength * 2 - 2 + i * shapeLength * 2;\n            ul = ll + 1;\n            ur = ul + offset;\n            lr = ll + offset;\n\n            indices[index++] = ul;\n            indices[index++] = ll;\n            indices[index++] = ur;\n            indices[index++] = ur;\n            indices[index++] = ll;\n            indices[index++] = lr;\n        }\n\n        if (vertexFormat.st || vertexFormat.tangent || vertexFormat.bitangent) { // st required for tangent/bitangent calculation\n            var st = new Float32Array(vertexCount * 2);\n            var lengthSt = 1 / (length - 1);\n            var heightSt = 1 / (boundingRectangle.height);\n            var heightOffset = boundingRectangle.height / 2;\n            var s, t;\n            var stindex = 0;\n            for (i = 0; i < length; i++) {\n                s = i * lengthSt;\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n                for (j = 1; j < shapeLength; j++) {\n                    t = heightSt * (shape[j].y + heightOffset);\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                    st[stindex++] = s;\n                    st[stindex++] = t;\n                }\n                t = heightSt * (shape[0].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = 0;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n            for (j = 0; j < shapeLength; j++) {\n                s = (length - 1) * lengthSt;\n                t = heightSt * (shape[j].y + heightOffset);\n                st[stindex++] = s;\n                st[stindex++] = t;\n            }\n\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : new Float32Array(st)\n            });\n        }\n\n        var endOffset = vertexCount - shapeLength * 2;\n        for (i = 0; i < firstEndIndices.length; i += 3) {\n            var v0 = firstEndIndices[i] + endOffset;\n            var v1 = firstEndIndices[i + 1] + endOffset;\n            var v2 = firstEndIndices[i + 2] + endOffset;\n\n            indices[index++] = v0;\n            indices[index++] = v1;\n            indices[index++] = v2;\n            indices[index++] = v2 + shapeLength;\n            indices[index++] = v1 + shapeLength;\n            indices[index++] = v0 + shapeLength;\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : indices,\n            boundingSphere : BoundingSphere.fromVertices(combinedPositions),\n            primitiveType : PrimitiveType.TRIANGLES\n        });\n\n        if (vertexFormat.normal) {\n            geometry = GeometryPipeline.computeNormal(geometry);\n        }\n\n        if (vertexFormat.tangent || vertexFormat.bitangent) {\n            try {\n                geometry = GeometryPipeline.computeTangentAndBitangent(geometry);\n            } catch (e) {\n                oneTimeWarning('polyline-volume-tangent-bitangent', 'Unable to compute tangents and bitangents for polyline volume geometry');\n                //TODO https://github.com/AnalyticalGraphicsInc/cesium/issues/3609\n            }\n\n            if (!vertexFormat.tangent) {\n                geometry.attributes.tangent = undefined;\n            }\n            if (!vertexFormat.bitangent) {\n                geometry.attributes.bitangent = undefined;\n            }\n            if (!vertexFormat.st) {\n                geometry.attributes.st = undefined;\n            }\n        }\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeGeometry#createGeometry\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volume = new Cesium.PolylineVolumeGeometry({\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.\n     */\n    PolylineVolumeGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeGeometry.createGeometry = function(polylineVolumeGeometry) {\n        var positions = polylineVolumeGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeGeometry, true);\n        return computeAttributes(computedPositions, shape2D, boundingRectangle, polylineVolumeGeometry._vertexFormat);\n    };\n\n    return PolylineVolumeGeometry;\n});\n","define([\n        './arrayRemoveDuplicates',\n        './BoundingRectangle',\n        './BoundingSphere',\n        './Cartesian2',\n        './Cartesian3',\n        './ComponentDatatype',\n        './CornerType',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './IndexDatatype',\n        './Math',\n        './PolygonPipeline',\n        './PolylineVolumeGeometryLibrary',\n        './PrimitiveType',\n        './WindingOrder'\n    ], function(\n        arrayRemoveDuplicates,\n        BoundingRectangle,\n        BoundingSphere,\n        Cartesian2,\n        Cartesian3,\n        ComponentDatatype,\n        CornerType,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        IndexDatatype,\n        CesiumMath,\n        PolygonPipeline,\n        PolylineVolumeGeometryLibrary,\n        PrimitiveType,\n        WindingOrder) {\n    'use strict';\n\n    function computeAttributes(positions, shape) {\n        var attributes = new GeometryAttributes();\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : positions\n        });\n\n        var shapeLength = shape.length;\n        var vertexCount = attributes.position.values.length / 3;\n        var positionLength = positions.length / 3;\n        var shapeCount = positionLength / shapeLength;\n        var indices = IndexDatatype.createTypedArray(vertexCount, 2 * shapeLength * (shapeCount + 1));\n        var i, j;\n        var index = 0;\n        i = 0;\n        var offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        i = shapeCount - 1;\n        offset = i * shapeLength;\n        for (j = 0; j < shapeLength - 1; j++) {\n            indices[index++] = j + offset;\n            indices[index++] = j + offset + 1;\n        }\n        indices[index++] = shapeLength - 1 + offset;\n        indices[index++] = offset;\n\n        for (i = 0; i < shapeCount - 1; i++) {\n            var firstOffset = shapeLength * i;\n            var secondOffset = firstOffset + shapeLength;\n            for (j = 0; j < shapeLength; j++) {\n                indices[index++] = j + firstOffset;\n                indices[index++] = j + secondOffset;\n            }\n        }\n\n        var geometry = new Geometry({\n            attributes : attributes,\n            indices : IndexDatatype.createTypedArray(vertexCount, indices),\n            boundingSphere : BoundingSphere.fromVertices(positions),\n            primitiveType : PrimitiveType.LINES\n        });\n\n        return geometry;\n    }\n\n    /**\n     * A description of a polyline with a volume (a 2D shape extruded along a polyline).\n     *\n     * @alias PolylineVolumeOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.\n     * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.\n     *\n     * @see PolylineVolumeOutlineGeometry#createGeometry\n     *\n     * @example\n     * function computeCircle(radius) {\n     *   var positions = [];\n     *   for (var i = 0; i < 360; i++) {\n     *     var radians = Cesium.Math.toRadians(i);\n     *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));\n     *   }\n     *   return positions;\n     * }\n     *\n     * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({\n     *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([\n     *     -72.0, 40.0,\n     *     -70.0, 35.0\n     *   ]),\n     *   shapePositions : computeCircle(100000.0)\n     * });\n     */\n    function PolylineVolumeOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.polylinePositions;\n        var shape = options.shapePositions;\n\n        \n\n        this._positions = positions;\n        this._shape = shape;\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._cornerType = defaultValue(options.cornerType, CornerType.ROUNDED);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._workerName = 'createPolylineVolumeOutlineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += 1 + shape.length * Cartesian2.packedLength;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 2;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineVolumeOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineVolumeOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var shape = value._shape;\n        length = shape.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            Cartesian2.pack(shape[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex++] = value._cornerType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        polylinePositions : undefined,\n        shapePositions : undefined,\n        ellipsoid : scratchEllipsoid,\n        height : undefined,\n        cornerType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.\n     */\n    PolylineVolumeOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var shape = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian2.packedLength) {\n            shape[i] = Cartesian2.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var cornerType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.polylinePositions = positions;\n            scratchOptions.shapePositions = shape;\n            scratchOptions.cornerType = cornerType;\n            scratchOptions.granularity = granularity;\n            return new PolylineVolumeOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._shape = shape;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._cornerType = cornerType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var brScratch = new BoundingRectangle();\n\n    /**\n     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineVolumeOutlineGeometry.createGeometry = function(polylineVolumeOutlineGeometry) {\n        var positions = polylineVolumeOutlineGeometry._positions;\n        var cleanPositions = arrayRemoveDuplicates(positions, Cartesian3.equalsEpsilon);\n        var shape2D = polylineVolumeOutlineGeometry._shape;\n        shape2D = PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(shape2D);\n\n        if (cleanPositions.length < 2 || shape2D.length < 3) {\n            return undefined;\n        }\n\n        if (PolygonPipeline.computeWindingOrder2D(shape2D) === WindingOrder.CLOCKWISE) {\n            shape2D.reverse();\n        }\n        var boundingRectangle = BoundingRectangle.fromPoints(shape2D, brScratch);\n\n        var computedPositions = PolylineVolumeGeometryLibrary.computePositions(cleanPositions, shape2D, boundingRectangle, polylineVolumeOutlineGeometry, false);\n        return computeAttributes(computedPositions, shape2D);\n    };\n\n    return PolylineVolumeOutlineGeometry;\n});\n","define([\n        '../Core/ApproximateTerrainHeights',\n        '../Core/Cartesian3',\n        '../Core/Cartographic',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/Ellipsoid',\n        '../Core/GeometryInstance',\n        '../Core/GeometryOffsetAttribute',\n        '../Core/Iso8601',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/Rectangle',\n        '../Core/RectangleGeometry',\n        '../Core/RectangleOutlineGeometry',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/GroundPrimitive',\n        '../Scene/HeightReference',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './GroundGeometryUpdater',\n        './Property'\n    ], function(\n        ApproximateTerrainHeights,\n        Cartesian3,\n        Cartographic,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        Ellipsoid,\n        GeometryInstance,\n        GeometryOffsetAttribute,\n        Iso8601,\n        OffsetGeometryInstanceAttribute,\n        Rectangle,\n        RectangleGeometry,\n        RectangleOutlineGeometry,\n        ShowGeometryInstanceAttribute,\n        GroundPrimitive,\n        HeightReference,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        GroundGeometryUpdater,\n        Property) {\n    'use strict';\n\n    var scratchColor = new Color();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n    var scratchRectangle = new Rectangle();\n    var scratchCenterRect = new Rectangle();\n    var scratchCarto = new Cartographic();\n\n    function RectangleGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.rectangle = undefined;\n        this.height = undefined;\n        this.extrudedHeight = undefined;\n        this.granularity = undefined;\n        this.stRotation = undefined;\n        this.rotation = undefined;\n        this.offsetAttribute = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for rectangles.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias RectangleGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function RectangleGeometryUpdater(entity, scene) {\n        GroundGeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new RectangleGeometryOptions(entity),\n            geometryPropertyName : 'rectangle',\n            observedPropertyNames : ['availability', 'rectangle']\n        });\n\n        this._onEntityPropertyChanged(entity, 'rectangle', entity.rectangle, undefined);\n    }\n\n    if (defined(Object.create)) {\n        RectangleGeometryUpdater.prototype = Object.create(GroundGeometryUpdater.prototype);\n        RectangleGeometryUpdater.prototype.constructor = RectangleGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    RectangleGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time)),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(time)),\n            offset : undefined,\n            color : undefined\n        };\n\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    RectangleGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        var attributes = {\n            show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n            color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n            distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition),\n            offset : undefined\n        };\n\n        if (defined(this._options.offsetAttribute)) {\n            attributes.offset = OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty, time, defaultOffset, offsetScratch));\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new RectangleOutlineGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    RectangleGeometryUpdater.prototype._computeCenter = function(time, result) {\n        var rect = Property.getValueOrUndefined(this._entity.rectangle.coordinates, time, scratchCenterRect);\n        if (!defined(rect)) {\n            return;\n        }\n        var center = Rectangle.center(rect, scratchCarto);\n        return Cartographic.toCartesian(center, Ellipsoid.WGS84, result);\n    };\n\n    RectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle) {\n        return !defined(rectangle.coordinates) || GeometryUpdater.prototype._isHidden.call(this, entity, rectangle);\n    };\n\n    RectangleGeometryUpdater.prototype._isDynamic = function(entity, rectangle) {\n        return !rectangle.coordinates.isConstant || //\n               !Property.isConstant(rectangle.height) || //\n               !Property.isConstant(rectangle.extrudedHeight) || //\n               !Property.isConstant(rectangle.granularity) || //\n               !Property.isConstant(rectangle.stRotation) || //\n               !Property.isConstant(rectangle.rotation) || //\n               !Property.isConstant(rectangle.outlineWidth) || //\n               !Property.isConstant(rectangle.zIndex) || //\n               (this._onTerrain && !Property.isConstant(this._materialProperty));\n    };\n\n    RectangleGeometryUpdater.prototype._setStaticOptions = function(entity, rectangle) {\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var heightValue = Property.getValueOrUndefined(rectangle.height, Iso8601.MINIMUM_VALUE);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, Iso8601.MINIMUM_VALUE);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, Iso8601.MINIMUM_VALUE, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.rectangle = rectangle.coordinates.getValue(Iso8601.MINIMUM_VALUE, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, Iso8601.MINIMUM_VALUE);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, Iso8601.MINIMUM_VALUE);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, Iso8601.MINIMUM_VALUE);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    RectangleGeometryUpdater.DynamicGeometryUpdater = DynamicRectangleGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicRectangleGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicRectangleGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicRectangleGeometryUpdater.prototype.constructor = DynamicRectangleGeometryUpdater;\n    }\n\n    DynamicRectangleGeometryUpdater.prototype._isHidden = function(entity, rectangle, time) {\n        return  !defined(this._options.rectangle) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, rectangle, time);\n    };\n\n    DynamicRectangleGeometryUpdater.prototype._setOptions = function(entity, rectangle, time) {\n        var options = this._options;\n        var heightValue = Property.getValueOrUndefined(rectangle.height, time);\n        var heightReferenceValue = Property.getValueOrDefault(rectangle.heightReference, time, HeightReference.NONE);\n        var extrudedHeightValue = Property.getValueOrUndefined(rectangle.extrudedHeight, time);\n        var extrudedHeightReferenceValue = Property.getValueOrDefault(rectangle.extrudedHeightReference, time, HeightReference.NONE);\n        if (defined(extrudedHeightValue) && !defined(heightValue)) {\n            heightValue = 0;\n        }\n\n        options.rectangle = Property.getValueOrUndefined(rectangle.coordinates, time, options.rectangle);\n        options.granularity = Property.getValueOrUndefined(rectangle.granularity, time);\n        options.stRotation = Property.getValueOrUndefined(rectangle.stRotation, time);\n        options.rotation = Property.getValueOrUndefined(rectangle.rotation, time);\n        options.offsetAttribute = GroundGeometryUpdater.computeGeometryOffsetAttribute(heightValue, heightReferenceValue, extrudedHeightValue, extrudedHeightReferenceValue);\n        options.height = GroundGeometryUpdater.getGeometryHeight(heightValue, heightReferenceValue);\n\n        extrudedHeightValue = GroundGeometryUpdater.getGeometryExtrudedHeight(extrudedHeightValue, extrudedHeightReferenceValue);\n        if (extrudedHeightValue === GroundGeometryUpdater.CLAMP_TO_GROUND) {\n            extrudedHeightValue = ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(options, scratchRectangle)).minimumTerrainHeight;\n        }\n\n        options.extrudedHeight = extrudedHeightValue;\n    };\n\n    return RectangleGeometryUpdater;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Color',\n        '../Core/defined',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/GroundPrimitive',\n        './BoundingSphereState',\n        './Property'\n    ], function(\n        AssociativeArray,\n        Color,\n        defined,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        GroundPrimitive,\n        BoundingSphereState,\n        Property) {\n    'use strict';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    function Batch(primitives, classificationType, color, key, zIndex) {\n        this.primitives = primitives;\n        this.zIndex = zIndex;\n        this.classificationType = classificationType;\n        this.color = color;\n        this.key = key;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.isDirty = false;\n    }\n\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var scratchArray = new Array(4);\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    classificationType : this.classificationType\n                });\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant || waitingOnCreate) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var fillColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, colorScratch);\n\n                    if (!Color.equals(attributes._lastColor, fillColor)) {\n                        attributes._lastColor = Color.clone(fillColor, attributes._lastColor);\n                        var color = this.color;\n                        var newColor = fillColor.toBytes(scratchArray);\n                        if (color[0] !== newColor[0] || color[1] !== newColor[1] ||\n                            color[2] !== newColor[2] || color[3] !== newColor[3]) {\n                           this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var bs = primitive.getBoundingSphere(updater.entity);\n        if (!defined(bs)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        bs.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryColorBatch(primitives, classificationType) {\n        this._batches = new AssociativeArray();\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n    }\n\n    StaticGroundGeometryColorBatch.prototype.add = function(time, updater) {\n        var instance = updater.createFillGeometryInstance(time);\n        var batches = this._batches;\n        // color and zIndex are batch breakers, so we'll use that for the key\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        var batchKey = new Uint32Array(instance.attributes.color.value.buffer)[0] + ':' + zIndex;\n        var batch;\n        if (batches.contains(batchKey)) {\n            batch = batches.get(batchKey);\n        } else {\n            batch = new Batch(this._primitives, this._classificationType, instance.attributes.color.value, batchKey, zIndex);\n            batches.set(batchKey, batch);\n        }\n        batch.add(updater, instance);\n        return batch;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.remove = function(updater) {\n        var batchesArray = this._batches.values;\n        var count = batchesArray.length;\n        for (var i = 0; i < count; ++i) {\n            if (batchesArray[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticGroundGeometryColorBatch.prototype.update = function(time) {\n        var i;\n        var updater;\n\n        //Perform initial update\n        var isUpdated = true;\n        var batches = this._batches;\n        var batchesArray = batches.values;\n        var batchCount = batchesArray.length;\n        for (i = 0; i < batchCount; ++i) {\n            isUpdated = batchesArray[i].update(time) && isUpdated;\n        }\n\n        //If any items swapped between batches we need to move them\n        for (i = 0; i < batchCount; ++i) {\n            var oldBatch = batchesArray[i];\n            var itemsToRemove = oldBatch.itemsToRemove;\n            var itemsToMoveLength = itemsToRemove.length;\n            for (var j = 0; j < itemsToMoveLength; j++) {\n                updater = itemsToRemove[j];\n                oldBatch.remove(updater);\n                var newBatch = this.add(time, updater);\n                oldBatch.isDirty = true;\n                newBatch.isDirty = true;\n            }\n        }\n\n        //If we moved anything around, we need to re-build the primitive and remove empty batches\n        var batchesArrayCopy = batchesArray.slice();\n        var batchesCopyCount = batchesArrayCopy.length;\n        for (i = 0; i < batchesCopyCount; ++i) {\n            var batch = batchesArrayCopy[i];\n            if (batch.isDirty) {\n                isUpdated = batchesArrayCopy[i].update(time) && isUpdated;\n                batch.isDirty = false;\n            }\n            if (batch.geometry.length === 0) {\n                batches.remove(batch.key);\n            }\n        }\n\n        return isUpdated;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.getBoundingSphere = function(updater, result) {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            var batch = batchesArray[i];\n            if (batch.contains(updater)) {\n                return batch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryColorBatch.prototype.removeAllPrimitives = function() {\n        var batchesArray = this._batches.values;\n        var batchCount = batchesArray.length;\n        for (var i = 0; i < batchCount; ++i) {\n            batchesArray[i].removeAllPrimitives();\n        }\n    };\n\n    return StaticGroundGeometryColorBatch;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Core/RectangleCollisionChecker',\n        '../Scene/ClassificationType',\n        '../Scene/GroundPrimitive',\n        '../Scene/ShadowVolumeAppearance',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        AssociativeArray,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        RectangleCollisionChecker,\n        ClassificationType,\n        GroundPrimitive,\n        ShadowVolumeAppearance,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(primitives, classificationType, appearanceType, materialProperty, usingSphericalTextureCoordinates, zIndex) {\n        this.primitives = primitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.usingSphericalTextureCoordinates = usingSphericalTextureCoordinates;\n        this.zIndex = zIndex;\n        this.rectangleCollisionCheck = new RectangleCollisionChecker();\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    Batch.prototype.overlapping = function(rectangle) {\n        return this.rectangleCollisionCheck.collides(rectangle);\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        this.rectangleCollisionCheck.insert(id, geometryInstance.geometry.rectangle);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        var geometryInstance = this.geometry.get(id);\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.rectangleCollisionCheck.remove(id, geometryInstance.geometry.rectangle);\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        primitives.remove(primitive);\n                    }\n                }\n\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n\n                primitive = new GroundPrimitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType({\n                        material : this.material\n                        // translucent and closed properties overridden\n                    }),\n                    classificationType : this.classificationType\n                });\n\n                primitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n            this.primitive.appearance.material = this.material;\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundGeometryPerMaterialBatch(primitives, classificationType, appearanceType) {\n        this._items = [];\n        this._primitives = primitives;\n        this._classificationType = classificationType;\n        this._appearanceType = appearanceType;\n    }\n\n    StaticGroundGeometryPerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var usingSphericalTextureCoordinates = ShadowVolumeAppearance.shouldUseSphericalCoordinates(geometryInstance.geometry.rectangle);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater can be placed in an existing batch. Requirements:\n        // * compatible material (same material or same color)\n        // * same type of texture coordinates (spherical vs. planar)\n        // * conservatively non-overlapping with any entities in the existing batch\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.usingSphericalTextureCoordinates === usingSphericalTextureCoordinates &&\n                item.zIndex === zIndex &&\n                !item.overlapping(geometryInstance.geometry.rectangle)) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._primitives, this._classificationType, this._appearanceType, updater.fillMaterialProperty, usingSphericalTextureCoordinates, zIndex);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\n\n    return StaticGroundGeometryPerMaterialBatch;\n});\n","define([\n        '../ThirdParty/rbush',\n        './Check'\n    ], function(\n        rbush,\n        Check) {\n    'use strict';\n\n    /**\n     * Wrapper around rbush for use with Rectangle types.\n     * @private\n     */\n    function RectangleCollisionChecker() {\n        this._tree = rbush();\n    }\n\n    function RectangleWithId() {\n        this.minX = 0.0;\n        this.minY = 0.0;\n        this.maxX = 0.0;\n        this.maxY = 0.0;\n        this.id = '';\n    }\n\n    RectangleWithId.fromRectangleAndId = function(id, rectangle, result) {\n        result.minX = rectangle.west;\n        result.minY = rectangle.south;\n        result.maxX = rectangle.east;\n        result.maxY = rectangle.north;\n        result.id = id;\n        return result;\n    };\n\n    /**\n     * Insert a rectangle into the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being inserted.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.insert = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, new RectangleWithId());\n        this._tree.insert(withId);\n    };\n\n    function idCompare(a, b) {\n        return a.id === b.id;\n    }\n\n    var removalScratch = new RectangleWithId();\n    /**\n     * Remove a rectangle from the collision checker.\n     *\n     * @param {String} id Unique string ID for the rectangle being removed.\n     * @param {Rectangle} rectangle A Rectangle\n     * @private\n     */\n    RectangleCollisionChecker.prototype.remove = function(id, rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId(id, rectangle, removalScratch);\n        this._tree.remove(withId, idCompare);\n    };\n\n    var collisionScratch = new RectangleWithId();\n    /**\n     * Checks if a given rectangle collides with any of the rectangles in the collection.\n     *\n     * @param {Rectangle} rectangle A Rectangle that should be checked against the rectangles in the collision checker.\n     * @returns {Boolean} Whether the rectangle collides with any of the rectangles in the collision checker.\n     */\n    RectangleCollisionChecker.prototype.collides = function(rectangle) {\n        \n\n        var withId = RectangleWithId.fromRectangleAndId('', rectangle, collisionScratch);\n        return this._tree.collides(withId);\n    };\n\n    return RectangleCollisionChecker;\n});\n","define(['./quickselect'], function(quickselect) {\n'use strict';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nreturn rbush;\n});\n","define([], function() {\n'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n};\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Cartesian3',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/OffsetGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/PerInstanceColorAppearance',\n        '../Scene/Primitive',\n        './BoundingSphereState',\n        './Property'\n    ], function(\n        AssociativeArray,\n        Cartesian3,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        OffsetGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        PerInstanceColorAppearance,\n        Primitive,\n        BoundingSphereState,\n        Property) {\n    'use strict';\n\n    var colorScratch = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n    var defaultOffset = Cartesian3.ZERO;\n    var offsetScratch = new Cartesian3();\n\n    function Batch(primitives, translucent, width, shadows) {\n        this.translucent = translucent;\n        this.width = width;\n        this.shadows = shadows;\n        this.primitives = primitives;\n        this.createPrimitive = false;\n        this.waitingOnCreate = false;\n        this.primitive = undefined;\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.updaters = new AssociativeArray();\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.itemsToRemove = [];\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n    }\n    Batch.prototype.add = function(updater, instance) {\n        var id = updater.id;\n        this.createPrimitive = true;\n        this.geometry.set(id, instance);\n        this.updaters.set(id, updater);\n        if (!updater.hasConstantOutline || !updater.outlineColorProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty) || !Property.isConstant(updater.terrainOffsetProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n                this.showsUpdated.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var removedCount = 0;\n        var primitive = this.primitive;\n        var primitives = this.primitives;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometries = this.geometry.values;\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        primitives.remove(primitive);\n                    }\n                }\n\n                primitive = new Primitive({\n                    show : false,\n                    asynchronous : true,\n                    geometryInstances : geometries,\n                    appearance : new PerInstanceColorAppearance({\n                        flat : true,\n                        translucent : this.translucent,\n                        renderState : {\n                            lineWidth : this.width\n                        }\n                    }),\n                    shadows : this.shadows\n                });\n\n                primitives.add(primitive);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    primitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    primitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n            this.waitingOnCreate = true;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                primitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            var waitingOnCreate = this.waitingOnCreate;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.outlineColorProperty.isConstant || waitingOnCreate) {\n                    var outlineColorProperty = updater.outlineColorProperty;\n                    var outlineColor = Property.getValueOrDefault(outlineColorProperty, time, Color.WHITE, colorScratch);\n                    if (!Color.equals(attributes._lastColor, outlineColor)) {\n                        attributes._lastColor = Color.clone(outlineColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(outlineColor, attributes.color);\n                        if ((this.translucent && attributes.color[3] === 255) || (!this.translucent && attributes.color[3] !== 255)) {\n                            this.itemsToRemove[removedCount++] = updater;\n                        }\n                    }\n                }\n\n                var show = updater.entity.isShowing && (updater.hasConstantOutline || updater.isOutlineVisible(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n\n                var offsetProperty = updater.terrainOffsetProperty;\n                if (!Property.isConstant(offsetProperty)) {\n                    var offset = Property.getValueOrDefault(offsetProperty, time, defaultOffset, offsetScratch);\n                    if (!Cartesian3.equals(offset, attributes._lastOffset)) {\n                        attributes._lastOffset = Cartesian3.clone(offset, attributes._lastOffset);\n                        attributes.offset = OffsetGeometryInstanceAttribute.toValue(offset, attributes.offset);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n            this.waitingOnCreate = false;\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n\n        this.itemsToRemove.length = removedCount;\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = updater.entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||//\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.removeAllPrimitives = function() {\n        var primitives = this.primitives;\n\n        var primitive = this.primitive;\n        if (defined(primitive)) {\n            primitives.remove(primitive);\n            this.primitive = undefined;\n            this.geometry.removeAll();\n            this.updaters.removeAll();\n        }\n\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            primitives.remove(oldPrimitive);\n            this.oldPrimitive = undefined;\n        }\n    };\n\n    /**\n     * @private\n     */\n    function StaticOutlineGeometryBatch(primitives, scene, shadows) {\n        this._primitives = primitives;\n        this._scene = scene;\n        this._shadows = shadows;\n        this._solidBatches = new AssociativeArray();\n        this._translucentBatches = new AssociativeArray();\n    }\n    StaticOutlineGeometryBatch.prototype.add = function(time, updater) {\n        var instance = updater.createOutlineGeometryInstance(time);\n        var width = this._scene.clampLineWidth(updater.outlineWidth);\n        var batches;\n        var batch;\n        if (instance.attributes.color.value[3] === 255) {\n            batches = this._solidBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, false, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        } else {\n            batches = this._translucentBatches;\n            batch = batches.get(width);\n            if (!defined(batch)) {\n                batch = new Batch(this._primitives, true, width, this._shadows);\n                batches.set(width, batch);\n            }\n            batch.add(updater, instance);\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.remove = function(updater) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            if (solidBatches[i].remove(updater)) {\n                return;\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            if (translucentBatches[i].remove(updater)) {\n                return;\n            }\n        }\n    };\n\n    StaticOutlineGeometryBatch.prototype.update = function(time) {\n        var i;\n        var x;\n        var updater;\n        var batch;\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        var itemsToRemove;\n        var isUpdated = true;\n        var needUpdate = false;\n\n        do {\n            needUpdate = false;\n            for (x = 0; x < solidBatchesLength; x++) {\n                batch = solidBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var solidsToMoveLength = itemsToRemove.length;\n                if (solidsToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < solidsToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n            for (x = 0; x < translucentBatchesLength; x++) {\n                batch = translucentBatches[x];\n                //Perform initial update\n                isUpdated = batch.update(time);\n\n                //If any items swapped between solid/translucent, we need to\n                //move them between batches\n                itemsToRemove = batch.itemsToRemove;\n                var translucentToMoveLength = itemsToRemove.length;\n                if (translucentToMoveLength > 0) {\n                    needUpdate = true;\n                    for (i = 0; i < translucentToMoveLength; i++) {\n                        updater = itemsToRemove[i];\n                        batch.remove(updater);\n                        this.add(time, updater);\n                    }\n                }\n            }\n        } while (needUpdate);\n\n        return isUpdated;\n    };\n\n    StaticOutlineGeometryBatch.prototype.getBoundingSphere = function(updater, result) {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            var solidBatch = solidBatches[i];\n            if (solidBatch.contains(updater)){\n                return solidBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            var translucentBatch = translucentBatches[i];\n            if (translucentBatch.contains(updater)){\n                return translucentBatch.getBoundingSphere(updater, result);\n            }\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticOutlineGeometryBatch.prototype.removeAllPrimitives = function() {\n        var i;\n\n        var solidBatches = this._solidBatches.values;\n        var solidBatchesLength = solidBatches.length;\n        for (i = 0; i < solidBatchesLength; i++) {\n            solidBatches[i].removeAllPrimitives();\n        }\n\n        var translucentBatches = this._translucentBatches.values;\n        var translucentBatchesLength = translucentBatches.length;\n        for (i = 0; i < translucentBatchesLength; i++) {\n            translucentBatches[i].removeAllPrimitives();\n        }\n    };\n\n    return StaticOutlineGeometryBatch;\n});\n","define([\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/GeometryInstance',\n        '../Core/Iso8601',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Core/WallGeometry',\n        '../Core/WallOutlineGeometry',\n        '../Scene/MaterialAppearance',\n        '../Scene/PerInstanceColorAppearance',\n        './ColorMaterialProperty',\n        './DynamicGeometryUpdater',\n        './GeometryUpdater',\n        './Property'\n    ], function(\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DeveloperError,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        GeometryInstance,\n        Iso8601,\n        ShowGeometryInstanceAttribute,\n        WallGeometry,\n        WallOutlineGeometry,\n        MaterialAppearance,\n        PerInstanceColorAppearance,\n        ColorMaterialProperty,\n        DynamicGeometryUpdater,\n        GeometryUpdater,\n        Property) {\n    'use strict';\n\n    var scratchColor = new Color();\n\n    function WallGeometryOptions(entity) {\n        this.id = entity;\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.minimumHeights = undefined;\n        this.maximumHeights = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for walls.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias WallGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function WallGeometryUpdater(entity, scene) {\n        GeometryUpdater.call(this, {\n            entity : entity,\n            scene : scene,\n            geometryOptions : new WallGeometryOptions(entity),\n            geometryPropertyName : 'wall',\n            observedPropertyNames : ['availability', 'wall']\n        });\n\n        this._onEntityPropertyChanged(entity, 'wall', entity.wall, undefined);\n    }\n\n    if (defined(Object.create)) {\n        WallGeometryUpdater.prototype = Object.create(GeometryUpdater.prototype);\n        WallGeometryUpdater.prototype.constructor = WallGeometryUpdater;\n    }\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    WallGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n\n        var attributes;\n\n        var color;\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._fillProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            var currentColor;\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute,\n                color : color\n            };\n        } else {\n            attributes = {\n                show : show,\n                distanceDisplayCondition : distanceDisplayConditionAttribute\n            };\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallGeometry(this._options),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    WallGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var outlineColor = Property.getValueOrDefault(this._outlineColorProperty, time, Color.BLACK, scratchColor);\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new WallOutlineGeometry(this._options),\n            attributes : {\n                show : new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time) && this._showOutlineProperty.getValue(time)),\n                color : ColorGeometryInstanceAttribute.fromColor(outlineColor),\n                distanceDisplayCondition : DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)\n            }\n        });\n    };\n\n    WallGeometryUpdater.prototype._isHidden = function(entity, wall) {\n        return !defined(wall.positions) || GeometryUpdater.prototype._isHidden.call(this, entity, wall);\n    };\n\n    WallGeometryUpdater.prototype._getIsClosed = function(options) {\n        return false;\n    };\n\n    WallGeometryUpdater.prototype._isDynamic = function(entity, wall) {\n        return !wall.positions.isConstant || //\n               !Property.isConstant(wall.minimumHeights) || //\n               !Property.isConstant(wall.maximumHeights) || //\n               !Property.isConstant(wall.outlineWidth) || //\n               !Property.isConstant(wall.granularity);\n    };\n\n    WallGeometryUpdater.prototype._setStaticOptions = function(entity, wall) {\n        var minimumHeights = wall.minimumHeights;\n        var maximumHeights = wall.maximumHeights;\n        var granularity = wall.granularity;\n        var isColorMaterial = this._materialProperty instanceof ColorMaterialProperty;\n\n        var options = this._options;\n        options.vertexFormat = isColorMaterial ? PerInstanceColorAppearance.VERTEX_FORMAT : MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;\n        options.positions = wall.positions.getValue(Iso8601.MINIMUM_VALUE, options.positions);\n        options.minimumHeights = defined(minimumHeights) ? minimumHeights.getValue(Iso8601.MINIMUM_VALUE, options.minimumHeights) : undefined;\n        options.maximumHeights = defined(maximumHeights) ? maximumHeights.getValue(Iso8601.MINIMUM_VALUE, options.maximumHeights) : undefined;\n        options.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n    };\n\n    WallGeometryUpdater.DynamicGeometryUpdater = DynamicWallGeometryUpdater;\n\n    /**\n     * @private\n     */\n    function DynamicWallGeometryUpdater(geometryUpdater, primitives, groundPrimitives) {\n        DynamicGeometryUpdater.call(this, geometryUpdater, primitives, groundPrimitives);\n    }\n\n    if (defined(Object.create)) {\n        DynamicWallGeometryUpdater.prototype = Object.create(DynamicGeometryUpdater.prototype);\n        DynamicWallGeometryUpdater.prototype.constructor = DynamicWallGeometryUpdater;\n    }\n\n    DynamicWallGeometryUpdater.prototype._isHidden = function(entity, wall, time) {\n        return  !defined(this._options.positions) || DynamicGeometryUpdater.prototype._isHidden.call(this, entity, wall, time);\n    };\n\n    DynamicWallGeometryUpdater.prototype._setOptions = function(entity, wall, time) {\n        var options = this._options;\n        options.positions = Property.getValueOrUndefined(wall.positions, time, options.positions);\n        options.minimumHeights = Property.getValueOrUndefined(wall.minimumHeights, time, options.minimumHeights);\n        options.maximumHeights = Property.getValueOrUndefined(wall.maximumHeights, time, options.maximumHeights);\n        options.granularity = Property.getValueOrUndefined(wall.granularity, time);\n    };\n\n    return WallGeometryUpdater;\n});\n","define([\n        './BoundingSphere',\n        './Cartesian3',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './IndexDatatype',\n        './Math',\n        './PrimitiveType',\n        './VertexFormat',\n        './WallGeometryLibrary'\n    ], function(\n        BoundingSphere,\n        Cartesian3,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        IndexDatatype,\n        CesiumMath,\n        PrimitiveType,\n        VertexFormat,\n        WallGeometryLibrary) {\n    'use strict';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n    var scratchCartesian3Position3 = new Cartesian3();\n    var scratchCartesian3Position4 = new Cartesian3();\n    var scratchCartesian3Position5 = new Cartesian3();\n    var scratchBitangent = new Cartesian3();\n    var scratchTangent = new Cartesian3();\n    var scratchNormal = new Cartesian3();\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}\n     *\n     * @example\n     * // create a wall that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     */\n    function WallGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex] = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallGeometry} [result] The object into which to store the result.\n     * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.\n     */\n    WallGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @returns {WallGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallGeometry.createGeometry(wall);\n     *\n     * @see WallGeometry#createGeometry\n     */\n    WallGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid,\n            vertexFormat : options.vertexFormat\n        };\n        return new WallGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallGeometry} wallGeometry A description of the wall.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var vertexFormat = wallGeometry._vertexFormat;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, true);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n        var numCorners = pos.numCorners;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = vertexFormat.position ? new Float64Array(size) : undefined;\n        var normals = vertexFormat.normal ? new Float32Array(size) : undefined;\n        var tangents = vertexFormat.tangent ? new Float32Array(size) : undefined;\n        var bitangents = vertexFormat.bitangent ? new Float32Array(size) : undefined;\n        var textureCoordinates = vertexFormat.st ? new Float32Array(size / 3 * 2) : undefined;\n\n        var positionIndex = 0;\n        var normalIndex = 0;\n        var bitangentIndex = 0;\n        var tangentIndex = 0;\n        var stIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        var normal = scratchNormal;\n        var tangent = scratchTangent;\n        var bitangent = scratchBitangent;\n        var recomputeNormal = true;\n        length /= 3;\n        var i;\n        var s = 0;\n        var ds = 1/(length - wallPositions.length + 1);\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n            if (vertexFormat.position) {\n                // insert the lower point\n                positions[positionIndex++] = bottomPosition.x;\n                positions[positionIndex++] = bottomPosition.y;\n                positions[positionIndex++] = bottomPosition.z;\n\n                // insert the upper point\n                positions[positionIndex++] = topPosition.x;\n                positions[positionIndex++] = topPosition.y;\n                positions[positionIndex++] = topPosition.z;\n            }\n\n            if (vertexFormat.st) {\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 0.0;\n\n                textureCoordinates[stIndex++] = s;\n                textureCoordinates[stIndex++] = 1.0;\n            }\n\n            if (vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\n                var nextPosition;\n                var nextTop = Cartesian3.clone(Cartesian3.ZERO, scratchCartesian3Position5);\n                var groundPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position2), scratchCartesian3Position2);\n                if (i + 1 < length) {\n                    nextPosition = ellipsoid.scaleToGeodeticSurface(Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position3), scratchCartesian3Position3);\n                    nextTop = Cartesian3.fromArray(topPositions, i3 + 3, scratchCartesian3Position5);\n                }\n\n                if (recomputeNormal) {\n                    var scalednextPosition = Cartesian3.subtract(nextTop, topPosition, scratchCartesian3Position4);\n                    var scaledGroundPosition = Cartesian3.subtract(groundPosition, topPosition, scratchCartesian3Position1);\n                    normal = Cartesian3.normalize(Cartesian3.cross(scaledGroundPosition, scalednextPosition, normal), normal);\n                    recomputeNormal = false;\n                }\n\n                if (Cartesian3.equalsEpsilon(nextPosition, groundPosition, CesiumMath.EPSILON10)) {\n                    recomputeNormal = true;\n                } else {\n                    s += ds;\n                    if (vertexFormat.tangent) {\n                        tangent = Cartesian3.normalize(Cartesian3.subtract(nextPosition, groundPosition, tangent), tangent);\n                    }\n                    if (vertexFormat.bitangent) {\n                        bitangent = Cartesian3.normalize(Cartesian3.cross(normal, tangent, bitangent), bitangent);\n                    }\n                }\n\n                if (vertexFormat.normal) {\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n\n                    normals[normalIndex++] = normal.x;\n                    normals[normalIndex++] = normal.y;\n                    normals[normalIndex++] = normal.z;\n                }\n\n                if (vertexFormat.tangent) {\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n\n                    tangents[tangentIndex++] = tangent.x;\n                    tangents[tangentIndex++] = tangent.y;\n                    tangents[tangentIndex++] = tangent.z;\n                }\n\n                if (vertexFormat.bitangent) {\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n\n                    bitangents[bitangentIndex++] = bitangent.x;\n                    bitangents[bitangentIndex++] = bitangent.y;\n                    bitangents[bitangentIndex++] = bitangent.z;\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        if (vertexFormat.position) {\n            attributes.position = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            });\n        }\n\n        if (vertexFormat.normal) {\n            attributes.normal = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : normals\n            });\n        }\n\n        if (vertexFormat.tangent) {\n            attributes.tangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : tangents\n            });\n        }\n\n        if (vertexFormat.bitangent) {\n            attributes.bitangent = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 3,\n                values : bitangents\n            });\n        }\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : textureCoordinates\n            });\n        }\n\n        // prepare the side walls, two triangles for each wall\n        //\n        //    A (i+1)  B (i+3) E\n        //    +--------+-------+\n        //    |      / |      /|    triangles:  A C B\n        //    |     /  |     / |                B C D\n        //    |    /   |    /  |\n        //    |   /    |   /   |\n        //    |  /     |  /    |\n        //    | /      | /     |\n        //    +--------+-------+\n        //    C (i)    D (i+2) F\n        //\n\n        var numVertices = size / 3;\n        size -= 6 * (numCorners + 1);\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\n\n    return WallGeometry;\n});\n","define([\n        './BoundingSphere',\n        './Cartesian3',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './IndexDatatype',\n        './Math',\n        './PrimitiveType',\n        './WallGeometryLibrary'\n    ], function(\n        BoundingSphere,\n        Cartesian3,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        IndexDatatype,\n        CesiumMath,\n        PrimitiveType,\n        WallGeometryLibrary) {\n    'use strict';\n\n    var scratchCartesian3Position1 = new Cartesian3();\n    var scratchCartesian3Position2 = new Cartesian3();\n\n    /**\n     * A description of a wall outline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @alias WallOutlineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\n     * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     *\n     * @exception {DeveloperError} positions length must be greater than or equal to 2.\n     * @exception {DeveloperError} positions and maximumHeights must have the same length.\n     * @exception {DeveloperError} positions and minimumHeights must have the same length.\n     *\n     * @see WallGeometry#createGeometry\n     * @see WallGeometry#fromConstantHeight\n     *\n     * @example\n     * // create a wall outline that spans from ground level to 10000 meters\n     * var wall = new Cesium.WallOutlineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([\n     *     19.0, 47.0, 10000.0,\n     *     19.0, 48.0, 10000.0,\n     *     20.0, 48.0, 10000.0,\n     *     20.0, 47.0, 10000.0,\n     *     19.0, 47.0, 10000.0\n     *   ])\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     */\n    function WallOutlineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n        var wallPositions = options.positions;\n        var maximumHeights = options.maximumHeights;\n        var minimumHeights = options.minimumHeights;\n\n        \n\n        var granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        var ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n        this._positions = wallPositions;\n        this._minimumHeights = minimumHeights;\n        this._maximumHeights = maximumHeights;\n        this._granularity = granularity;\n        this._ellipsoid = Ellipsoid.clone(ellipsoid);\n        this._workerName = 'createWallOutlineGeometry';\n\n        var numComponents = 1 + wallPositions.length * Cartesian3.packedLength + 2;\n        if (defined(minimumHeights)) {\n            numComponents += minimumHeights.length;\n        }\n        if (defined(maximumHeights)) {\n            numComponents += maximumHeights.length;\n        }\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + 1;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {WallOutlineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    WallOutlineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var minimumHeights = value._minimumHeights;\n        length = defined(minimumHeights) ? minimumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(minimumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = minimumHeights[i];\n            }\n        }\n\n        var maximumHeights = value._maximumHeights;\n        length = defined(maximumHeights) ? maximumHeights.length : 0;\n        array[startingIndex++] = length;\n\n        if (defined(maximumHeights)) {\n            for (i = 0; i < length; ++i) {\n                array[startingIndex++] = maximumHeights[i];\n            }\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchOptions = {\n        positions : undefined,\n        minimumHeights : undefined,\n        maximumHeights : undefined,\n        ellipsoid : scratchEllipsoid,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {WallOutlineGeometry} [result] The object into which to store the result.\n     * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.\n     */\n    WallOutlineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var minimumHeights;\n\n        if (length > 0) {\n            minimumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                minimumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        length = array[startingIndex++];\n        var maximumHeights;\n\n        if (length > 0) {\n            maximumHeights = new Array(length);\n            for (i = 0; i < length; ++i) {\n                maximumHeights[i] = array[startingIndex++];\n            }\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.minimumHeights = minimumHeights;\n            scratchOptions.maximumHeights = maximumHeights;\n            scratchOptions.granularity = granularity;\n            return new WallOutlineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._minimumHeights = minimumHeights;\n        result._maximumHeights = maximumHeights;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    /**\n     * A description of a walloutline. A wall is defined by a series of points,\n     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.\n     * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the\n     *        wall at <code>positions</code>. If undefined, the height of each position in used.\n     * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the\n     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation\n     * @returns {WallOutlineGeometry}\n     *\n     *\n     * @example\n     * // create a wall that spans from 10000 meters to 20000 meters\n     * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     19.0, 47.0,\n     *     19.0, 48.0,\n     *     20.0, 48.0,\n     *     20.0, 47.0,\n     *     19.0, 47.0,\n     *   ]),\n     *   minimumHeight : 20000.0,\n     *   maximumHeight : 10000.0\n     * });\n     * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);\n     *\n     * @see WallOutlineGeometry#createGeometry\n     */\n    WallOutlineGeometry.fromConstantHeights = function(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n\n        \n\n        var minHeights;\n        var maxHeights;\n\n        var min = options.minimumHeight;\n        var max = options.maximumHeight;\n\n        var doMin = defined(min);\n        var doMax = defined(max);\n        if (doMin || doMax) {\n            var length = positions.length;\n            minHeights = (doMin) ? new Array(length) : undefined;\n            maxHeights = (doMax) ? new Array(length) : undefined;\n\n            for (var i = 0; i < length; ++i) {\n                if (doMin) {\n                    minHeights[i] = min;\n                }\n\n                if (doMax) {\n                    maxHeights[i] = max;\n                }\n            }\n        }\n\n        var newOptions = {\n            positions : positions,\n            maximumHeights : maxHeights,\n            minimumHeights : minHeights,\n            ellipsoid : options.ellipsoid\n        };\n        return new WallOutlineGeometry(newOptions);\n    };\n\n    /**\n     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    WallOutlineGeometry.createGeometry = function(wallGeometry) {\n        var wallPositions = wallGeometry._positions;\n        var minimumHeights = wallGeometry._minimumHeights;\n        var maximumHeights = wallGeometry._maximumHeights;\n        var granularity = wallGeometry._granularity;\n        var ellipsoid = wallGeometry._ellipsoid;\n\n        var pos = WallGeometryLibrary.computePositions(ellipsoid, wallPositions, maximumHeights, minimumHeights, granularity, false);\n        if (!defined(pos)) {\n            return;\n        }\n\n        var bottomPositions = pos.bottomPositions;\n        var topPositions = pos.topPositions;\n\n        var length = topPositions.length;\n        var size = length * 2;\n\n        var positions = new Float64Array(size);\n        var positionIndex = 0;\n\n        // add lower and upper points one after the other, lower\n        // points being even and upper points being odd\n        length /= 3;\n        var i;\n        for (i = 0; i < length; ++i) {\n            var i3 = i * 3;\n            var topPosition = Cartesian3.fromArray(topPositions, i3, scratchCartesian3Position1);\n            var bottomPosition = Cartesian3.fromArray(bottomPositions, i3, scratchCartesian3Position2);\n\n            // insert the lower point\n            positions[positionIndex++] = bottomPosition.x;\n            positions[positionIndex++] = bottomPosition.y;\n            positions[positionIndex++] = bottomPosition.z;\n\n            // insert the upper point\n            positions[positionIndex++] = topPosition.x;\n            positions[positionIndex++] = topPosition.y;\n            positions[positionIndex++] = topPosition.z;\n        }\n\n        var attributes = new GeometryAttributes({\n            position : new GeometryAttribute({\n                componentDatatype : ComponentDatatype.DOUBLE,\n                componentsPerAttribute : 3,\n                values : positions\n            })\n        });\n\n        var numVertices = size / 3;\n        size = 2 * numVertices - 4 + numVertices;\n        var indices = IndexDatatype.createTypedArray(numVertices, size);\n\n        var edgeIndex = 0;\n        for (i = 0; i < numVertices - 2; i += 2) {\n            var LL = i;\n            var LR = i + 2;\n            var pl = Cartesian3.fromArray(positions, LL * 3, scratchCartesian3Position1);\n            var pr = Cartesian3.fromArray(positions, LR * 3, scratchCartesian3Position2);\n            if (Cartesian3.equalsEpsilon(pl, pr, CesiumMath.EPSILON10)) {\n                continue;\n            }\n            var UL = i + 1;\n            var UR = i + 3;\n\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = UL;\n            indices[edgeIndex++] = UR;\n            indices[edgeIndex++] = LL;\n            indices[edgeIndex++] = LR;\n        }\n\n        indices[edgeIndex++] = numVertices - 2;\n        indices[edgeIndex++] = numVertices - 1;\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.LINES,\n            boundingSphere : new BoundingSphere.fromVertices(positions)\n        });\n    };\n\n    return WallOutlineGeometry;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Cartesian2',\n        '../Core/Cartesian3',\n        '../Core/Color',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayCondition',\n        '../Core/NearFarScalar',\n        '../Scene/HeightReference',\n        '../Scene/HorizontalOrigin',\n        '../Scene/LabelStyle',\n        '../Scene/VerticalOrigin',\n        './BoundingSphereState',\n        './Property'\n    ], function(\n        AssociativeArray,\n        Cartesian2,\n        Cartesian3,\n        Color,\n        defaultValue,\n        defined,\n        destroyObject,\n        DeveloperError,\n        DistanceDisplayCondition,\n        NearFarScalar,\n        HeightReference,\n        HorizontalOrigin,\n        LabelStyle,\n        VerticalOrigin,\n        BoundingSphereState,\n        Property) {\n    'use strict';\n\n    var defaultScale = 1.0;\n    var defaultFont = '30px sans-serif';\n    var defaultStyle = LabelStyle.FILL;\n    var defaultFillColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 1.0;\n    var defaultShowBackground = false;\n    var defaultBackgroundColor = new Color(0.165, 0.165, 0.165, 0.8);\n    var defaultBackgroundPadding = new Cartesian2(7, 5);\n    var defaultPixelOffset = Cartesian2.ZERO;\n    var defaultEyeOffset = Cartesian3.ZERO;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultHorizontalOrigin = HorizontalOrigin.CENTER;\n    var defaultVerticalOrigin = VerticalOrigin.CENTER;\n\n    var positionScratch = new Cartesian3();\n    var fillColorScratch = new Color();\n    var outlineColorScratch = new Color();\n    var backgroundColorScratch = new Color();\n    var backgroundPaddingScratch = new Cartesian2();\n    var eyeOffsetScratch = new Cartesian3();\n    var pixelOffsetScratch = new Cartesian2();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var pixelOffsetScaleByDistanceScratch = new NearFarScalar();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.label = undefined;\n        this.index = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps the {@link LabelGraphics} instance\n     * in {@link Entity#label} to a {@link Label}.\n     * @alias LabelVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function LabelVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    LabelVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var labelGraphics = entity._label;\n            var text;\n            var label = item.label;\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(labelGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                text = Property.getValueOrUndefined(labelGraphics._text, time);\n                show = defined(position) && defined(text);\n            }\n\n            if (!show) {\n                //don't bother creating or updating anything else\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var updateClamping = false;\n            var heightReference = Property.getValueOrDefault(labelGraphics._heightReference, time, defaultHeightReference);\n\n            if (!defined(label)) {\n                label = cluster.getLabel(entity);\n                label.id = entity;\n                item.label = label;\n\n                // If this new label happens to have a position and height reference that match our new values,\n                // label._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(label.position, position) && label.heightReference === heightReference;\n            }\n\n            label.show = true;\n            label.position = position;\n            label.text = text;\n            label.scale = Property.getValueOrDefault(labelGraphics._scale, time, defaultScale);\n            label.font = Property.getValueOrDefault(labelGraphics._font, time, defaultFont);\n            label.style = Property.getValueOrDefault(labelGraphics._style, time, defaultStyle);\n            label.fillColor = Property.getValueOrDefault(labelGraphics._fillColor, time, defaultFillColor, fillColorScratch);\n            label.outlineColor = Property.getValueOrDefault(labelGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n            label.outlineWidth = Property.getValueOrDefault(labelGraphics._outlineWidth, time, defaultOutlineWidth);\n            label.showBackground = Property.getValueOrDefault(labelGraphics._showBackground, time, defaultShowBackground);\n            label.backgroundColor = Property.getValueOrDefault(labelGraphics._backgroundColor, time, defaultBackgroundColor, backgroundColorScratch);\n            label.backgroundPadding = Property.getValueOrDefault(labelGraphics._backgroundPadding, time, defaultBackgroundPadding, backgroundPaddingScratch);\n            label.pixelOffset = Property.getValueOrDefault(labelGraphics._pixelOffset, time, defaultPixelOffset, pixelOffsetScratch);\n            label.eyeOffset = Property.getValueOrDefault(labelGraphics._eyeOffset, time, defaultEyeOffset, eyeOffsetScratch);\n            label.heightReference = heightReference;\n            label.horizontalOrigin = Property.getValueOrDefault(labelGraphics._horizontalOrigin, time, defaultHorizontalOrigin);\n            label.verticalOrigin = Property.getValueOrDefault(labelGraphics._verticalOrigin, time, defaultVerticalOrigin);\n            label.translucencyByDistance = Property.getValueOrUndefined(labelGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n            label.pixelOffsetScaleByDistance = Property.getValueOrUndefined(labelGraphics._pixelOffsetScaleByDistance, time, pixelOffsetScaleByDistanceScratch);\n            label.scaleByDistance = Property.getValueOrUndefined(labelGraphics._scaleByDistance, time, scaleByDistanceScratch);\n            label.distanceDisplayCondition = Property.getValueOrUndefined(labelGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n            label.disableDepthTestDistance = Property.getValueOrUndefined(labelGraphics._disableDepthTestDistance, time);\n\n            if (updateClamping) {\n                label._updateClamping();\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    LabelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !defined(item.label)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var label = item.label;\n        result.center = Cartesian3.clone(defaultValue(label._clampedPosition, label.position), result.center);\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    LabelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    LabelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removeLabel(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    LabelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._label) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            item.label = undefined;\n            cluster.removeLabel(entity);\n        }\n    }\n\n    return LabelVisualizer;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/BoundingSphere',\n        '../Core/Cartesian2',\n        '../Core/Color',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/Matrix4',\n        '../Core/Resource',\n        '../Scene/Axis',\n        '../Scene/ColorBlendMode',\n        '../Scene/HeightReference',\n        '../Scene/Model',\n        '../Scene/ModelAnimationLoop',\n        '../Scene/ShadowMode',\n        './BoundingSphereState',\n        './Property'\n    ], function(\n        AssociativeArray,\n        BoundingSphere,\n        Cartesian2,\n        Color,\n        defined,\n        destroyObject,\n        DeveloperError,\n        Matrix4,\n        Resource,\n        Axis,\n        ColorBlendMode,\n        HeightReference,\n        Model,\n        ModelAnimationLoop,\n        ShadowMode,\n        BoundingSphereState,\n        Property) {\n    'use strict';\n\n    var defaultScale = 1.0;\n    var defaultMinimumPixelSize = 0.0;\n    var defaultIncrementallyLoadTextures = true;\n    var defaultClampAnimations = true;\n    var defaultShadows = ShadowMode.ENABLED;\n    var defaultHeightReference = HeightReference.NONE;\n    var defaultSilhouetteColor = Color.RED;\n    var defaultSilhouetteSize = 0.0;\n    var defaultColor = Color.WHITE;\n    var defaultColorBlendMode = ColorBlendMode.HIGHLIGHT;\n    var defaultColorBlendAmount = 0.5;\n    var defaultImageBasedLightingFactor = new Cartesian2(1.0, 1.0);\n    var defaultUpAxis = Axis.Y;\n\n    var modelMatrixScratch = new Matrix4();\n    var nodeMatrixScratch = new Matrix4();\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.\n     * @alias ModelVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function ModelVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._primitives = scene.primitives;\n        this._entityCollection = entityCollection;\n        this._modelHash = {};\n        this._entitiesToVisualize = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates models created this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    ModelVisualizer.prototype.update = function(time) {\n        \n\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (var i = 0, len = entities.length; i < len; i++) {\n            var entity = entities[i];\n            var modelGraphics = entity._model;\n\n            var resource;\n            var modelData = modelHash[entity.id];\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(modelGraphics._show, time, true);\n\n            var modelMatrix;\n            if (show) {\n                modelMatrix = entity.computeModelMatrix(time, modelMatrixScratch);\n                resource = Resource.createIfNeeded(Property.getValueOrUndefined(modelGraphics._uri, time));\n                show = defined(modelMatrix) && defined(resource);\n            }\n\n            if (!show) {\n                if (defined(modelData)) {\n                    modelData.modelPrimitive.show = false;\n                }\n                continue;\n            }\n\n            var model = defined(modelData) ? modelData.modelPrimitive : undefined;\n            if (!defined(model) || resource.url !== modelData.url) {\n                if (defined(model)) {\n                    primitives.removeAndDestroy(model);\n                    delete modelHash[entity.id];\n                }\n                model = Model.fromGltf({\n                    url : resource,\n                    incrementallyLoadTextures : Property.getValueOrDefault(modelGraphics._incrementallyLoadTextures, time, defaultIncrementallyLoadTextures),\n                    scene : this._scene\n                });\n                model.id = entity;\n                primitives.add(model);\n\n                modelData = {\n                    modelPrimitive : model,\n                    url : resource.url,\n                    animationsRunning : false,\n                    nodeTransformationsScratch : {},\n                    articulationsScratch : {},\n                    loadFail : false\n                };\n                modelHash[entity.id] = modelData;\n\n                checkModelLoad(model, entity, modelHash);\n            }\n\n            model.show = true;\n            model.scale = Property.getValueOrDefault(modelGraphics._scale, time, defaultScale);\n            model.minimumPixelSize = Property.getValueOrDefault(modelGraphics._minimumPixelSize, time, defaultMinimumPixelSize);\n            model.maximumScale = Property.getValueOrUndefined(modelGraphics._maximumScale, time);\n            model.modelMatrix = Matrix4.clone(modelMatrix, model.modelMatrix);\n            model.shadows = Property.getValueOrDefault(modelGraphics._shadows, time, defaultShadows);\n            model.heightReference = Property.getValueOrDefault(modelGraphics._heightReference, time, defaultHeightReference);\n            model.distanceDisplayCondition = Property.getValueOrUndefined(modelGraphics._distanceDisplayCondition, time);\n            model.silhouetteColor = Property.getValueOrDefault(modelGraphics._silhouetteColor, time, defaultSilhouetteColor, model._silhouetteColor);\n            model.silhouetteSize = Property.getValueOrDefault(modelGraphics._silhouetteSize, time, defaultSilhouetteSize);\n            model.color = Property.getValueOrDefault(modelGraphics._color, time, defaultColor, model._color);\n            model.colorBlendMode = Property.getValueOrDefault(modelGraphics._colorBlendMode, time, defaultColorBlendMode);\n            model.colorBlendAmount = Property.getValueOrDefault(modelGraphics._colorBlendAmount, time, defaultColorBlendAmount);\n            model.clippingPlanes = Property.getValueOrUndefined(modelGraphics._clippingPlanes, time);\n            model.clampAnimations = Property.getValueOrDefault(modelGraphics._clampAnimations, time, defaultClampAnimations);\n            model.imageBasedLightingFactor = Property.getValueOrDefault(modelGraphics._imageBasedLightingFactor, time, defaultImageBasedLightingFactor);\n            model.lightColor = Property.getValueOrUndefined(modelGraphics._lightColor, time);\n            model._upAxis = Property.getValueOrDefault(modelGraphics._upAxis, time, defaultUpAxis);\n            model._forwardAxis = Property.getValueOrUndefined(modelGraphics._forwardAxis, time);\n\n            if (model.ready) {\n                var runAnimations = Property.getValueOrDefault(modelGraphics._runAnimations, time, true);\n                if (modelData.animationsRunning !== runAnimations) {\n                    if (runAnimations) {\n                        model.activeAnimations.addAll({\n                            loop : ModelAnimationLoop.REPEAT\n                        });\n                    } else {\n                        model.activeAnimations.removeAll();\n                    }\n                    modelData.animationsRunning = runAnimations;\n                }\n\n                // Apply node transformations\n                var nodeTransformations = Property.getValueOrUndefined(modelGraphics._nodeTransformations, time, modelData.nodeTransformationsScratch);\n                if (defined(nodeTransformations)) {\n                    var nodeNames = Object.keys(nodeTransformations);\n                    for (var nodeIndex = 0, nodeLength = nodeNames.length; nodeIndex < nodeLength; ++nodeIndex) {\n                        var nodeName = nodeNames[nodeIndex];\n\n                        var nodeTransformation = nodeTransformations[nodeName];\n                        if (!defined(nodeTransformation)) {\n                            continue;\n                        }\n\n                        var modelNode = model.getNode(nodeName);\n                        if (!defined(modelNode)) {\n                            continue;\n                        }\n\n                        var transformationMatrix = Matrix4.fromTranslationRotationScale(nodeTransformation, nodeMatrixScratch);\n                        modelNode.matrix = Matrix4.multiply(modelNode.originalMatrix, transformationMatrix, transformationMatrix);\n                    }\n                }\n\n                // Apply articulations\n                var anyArticulationUpdated = false;\n                var articulations = Property.getValueOrUndefined(modelGraphics._articulations, time, modelData.articulationsScratch);\n                if (defined(articulations)) {\n                    var articulationStageKeys = Object.keys(articulations);\n                    for (var s = 0, numKeys = articulationStageKeys.length; s < numKeys; ++s) {\n                        var key = articulationStageKeys[s];\n\n                        var articulationStageValue = articulations[key];\n                        if (!defined(articulationStageValue)) {\n                            continue;\n                        }\n\n                        anyArticulationUpdated = true;\n                        model.setArticulationStage(key, articulationStageValue);\n                    }\n                }\n\n                if (anyArticulationUpdated) {\n                    model.applyArticulations();\n                }\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    ModelVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    ModelVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entitiesToVisualize.values;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n        for (var i = entities.length - 1; i > -1; i--) {\n            removeModel(this, entities[i], modelHash, primitives);\n        }\n        return destroyObject(this);\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    ModelVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var modelData = this._modelHash[entity.id];\n        if (!defined(modelData) || modelData.loadFail) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var model = modelData.modelPrimitive;\n        if (!defined(model) || !model.show) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (!model.ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        if (model.heightReference === HeightReference.NONE) {\n            BoundingSphere.transform(model.boundingSphere, model.modelMatrix, result);\n        } else {\n            if (!defined(model._clampedModelMatrix) || model._heightChanged) {\n                return BoundingSphereState.PENDING;\n            }\n            BoundingSphere.transform(model.boundingSphere, model._clampedModelMatrix, result);\n        }\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * @private\n     */\n    ModelVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var entities = this._entitiesToVisualize;\n        var modelHash = this._modelHash;\n        var primitives = this._primitives;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                entities.set(entity.id, entity);\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._model) && defined(entity._position)) {\n                clearNodeTransformationsArticulationsScratch(entity, modelHash);\n                entities.set(entity.id, entity);\n            } else {\n                removeModel(this, entity, modelHash, primitives);\n                entities.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            removeModel(this, entity, modelHash, primitives);\n            entities.remove(entity.id);\n        }\n    };\n\n    function removeModel(visualizer, entity, modelHash, primitives) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            primitives.removeAndDestroy(modelData.modelPrimitive);\n            delete modelHash[entity.id];\n        }\n    }\n\n    function clearNodeTransformationsArticulationsScratch(entity, modelHash) {\n        var modelData = modelHash[entity.id];\n        if (defined(modelData)) {\n            modelData.nodeTransformationsScratch = {};\n            modelData.articulationsScratch = {};\n        }\n    }\n\n    function checkModelLoad(model, entity, modelHash){\n        model.readyPromise.otherwise(function(error){\n            console.error(error);\n            modelHash[entity.id].loadFail = true;\n        });\n    }\n\n    return ModelVisualizer;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Cartesian3',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/JulianDate',\n        '../Core/Matrix3',\n        '../Core/Matrix4',\n        '../Core/ReferenceFrame',\n        '../Core/TimeInterval',\n        '../Core/Transforms',\n        '../Scene/PolylineCollection',\n        '../Scene/SceneMode',\n        './CompositePositionProperty',\n        './ConstantPositionProperty',\n        './MaterialProperty',\n        './Property',\n        './ReferenceProperty',\n        './SampledPositionProperty',\n        './ScaledPositionProperty',\n        './TimeIntervalCollectionPositionProperty'\n    ], function(\n        AssociativeArray,\n        Cartesian3,\n        defined,\n        destroyObject,\n        DeveloperError,\n        JulianDate,\n        Matrix3,\n        Matrix4,\n        ReferenceFrame,\n        TimeInterval,\n        Transforms,\n        PolylineCollection,\n        SceneMode,\n        CompositePositionProperty,\n        ConstantPositionProperty,\n        MaterialProperty,\n        Property,\n        ReferenceProperty,\n        SampledPositionProperty,\n        ScaledPositionProperty,\n        TimeIntervalCollectionPositionProperty) {\n    'use strict';\n\n    var defaultResolution = 60.0;\n    var defaultWidth = 1.0;\n\n    var scratchTimeInterval = new TimeInterval();\n    var subSampleCompositePropertyScratch = new TimeInterval();\n    var subSampleIntervalPropertyScratch = new TimeInterval();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.polyline = undefined;\n        this.index = undefined;\n        this.updater = undefined;\n    }\n\n    function subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var r = startingIndex;\n        //Always step exactly on start (but only use it if it exists.)\n        var tmp;\n        tmp = property.getValueInReferenceFrame(start, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n\n        //Iterate over all interval times and add the ones that fall in our\n        //time range.  Note that times can contain data outside of\n        //the intervals range.  This is by design for use with interpolation.\n        var t = 0;\n        var len = times.length;\n        var current = times[t];\n        var loopStop = stop;\n        var sampling = false;\n        var sampleStepsToTake;\n        var sampleStepsTaken;\n        var sampleStepSize;\n\n        while (t < len) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(current, updateTime)) {\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n                steppedOnNow = true;\n            }\n            if (JulianDate.greaterThan(current, start) && JulianDate.lessThan(current, loopStop) && !current.equals(updateTime)) {\n                tmp = property.getValueInReferenceFrame(current, referenceFrame, result[r]);\n                if (defined(tmp)) {\n                    result[r++] = tmp;\n                }\n            }\n\n            if (t < (len - 1)) {\n                if (maximumStep > 0 && !sampling) {\n                    var next = times[t + 1];\n                    var secondsUntilNext = JulianDate.secondsDifference(next, current);\n                    sampling = secondsUntilNext > maximumStep;\n\n                    if (sampling) {\n                        sampleStepsToTake = Math.ceil(secondsUntilNext / maximumStep);\n                        sampleStepsTaken = 0;\n                        sampleStepSize = secondsUntilNext / Math.max(sampleStepsToTake, 2);\n                        sampleStepsToTake = Math.max(sampleStepsToTake - 1, 1);\n                    }\n                }\n\n                if (sampling && sampleStepsTaken < sampleStepsToTake) {\n                    current = JulianDate.addSeconds(current, sampleStepSize, new JulianDate());\n                    sampleStepsTaken++;\n                    continue;\n                }\n            }\n            sampling = false;\n            t++;\n            current = times[t];\n        }\n\n        //Always step exactly on stop (but only use it if it exists.)\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[r]);\n        if (defined(tmp)) {\n            result[r++] = tmp;\n        }\n\n        return r;\n    }\n\n    function subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp;\n        var i = 0;\n        var index = startingIndex;\n        var time = start;\n        var stepSize = Math.max(maximumStep, 60);\n        var steppedOnNow = !defined(updateTime) || JulianDate.lessThanOrEquals(updateTime, start) || JulianDate.greaterThanOrEquals(updateTime, stop);\n        while (JulianDate.lessThan(time, stop)) {\n            if (!steppedOnNow && JulianDate.greaterThanOrEquals(time, updateTime)) {\n                steppedOnNow = true;\n                tmp = property.getValueInReferenceFrame(updateTime, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n            tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n            if (defined(tmp)) {\n                result[index] = tmp;\n                index++;\n            }\n            i++;\n            time = JulianDate.addSeconds(start, stepSize * i, new JulianDate());\n        }\n        //Always sample stop.\n        tmp = property.getValueInReferenceFrame(stop, referenceFrame, result[index]);\n        if (defined(tmp)) {\n            result[index] = tmp;\n            index++;\n        }\n        return index;\n    }\n\n    function subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleIntervalPropertyScratch.start = start;\n        subSampleIntervalPropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleIntervalPropertyScratch, scratchTimeInterval).isEmpty) {\n                var time = interval.start;\n                if (!interval.isStartIncluded) {\n                    if (interval.isStopIncluded) {\n                        time = interval.stop;\n                    } else {\n                        time = JulianDate.addSeconds(interval.start, JulianDate.secondsDifference(interval.stop, interval.start) / 2, new JulianDate());\n                    }\n                }\n                var tmp = property.getValueInReferenceFrame(time, referenceFrame, result[index]);\n                if (defined(tmp)) {\n                    result[index] = tmp;\n                    index++;\n                }\n            }\n        }\n        return index;\n    }\n\n    function subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        var tmp = property.getValueInReferenceFrame(start, referenceFrame, result[startingIndex]);\n        if (defined(tmp)) {\n            result[startingIndex++] = tmp;\n        }\n        return startingIndex;\n    }\n\n    function subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, startingIndex, result) {\n        subSampleCompositePropertyScratch.start = start;\n        subSampleCompositePropertyScratch.stop = stop;\n\n        var index = startingIndex;\n        var intervals = property.intervals;\n        for (var i = 0; i < intervals.length; i++) {\n            var interval = intervals.get(i);\n            if (!TimeInterval.intersect(interval, subSampleCompositePropertyScratch, scratchTimeInterval).isEmpty) {\n                var intervalStart = interval.start;\n                var intervalStop = interval.stop;\n\n                var sampleStart = start;\n                if (JulianDate.greaterThan(intervalStart, sampleStart)) {\n                    sampleStart = intervalStart;\n                }\n\n                var sampleStop = stop;\n                if (JulianDate.lessThan(intervalStop, sampleStop)) {\n                    sampleStop = intervalStop;\n                }\n\n                index = reallySubSample(interval.data, sampleStart, sampleStop, updateTime, referenceFrame, maximumStep, index, result);\n            }\n        }\n        return index;\n    }\n\n    function reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, index, result) {\n        //Unwrap any references until we have the actual property.\n        while (property instanceof ReferenceProperty) {\n            property = property.resolvedProperty;\n        }\n\n        if (property instanceof SampledPositionProperty) {\n            var times = property._property._times;\n            index = subSampleSampledProperty(property, start, stop, times, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof CompositePositionProperty) {\n            index = subSampleCompositeProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof TimeIntervalCollectionPositionProperty) {\n            index = subSampleIntervalProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else if (property instanceof ConstantPositionProperty ||\n                   (property instanceof ScaledPositionProperty && Property.isConstant(property))) {\n            index = subSampleConstantProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        } else {\n            //Fallback to generic sampling.\n            index = subSampleGenericProperty(property, start, stop, updateTime, referenceFrame, maximumStep, index, result);\n        }\n        return index;\n    }\n\n    function subSample(property, start, stop, updateTime, referenceFrame, maximumStep, result) {\n        if (!defined(result)) {\n            result = [];\n        }\n\n        var length = reallySubSample(property, start, stop, updateTime, referenceFrame, maximumStep, 0, result);\n        result.length = length;\n        return result;\n    }\n\n    var toFixedScratch = new Matrix3();\n    function PolylineUpdater(scene, referenceFrame) {\n        this._unusedIndexes = [];\n        this._polylineCollection = new PolylineCollection();\n        this._scene = scene;\n        this._referenceFrame = referenceFrame;\n        scene.primitives.add(this._polylineCollection);\n    }\n\n    PolylineUpdater.prototype.update = function(time) {\n        if (this._referenceFrame === ReferenceFrame.INERTIAL) {\n            var toFixed = Transforms.computeIcrfToFixedMatrix(time, toFixedScratch);\n            if (!defined(toFixed)) {\n                toFixed = Transforms.computeTemeToPseudoFixedMatrix(time, toFixedScratch);\n            }\n            Matrix4.fromRotationTranslation(toFixed, Cartesian3.ZERO, this._polylineCollection.modelMatrix);\n        }\n    };\n\n    PolylineUpdater.prototype.updateObject = function(time, item) {\n        var entity = item.entity;\n        var pathGraphics = entity._path;\n        var positionProperty = entity._position;\n\n        var sampleStart;\n        var sampleStop;\n        var showProperty = pathGraphics._show;\n        var polyline = item.polyline;\n        var show = entity.isShowing && (!defined(showProperty) || showProperty.getValue(time));\n\n        //While we want to show the path, there may not actually be anything to show\n        //depending on lead/trail settings.  Compute the interval of the path to\n        //show and check against actual availability.\n        if (show) {\n            var leadTime = Property.getValueOrUndefined(pathGraphics._leadTime, time);\n            var trailTime = Property.getValueOrUndefined(pathGraphics._trailTime, time);\n            var availability = entity._availability;\n            var hasAvailability = defined(availability);\n            var hasLeadTime = defined(leadTime);\n            var hasTrailTime = defined(trailTime);\n\n            //Objects need to have either defined availability or both a lead and trail time in order to\n            //draw a path (since we can't draw \"infinite\" paths.\n            show = hasAvailability || (hasLeadTime && hasTrailTime);\n\n            //The final step is to compute the actual start/stop times of the path to show.\n            //If current time is outside of the availability interval, there's a chance that\n            //we won't have to draw anything anyway.\n            if (show) {\n                if (hasTrailTime) {\n                    sampleStart = JulianDate.addSeconds(time, -trailTime, new JulianDate());\n                }\n                if (hasLeadTime) {\n                    sampleStop = JulianDate.addSeconds(time, leadTime, new JulianDate());\n                }\n\n                if (hasAvailability) {\n                    var start = availability.start;\n                    var stop = availability.stop;\n\n                    if (!hasTrailTime || JulianDate.greaterThan(start, sampleStart)) {\n                        sampleStart = start;\n                    }\n\n                    if (!hasLeadTime || JulianDate.lessThan(stop, sampleStop)) {\n                        sampleStop = stop;\n                    }\n                }\n                show = JulianDate.lessThan(sampleStart, sampleStop);\n            }\n        }\n\n        if (!show) {\n            //don't bother creating or updating anything else\n            if (defined(polyline)) {\n                this._unusedIndexes.push(item.index);\n                item.polyline = undefined;\n                polyline.show = false;\n                item.index = undefined;\n            }\n            return;\n        }\n\n        if (!defined(polyline)) {\n            var unusedIndexes = this._unusedIndexes;\n            var length = unusedIndexes.length;\n            if (length > 0) {\n                var index = unusedIndexes.pop();\n                polyline = this._polylineCollection.get(index);\n                item.index = index;\n            } else {\n                item.index = this._polylineCollection.length;\n                polyline = this._polylineCollection.add();\n            }\n            polyline.id = entity;\n            item.polyline = polyline;\n        }\n\n        var resolution = Property.getValueOrDefault(pathGraphics._resolution, time, defaultResolution);\n\n        polyline.show = true;\n        polyline.positions = subSample(positionProperty, sampleStart, sampleStop, time, this._referenceFrame, resolution, polyline.positions.slice());\n        polyline.material = MaterialProperty.getValue(time, pathGraphics._material, polyline.material);\n        polyline.width = Property.getValueOrDefault(pathGraphics._width, time, defaultWidth);\n        polyline.distanceDisplayCondition = Property.getValueOrUndefined(pathGraphics._distanceDisplayCondition, time, polyline.distanceDisplayCondition);\n    };\n\n    PolylineUpdater.prototype.removeObject = function(item) {\n        var polyline = item.polyline;\n        if (defined(polyline)) {\n            this._unusedIndexes.push(item.index);\n            item.polyline = undefined;\n            polyline.show = false;\n            polyline.id = undefined;\n            item.index = undefined;\n        }\n    };\n\n    PolylineUpdater.prototype.destroy = function() {\n        this._scene.primitives.remove(this._polylineCollection);\n        return destroyObject(this);\n    };\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.\n     * @alias PathVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PathVisualizer(scene, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        this._scene = scene;\n        this._updaters = {};\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PathVisualizer.prototype.update = function(time) {\n        \n\n        var updaters = this._updaters;\n        for ( var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].update(time);\n            }\n        }\n\n        var items = this._items.values;\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var positionProperty = entity._position;\n\n            var lastUpdater = item.updater;\n\n            var frameToVisualize = ReferenceFrame.FIXED;\n            if (this._scene.mode === SceneMode.SCENE3D) {\n                frameToVisualize = positionProperty.referenceFrame;\n            }\n\n            var currentUpdater = this._updaters[frameToVisualize];\n\n            if ((lastUpdater === currentUpdater) && (defined(currentUpdater))) {\n                currentUpdater.updateObject(time, item);\n                continue;\n            }\n\n            if (defined(lastUpdater)) {\n                lastUpdater.removeObject(item);\n            }\n\n            if (!defined(currentUpdater)) {\n                currentUpdater = new PolylineUpdater(this._scene, frameToVisualize);\n                currentUpdater.update(time);\n                this._updaters[frameToVisualize] = currentUpdater;\n            }\n\n            item.updater = currentUpdater;\n            if (defined(currentUpdater)) {\n                currentUpdater.updateObject(time, item);\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PathVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PathVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged, this);\n\n        var updaters = this._updaters;\n        for ( var key in updaters) {\n            if (updaters.hasOwnProperty(key)) {\n                updaters[key].destroy();\n            }\n        }\n\n        return destroyObject(this);\n    };\n\n    PathVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var item;\n        var items = this._items;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._path) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                item = items.get(entity.id);\n                if (defined(item)) {\n                    if (defined(item.updater)) {\n                        item.updater.removeObject(item);\n                    }\n                    items.remove(entity.id);\n                }\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            item = items.get(entity.id);\n            if (defined(item)) {\n                if (defined(item.updater)) {\n                    item.updater.removeObject(item);\n                }\n                items.remove(entity.id);\n            }\n        }\n    };\n\n    //for testing\n    PathVisualizer._subSample = subSample;\n\n    return PathVisualizer;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/Cartesian3',\n        '../Core/Color',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayCondition',\n        '../Core/NearFarScalar',\n        '../Scene/createBillboardPointCallback',\n        '../Scene/HeightReference',\n        './BoundingSphereState',\n        './Property'\n    ], function(\n        AssociativeArray,\n        Cartesian3,\n        Color,\n        defined,\n        destroyObject,\n        DeveloperError,\n        DistanceDisplayCondition,\n        NearFarScalar,\n        createBillboardPointCallback,\n        HeightReference,\n        BoundingSphereState,\n        Property) {\n    'use strict';\n\n    var defaultColor = Color.WHITE;\n    var defaultOutlineColor = Color.BLACK;\n    var defaultOutlineWidth = 0.0;\n    var defaultPixelSize = 1.0;\n    var defaultDisableDepthTestDistance = 0.0;\n\n    var colorScratch = new Color();\n    var positionScratch = new Cartesian3();\n    var outlineColorScratch = new Color();\n    var scaleByDistanceScratch = new NearFarScalar();\n    var translucencyByDistanceScratch = new NearFarScalar();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n\n    function EntityData(entity) {\n        this.entity = entity;\n        this.pointPrimitive = undefined;\n        this.billboard = undefined;\n        this.color = undefined;\n        this.outlineColor = undefined;\n        this.pixelSize = undefined;\n        this.outlineWidth = undefined;\n    }\n\n    /**\n     * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.\n     * @alias PointVisualizer\n     * @constructor\n     *\n     * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     */\n    function PointVisualizer(entityCluster, entityCollection) {\n        \n\n        entityCollection.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n\n        this._cluster = entityCluster;\n        this._entityCollection = entityCollection;\n        this._items = new AssociativeArray();\n        this._onCollectionChanged(entityCollection, entityCollection.values, [], []);\n    }\n\n    /**\n     * Updates the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} This function always returns true.\n     */\n    PointVisualizer.prototype.update = function(time) {\n        \n\n        var items = this._items.values;\n        var cluster = this._cluster;\n        for (var i = 0, len = items.length; i < len; i++) {\n            var item = items[i];\n            var entity = item.entity;\n            var pointGraphics = entity._point;\n            var pointPrimitive = item.pointPrimitive;\n            var billboard = item.billboard;\n            var heightReference = Property.getValueOrDefault(pointGraphics._heightReference, time, HeightReference.NONE);\n            var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(pointGraphics._show, time, true);\n            var position;\n            if (show) {\n                position = Property.getValueOrUndefined(entity._position, time, positionScratch);\n                show = defined(position);\n            }\n            if (!show) {\n                returnPrimitive(item, entity, cluster);\n                continue;\n            }\n\n            if (!Property.isConstant(entity._position)) {\n                cluster._clusterDirty = true;\n            }\n\n            var needsRedraw = false;\n            var updateClamping = false;\n            if ((heightReference !== HeightReference.NONE) && !defined(billboard)) {\n                if (defined(pointPrimitive)) {\n                    returnPrimitive(item, entity, cluster);\n                    pointPrimitive = undefined;\n                }\n\n                billboard = cluster.getBillboard(entity);\n                billboard.id = entity;\n                billboard.image = undefined;\n                item.billboard = billboard;\n                needsRedraw = true;\n\n                // If this new billboard happens to have a position and height reference that match our new values,\n                // billboard._updateClamping will not be called automatically. That's a problem because the clamped\n                // height may be based on different terrain than is now loaded. So we'll manually call\n                // _updateClamping below.\n                updateClamping = Cartesian3.equals(billboard.position, position) && billboard.heightReference === heightReference;\n            } else if ((heightReference === HeightReference.NONE) && !defined(pointPrimitive)) {\n                if (defined(billboard)) {\n                    returnPrimitive(item, entity, cluster);\n                    billboard = undefined;\n                }\n\n                pointPrimitive = cluster.getPoint(entity);\n                pointPrimitive.id = entity;\n                item.pointPrimitive = pointPrimitive;\n            }\n\n            if (defined(pointPrimitive)) {\n                pointPrimitive.show = true;\n                pointPrimitive.position = position;\n                pointPrimitive.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                pointPrimitive.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                pointPrimitive.color = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                pointPrimitive.outlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                pointPrimitive.outlineWidth = Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth);\n                pointPrimitive.pixelSize = Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize);\n                pointPrimitive.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                pointPrimitive.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n            } else if (defined(billboard)) {\n                billboard.show = true;\n                billboard.position = position;\n                billboard.scaleByDistance = Property.getValueOrUndefined(pointGraphics._scaleByDistance, time, scaleByDistanceScratch);\n                billboard.translucencyByDistance = Property.getValueOrUndefined(pointGraphics._translucencyByDistance, time, translucencyByDistanceScratch);\n                billboard.distanceDisplayCondition = Property.getValueOrUndefined(pointGraphics._distanceDisplayCondition, time, distanceDisplayConditionScratch);\n                billboard.disableDepthTestDistance = Property.getValueOrDefault(pointGraphics._disableDepthTestDistance, time, defaultDisableDepthTestDistance);\n                billboard.heightReference = heightReference;\n\n                var newColor = Property.getValueOrDefault(pointGraphics._color, time, defaultColor, colorScratch);\n                var newOutlineColor = Property.getValueOrDefault(pointGraphics._outlineColor, time, defaultOutlineColor, outlineColorScratch);\n                var newOutlineWidth = Math.round(Property.getValueOrDefault(pointGraphics._outlineWidth, time, defaultOutlineWidth));\n                var newPixelSize = Math.max(1, Math.round(Property.getValueOrDefault(pointGraphics._pixelSize, time, defaultPixelSize)));\n\n                if (newOutlineWidth > 0) {\n                    billboard.scale = 1.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 newPixelSize !== item.pixelSize || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                } else {\n                    billboard.scale = newPixelSize / 50.0;\n                    newPixelSize = 50.0;\n                    needsRedraw = needsRedraw || //\n                                 newOutlineWidth !== item.outlineWidth || //\n                                 !Color.equals(newColor, item.color) || //\n                                 !Color.equals(newOutlineColor, item.outlineColor);\n                }\n\n                if (needsRedraw) {\n                    item.color = Color.clone(newColor, item.color);\n                    item.outlineColor = Color.clone(newOutlineColor, item.outlineColor);\n                    item.pixelSize = newPixelSize;\n                    item.outlineWidth = newOutlineWidth;\n\n                    var centerAlpha = newColor.alpha;\n                    var cssColor = newColor.toCssColorString();\n                    var cssOutlineColor = newOutlineColor.toCssColorString();\n                    var textureId = JSON.stringify([cssColor, newPixelSize, cssOutlineColor, newOutlineWidth]);\n\n                    billboard.setImage(textureId, createBillboardPointCallback(centerAlpha, cssColor, cssOutlineColor, newOutlineWidth, newPixelSize));\n                }\n\n                if (updateClamping) {\n                    billboard._updateClamping();\n                }\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PointVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var item = this._items.get(entity.id);\n        if (!defined(item) || !(defined(item.pointPrimitive) || defined(item.billboard))) {\n            return BoundingSphereState.FAILED;\n        }\n\n        if (defined(item.pointPrimitive)) {\n            result.center = Cartesian3.clone(item.pointPrimitive.position, result.center);\n        } else {\n            var billboard = item.billboard;\n            if (!defined(billboard._clampedPosition)) {\n                return BoundingSphereState.PENDING;\n            }\n            result.center = Cartesian3.clone(billboard._clampedPosition, result.center);\n        }\n\n        result.radius = 0;\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PointVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PointVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged, this);\n        var entities = this._entityCollection.values;\n        for (var i = 0; i < entities.length; i++) {\n            this._cluster.removePoint(entities[i]);\n        }\n        return destroyObject(this);\n    };\n\n    PointVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed, changed) {\n        var i;\n        var entity;\n        var items = this._items;\n        var cluster = this._cluster;\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                items.set(entity.id, new EntityData(entity));\n            }\n        }\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            if (defined(entity._point) && defined(entity._position)) {\n                if (!items.contains(entity.id)) {\n                    items.set(entity.id, new EntityData(entity));\n                }\n            } else {\n                returnPrimitive(items.get(entity.id), entity, cluster);\n                items.remove(entity.id);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            returnPrimitive(items.get(entity.id), entity, cluster);\n            items.remove(entity.id);\n        }\n    };\n\n    function returnPrimitive(item, entity, cluster) {\n        if (defined(item)) {\n            var pointPrimitive = item.pointPrimitive;\n            if (defined(pointPrimitive)) {\n                item.pointPrimitive = undefined;\n                cluster.removePoint(entity);\n                return;\n            }\n            var billboard = item.billboard;\n            if (defined(billboard)) {\n                item.billboard = undefined;\n                cluster.removeBillboard(entity);\n            }\n        }\n    }\n\n    return PointVisualizer;\n});\n","define([\n        '../Core/AssociativeArray',\n        '../Core/BoundingSphere',\n        '../Core/Check',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/destroyObject',\n        '../Scene/ClassificationType',\n        '../Scene/PolylineColorAppearance',\n        '../Scene/PolylineMaterialAppearance',\n        '../Scene/ShadowMode',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './DynamicGeometryBatch',\n        './PolylineGeometryUpdater',\n        './StaticGeometryColorBatch',\n        './StaticGeometryPerMaterialBatch',\n        './StaticGroundPolylinePerMaterialBatch'\n    ], function(\n        AssociativeArray,\n        BoundingSphere,\n        Check,\n        defaultValue,\n        defined,\n        destroyObject,\n        ClassificationType,\n        PolylineColorAppearance,\n        PolylineMaterialAppearance,\n        ShadowMode,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        DynamicGeometryBatch,\n        PolylineGeometryUpdater,\n        StaticGeometryColorBatch,\n        StaticGeometryPerMaterialBatch,\n        StaticGroundPolylinePerMaterialBatch) {\n    'use strict';\n\n    var emptyArray = [];\n\n    function removeUpdater(that, updater) {\n        //We don't keep track of which batch an updater is in, so just remove it from all of them.\n        var batches = that._batches;\n        var length = batches.length;\n        for (var i = 0; i < length; i++) {\n            batches[i].remove(updater);\n        }\n    }\n\n    function insertUpdaterIntoBatch(that, time, updater) {\n        if (updater.isDynamic) {\n            that._dynamicBatch.add(time, updater);\n            return;\n        }\n\n        if (updater.clampToGround && updater.fillEnabled) { // Also checks for support\n            var classificationType = updater.classificationTypeProperty.getValue(time);\n            that._groundBatches[classificationType].add(time, updater);\n            return;\n        }\n\n        var shadows;\n        if (updater.fillEnabled) {\n            shadows = updater.shadowsProperty.getValue(time);\n        }\n\n        var multiplier = 0;\n        if (defined(updater.depthFailMaterialProperty)) {\n            multiplier = updater.depthFailMaterialProperty instanceof ColorMaterialProperty ? 1 : 2;\n        }\n\n        var index;\n        if (defined(shadows)) {\n            index = shadows + multiplier * ShadowMode.NUMBER_OF_SHADOW_MODES;\n        }\n\n        if (updater.fillEnabled) {\n            if (updater.fillMaterialProperty instanceof ColorMaterialProperty) {\n                that._colorBatches[index].add(time, updater);\n            } else {\n                that._materialBatches[index].add(time, updater);\n            }\n        }\n    }\n\n    /**\n     * A visualizer for polylines represented by {@link Primitive} instances.\n     * @alias PolylineVisualizer\n     * @constructor\n     *\n     * @param {Scene} scene The scene the primitives will be rendered in.\n     * @param {EntityCollection} entityCollection The entityCollection to visualize.\n     * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities\n     * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities\n     */\n    function PolylineVisualizer(scene, entityCollection, primitives, groundPrimitives) {\n        \n\n        groundPrimitives = defaultValue(groundPrimitives, scene.groundPrimitives);\n        primitives = defaultValue(primitives, scene.primitives);\n\n        this._scene = scene;\n        this._primitives = primitives;\n        this._entityCollection = undefined;\n        this._addedObjects = new AssociativeArray();\n        this._removedObjects = new AssociativeArray();\n        this._changedObjects = new AssociativeArray();\n\n        var i;\n        var numberOfShadowModes = ShadowMode.NUMBER_OF_SHADOW_MODES;\n        this._colorBatches = new Array(numberOfShadowModes * 3);\n        this._materialBatches = new Array(numberOfShadowModes * 3);\n\n        for (i = 0; i < numberOfShadowModes; ++i) {\n            this._colorBatches[i] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, undefined, false, i); // no depth fail appearance\n            this._materialBatches[i] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, undefined, false, i);\n\n            this._colorBatches[i + numberOfShadowModes] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineColorAppearance, false, i); //depth fail appearance variations\n            this._materialBatches[i + numberOfShadowModes] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineColorAppearance, false, i);\n\n            this._colorBatches[i + numberOfShadowModes * 2] = new StaticGeometryColorBatch(primitives, PolylineColorAppearance, PolylineMaterialAppearance, false, i);\n            this._materialBatches[i + numberOfShadowModes * 2] = new StaticGeometryPerMaterialBatch(primitives, PolylineMaterialAppearance, PolylineMaterialAppearance, false, i);\n        }\n\n        this._dynamicBatch = new DynamicGeometryBatch(primitives, groundPrimitives);\n\n        var numberOfClassificationTypes = ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;\n        this._groundBatches = new Array(numberOfClassificationTypes);\n\n        for (i = 0; i < numberOfClassificationTypes; ++i) {\n            this._groundBatches[i] = new StaticGroundPolylinePerMaterialBatch(groundPrimitives, i);\n        }\n\n        this._batches = this._colorBatches.concat(this._materialBatches, this._dynamicBatch, this._groundBatches);\n\n        this._subscriptions = new AssociativeArray();\n        this._updaters = new AssociativeArray();\n\n        this._entityCollection = entityCollection;\n        entityCollection.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._onCollectionChanged(entityCollection, entityCollection.values, emptyArray);\n    }\n\n    /**\n     * Updates all of the primitives created by this visualizer to match their\n     * Entity counterpart at the given time.\n     *\n     * @param {JulianDate} time The time to update to.\n     * @returns {Boolean} True if the visualizer successfully updated to the provided time,\n     * false if the visualizer is waiting for asynchronous primitives to be created.\n     */\n    PolylineVisualizer.prototype.update = function(time) {\n        \n\n        var addedObjects = this._addedObjects;\n        var added = addedObjects.values;\n        var removedObjects = this._removedObjects;\n        var removed = removedObjects.values;\n        var changedObjects = this._changedObjects;\n        var changed = changedObjects.values;\n\n        var i;\n        var entity;\n        var id;\n        var updater;\n\n        for (i = changed.length - 1; i > -1; i--) {\n            entity = changed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n\n            //If in a single update, an entity gets removed and a new instance\n            //re-added with the same id, the updater no longer tracks the\n            //correct entity, we need to both remove the old one and\n            //add the new one, which is done by pushing the entity\n            //onto the removed/added lists.\n            if (updater.entity === entity) {\n                removeUpdater(this, updater);\n                insertUpdaterIntoBatch(this, time, updater);\n            } else {\n                removed.push(entity);\n                added.push(entity);\n            }\n        }\n\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            updater = this._updaters.get(id);\n            removeUpdater(this, updater);\n            updater.destroy();\n            this._updaters.remove(id);\n            this._subscriptions.get(id)();\n            this._subscriptions.remove(id);\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            updater = new PolylineGeometryUpdater(entity, this._scene);\n            this._updaters.set(id, updater);\n            insertUpdaterIntoBatch(this, time, updater);\n            this._subscriptions.set(id, updater.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged, this));\n        }\n\n        addedObjects.removeAll();\n        removedObjects.removeAll();\n        changedObjects.removeAll();\n\n        var isUpdated = true;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            isUpdated = batches[i].update(time) && isUpdated;\n        }\n\n        return isUpdated;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    PolylineVisualizer.prototype.getBoundingSphere = function(entity, result) {\n        \n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var batches = this._batches;\n        var batchesLength = batches.length;\n        var updater = this._updaters.get(entity.id);\n        for (var i = 0; i < batchesLength; i++) {\n            state = batches[i].getBoundingSphere(updater, tmp);\n            if (state === BoundingSphereState.PENDING) {\n                return BoundingSphereState.PENDING;\n            } else if (state === BoundingSphereState.DONE) {\n                boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                count++;\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineVisualizer.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Removes and destroys all primitives created by this instance.\n     */\n    PolylineVisualizer.prototype.destroy = function() {\n        this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged, this);\n        this._addedObjects.removeAll();\n        this._removedObjects.removeAll();\n\n        var i;\n        var batches = this._batches;\n        var length = batches.length;\n        for (i = 0; i < length; i++) {\n            batches[i].removeAllPrimitives();\n        }\n\n        var subscriptions = this._subscriptions.values;\n        length = subscriptions.length;\n        for (i = 0; i < length; i++) {\n            subscriptions[i]();\n        }\n        this._subscriptions.removeAll();\n        return destroyObject(this);\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer._onGeometryChanged = function(updater) {\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var entity = updater.entity;\n        var id = entity.id;\n\n        if (!defined(removedObjects.get(id)) && !defined(changedObjects.get(id))) {\n            changedObjects.set(id, entity);\n        }\n    };\n\n    /**\n     * @private\n     */\n    PolylineVisualizer.prototype._onCollectionChanged = function(entityCollection, added, removed) {\n        var addedObjects = this._addedObjects;\n        var removedObjects = this._removedObjects;\n        var changedObjects = this._changedObjects;\n\n        var i;\n        var id;\n        var entity;\n        for (i = removed.length - 1; i > -1; i--) {\n            entity = removed[i];\n            id = entity.id;\n            if (!addedObjects.remove(id)) {\n                removedObjects.set(id, entity);\n                changedObjects.remove(id);\n            }\n        }\n\n        for (i = added.length - 1; i > -1; i--) {\n            entity = added[i];\n            id = entity.id;\n            if (removedObjects.remove(id)) {\n                changedObjects.set(id, entity);\n            } else {\n                addedObjects.set(id, entity);\n            }\n        }\n    };\n\n    return PolylineVisualizer;\n});\n","define([\n        '../Core/ArcType',\n        '../Core/BoundingSphere',\n        '../Core/Check',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/destroyObject',\n        '../Core/DeveloperError',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/Event',\n        '../Core/GeometryInstance',\n        '../Core/GroundPolylineGeometry',\n        '../Core/Iso8601',\n        '../Core/oneTimeWarning',\n        '../Core/PolylineGeometry',\n        '../Core/PolylinePipeline',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../DataSources/Entity',\n        '../Scene/ClassificationType',\n        '../Scene/GroundPolylinePrimitive',\n        '../Scene/PolylineCollection',\n        '../Scene/PolylineColorAppearance',\n        '../Scene/PolylineMaterialAppearance',\n        '../Scene/ShadowMode',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './ConstantProperty',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        ArcType,\n        BoundingSphere,\n        Check,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defaultValue,\n        defined,\n        defineProperties,\n        destroyObject,\n        DeveloperError,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        Event,\n        GeometryInstance,\n        GroundPolylineGeometry,\n        Iso8601,\n        oneTimeWarning,\n        PolylineGeometry,\n        PolylinePipeline,\n        ShowGeometryInstanceAttribute,\n        Entity,\n        ClassificationType,\n        GroundPolylinePrimitive,\n        PolylineCollection,\n        PolylineColorAppearance,\n        PolylineMaterialAppearance,\n        ShadowMode,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        ConstantProperty,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    var defaultZIndex = new ConstantProperty(0);\n\n    //We use this object to create one polyline collection per-scene.\n    var polylineCollections = {};\n\n    var scratchColor = new Color();\n    var defaultMaterial = new ColorMaterialProperty(Color.WHITE);\n    var defaultShow = new ConstantProperty(true);\n    var defaultShadows = new ConstantProperty(ShadowMode.DISABLED);\n    var defaultDistanceDisplayCondition = new ConstantProperty(new DistanceDisplayCondition());\n    var defaultClassificationType = new ConstantProperty(ClassificationType.BOTH);\n\n    function GeometryOptions() {\n        this.vertexFormat = undefined;\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    function GroundGeometryOptions() {\n        this.positions = undefined;\n        this.width = undefined;\n        this.arcType = undefined;\n        this.granularity = undefined;\n    }\n\n    /**\n     * A {@link GeometryUpdater} for polylines.\n     * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.\n     * @alias PolylineGeometryUpdater\n     * @constructor\n     *\n     * @param {Entity} entity The entity containing the geometry to be visualized.\n     * @param {Scene} scene The scene where visualization is taking place.\n     */\n    function PolylineGeometryUpdater(entity, scene) {\n        \n\n        this._entity = entity;\n        this._scene = scene;\n        this._entitySubscription = entity.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged, this);\n        this._fillEnabled = false;\n        this._dynamic = false;\n        this._geometryChanged = new Event();\n        this._showProperty = undefined;\n        this._materialProperty = undefined;\n        this._shadowsProperty = undefined;\n        this._distanceDisplayConditionProperty = undefined;\n        this._classificationTypeProperty = undefined;\n        this._depthFailMaterialProperty = undefined;\n        this._geometryOptions = new GeometryOptions();\n        this._groundGeometryOptions = new GroundGeometryOptions();\n        this._id = 'polyline-' + entity.id;\n        this._clampToGround = false;\n        this._supportsPolylinesOnTerrain = Entity.supportsPolylinesOnTerrain(scene);\n\n        this._zIndex = 0;\n\n        this._onEntityPropertyChanged(entity, 'polyline', entity.polyline, undefined);\n    }\n\n    defineProperties(PolylineGeometryUpdater.prototype, {\n        /**\n         * Gets the unique ID associated with this updater\n         * @memberof PolylineGeometryUpdater.prototype\n         * @type {String}\n         * @readonly\n         */\n        id: {\n            get: function() {\n                return this._id;\n            }\n        },\n        /**\n         * Gets the entity associated with this geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Entity}\n         * @readonly\n         */\n        entity : {\n            get : function() {\n                return this._entity;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has a fill component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        fillEnabled : {\n            get : function() {\n                return this._fillEnabled;\n            }\n        },\n        /**\n         * Gets a value indicating if fill visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantFill : {\n            get : function() {\n                return !this._fillEnabled || (!defined(this._entity.availability) && Property.isConstant(this._showProperty));\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        fillMaterialProperty : {\n            get : function() {\n                return this._materialProperty;\n            }\n        },\n        /**\n         * Gets the material property used to fill the geometry when it fails the depth test.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {MaterialProperty}\n         * @readonly\n         */\n        depthFailMaterialProperty : {\n            get : function() {\n                return this._depthFailMaterialProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry has an outline component.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        outlineEnabled : {\n            value : false\n        },\n        /**\n         * Gets a value indicating if outline visibility varies with simulation time.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        hasConstantOutline : {\n            value : true\n        },\n        /**\n         * Gets the {@link Color} property for the geometry outline.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        outlineColorProperty : {\n            value : undefined\n        },\n        /**\n         * Gets the property specifying whether the geometry\n         * casts or receives shadows from each light source.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        shadowsProperty : {\n            get : function() {\n                return this._shadowsProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        distanceDisplayConditionProperty : {\n            get : function() {\n                return this._distanceDisplayConditionProperty;\n            }\n        },\n        /**\n         * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Property}\n         * @readonly\n         */\n        classificationTypeProperty : {\n            get : function() {\n                return this._classificationTypeProperty;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is time-varying.\n         * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}\n         * returned by GeometryUpdater#createDynamicUpdater.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isDynamic : {\n            get : function() {\n                return this._dynamic;\n            }\n        },\n        /**\n         * Gets a value indicating if the geometry is closed.\n         * This property is only valid for static geometry.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        isClosed : {\n            value : false\n        },\n        /**\n         * Gets an event that is raised whenever the public properties\n         * of this updater change.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        geometryChanged : {\n            get : function() {\n                return this._geometryChanged;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the path of the line.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {ArcType}\n         * @readonly\n         */\n        arcType : {\n            get : function() {\n                return this._arcType;\n            }\n        },\n\n        /**\n         * Gets a value indicating if the geometry is clamped to the ground.\n         * Returns false if polylines on terrain is not supported.\n         * @memberof PolylineGeometryUpdater.prototype\n         *\n         * @type {Boolean}\n         * @readonly\n         */\n        clampToGround : {\n            get : function() {\n                return this._clampToGround && this._supportsPolylinesOnTerrain;\n            }\n        },\n\n        /**\n         * Gets the zindex\n         * @type {Number}\n         * @memberof PolylineGeometryUpdater.prototype\n         * @readonly\n         */\n        zIndex: {\n            get: function() {\n                return this._zIndex;\n            }\n        }\n    });\n\n    /**\n     * Checks if the geometry is outlined at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isOutlineVisible = function(time) {\n        return false;\n    };\n\n    /**\n     * Checks if the geometry is filled at the provided time.\n     *\n     * @param {JulianDate} time The time for which to retrieve visibility.\n     * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.\n     */\n    PolylineGeometryUpdater.prototype.isFilled = function(time) {\n        var entity = this._entity;\n        var visible = this._fillEnabled && entity.isAvailable(time) && this._showProperty.getValue(time);\n        return defaultValue(visible, false);\n    };\n\n    /**\n     * Creates the geometry instance which represents the fill of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent a filled geometry.\n     */\n    PolylineGeometryUpdater.prototype.createFillGeometryInstance = function(time) {\n        \n\n        var entity = this._entity;\n        var isAvailable = entity.isAvailable(time);\n        var show = new ShowGeometryInstanceAttribute(isAvailable && entity.isShowing && this._showProperty.getValue(time));\n        var distanceDisplayCondition = this._distanceDisplayConditionProperty.getValue(time);\n        var distanceDisplayConditionAttribute = DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition);\n\n        var attributes = {\n            show : show,\n            distanceDisplayCondition : distanceDisplayConditionAttribute\n        };\n\n        var currentColor;\n        if (this._materialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._materialProperty.color) && (this._materialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._materialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.color = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        if (this.clampToGround) {\n            return new GeometryInstance({\n                id : entity,\n                geometry : new GroundPolylineGeometry(this._groundGeometryOptions),\n                attributes : attributes\n            });\n        }\n\n        if (defined(this._depthFailMaterialProperty) && this._depthFailMaterialProperty instanceof ColorMaterialProperty) {\n            if (defined(this._depthFailMaterialProperty.color) && (this._depthFailMaterialProperty.color.isConstant || isAvailable)) {\n                currentColor = this._depthFailMaterialProperty.color.getValue(time, scratchColor);\n            }\n            if (!defined(currentColor)) {\n                currentColor = Color.WHITE;\n            }\n            attributes.depthFailColor = ColorGeometryInstanceAttribute.fromColor(currentColor);\n        }\n\n        return new GeometryInstance({\n            id : entity,\n            geometry : new PolylineGeometry(this._geometryOptions),\n            attributes : attributes\n        });\n    };\n\n    /**\n     * Creates the geometry instance which represents the outline of the geometry.\n     *\n     * @param {JulianDate} time The time to use when retrieving initial attribute values.\n     * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.\n     *\n     * @exception {DeveloperError} This instance does not represent an outlined geometry.\n     */\n    PolylineGeometryUpdater.prototype.createOutlineGeometryInstance = function(time) {\n        \n    };\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     */\n    PolylineGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     */\n    PolylineGeometryUpdater.prototype.destroy = function() {\n        this._entitySubscription();\n        destroyObject(this);\n    };\n\n    PolylineGeometryUpdater.prototype._onEntityPropertyChanged = function(entity, propertyName, newValue, oldValue) {\n        if (!(propertyName === 'availability' || propertyName === 'polyline')) {\n            return;\n        }\n\n        var polyline = this._entity.polyline;\n\n        if (!defined(polyline)) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var positionsProperty = polyline.positions;\n\n        var show = polyline.show;\n        if ((defined(show) && show.isConstant && !show.getValue(Iso8601.MINIMUM_VALUE)) || //\n            (!defined(positionsProperty))) {\n            if (this._fillEnabled) {\n                this._fillEnabled = false;\n                this._geometryChanged.raiseEvent(this);\n            }\n            return;\n        }\n\n        var zIndex = polyline.zIndex;\n        var material = defaultValue(polyline.material, defaultMaterial);\n        var isColorMaterial = material instanceof ColorMaterialProperty;\n        this._materialProperty = material;\n        this._depthFailMaterialProperty = polyline.depthFailMaterial;\n        this._showProperty = defaultValue(show, defaultShow);\n        this._shadowsProperty = defaultValue(polyline.shadows, defaultShadows);\n        this._distanceDisplayConditionProperty = defaultValue(polyline.distanceDisplayCondition, defaultDistanceDisplayCondition);\n        this._classificationTypeProperty = defaultValue(polyline.classificationType, defaultClassificationType);\n        this._fillEnabled = true;\n        this._zIndex = defaultValue(zIndex, defaultZIndex);\n\n        var width = polyline.width;\n        var arcType = polyline.arcType;\n        var clampToGround = polyline.clampToGround;\n        var granularity = polyline.granularity;\n\n        if (!positionsProperty.isConstant || !Property.isConstant(width) ||\n            !Property.isConstant(arcType) || !Property.isConstant(granularity) ||\n            !Property.isConstant(clampToGround) || !Property.isConstant(zIndex)) {\n            if (!this._dynamic) {\n                this._dynamic = true;\n                this._geometryChanged.raiseEvent(this);\n            }\n        } else {\n            var geometryOptions = this._geometryOptions;\n            var positions = positionsProperty.getValue(Iso8601.MINIMUM_VALUE, geometryOptions.positions);\n\n            //Because of the way we currently handle reference properties,\n            //we can't automatically assume the positions are always valid.\n            if (!defined(positions) || positions.length < 2) {\n                if (this._fillEnabled) {\n                    this._fillEnabled = false;\n                    this._geometryChanged.raiseEvent(this);\n                }\n                return;\n            }\n\n            var vertexFormat;\n            if (isColorMaterial && (!defined(this._depthFailMaterialProperty) || this._depthFailMaterialProperty instanceof ColorMaterialProperty)) {\n                vertexFormat = PolylineColorAppearance.VERTEX_FORMAT;\n            } else {\n                vertexFormat = PolylineMaterialAppearance.VERTEX_FORMAT;\n            }\n\n            geometryOptions.vertexFormat = vertexFormat;\n            geometryOptions.positions = positions;\n            geometryOptions.width = defined(width) ? width.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.arcType = defined(arcType) ? arcType.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n            geometryOptions.granularity = defined(granularity) ? granularity.getValue(Iso8601.MINIMUM_VALUE) : undefined;\n\n            var groundGeometryOptions = this._groundGeometryOptions;\n            groundGeometryOptions.positions = positions;\n            groundGeometryOptions.width = geometryOptions.width;\n            groundGeometryOptions.arcType = geometryOptions.arcType;\n            groundGeometryOptions.granularity = geometryOptions.granularity;\n\n            this._clampToGround = defined(clampToGround) ? clampToGround.getValue(Iso8601.MINIMUM_VALUE) : false;\n\n            if (!this._clampToGround && defined(zIndex)) {\n                oneTimeWarning('Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored.');\n            }\n\n            this._dynamic = false;\n            this._geometryChanged.raiseEvent(this);\n        }\n    };\n\n    /**\n     * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.\n     *\n     * @param {PrimitiveCollection} primitives The primitive collection to use.\n     * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.\n     * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.\n     *\n     * @exception {DeveloperError} This instance does not represent dynamic geometry.\n     */\n    PolylineGeometryUpdater.prototype.createDynamicUpdater = function(primitives, groundPrimitives) {\n        \n\n        return new DynamicGeometryUpdater(primitives, groundPrimitives, this);\n    };\n\n    /**\n     * @private\n     */\n    var generateCartesianArcOptions = {\n        positions : undefined,\n        granularity : undefined,\n        height : undefined,\n        ellipsoid : undefined\n    };\n\n    function DynamicGeometryUpdater(primitives, groundPrimitives, geometryUpdater) {\n        this._line = undefined;\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n        this._groundPolylinePrimitive = undefined;\n        this._material = undefined;\n        this._geometryUpdater = geometryUpdater;\n        this._positions = [];\n    }\n\n    function getLine(dynamicGeometryUpdater) {\n        if (defined(dynamicGeometryUpdater._line)) {\n            return dynamicGeometryUpdater._line;\n        }\n\n        var sceneId = dynamicGeometryUpdater._geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        var primitives = dynamicGeometryUpdater._primitives;\n        if (!defined(polylineCollection) || polylineCollection.isDestroyed()) {\n            polylineCollection = new PolylineCollection();\n            polylineCollections[sceneId] = polylineCollection;\n            primitives.add(polylineCollection);\n        } else if (!primitives.contains(polylineCollection)) {\n            primitives.add(polylineCollection);\n        }\n\n        var line = polylineCollection.add();\n        line.id = dynamicGeometryUpdater._geometryUpdater._entity;\n        dynamicGeometryUpdater._line = line;\n        return line;\n    }\n\n    DynamicGeometryUpdater.prototype.update = function(time) {\n        var geometryUpdater = this._geometryUpdater;\n        var entity = geometryUpdater._entity;\n        var polyline = entity.polyline;\n\n        var positionsProperty = polyline.positions;\n        var positions = Property.getValueOrUndefined(positionsProperty, time, this._positions);\n\n        // Synchronize with geometryUpdater for GroundPolylinePrimitive\n        geometryUpdater._clampToGround = Property.getValueOrDefault(polyline._clampToGround, time, false);\n        geometryUpdater._groundGeometryOptions.positions = positions;\n        geometryUpdater._groundGeometryOptions.width = Property.getValueOrDefault(polyline._width, time, 1);\n        geometryUpdater._groundGeometryOptions.arcType = Property.getValueOrDefault(polyline._arcType, time, ArcType.GEODESIC);\n        geometryUpdater._groundGeometryOptions.granularity = Property.getValueOrDefault(polyline._granularity, time, 9999);\n\n        var groundPrimitives = this._groundPrimitives;\n\n        if (defined(this._groundPolylinePrimitive)) {\n            groundPrimitives.remove(this._groundPolylinePrimitive); // destroys by default\n            this._groundPolylinePrimitive = undefined;\n        }\n\n        if (geometryUpdater.clampToGround) {\n            if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n                return;\n            }\n\n            if (!defined(positions) || positions.length < 2) {\n                return;\n            }\n\n            var fillMaterialProperty = geometryUpdater.fillMaterialProperty;\n            var appearance;\n            if (fillMaterialProperty instanceof ColorMaterialProperty) {\n                appearance = new PolylineColorAppearance();\n            } else {\n                var material = MaterialProperty.getValue(time, fillMaterialProperty, this._material);\n                appearance = new PolylineMaterialAppearance({\n                    material : material,\n                    translucent : material.isTranslucent()\n                });\n                this._material = material;\n            }\n\n            this._groundPolylinePrimitive = groundPrimitives.add(new GroundPolylinePrimitive({\n                geometryInstances : geometryUpdater.createFillGeometryInstance(time),\n                appearance : appearance,\n                classificationType : geometryUpdater.classificationTypeProperty.getValue(time),\n                asynchronous : false\n            }), Property.getValueOrUndefined(geometryUpdater.zIndex, time));\n\n            // Hide the polyline in the collection, if any\n            if (defined(this._line)) {\n                this._line.show = false;\n            }\n            return;\n        }\n\n        var line = getLine(this);\n\n        if (!entity.isShowing || !entity.isAvailable(time) || !Property.getValueOrDefault(polyline._show, time, true)) {\n            line.show = false;\n            return;\n        }\n\n        if (!defined(positions) || positions.length < 2) {\n            line.show = false;\n            return;\n        }\n\n        var arcType = ArcType.GEODESIC;\n        arcType = Property.getValueOrDefault(polyline._arcType, time, arcType);\n\n        var globe = geometryUpdater._scene.globe;\n        if (arcType !== ArcType.NONE && defined(globe)) {\n            generateCartesianArcOptions.ellipsoid = globe.ellipsoid;\n            generateCartesianArcOptions.positions = positions;\n            generateCartesianArcOptions.granularity = Property.getValueOrUndefined(polyline._granularity, time);\n            generateCartesianArcOptions.height = PolylinePipeline.extractHeights(positions, globe.ellipsoid);\n            positions = PolylinePipeline.generateCartesianArc(generateCartesianArcOptions);\n        }\n\n        line.show = true;\n        line.positions = positions.slice();\n        line.material = MaterialProperty.getValue(time, geometryUpdater.fillMaterialProperty, line.material);\n        line.width = Property.getValueOrDefault(polyline._width, time, 1);\n        line.distanceDisplayCondition = Property.getValueOrUndefined(polyline._distanceDisplayCondition, time, line.distanceDisplayCondition);\n    };\n\n    DynamicGeometryUpdater.prototype.getBoundingSphere = function(result) {\n        \n\n        if (!this._geometryUpdater.clampToGround) {\n            var line = getLine(this);\n            if (line.show && line.positions.length > 0) {\n                BoundingSphere.fromPoints(line.positions, result);\n                return BoundingSphereState.DONE;\n            }\n        } else {\n            var groundPolylinePrimitive = this._groundPolylinePrimitive;\n            if (defined(groundPolylinePrimitive) && groundPolylinePrimitive.show && groundPolylinePrimitive.ready) {\n                var attributes = groundPolylinePrimitive.getGeometryInstanceAttributes(this._geometryUpdater._entity);\n                if (defined(attributes) && defined(attributes.boundingSphere)) {\n                    BoundingSphere.clone(attributes.boundingSphere, result);\n                    return BoundingSphereState.DONE;\n                }\n            }\n\n            if ((defined(groundPolylinePrimitive) && !groundPolylinePrimitive.ready)) {\n                return BoundingSphereState.PENDING;\n            }\n\n            return BoundingSphereState.DONE;\n        }\n\n        return BoundingSphereState.FAILED;\n    };\n\n    DynamicGeometryUpdater.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    DynamicGeometryUpdater.prototype.destroy = function() {\n        var geometryUpdater = this._geometryUpdater;\n        var sceneId = geometryUpdater._scene.id;\n        var polylineCollection = polylineCollections[sceneId];\n        if (defined(polylineCollection)) {\n            polylineCollection.remove(this._line);\n            if (polylineCollection.length === 0) {\n                this._primitives.removeAndDestroy(polylineCollection);\n                delete polylineCollections[sceneId];\n            }\n        }\n        if (defined(this._groundPolylinePrimitive)) {\n            this._groundPrimitives.remove(this._groundPolylinePrimitive);\n        }\n        destroyObject(this);\n    };\n\n    return PolylineGeometryUpdater;\n});\n","define([\n        './ArcType',\n        './arrayRemoveDuplicates',\n        './BoundingSphere',\n        './Cartesian3',\n        './Color',\n        './ComponentDatatype',\n        './defaultValue',\n        './defined',\n        './DeveloperError',\n        './Ellipsoid',\n        './Geometry',\n        './GeometryAttribute',\n        './GeometryAttributes',\n        './GeometryType',\n        './IndexDatatype',\n        './Math',\n        './PolylinePipeline',\n        './PrimitiveType',\n        './VertexFormat'\n    ], function(\n        ArcType,\n        arrayRemoveDuplicates,\n        BoundingSphere,\n        Cartesian3,\n        Color,\n        ComponentDatatype,\n        defaultValue,\n        defined,\n        DeveloperError,\n        Ellipsoid,\n        Geometry,\n        GeometryAttribute,\n        GeometryAttributes,\n        GeometryType,\n        IndexDatatype,\n        CesiumMath,\n        PolylinePipeline,\n        PrimitiveType,\n        VertexFormat) {\n    'use strict';\n\n    var scratchInterpolateColorsArray = [];\n\n    function interpolateColors(p0, p1, color0, color1, numPoints) {\n        var colors = scratchInterpolateColorsArray;\n        colors.length = numPoints;\n        var i;\n\n        var r0 = color0.red;\n        var g0 = color0.green;\n        var b0 = color0.blue;\n        var a0 = color0.alpha;\n\n        var r1 = color1.red;\n        var g1 = color1.green;\n        var b1 = color1.blue;\n        var a1 = color1.alpha;\n\n        if (Color.equals(color0, color1)) {\n            for (i = 0; i < numPoints; i++) {\n                colors[i] = Color.clone(color0);\n            }\n            return colors;\n        }\n\n        var redPerVertex = (r1 - r0) / numPoints;\n        var greenPerVertex = (g1 - g0) / numPoints;\n        var bluePerVertex = (b1 - b0) / numPoints;\n        var alphaPerVertex = (a1 - a0) / numPoints;\n\n        for (i = 0; i < numPoints; i++) {\n            colors[i] = new Color(r0 + i * redPerVertex, g0 + i * greenPerVertex, b0 + i * bluePerVertex, a0 + i * alphaPerVertex);\n        }\n\n        return colors;\n    }\n\n    /**\n     * A description of a polyline modeled as a line strip; the first two positions define a line segment,\n     * and each additional position defines a line segment from the previous position. The polyline is capable of\n     * displaying with a material.\n     *\n     * @alias PolylineGeometry\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.\n     * @param {Number} [options.width=1.0] The width in pixels.\n     * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.\n     * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow.\n     * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\n     *\n     * @exception {DeveloperError} At least two positions are required.\n     * @exception {DeveloperError} width must be greater than or equal to one.\n     * @exception {DeveloperError} colors has an invalid length.\n     *\n     * @see PolylineGeometry#createGeometry\n     *\n     * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}\n     *\n     * @example\n     * // A polyline with two connected line segments\n     * var polyline = new Cesium.PolylineGeometry({\n     *   positions : Cesium.Cartesian3.fromDegreesArray([\n     *     0.0, 0.0,\n     *     5.0, 0.0,\n     *     5.0, 5.0\n     *   ]),\n     *   width : 10.0\n     * });\n     * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);\n     */\n    function PolylineGeometry(options) {\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n        var positions = options.positions;\n        var colors = options.colors;\n        var width = defaultValue(options.width, 1.0);\n        var colorsPerVertex = defaultValue(options.colorsPerVertex, false);\n\n        \n\n        this._positions = positions;\n        this._colors = colors;\n        this._width = width;\n        this._colorsPerVertex = colorsPerVertex;\n        this._vertexFormat = VertexFormat.clone(defaultValue(options.vertexFormat, VertexFormat.DEFAULT));\n\n        this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\n        this._granularity = defaultValue(options.granularity, CesiumMath.RADIANS_PER_DEGREE);\n        this._ellipsoid = Ellipsoid.clone(defaultValue(options.ellipsoid, Ellipsoid.WGS84));\n        this._workerName = 'createPolylineGeometry';\n\n        var numComponents = 1 + positions.length * Cartesian3.packedLength;\n        numComponents += defined(colors) ? 1 + colors.length * Color.packedLength : 1;\n\n        /**\n         * The number of elements used to pack the object into an array.\n         * @type {Number}\n         */\n        this.packedLength = numComponents + Ellipsoid.packedLength + VertexFormat.packedLength + 4;\n    }\n\n    /**\n     * Stores the provided instance into the provided array.\n     *\n     * @param {PolylineGeometry} value The value to pack.\n     * @param {Number[]} array The array to pack into.\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\n     *\n     * @returns {Number[]} The array that was packed into\n     */\n    PolylineGeometry.pack = function(value, array, startingIndex) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var positions = value._positions;\n        var length = positions.length;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            Cartesian3.pack(positions[i], array, startingIndex);\n        }\n\n        var colors = value._colors;\n        length = defined(colors) ? colors.length : 0.0;\n        array[startingIndex++] = length;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            Color.pack(colors[i], array, startingIndex);\n        }\n\n        Ellipsoid.pack(value._ellipsoid, array, startingIndex);\n        startingIndex += Ellipsoid.packedLength;\n\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\n        startingIndex += VertexFormat.packedLength;\n\n        array[startingIndex++] = value._width;\n        array[startingIndex++] = value._colorsPerVertex ? 1.0 : 0.0;\n        array[startingIndex++] = value._arcType;\n        array[startingIndex]   = value._granularity;\n\n        return array;\n    };\n\n    var scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\n    var scratchVertexFormat = new VertexFormat();\n    var scratchOptions = {\n        positions : undefined,\n        colors : undefined,\n        ellipsoid : scratchEllipsoid,\n        vertexFormat : scratchVertexFormat,\n        width : undefined,\n        colorsPerVertex : undefined,\n        arcType : undefined,\n        granularity : undefined\n    };\n\n    /**\n     * Retrieves an instance from a packed array.\n     *\n     * @param {Number[]} array The packed array.\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\n     * @param {PolylineGeometry} [result] The object into which to store the result.\n     * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.\n     */\n    PolylineGeometry.unpack = function(array, startingIndex, result) {\n        \n\n        startingIndex = defaultValue(startingIndex, 0);\n\n        var i;\n\n        var length = array[startingIndex++];\n        var positions = new Array(length);\n\n        for (i = 0; i < length; ++i, startingIndex += Cartesian3.packedLength) {\n            positions[i] = Cartesian3.unpack(array, startingIndex);\n        }\n\n        length = array[startingIndex++];\n        var colors = length > 0 ? new Array(length) : undefined;\n\n        for (i = 0; i < length; ++i, startingIndex += Color.packedLength) {\n            colors[i] = Color.unpack(array, startingIndex);\n        }\n\n        var ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\n        startingIndex += Ellipsoid.packedLength;\n\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\n        startingIndex += VertexFormat.packedLength;\n\n        var width = array[startingIndex++];\n        var colorsPerVertex = array[startingIndex++] === 1.0;\n        var arcType = array[startingIndex++];\n        var granularity = array[startingIndex];\n\n        if (!defined(result)) {\n            scratchOptions.positions = positions;\n            scratchOptions.colors = colors;\n            scratchOptions.width = width;\n            scratchOptions.colorsPerVertex = colorsPerVertex;\n            scratchOptions.arcType = arcType;\n            scratchOptions.granularity = granularity;\n            return new PolylineGeometry(scratchOptions);\n        }\n\n        result._positions = positions;\n        result._colors = colors;\n        result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\n        result._width = width;\n        result._colorsPerVertex = colorsPerVertex;\n        result._arcType = arcType;\n        result._granularity = granularity;\n\n        return result;\n    };\n\n    var scratchCartesian3 = new Cartesian3();\n    var scratchPosition = new Cartesian3();\n    var scratchPrevPosition = new Cartesian3();\n    var scratchNextPosition = new Cartesian3();\n\n    /**\n     * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.\n     *\n     * @param {PolylineGeometry} polylineGeometry A description of the polyline.\n     * @returns {Geometry|undefined} The computed vertices and indices.\n     */\n    PolylineGeometry.createGeometry = function(polylineGeometry) {\n        var width = polylineGeometry._width;\n        var vertexFormat = polylineGeometry._vertexFormat;\n        var colors = polylineGeometry._colors;\n        var colorsPerVertex = polylineGeometry._colorsPerVertex;\n        var arcType = polylineGeometry._arcType;\n        var granularity = polylineGeometry._granularity;\n        var ellipsoid = polylineGeometry._ellipsoid;\n\n        var i;\n        var j;\n        var k;\n\n        var positions = arrayRemoveDuplicates(polylineGeometry._positions, Cartesian3.equalsEpsilon);\n        var positionsLength = positions.length;\n\n        // A width of a pixel or less is not a valid geometry, but in order to support external data\n        // that may have errors we treat this as an empty geometry.\n        if (positionsLength < 2 || width <= 0.0) {\n            return undefined;\n        }\n\n        if (arcType === ArcType.GEODESIC || arcType === ArcType.RHUMB) {\n            var subdivisionSize;\n            var numberOfPointsFunction;\n            if (arcType === ArcType.GEODESIC) {\n                subdivisionSize = CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\n                numberOfPointsFunction = PolylinePipeline.numberOfPoints;\n            } else {\n                subdivisionSize = granularity;\n                numberOfPointsFunction = PolylinePipeline.numberOfPointsRhumbLine;\n            }\n\n            var heights = PolylinePipeline.extractHeights(positions, ellipsoid);\n\n            if (defined(colors)) {\n                var colorLength = 1;\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    colorLength += numberOfPointsFunction(positions[i], positions[i + 1], subdivisionSize);\n                }\n\n                var newColors = new Array(colorLength);\n                var newColorIndex = 0;\n\n                for (i = 0; i < positionsLength - 1; ++i) {\n                    var p0 = positions[i];\n                    var p1 = positions[i + 1];\n                    var c0 = colors[i];\n\n                    var numColors = numberOfPointsFunction(p0, p1, subdivisionSize);\n                    if (colorsPerVertex && i < colorLength) {\n                        var c1 = colors[i + 1];\n                        var interpolatedColors = interpolateColors(p0, p1, c0, c1, numColors);\n                        var interpolatedColorsLength = interpolatedColors.length;\n                        for (j = 0; j < interpolatedColorsLength; ++j) {\n                            newColors[newColorIndex++] = interpolatedColors[j];\n                        }\n                    } else {\n                        for (j = 0; j < numColors; ++j) {\n                            newColors[newColorIndex++] = Color.clone(c0);\n                        }\n                    }\n                }\n\n                newColors[newColorIndex] = Color.clone(colors[colors.length - 1]);\n                colors = newColors;\n\n                scratchInterpolateColorsArray.length = 0;\n            }\n\n            if (arcType === ArcType.GEODESIC) {\n                positions = PolylinePipeline.generateCartesianArc({\n                    positions: positions,\n                    minDistance: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            } else {\n                positions = PolylinePipeline.generateCartesianRhumbArc({\n                    positions: positions,\n                    granularity: subdivisionSize,\n                    ellipsoid: ellipsoid,\n                    height: heights\n                });\n            }\n        }\n\n        positionsLength = positions.length;\n        var size = positionsLength * 4.0 - 4.0;\n\n        var finalPositions = new Float64Array(size * 3);\n        var prevPositions = new Float64Array(size * 3);\n        var nextPositions = new Float64Array(size * 3);\n        var expandAndWidth = new Float32Array(size * 2);\n        var st = vertexFormat.st ? new Float32Array(size * 2) : undefined;\n        var finalColors = defined(colors) ? new Uint8Array(size * 4) : undefined;\n\n        var positionIndex = 0;\n        var expandAndWidthIndex = 0;\n        var stIndex = 0;\n        var colorIndex = 0;\n        var position;\n\n        for (j = 0; j < positionsLength; ++j) {\n            if (j === 0) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[0], positions[1], position);\n                Cartesian3.add(positions[0], position, position);\n            } else {\n                position = positions[j - 1];\n            }\n\n            Cartesian3.clone(position, scratchPrevPosition);\n            Cartesian3.clone(positions[j], scratchPosition);\n\n            if (j === positionsLength - 1) {\n                position = scratchCartesian3;\n                Cartesian3.subtract(positions[positionsLength - 1], positions[positionsLength - 2], position);\n                Cartesian3.add(positions[positionsLength - 1], position, position);\n            } else {\n                position = positions[j + 1];\n            }\n\n            Cartesian3.clone(position, scratchNextPosition);\n\n            var color0, color1;\n            if (defined(finalColors)) {\n                if (j !== 0 && !colorsPerVertex) {\n                    color0 = colors[j - 1];\n                } else {\n                    color0 = colors[j];\n                }\n\n                if (j !== positionsLength - 1) {\n                    color1 = colors[j];\n                }\n            }\n\n            var startK = j === 0 ? 2 : 0;\n            var endK = j === positionsLength - 1 ? 2 : 4;\n\n            for (k = startK; k < endK; ++k) {\n                Cartesian3.pack(scratchPosition, finalPositions, positionIndex);\n                Cartesian3.pack(scratchPrevPosition, prevPositions, positionIndex);\n                Cartesian3.pack(scratchNextPosition, nextPositions, positionIndex);\n                positionIndex += 3;\n\n                var direction = (k - 2 < 0) ? -1.0 : 1.0;\n                expandAndWidth[expandAndWidthIndex++] = 2 * (k % 2) - 1;       // expand direction\n                expandAndWidth[expandAndWidthIndex++] = direction * width;\n\n                if (vertexFormat.st) {\n                    st[stIndex++] = j / (positionsLength - 1);\n                    st[stIndex++] = Math.max(expandAndWidth[expandAndWidthIndex - 2], 0.0);\n                }\n\n                if (defined(finalColors)) {\n                    var color = (k < 2) ? color0 : color1;\n\n                    finalColors[colorIndex++] = Color.floatToByte(color.red);\n                    finalColors[colorIndex++] = Color.floatToByte(color.green);\n                    finalColors[colorIndex++] = Color.floatToByte(color.blue);\n                    finalColors[colorIndex++] = Color.floatToByte(color.alpha);\n                }\n            }\n        }\n\n        var attributes = new GeometryAttributes();\n\n        attributes.position = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : finalPositions\n        });\n\n        attributes.prevPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : prevPositions\n        });\n\n        attributes.nextPosition = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.DOUBLE,\n            componentsPerAttribute : 3,\n            values : nextPositions\n        });\n\n        attributes.expandAndWidth = new GeometryAttribute({\n            componentDatatype : ComponentDatatype.FLOAT,\n            componentsPerAttribute : 2,\n            values : expandAndWidth\n        });\n\n        if (vertexFormat.st) {\n            attributes.st = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.FLOAT,\n                componentsPerAttribute : 2,\n                values : st\n            });\n        }\n\n        if (defined(finalColors)) {\n            attributes.color = new GeometryAttribute({\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\n                componentsPerAttribute : 4,\n                values : finalColors,\n                normalize : true\n            });\n        }\n\n        var indices = IndexDatatype.createTypedArray(size, positionsLength * 6 - 6);\n        var index = 0;\n        var indicesIndex = 0;\n        var length = positionsLength - 1.0;\n        for (j = 0; j < length; ++j) {\n            indices[indicesIndex++] = index;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 1;\n\n            indices[indicesIndex++] = index + 1;\n            indices[indicesIndex++] = index + 2;\n            indices[indicesIndex++] = index + 3;\n\n            index += 4;\n        }\n\n        return new Geometry({\n            attributes : attributes,\n            indices : indices,\n            primitiveType : PrimitiveType.TRIANGLES,\n            boundingSphere : BoundingSphere.fromPoints(positions),\n            geometryType : GeometryType.POLYLINES\n        });\n    };\n\n    return PolylineGeometry;\n});\n","define([\n        '../Core/defaultValue',\n        '../Core/AssociativeArray',\n        '../Core/Color',\n        '../Core/ColorGeometryInstanceAttribute',\n        '../Core/defined',\n        '../Core/DistanceDisplayCondition',\n        '../Core/DistanceDisplayConditionGeometryInstanceAttribute',\n        '../Core/ShowGeometryInstanceAttribute',\n        '../Scene/GroundPolylinePrimitive',\n        '../Scene/PolylineColorAppearance',\n        '../Scene/PolylineMaterialAppearance',\n        './BoundingSphereState',\n        './ColorMaterialProperty',\n        './MaterialProperty',\n        './Property'\n    ], function(\n        defaultValue,\n        AssociativeArray,\n        Color,\n        ColorGeometryInstanceAttribute,\n        defined,\n        DistanceDisplayCondition,\n        DistanceDisplayConditionGeometryInstanceAttribute,\n        ShowGeometryInstanceAttribute,\n        GroundPolylinePrimitive,\n        PolylineColorAppearance,\n        PolylineMaterialAppearance,\n        BoundingSphereState,\n        ColorMaterialProperty,\n        MaterialProperty,\n        Property) {\n    'use strict';\n\n    var scratchColor = new Color();\n    var distanceDisplayConditionScratch = new DistanceDisplayCondition();\n    var defaultDistanceDisplayCondition = new DistanceDisplayCondition();\n\n    // Encapsulates a Primitive and all the entities that it represents.\n    function Batch(orderedGroundPrimitives, classificationType, materialProperty, zIndex, asynchronous) {\n        var appearanceType;\n        if (materialProperty instanceof ColorMaterialProperty) {\n            appearanceType = PolylineColorAppearance;\n        } else {\n            appearanceType = PolylineMaterialAppearance;\n        }\n\n        this.orderedGroundPrimitives = orderedGroundPrimitives; // scene level primitive collection\n        this.classificationType = classificationType;\n        this.appearanceType = appearanceType;\n        this.materialProperty = materialProperty;\n        this.updaters = new AssociativeArray();\n        this.createPrimitive = true;\n        this.primitive = undefined; // a GroundPolylinePrimitive encapsulating all the entities\n        this.oldPrimitive = undefined;\n        this.geometry = new AssociativeArray();\n        this.material = undefined;\n        this.updatersWithAttributes = new AssociativeArray();\n        this.attributes = new AssociativeArray();\n        this.invalidated = false;\n        this.removeMaterialSubscription = materialProperty.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged, this);\n        this.subscriptions = new AssociativeArray();\n        this.showsUpdated = new AssociativeArray();\n        this.zIndex = zIndex;\n\n        this._asynchronous = asynchronous;\n    }\n\n    Batch.prototype.onMaterialChanged = function() {\n        this.invalidated = true;\n    };\n\n    // Check if the given updater's material is compatible with this batch\n    Batch.prototype.isMaterial = function(updater) {\n        var material = this.materialProperty;\n        var updaterMaterial = updater.fillMaterialProperty;\n\n        if (updaterMaterial === material ||\n            (updaterMaterial instanceof ColorMaterialProperty && material instanceof ColorMaterialProperty)) {\n            return true;\n        }\n        return defined(material) && material.equals(updaterMaterial);\n    };\n\n    Batch.prototype.add = function(time, updater, geometryInstance) {\n        var id = updater.id;\n        this.updaters.set(id, updater);\n        this.geometry.set(id, geometryInstance);\n        // Updaters with dynamic attributes must be tracked separately, may exit the batch\n        if (!updater.hasConstantFill || !updater.fillMaterialProperty.isConstant || !Property.isConstant(updater.distanceDisplayConditionProperty)) {\n            this.updatersWithAttributes.set(id, updater);\n        } else {\n            var that = this;\n            // Listen for show changes. These will be synchronized in updateShows.\n            this.subscriptions.set(id, updater.entity.definitionChanged.addEventListener(function(entity, propertyName, newValue, oldValue) {\n                if (propertyName === 'isShowing') {\n                    that.showsUpdated.set(updater.id, updater);\n                }\n            }));\n        }\n        this.createPrimitive = true;\n    };\n\n    Batch.prototype.remove = function(updater) {\n        var id = updater.id;\n        this.createPrimitive = this.geometry.remove(id) || this.createPrimitive;\n        if (this.updaters.remove(id)) {\n            this.updatersWithAttributes.remove(id);\n            var unsubscribe = this.subscriptions.get(id);\n            if (defined(unsubscribe)) {\n                unsubscribe();\n                this.subscriptions.remove(id);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    Batch.prototype.update = function(time) {\n        var isUpdated = true;\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        var geometries = this.geometry.values;\n        var i;\n\n        if (this.createPrimitive) {\n            var geometriesLength = geometries.length;\n            if (geometriesLength > 0) {\n                if (defined(primitive)) {\n                    // Keep a handle to the old primitive so it can be removed when the updated version is ready.\n                    if (!defined(this.oldPrimitive)) {\n                        this.oldPrimitive = primitive;\n                    } else {\n                        // For if the new primitive changes again before it is ready.\n                        orderedGroundPrimitives.remove(primitive);\n                    }\n                }\n\n                primitive = new GroundPolylinePrimitive({\n                    show : false,\n                    asynchronous : this._asynchronous,\n                    geometryInstances : geometries,\n                    appearance : new this.appearanceType(),\n                    classificationType : this.classificationType\n                });\n\n                if (this.appearanceType === PolylineMaterialAppearance) {\n                    this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                    primitive.appearance.material = this.material;\n                }\n\n                orderedGroundPrimitives.add(primitive, this.zIndex);\n                isUpdated = false;\n            } else {\n                if (defined(primitive)) {\n                    orderedGroundPrimitives.remove(primitive);\n                    primitive = undefined;\n                }\n                var oldPrimitive = this.oldPrimitive;\n                if (defined(oldPrimitive)) {\n                    orderedGroundPrimitives.remove(oldPrimitive);\n                    this.oldPrimitive = undefined;\n                }\n            }\n\n            this.attributes.removeAll();\n            this.primitive = primitive;\n            this.createPrimitive = false;\n        } else if (defined(primitive) && primitive.ready) {\n            primitive.show = true;\n            if (defined(this.oldPrimitive)) {\n                orderedGroundPrimitives.remove(this.oldPrimitive);\n                this.oldPrimitive = undefined;\n            }\n\n            if (this.appearanceType === PolylineMaterialAppearance) {\n                this.material = MaterialProperty.getValue(time, this.materialProperty, this.material);\n                this.primitive.appearance.material = this.material;\n            }\n            var updatersWithAttributes = this.updatersWithAttributes.values;\n            var length = updatersWithAttributes.length;\n            for (i = 0; i < length; i++) {\n                var updater = updatersWithAttributes[i];\n                var entity = updater.entity;\n                var instance = this.geometry.get(updater.id);\n\n                var attributes = this.attributes.get(instance.id.id);\n                if (!defined(attributes)) {\n                    attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                    this.attributes.set(instance.id.id, attributes);\n                }\n\n                if (!updater.fillMaterialProperty.isConstant) {\n                    var colorProperty = updater.fillMaterialProperty.color;\n                    var resultColor = Property.getValueOrDefault(colorProperty, time, Color.WHITE, scratchColor);\n                    if (!Color.equals(attributes._lastColor, resultColor)) {\n                        attributes._lastColor = Color.clone(resultColor, attributes._lastColor);\n                        attributes.color = ColorGeometryInstanceAttribute.toValue(resultColor, attributes.color);\n                    }\n                }\n\n                var show = entity.isShowing && (updater.hasConstantFill || updater.isFilled(time));\n                var currentShow = attributes.show[0] === 1;\n                if (show !== currentShow) {\n                    attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                }\n\n                var distanceDisplayConditionProperty = updater.distanceDisplayConditionProperty;\n                if (!Property.isConstant(distanceDisplayConditionProperty)) {\n                    var distanceDisplayCondition = Property.getValueOrDefault(distanceDisplayConditionProperty, time, defaultDistanceDisplayCondition, distanceDisplayConditionScratch);\n                    if (!DistanceDisplayCondition.equals(distanceDisplayCondition, attributes._lastDistanceDisplayCondition)) {\n                        attributes._lastDistanceDisplayCondition = DistanceDisplayCondition.clone(distanceDisplayCondition, attributes._lastDistanceDisplayCondition);\n                        attributes.distanceDisplayCondition = DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);\n                    }\n                }\n            }\n\n            this.updateShows(primitive);\n        } else if (defined(primitive) && !primitive.ready) {\n            isUpdated = false;\n        }\n        return isUpdated;\n    };\n\n    Batch.prototype.updateShows = function(primitive) {\n        var showsUpdated = this.showsUpdated.values;\n        var length = showsUpdated.length;\n        for (var i = 0; i < length; i++) {\n            var updater = showsUpdated[i];\n            var entity = updater.entity;\n            var instance = this.geometry.get(updater.id);\n\n            var attributes = this.attributes.get(instance.id.id);\n            if (!defined(attributes)) {\n                attributes = primitive.getGeometryInstanceAttributes(instance.id);\n                this.attributes.set(instance.id.id, attributes);\n            }\n\n            var show = entity.isShowing;\n            var currentShow = attributes.show[0] === 1;\n            if (show !== currentShow) {\n                attributes.show = ShowGeometryInstanceAttribute.toValue(show, attributes.show);\n                instance.attributes.show.value[0] = attributes.show[0];\n            }\n        }\n        this.showsUpdated.removeAll();\n    };\n\n    Batch.prototype.contains = function(updater) {\n        return this.updaters.contains(updater.id);\n    };\n\n    Batch.prototype.getBoundingSphere = function(updater, result) {\n        var primitive = this.primitive;\n        if (!primitive.ready) {\n            return BoundingSphereState.PENDING;\n        }\n        var attributes = primitive.getGeometryInstanceAttributes(updater.entity);\n        if (!defined(attributes) || !defined(attributes.boundingSphere) ||\n            (defined(attributes.show) && attributes.show[0] === 0)) {\n            return BoundingSphereState.FAILED;\n        }\n        attributes.boundingSphere.clone(result);\n        return BoundingSphereState.DONE;\n    };\n\n    Batch.prototype.destroy = function() {\n        var primitive = this.primitive;\n        var orderedGroundPrimitives = this.orderedGroundPrimitives;\n        if (defined(primitive)) {\n            orderedGroundPrimitives.remove(primitive);\n        }\n        var oldPrimitive = this.oldPrimitive;\n        if (defined(oldPrimitive)) {\n            orderedGroundPrimitives.remove(oldPrimitive);\n        }\n        this.removeMaterialSubscription();\n    };\n\n    /**\n     * @private\n     */\n    function StaticGroundPolylinePerMaterialBatch(orderedGroundPrimitives, classificationType, asynchronous) {\n        this._items = [];\n        this._orderedGroundPrimitives = orderedGroundPrimitives;\n        this._classificationType = classificationType;\n        this._asynchronous = defaultValue(asynchronous, true);\n    }\n\n    StaticGroundPolylinePerMaterialBatch.prototype.add = function(time, updater) {\n        var items = this._items;\n        var length = items.length;\n        var geometryInstance = updater.createFillGeometryInstance(time);\n        var zIndex = Property.getValueOrDefault(updater.zIndex, 0);\n        // Check if the Entity represented by the updater has the same material or a material representable with per-instance color.\n        for (var i = 0; i < length; ++i) {\n            var item = items[i];\n            if (item.isMaterial(updater) &&\n                item.zIndex === zIndex) {\n                item.add(time, updater, geometryInstance);\n                return;\n            }\n        }\n        // If a compatible batch wasn't found, create a new batch.\n        var batch = new Batch(this._orderedGroundPrimitives, this._classificationType, updater.fillMaterialProperty, zIndex, this._asynchronous);\n        batch.add(time, updater, geometryInstance);\n        items.push(batch);\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.remove = function(updater) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.remove(updater)) {\n                if (item.updaters.length === 0) {\n                    items.splice(i, 1);\n                    item.destroy();\n                }\n                break;\n            }\n        }\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.update = function(time) {\n        var i;\n        var items = this._items;\n        var length = items.length;\n\n        for (i = length - 1; i >= 0; i--) {\n            var item = items[i];\n            if (item.invalidated) {\n                items.splice(i, 1);\n                var updaters = item.updaters.values;\n                var updatersLength = updaters.length;\n                for (var h = 0; h < updatersLength; h++) {\n                    this.add(time, updaters[h]);\n                }\n                item.destroy();\n            }\n        }\n\n        var isUpdated = true;\n        for (i = 0; i < items.length; i++) {\n            isUpdated = items[i].update(time) && isUpdated;\n        }\n        return isUpdated;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere = function(updater, result) {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            var item = items[i];\n            if (item.contains(updater)){\n                return item.getBoundingSphere(updater, result);\n            }\n        }\n        return BoundingSphereState.FAILED;\n    };\n\n    StaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives = function() {\n        var items = this._items;\n        var length = items.length;\n        for (var i = 0; i < length; i++) {\n            items[i].destroy();\n        }\n        this._items.length = 0;\n    };\n\n    return StaticGroundPolylinePerMaterialBatch;\n});\n","define([\n        '../Core/ApproximateTerrainHeights',\n        '../Core/BoundingSphere',\n        '../Core/Check',\n        '../Core/createGuid',\n        '../Core/defaultValue',\n        '../Core/defined',\n        '../Core/defineProperties',\n        '../Core/destroyObject',\n        '../Core/EventHelper',\n        '../Scene/GroundPolylinePrimitive',\n        '../Scene/GroundPrimitive',\n        '../Scene/OrderedGroundPrimitiveCollection',\n        '../Scene/PrimitiveCollection',\n        './BillboardVisualizer',\n        './BoundingSphereState',\n        './CustomDataSource',\n        './GeometryVisualizer',\n        './LabelVisualizer',\n        './ModelVisualizer',\n        './PathVisualizer',\n        './PointVisualizer',\n        './PolylineVisualizer'\n    ], function(\n        ApproximateTerrainHeights,\n        BoundingSphere,\n        Check,\n        createGuid,\n        defaultValue,\n        defined,\n        defineProperties,\n        destroyObject,\n        EventHelper,\n        GroundPolylinePrimitive,\n        GroundPrimitive,\n        OrderedGroundPrimitiveCollection,\n        PrimitiveCollection,\n        BillboardVisualizer,\n        BoundingSphereState,\n        CustomDataSource,\n        GeometryVisualizer,\n        LabelVisualizer,\n        ModelVisualizer,\n        PathVisualizer,\n        PointVisualizer,\n        PolylineVisualizer) {\n    'use strict';\n\n    /**\n     * Visualizes a collection of {@link DataSource} instances.\n     * @alias DataSourceDisplay\n     * @constructor\n     *\n     * @param {Object} options Object with the following properties:\n     * @param {Scene} options.scene The scene in which to display the data.\n     * @param {DataSourceCollection} options.dataSourceCollection The data sources to display.\n     * @param {DataSourceDisplay~VisualizersCallback} [options.visualizersCallback=DataSourceDisplay.defaultVisualizersCallback]\n     *        A function which creates an array of visualizers used for visualization.\n     *        If undefined, all standard visualizers are used.\n     */\n    function DataSourceDisplay(options) {\n        \n\n        this._displayID = createGuid();\n\n        GroundPrimitive.initializeTerrainHeights();\n        GroundPolylinePrimitive.initializeTerrainHeights();\n\n        var scene = options.scene;\n        var dataSourceCollection = options.dataSourceCollection;\n\n        this._eventHelper = new EventHelper();\n        this._eventHelper.add(dataSourceCollection.dataSourceAdded, this._onDataSourceAdded, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceRemoved, this._onDataSourceRemoved, this);\n        this._eventHelper.add(dataSourceCollection.dataSourceMoved, this._onDataSourceMoved, this);\n\n        this._dataSourceCollection = dataSourceCollection;\n        this._scene = scene;\n        this._visualizersCallback = defaultValue(options.visualizersCallback, DataSourceDisplay.defaultVisualizersCallback);\n\n        var primitivesAdded = false;\n        var primitives = new PrimitiveCollection();\n        var groundPrimitives = new PrimitiveCollection();\n\n        if (dataSourceCollection.length > 0) {\n            scene.primitives.add(primitives);\n            scene.groundPrimitives.add(groundPrimitives);\n            primitivesAdded = true;\n        }\n\n        this._primitives = primitives;\n        this._groundPrimitives = groundPrimitives;\n\n        for (var i = 0, len = dataSourceCollection.length; i < len; i++) {\n            this._onDataSourceAdded(dataSourceCollection, dataSourceCollection.get(i));\n        }\n\n        var defaultDataSource = new CustomDataSource();\n        this._onDataSourceAdded(undefined, defaultDataSource);\n        this._defaultDataSource = defaultDataSource;\n\n        var removeDefaultDataSoureListener;\n        var removeDataSourceCollectionListener;\n        if (!primitivesAdded) {\n            var that = this;\n            var addPrimitives = function() {\n                scene.primitives.add(primitives);\n                scene.groundPrimitives.add(groundPrimitives);\n                removeDefaultDataSoureListener();\n                removeDataSourceCollectionListener();\n                that._removeDefaultDataSoureListener = undefined;\n                that._removeDataSourceCollectionListener = undefined;\n            };\n            removeDefaultDataSoureListener = defaultDataSource.entities.collectionChanged.addEventListener(addPrimitives);\n            removeDataSourceCollectionListener = dataSourceCollection.dataSourceAdded.addEventListener(addPrimitives);\n        }\n\n        this._removeDefaultDataSoureListener = removeDefaultDataSoureListener;\n        this._removeDataSourceCollectionListener = removeDataSourceCollectionListener;\n\n        this._ready = false;\n    }\n\n    /**\n     * Gets or sets the default function which creates an array of visualizers used for visualization.\n     * By default, this function uses all standard visualizers.\n     *\n     * @type {DataSourceDisplay~VisualizersCallback}\n     */\n    DataSourceDisplay.defaultVisualizersCallback = function(scene, entityCluster, dataSource) {\n        var entities = dataSource.entities;\n        return [new BillboardVisualizer(entityCluster, entities),\n                new GeometryVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives),\n                new LabelVisualizer(entityCluster, entities),\n                new ModelVisualizer(scene, entities),\n                new PointVisualizer(entityCluster, entities),\n                new PathVisualizer(scene, entities),\n                new PolylineVisualizer(scene, entities, dataSource._primitives, dataSource._groundPrimitives)];\n    };\n\n    defineProperties(DataSourceDisplay.prototype, {\n        /**\n         * Gets the scene associated with this display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {Scene}\n         */\n        scene : {\n            get : function() {\n                return this._scene;\n            }\n        },\n        /**\n         * Gets the collection of data sources to display.\n         * @memberof DataSourceDisplay.prototype\n         * @type {DataSourceCollection}\n         */\n        dataSources : {\n            get : function() {\n                return this._dataSourceCollection;\n            }\n        },\n        /**\n         * Gets the default data source instance which can be used to\n         * manually create and visualize entities not tied to\n         * a specific data source. This instance is always available\n         * and does not appear in the list dataSources collection.\n         * @memberof DataSourceDisplay.prototype\n         * @type {CustomDataSource}\n         */\n        defaultDataSource : {\n            get : function() {\n                return this._defaultDataSource;\n            }\n        },\n\n        /**\n         * Gets a value indicating whether or not all entities in the data source are ready\n         * @memberof DataSourceDisplay.prototype\n         * @type {Boolean}\n         * @readonly\n         */\n        ready : {\n            get : function() {\n                return this._ready;\n            }\n        }\n    });\n\n    /**\n     * Returns true if this object was destroyed; otherwise, false.\n     * <br /><br />\n     * If this object was destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n     *\n     * @returns {Boolean} True if this object was destroyed; otherwise, false.\n     *\n     * @see DataSourceDisplay#destroy\n     */\n    DataSourceDisplay.prototype.isDestroyed = function() {\n        return false;\n    };\n\n    /**\n     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n     * <br /><br />\n     * Once an object is destroyed, it should not be used; calling any function other than\n     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n     * assign the return value (<code>undefined</code>) to the object as done in the example.\n     *\n     * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n     *\n     *\n     * @example\n     * dataSourceDisplay = dataSourceDisplay.destroy();\n     *\n     * @see DataSourceDisplay#isDestroyed\n     */\n    DataSourceDisplay.prototype.destroy = function() {\n        this._eventHelper.removeAll();\n\n        var dataSourceCollection = this._dataSourceCollection;\n        for (var i = 0, length = dataSourceCollection.length; i < length; ++i) {\n            this._onDataSourceRemoved(this._dataSourceCollection, dataSourceCollection.get(i));\n        }\n        this._onDataSourceRemoved(undefined, this._defaultDataSource);\n\n        if (defined(this._removeDefaultDataSoureListener)) {\n            this._removeDefaultDataSoureListener();\n            this._removeDataSourceCollectionListener();\n        } else {\n            this._scene.primitives.remove(this._primitives);\n            this._scene.groundPrimitives.remove(this._groundPrimitives);\n        }\n\n        return destroyObject(this);\n    };\n\n    /**\n     * Updates the display to the provided time.\n     *\n     * @param {JulianDate} time The simulation time.\n     * @returns {Boolean} True if all data sources are ready to be displayed, false otherwise.\n     */\n    DataSourceDisplay.prototype.update = function(time) {\n        \n\n        if (!ApproximateTerrainHeights.initialized) {\n            this._ready = false;\n            return false;\n        }\n\n        var result = true;\n\n        var i;\n        var x;\n        var visualizers;\n        var vLength;\n        var dataSources = this._dataSourceCollection;\n        var length = dataSources.length;\n        for (i = 0; i < length; i++) {\n            var dataSource = dataSources.get(i);\n            if (defined(dataSource.update)) {\n                result = dataSource.update(time) && result;\n            }\n\n            visualizers = dataSource._visualizersByDisplayID[this._displayID];\n            vLength = visualizers.length;\n            for (x = 0; x < vLength; x++) {\n                result = visualizers[x].update(time) && result;\n            }\n        }\n\n        visualizers = this._defaultDataSource._visualizersByDisplayID[this._displayID];\n        vLength = visualizers.length;\n        for (x = 0; x < vLength; x++) {\n            result = visualizers[x].update(time) && result;\n        }\n\n        this._ready = result;\n\n        return result;\n    };\n\n    var getBoundingSphereArrayScratch = [];\n    var getBoundingSphereBoundingSphereScratch = new BoundingSphere();\n\n    /**\n     * Computes a bounding sphere which encloses the visualization produced for the specified entity.\n     * The bounding sphere is in the fixed frame of the scene's globe.\n     *\n     * @param {Entity} entity The entity whose bounding sphere to compute.\n     * @param {Boolean} allowPartial If true, pending bounding spheres are ignored and an answer will be returned from the currently available data.\n     *                               If false, the the function will halt and return pending if any of the bounding spheres are pending.\n     * @param {BoundingSphere} result The bounding sphere onto which to store the result.\n     * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,\n     *                       BoundingSphereState.PENDING if the result is still being computed, or\n     *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.\n     * @private\n     */\n    DataSourceDisplay.prototype.getBoundingSphere = function(entity, allowPartial, result) {\n        \n\n        if (!this._ready) {\n            return BoundingSphereState.PENDING;\n        }\n\n        var i;\n        var length;\n        var dataSource = this._defaultDataSource;\n        if (!dataSource.entities.contains(entity)) {\n            dataSource = undefined;\n\n            var dataSources = this._dataSourceCollection;\n            length = dataSources.length;\n            for (i = 0; i < length; i++) {\n                var d = dataSources.get(i);\n                if (d.entities.contains(entity)) {\n                    dataSource = d;\n                    break;\n                }\n            }\n        }\n\n        if (!defined(dataSource)) {\n            return BoundingSphereState.FAILED;\n        }\n\n        var boundingSpheres = getBoundingSphereArrayScratch;\n        var tmp = getBoundingSphereBoundingSphereScratch;\n\n        var count = 0;\n        var state = BoundingSphereState.DONE;\n        var visualizers = dataSource._visualizers;\n        var visualizersLength = visualizers.length;\n\n        for (i = 0; i < visualizersLength; i++) {\n            var visualizer = visualizers[i];\n            if (defined(visualizer.getBoundingSphere)) {\n                state = visualizers[i].getBoundingSphere(entity, tmp);\n                if (!allowPartial && state === BoundingSphereState.PENDING) {\n                    return BoundingSphereState.PENDING;\n                } else if (state === BoundingSphereState.DONE) {\n                    boundingSpheres[count] = BoundingSphere.clone(tmp, boundingSpheres[count]);\n                    count++;\n                }\n            }\n        }\n\n        if (count === 0) {\n            return BoundingSphereState.FAILED;\n        }\n\n        boundingSpheres.length = count;\n        BoundingSphere.fromBoundingSpheres(boundingSpheres, result);\n        return BoundingSphereState.DONE;\n    };\n\n    DataSourceDisplay.prototype._onDataSourceAdded = function(dataSourceCollection, dataSource) {\n        var scene = this._scene;\n\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = displayPrimitives.add(new PrimitiveCollection());\n        var groundPrimitives = displayGroundPrimitives.add(new OrderedGroundPrimitiveCollection());\n\n        dataSource._primitives = primitives;\n        dataSource._groundPrimitives = groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        entityCluster._initialize(scene);\n\n        primitives.add(entityCluster);\n\n        var visualizers = this._visualizersCallback(scene, entityCluster, dataSource);\n\n        dataSource._visualizersByDisplayID = dataSource._visualizersByDisplayID || {};\n        dataSource._visualizersByDisplayID[this._displayID] = visualizers;\n\n        dataSource._visualizers = dataSource._visualizers || [];\n        dataSource._visualizers = dataSource._visualizers.concat(visualizers);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceRemoved = function(dataSourceCollection, dataSource) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        var entityCluster = dataSource.clustering;\n        primitives.remove(entityCluster);\n\n        var visualizers = dataSource._visualizersByDisplayID[this._displayID];\n        if (!defined(visualizers)) {\n            return;\n        }\n\n        var length = visualizers.length;\n        for (var i = 0; i < length; i++) {\n            var visualizer = visualizers[i];\n            visualizer.destroy();\n\n            var index = dataSource._visualizers.indexOf(visualizer);\n            dataSource._visualizers.splice(index, 1);\n        }\n\n        delete dataSource._visualizersByDisplayID[this._displayID];\n\n        displayPrimitives.remove(primitives);\n        displayGroundPrimitives.remove(groundPrimitives);\n    };\n\n    DataSourceDisplay.prototype._onDataSourceMoved = function(dataSource, newIndex, oldIndex) {\n        var displayPrimitives = this._primitives;\n        var displayGroundPrimitives = this._groundPrimitives;\n\n        var primitives = dataSource._primitives;\n        var groundPrimitives = dataSource._groundPrimitives;\n\n        if (newIndex === oldIndex + 1) {\n            displayPrimitives.raise(primitives);\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else if (newIndex === oldIndex - 1) {\n            displayPrimitives.lower(primitives);\n            displayGroundPrimitives.lower(groundPrimitives);\n        } else if (newIndex === 0) {\n            displayPrimitives.lowerToBottom(primitives);\n            displayGroundPrimitives.lowerToBottom(groundPrimitives);\n            displayPrimitives.raise(primitives); // keep defaultDataSource primitives at index 0 since it's not in the collection\n            displayGroundPrimitives.raise(groundPrimitives);\n        } else {\n            displayPrimitives.raiseToTop(primitives);\n            displayGroundPrimitives.raiseToTop(groundPrimitives);\n        }\n    };\n\n    /**\n     * A function which creates an array of visualizers used for visualization.\n     * @callback DataSourceDisplay~VisualizersCallback\n     *\n     * @param {Scene} scene The scene to create visualizers for.\n     * @param {DataSource} dataSource The data source to create visualizers for.\n     * @returns {Visualizer[]} An array of visualizers used for visualization.\n     *\n     * @example\n     * function createVisualizers(scene, dataSource) {\n     *     return [new Cesium.BillboardVisualizer(scene, dataSource.entities)];\n     * }\n     */\n\n    return DataSourceDisplay;\n});\n"],"sourceRoot":""}